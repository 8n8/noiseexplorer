<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Noise Explorer: NK</title>
	<meta name="keywords" content="noise protocol, protocol verification, formal verification, noise protocol framework, symbolic verification" />
	<meta name="description" content="Noise Explorer is an online engine for reasoning about Noise Protocol Framework Handshake Patterns. Noise Explorer allows you to design and validate Noise Handshake Patterns, to generate cryptographic models for formal verification and to explore a compendium of formal verification results for the most popular and relevant Noise Handshake Patterns in use today." />
	<link rel="image_src" href="https://noiseexplorer.com/res/img/logo.png" />
	<link rel="icon" type="image/png" href="../../res/img/logo.png" />
	<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans" rel="stylesheet" />
	<link href="../../res/css/style.css" rel="stylesheet" />
	<script type="application/javascript"></script>
</head>

<body>
	<div class="header">
		<img id="logo" src="../../res/img/logo.png" alt="" />
		<h1>Noise Explorer <span class="beta">beta</span></h1>
	</div>
	<div class="nav">
		<span class="menu">menu</span>
		<div class="navLinks">
			<a href="..">Design New Pattern</a>
			<a href="../patterns" class="currentNav">Explore Patterns</a>
			<a href="../cmd">Command-Line Tool</a>
		</div>
	</div>
	<div class="results" style="height: 840px;">
		<div class="arrowsFrame detailed">
			<h1 id="patternName">NK</h1>
			<div class="arrows" style="height: 840px;">
				<svg id="patternArrows" style="height: 840px;">
					<line data-seclevel="2" x1="1" x2="248" y1="300" y2="300"></line>
					<polyline data-seclevel="2" points="237 290 248 300 237 310"></polyline>
					<circle data-seclevel="0" cx="17" cy="300" r="15"></circle>
					<text class="msg" x="16" y="305">a</text>
					<text class="tokens" x="120" y="292">e, es</text>
				</svg>
			</div>
		</div>
		<div class="resultsExplanation detailed" style="height: 840px;">
			<h2>Noise Pattern Analysis</h2>
			<p>The responder is initialized with a pre-shared long-term static key, which is assumed to be pre-authenticated out of band by the initiator.</p> 
			
			<h3>Message A</h3>
			<p>Message A, sent by the initiator, does not benefit from <em>sender authentication</em> and does not provide <em>message integrity</em>. It could have been sent by any party, including an active attacker. Message contents benefit from <em>message secrecy</em> and some <em>forward secrecy</em>: the compromise of the responder's long-term private keys, even at a later date, will lead to message contents being decrypted by the attacker.  <span class="resultNums">0,2</span></p>
			<h3>Message B</h3>
			<p>Message B, sent by the responder, benefits from <em>receiver authentication</em> and is <em>resistant to Key Compromise Impersonation</em>. Assuming the corresponding private keys are secure, this authentication cannot be forged. However, if the responder carries out a separate session with a separate, compromised initiator, this other session can be used to forge the authenticity of this message with this session's initiator. Message contents benefit from some <em>message secrecy</em> and some <em>forward secrecy</em>, but not sufficiently to resist any active attacker.  <span class="resultNums">2,1</span></p>
			<h3>Message C</h3>
			<p>Message C, sent by the initiator, does not benefit from <em>sender authentication</em> and does not provide <em>message integrity</em>. It could have been sent by any party, including an active attacker. Message contents benefit from <em>message secrecy</em> and <em>strong forward secrecy</em>: if the ephemeral private keys are secure and the responder is not being actively impersonated by an active attacker, message contents cannot be decrypted.  <span class="resultNums">0,5</span></p>
			<h3>Message D</h3>
			<p>Message D, sent by the responder, benefits from <em>receiver authentication</em> and is <em>resistant to Key Compromise Impersonation</em>. Assuming the corresponding private keys are secure, this authentication cannot be forged. However, if the responder carries out a separate session with a separate, compromised initiator, this other session can be used to forge the authenticity of this message with this session's initiator. Message contents benefit from some <em>message secrecy</em> and some <em>forward secrecy</em>, but not sufficiently to resist any active attacker.  <span class="resultNums">2,1</span></p>
		</div>
	</div>
	<div class="rawResults">
		<h2>raw results &mdash; active attacker</h2>
result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,c_990,stage_a,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,c_990,stage_a,m,true)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) || event(leaks(phase0,alice)) cannot be proved.<br />result not attacker_p1(msg_a(alice,bob)) cannot be proved.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) || event(leaks(phase1,bob)) is true.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) || (event(leaks(phase1,bob)) && event(leaks(p,alice))) cannot be proved.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,c_990,stage_b,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,c_990,stage_b,m,true)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) || event(leaks(phase0,bob)) cannot be proved.<br />result not attacker_p1(msg_b(bob,alice)) cannot be proved.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) || event(leaks(phase1,alice)) cannot be proved.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) || (event(leaks(phase1,alice)) && event(leaks(p,bob))) cannot be proved.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,c_990,stage_c,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,c_990,stage_c,m,true)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) || event(leaks(phase0,alice)) cannot be proved.<br />result not attacker_p1(msg_c(alice,bob)) cannot be proved.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) || event(leaks(phase1,bob)) is true.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) || (event(leaks(phase1,bob)) && event(leaks(p,alice))) is true.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,c_990,stage_d,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,c_990,stage_d,m,true)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) || event(leaks(phase0,bob)) cannot be proved.<br />result not attacker_p1(msg_d(bob,alice)) cannot be proved.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) || event(leaks(phase1,alice)) cannot be proved.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) || (event(leaks(phase1,alice)) && event(leaks(p,bob))) cannot be proved.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) cannot be proved.
<h2>raw results &mdash; passive attacker</h2>
result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) is true.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,c_990,stage_a,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,c_990,stage_a,m,true)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(bob,alice,stage_a,m,true)) ==> event(sendmsg(alice,bob,stage_a,m,true)) || event(leaks(phase0,alice)) is true.<br />result not attacker_p1(msg_a(alice,bob)) cannot be proved.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) || event(leaks(phase1,bob)) is true.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) || (event(leaks(phase1,bob)) && event(leaks(p,alice))) cannot be proved.<br />result attacker_p1(msg_a(alice,bob)) ==> event(leaks(phase0,bob)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,c_990,stage_b,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,c_990,stage_b,m,true)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_b,m,true)) ==> event(sendmsg(bob,alice,stage_b,m,true)) || event(leaks(phase0,bob)) cannot be proved.<br />result not attacker_p1(msg_b(bob,alice)) is true.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) || event(leaks(phase1,alice)) is true.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) || (event(leaks(phase1,alice)) && event(leaks(p,bob))) is true.<br />result attacker_p1(msg_b(bob,alice)) ==> event(leaks(phase0,alice)) is true.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) is true.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,c_990,stage_c,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,c_990,stage_c,m,true)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) || event(leaks(phase0,alice)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(bob,alice,stage_c,m,true)) ==> event(sendmsg(alice,bob,stage_c,m,true)) || event(leaks(phase0,alice)) is true.<br />result not attacker_p1(msg_c(alice,bob)) is true.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) || event(leaks(phase1,bob)) is true.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) || (event(leaks(phase1,bob)) && event(leaks(p,alice))) is true.<br />result attacker_p1(msg_c(alice,bob)) ==> event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,c_990,stage_d,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,c_990,stage_d,m,true)) || event(leaks(phase0,bob)) is true.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) || event(leaks(phase0,bob)) || event(leaks(phase0,alice)) cannot be proved.<br />result event(recvmsg(alice,bob,stage_d,m,true)) ==> event(sendmsg(bob,alice,stage_d,m,true)) || event(leaks(phase0,bob)) cannot be proved.<br />result not attacker_p1(msg_d(bob,alice)) is true.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) || event(leaks(phase1,alice)) is true.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) || (event(leaks(phase1,alice)) && event(leaks(p,bob))) is true.<br />result attacker_p1(msg_d(bob,alice)) ==> event(leaks(phase0,alice)) is true.
<br /><br />
	</div>
	<div class="footer">
		<span class="about">about</span>
		<span>Noise Explorer is authored by <a href="https://nadim.computer" target="_blank">Nadim Kobeissi</a> (<a href="https://www.gnu.org/licenses/gpl-3.0.en.html" target="_blank">GPLv3</a>)</span><span style="float:right"><a href="https://symbolic.software" target="_blank">Symbolic Software</a> | <a href="https://inria.fr/" target="_blank">INRIA</a></span>
	</div>
</body>

</html>
