File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 261, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 262, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 262, character 36:
Warning: identifier h rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 301, character 6:
Warning: identifier e rebound.
File "X1X.noise.active.pv", line 302, characters 6-7:
Warning: identifier ne rebound.
File "X1X.noise.active.pv", line 303, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 313, character 6:
Warning: identifier e rebound.
File "X1X.noise.active.pv", line 314, characters 6-7:
Warning: identifier ne rebound.
File "X1X.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 317, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 318, character 6:
Warning: identifier s rebound.
File "X1X.noise.active.pv", line 319, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 319, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1X.noise.active.pv", line 320, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 321, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 321, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 322, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 329, character 6:
Warning: identifier s rebound.
File "X1X.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1X.noise.active.pv", line 331, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 331, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 332, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 340, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 340, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 341, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 348, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 348, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 349, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 356, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 356, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 357, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 366, characters 6-7:
Warning: identifier re rebound.
File "X1X.noise.active.pv", line 367, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 369, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 371, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 379, characters 6-7:
Warning: identifier re rebound.
File "X1X.noise.active.pv", line 380, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 382, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 383, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 383, characters 48-53:
Warning: identifier valid1 rebound.
File "X1X.noise.active.pv", line 384, characters 6-7:
Warning: identifier rs rebound.
File "X1X.noise.active.pv", line 385, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 386, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 388, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 396, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 396, characters 48-53:
Warning: identifier valid1 rebound.
File "X1X.noise.active.pv", line 397, characters 6-7:
Warning: identifier rs rebound.
File "X1X.noise.active.pv", line 398, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 400, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 408, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 409, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 411, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 419, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 421, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 429, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 431, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 629, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 429, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 431, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 621, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 348, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 348, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 349, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 614, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 408, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 409, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 411, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 606, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 329, character 6:
Warning: identifier s rebound.
File "X1X.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1X.noise.active.pv", line 331, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 331, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 332, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 599, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 379, characters 6-7:
Warning: identifier re rebound.
File "X1X.noise.active.pv", line 380, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 382, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 383, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 383, characters 48-53:
Warning: identifier valid1 rebound.
File "X1X.noise.active.pv", line 384, characters 6-7:
Warning: identifier rs rebound.
File "X1X.noise.active.pv", line 385, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 386, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 388, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 591, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 301, character 6:
Warning: identifier e rebound.
File "X1X.noise.active.pv", line 302, characters 6-7:
Warning: identifier ne rebound.
File "X1X.noise.active.pv", line 303, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 694, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 356, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 356, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 357, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 687, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 419, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 421, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 679, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 340, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 340, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 341, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 672, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 396, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 396, characters 48-53:
Warning: identifier valid1 rebound.
File "X1X.noise.active.pv", line 397, characters 6-7:
Warning: identifier rs rebound.
File "X1X.noise.active.pv", line 398, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 400, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 664, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 313, character 6:
Warning: identifier e rebound.
File "X1X.noise.active.pv", line 314, characters 6-7:
Warning: identifier ne rebound.
File "X1X.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 317, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 318, character 6:
Warning: identifier s rebound.
File "X1X.noise.active.pv", line 319, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 319, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1X.noise.active.pv", line 320, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 321, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 321, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1X.noise.active.pv", line 322, characters 6-7:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 252, characters 7-8:
Warning: identifier ck rebound.
File "X1X.noise.active.pv", line 271, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 657, characters 8-9:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 366, characters 6-7:
Warning: identifier re rebound.
File "X1X.noise.active.pv", line 367, characters 6-7:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 369, characters 7-8:
Warning: identifier ss rebound.
File "X1X.noise.active.pv", line 371, characters 7-8:
Warning: identifier hs rebound.
File "X1X.noise.active.pv", line 277, characters 7-8:
Warning: identifier cs rebound.
File "X1X.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}!
(
    {2}let s_585: keypair = keypairpack(empty,empty) in
    {3}out(pub, getpublickey(s_585));
    (
        {4}let e_586: keypair = keypairpack(empty,empty) in
        {5}let rs_587: key = empty in
        {6}let re_588: key = empty in
        {7}let v_589: bitstring = catch-fail(hash(somename,empty)) in
        {8}let v_590: key = catch-fail(v_589) in
        {9}let v_591: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {10}let v_592: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_589) then (if not-caught-fail(v_590) then (if not-caught-fail(v_591) then symmetricstatepack(v_591,v_590,v_589) else fail-any) else fail-any) else fail-any))) in
        {11}let v_593: symmetricstate = catch-fail((if success?((if not-caught-fail(v_589) then (if not-caught-fail(v_590) then (if not-caught-fail(v_591) then symmetricstatepack(v_591,v_590,v_589) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-3-tuple(v_592))))) then symmetricstatepack(1-proj-3-tuple(v_592),2-proj-3-tuple(v_592),hash(3-proj-3-tuple(v_592),empty)) else fail-any) else fail-any)) in
        {12}let hs: handshakestate = (if not-caught-fail(v_593) then handshakestatepack(v_593,s_585,e_586,rs_587,re_588,empty,true) else fail-any) in
        {13}insert statestore(alice,bob,statepack_a(hs))
    ) | (
        {36}get statestore(=alice,=bob,statepack_a(hs_594: handshakestate)) in
        {14}let v_595: bitstring = catch-fail(handshakestateunpack(hs_594)) in
        {15}let v_596: bitstring = catch-fail((empty,empty,empty)) in
        {16}let v_597: key = catch-fail(dhexp(key_e(alice,bob),g)) in
        {17}let v_598: keypair = catch-fail((if not-caught-fail(v_597) then keypairpack(v_597,key_e(alice,bob)) else fail-any)) in
        {18}let v_599: bitstring = catch-fail(getpublickey(v_598)) in
        {19}let v_600: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_595))) in
        {20}let v_601: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_595)) then (if (not-caught-fail(v_600) && success?(is-true(success?(1-proj-3-tuple(v_600))))) then symmetricstatepack(1-proj-3-tuple(v_600),2-proj-3-tuple(v_600),hash(3-proj-3-tuple(v_600),v_599)) else fail-any) else fail-any)) in
        {21}let v_602: bitstring = catch-fail(symmetricstateunpack(v_601)) in
        {22}let v_603: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_602))) in
        {23}let v_604: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_603),2-proj-2-tuple(v_603),3-proj-3-tuple(v_602),msg_a(alice,bob))) in
        {24}let v_605: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_602))) in
        {25}let v_606: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_603))) && success?(1-proj-3-tuple(v_602))) then (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-2-tuple(v_605))))) then cipherstatepack(1-proj-2-tuple(v_605),increment_nonce(2-proj-2-tuple(v_603))) else fail-any) else fail-any)) in
        {26}let v_607: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_602)) && success?(1-proj-3-tuple(v_602))) then (if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-2-tuple(v_603))))) then (if not-caught-fail(v_604) then (if not-caught-fail(v_606) then (v_606,v_604) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {27}let v_608: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_607),2-proj-3-tuple(v_602),3-proj-3-tuple(v_602)))) in
        {28}let v_609: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_607)) && success?(symmetricstatepack(1-proj-2-tuple(v_607),2-proj-3-tuple(v_602),3-proj-3-tuple(v_602)))) then (if (not-caught-fail(v_608) && success?(is-true(success?(1-proj-3-tuple(v_608))))) then symmetricstatepack(1-proj-3-tuple(v_608),2-proj-3-tuple(v_608),hash(3-proj-3-tuple(v_608),2-proj-2-tuple(v_607))) else fail-any) else fail-any)) in
        {29}let v_610: bitstring = catch-fail((if (not-caught-fail(v_602) && success?(is-true(success?(1-proj-3-tuple(v_602))))) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then (if not-caught-fail(v_609) then (v_609,2-proj-2-tuple(v_607)) else fail-any) else fail-any) else fail-any)) in
        {30}let v_611: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_610),2-proj-7-tuple(v_595),v_598,4-proj-7-tuple(v_595),5-proj-7-tuple(v_595),6-proj-7-tuple(v_595),7-proj-7-tuple(v_595))) in
        {31}let v_612: bitstring = catch-fail(concat3(v_599,2-proj-3-tuple(v_596),2-proj-2-tuple(v_610))) in
        {32}let (hs_613: handshakestate,re_614: key,message_a: bitstring) = (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-7-tuple(v_595))))) then (if (not-caught-fail(v_596) && success?(is-true(success?(1-proj-3-tuple(v_596))))) then (if not-caught-fail(v_598) then (if not-caught-fail(v_599) then (if not-caught-fail(v_601) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then (if not-caught-fail(v_611) then (if not-caught-fail(v_612) then (v_611,5-proj-7-tuple(v_595),v_612) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {33}event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true);
        {34}insert statestore(alice,bob,statepack_b(hs_613));
        {35}out(pub, message_a)
    ) | (
        {84}get statestore(=alice,=bob,statepack_b(hs_615: handshakestate)) in
        {37}in(pub, message_b: bitstring);
        {38}let v_616: bitstring = catch-fail(handshakestateunpack(hs_615)) in
        {39}let v_617: bitstring = catch-fail(deconcat3(message_b)) in
        {40}let v_618: bool = catch-fail(true) in
        {41}let v_619: key = catch-fail(1-proj-3-tuple(v_617)) in
        {42}let v_620: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_616))) in
        {43}let v_621: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_616)) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then symmetricstatepack(1-proj-3-tuple(v_620),2-proj-3-tuple(v_620),hash(3-proj-3-tuple(v_620),v_619)) else fail-any) else fail-any)) in
        {44}let v_622: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_616))) in
        {45}let v_623: bitstring = catch-fail(symmetricstateunpack(v_621)) in
        {46}let v_624: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_623),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then dhexp(2-proj-2-tuple(v_622),v_619) else fail-any) else fail-any))) in
        {47}let v_625: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_623),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then dhexp(2-proj-2-tuple(v_622),v_619) else fail-any) else fail-any))) in
        {48}let v_626: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_623),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then dhexp(2-proj-2-tuple(v_622),v_619) else fail-any) else fail-any))) in
        {49}let v_627: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then dhexp(2-proj-2-tuple(v_622),v_619) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_623))) then (if not-caught-fail(v_624) then (if not-caught-fail(v_625) then (if not-caught-fail(v_626) then (v_624,v_625,v_626) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {50}let v_628: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then dhexp(2-proj-2-tuple(v_622),v_619) else fail-any) else fail-any)) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-3-tuple(v_623))))) then (if (not-caught-fail(v_627) && success?(is-true(success?(1-proj-3-tuple(v_627))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_627)) then cipherstatepack(2-proj-3-tuple(v_627),minnonce) else fail-any),1-proj-3-tuple(v_627),3-proj-3-tuple(v_623)) else fail-any) else fail-any) else fail-any)) in
        {51}let v_629: bitstring = catch-fail(symmetricstateunpack(v_628)) in
        {52}let v_630: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_629))) in
        {53}let v_631: aead = catch-fail(decrypt(1-proj-2-tuple(v_630),2-proj-2-tuple(v_630),3-proj-3-tuple(v_629),2-proj-3-tuple(v_617))) in
        {54}let v_632: bitstring = catch-fail(aeadunpack(v_631)) in
        {55}let v_633: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_629))) in
        {56}let v_634: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_630))) && success?(1-proj-3-tuple(v_629))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then cipherstatepack(1-proj-2-tuple(v_633),increment_nonce(2-proj-2-tuple(v_630))) else fail-any) else fail-any)) in
        {57}let v_635: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_617)) && (success?(3-proj-3-tuple(v_629)) && success?(1-proj-3-tuple(v_629)))) then (if (not-caught-fail(v_630) && success?(is-true(success?(1-proj-2-tuple(v_630))))) then (if not-caught-fail(v_631) then (if (not-caught-fail(v_632) && success?(is-true(success?(1-proj-3-tuple(v_632))))) then (if not-caught-fail(v_634) then (v_634,3-proj-3-tuple(v_632),1-proj-3-tuple(v_632)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {58}let v_636: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_635),2-proj-3-tuple(v_629),3-proj-3-tuple(v_629)))) in
        {59}let v_637: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_617)) && success?(symmetricstatepack(1-proj-3-tuple(v_635),2-proj-3-tuple(v_629),3-proj-3-tuple(v_629)))) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then symmetricstatepack(1-proj-3-tuple(v_636),2-proj-3-tuple(v_636),hash(3-proj-3-tuple(v_636),2-proj-3-tuple(v_617))) else fail-any) else fail-any)) in
        {60}let v_638: bitstring = catch-fail((if success?(2-proj-3-tuple(v_617)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-3-tuple(v_629))))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-3-tuple(v_635))))) then (if not-caught-fail(v_637) then (v_637,2-proj-3-tuple(v_635),3-proj-3-tuple(v_635)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {61}let v_639: key = catch-fail(2-proj-3-tuple(v_638)) in
        {62}let v_640: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_616))) in
        {63}let v_641: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_638))) in
        {64}let v_642: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_641),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then dhexp(2-proj-2-tuple(v_640),v_639) else fail-any) else fail-any))) in
        {65}let v_643: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_641),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then dhexp(2-proj-2-tuple(v_640),v_639) else fail-any) else fail-any))) in
        {66}let v_644: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_641),(if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then dhexp(2-proj-2-tuple(v_640),v_639) else fail-any) else fail-any))) in
        {67}let v_645: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then dhexp(2-proj-2-tuple(v_640),v_639) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_641))) then (if not-caught-fail(v_642) then (if not-caught-fail(v_643) then (if not-caught-fail(v_644) then (v_642,v_643,v_644) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {68}let v_646: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_616)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then dhexp(2-proj-2-tuple(v_640),v_639) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_638))) then (if (not-caught-fail(v_641) && success?(is-true(success?(1-proj-3-tuple(v_641))))) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_645)) then cipherstatepack(2-proj-3-tuple(v_645),minnonce) else fail-any),1-proj-3-tuple(v_645),3-proj-3-tuple(v_641)) else fail-any) else fail-any) else fail-any)) in
        {69}let v_647: bitstring = catch-fail(symmetricstateunpack(v_646)) in
        {70}let v_648: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_647))) in
        {71}let v_649: aead = catch-fail(decrypt(1-proj-2-tuple(v_648),2-proj-2-tuple(v_648),3-proj-3-tuple(v_647),3-proj-3-tuple(v_617))) in
        {72}let v_650: bitstring = catch-fail(aeadunpack(v_649)) in
        {73}let v_651: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_647))) in
        {74}let v_652: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_648))) && success?(1-proj-3-tuple(v_647))) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-2-tuple(v_651))))) then cipherstatepack(1-proj-2-tuple(v_651),increment_nonce(2-proj-2-tuple(v_648))) else fail-any) else fail-any)) in
        {75}let v_653: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_617)) && (success?(3-proj-3-tuple(v_647)) && success?(1-proj-3-tuple(v_647)))) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then (if not-caught-fail(v_649) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-3-tuple(v_650))))) then (if not-caught-fail(v_652) then (v_652,3-proj-3-tuple(v_650),1-proj-3-tuple(v_650)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {76}let v_654: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_653),2-proj-3-tuple(v_647),3-proj-3-tuple(v_647)))) in
        {77}let v_655: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_617)) && success?(symmetricstatepack(1-proj-3-tuple(v_653),2-proj-3-tuple(v_647),3-proj-3-tuple(v_647)))) then (if (not-caught-fail(v_654) && success?(is-true(success?(1-proj-3-tuple(v_654))))) then symmetricstatepack(1-proj-3-tuple(v_654),2-proj-3-tuple(v_654),hash(3-proj-3-tuple(v_654),3-proj-3-tuple(v_617))) else fail-any) else fail-any)) in
        {78}let v_656: bitstring = catch-fail((if success?(3-proj-3-tuple(v_617)) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-3-tuple(v_647))))) then (if (not-caught-fail(v_653) && success?(is-true(success?(1-proj-3-tuple(v_653))))) then (if not-caught-fail(v_655) then (v_655,2-proj-3-tuple(v_653),3-proj-3-tuple(v_653)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {79}let v_657: key = catch-fail(dhexp(key_s(bob),g)) in
        {80}let v_658: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_656),2-proj-7-tuple(v_616),3-proj-7-tuple(v_616),v_639,v_619,6-proj-7-tuple(v_616),7-proj-7-tuple(v_616))) in
        {81}let (hs_659: handshakestate,re_660: key,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-7-tuple(v_616))))) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-3-tuple(v_617))))) then (if not-caught-fail(v_618) then (if not-caught-fail(v_619) then (if not-caught-fail(v_621) then (if not-caught-fail(v_628) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-3-tuple(v_638))))) then (if not-caught-fail(v_639) then (if not-caught-fail(v_646) then (if (not-caught-fail(v_656) && success?(is-true(success?(1-proj-3-tuple(v_656))))) then (if ((3-proj-3-tuple(v_638) && 3-proj-3-tuple(v_656)) && (v_639 = getpublickey((if not-caught-fail(v_657) then keypairpack(v_657,key_s(bob)) else fail-any)))) then (if not-caught-fail(v_658) then (v_658,getpublickey(3-proj-7-tuple(v_616)),2-proj-3-tuple(v_656),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {82}event RecvMsg(alice,bob,stage_b,plaintext_b,valid);
        {83}insert statestore(alice,bob,statepack_c(hs_659))
    ) | (
        {113}get statestore(=alice,=bob,statepack_c(hs_661: handshakestate)) in
        {85}let v_662: bitstring = catch-fail(handshakestateunpack(hs_661)) in
        {86}let v_663: bitstring = catch-fail((empty,empty,empty)) in
        {87}let v_664: key = catch-fail(dhexp(key_s(alice),g)) in
        {88}let v_665: keypair = catch-fail((if not-caught-fail(v_664) then keypairpack(v_664,key_s(alice)) else fail-any)) in
        {89}let v_666: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_662))) in
        {90}let v_667: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_666))) in
        {91}let v_668: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_667),2-proj-2-tuple(v_667),3-proj-3-tuple(v_666),getpublickey(v_665))) in
        {92}let v_669: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_666))) in
        {93}let v_670: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_667))) && success?(1-proj-3-tuple(v_666))) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-2-tuple(v_669))))) then cipherstatepack(1-proj-2-tuple(v_669),increment_nonce(2-proj-2-tuple(v_667))) else fail-any) else fail-any)) in
        {94}let v_671: bitstring = catch-fail((if (success?(getpublickey(v_665)) && (success?(3-proj-3-tuple(v_666)) && success?(1-proj-3-tuple(v_666)))) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-2-tuple(v_667))))) then (if not-caught-fail(v_668) then (if not-caught-fail(v_670) then (v_670,v_668) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {95}let v_672: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_671),2-proj-3-tuple(v_666),3-proj-3-tuple(v_666)))) in
        {96}let v_673: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_671)) && success?(symmetricstatepack(1-proj-2-tuple(v_671),2-proj-3-tuple(v_666),3-proj-3-tuple(v_666)))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-3-tuple(v_672))))) then symmetricstatepack(1-proj-3-tuple(v_672),2-proj-3-tuple(v_672),hash(3-proj-3-tuple(v_672),2-proj-2-tuple(v_671))) else fail-any) else fail-any)) in
        {97}let v_674: bitstring = catch-fail((if (success?(getpublickey(v_665)) && success?(1-proj-7-tuple(v_662))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if not-caught-fail(v_673) then (v_673,2-proj-2-tuple(v_671)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {98}let v_675: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_674))) in
        {99}let v_676: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_675))) in
        {100}let v_677: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_676),2-proj-2-tuple(v_676),3-proj-3-tuple(v_675),msg_c(alice,bob))) in
        {101}let v_678: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_675))) in
        {102}let v_679: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_676))) && success?(1-proj-3-tuple(v_675))) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-2-tuple(v_678))))) then cipherstatepack(1-proj-2-tuple(v_678),increment_nonce(2-proj-2-tuple(v_676))) else fail-any) else fail-any)) in
        {103}let v_680: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_675)) && success?(1-proj-3-tuple(v_675))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-2-tuple(v_676))))) then (if not-caught-fail(v_677) then (if not-caught-fail(v_679) then (v_679,v_677) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {104}let v_681: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_680),2-proj-3-tuple(v_675),3-proj-3-tuple(v_675)))) in
        {105}let v_682: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_680)) && success?(symmetricstatepack(1-proj-2-tuple(v_680),2-proj-3-tuple(v_675),3-proj-3-tuple(v_675)))) then (if (not-caught-fail(v_681) && success?(is-true(success?(1-proj-3-tuple(v_681))))) then symmetricstatepack(1-proj-3-tuple(v_681),2-proj-3-tuple(v_681),hash(3-proj-3-tuple(v_681),2-proj-2-tuple(v_680))) else fail-any) else fail-any)) in
        {106}let v_683: bitstring = catch-fail((if success?(1-proj-2-tuple(v_674)) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-3-tuple(v_675))))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-2-tuple(v_680))))) then (if not-caught-fail(v_682) then (v_682,2-proj-2-tuple(v_680)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let v_684: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_683),v_665,3-proj-7-tuple(v_662),4-proj-7-tuple(v_662),5-proj-7-tuple(v_662),6-proj-7-tuple(v_662),7-proj-7-tuple(v_662))) in
        {108}let v_685: bitstring = catch-fail(concat3(1-proj-3-tuple(v_663),2-proj-2-tuple(v_674),2-proj-2-tuple(v_683))) in
        {109}let (hs_686: handshakestate,re_687: key,message_c: bitstring) = (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-7-tuple(v_662))))) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-3-tuple(v_663))))) then (if not-caught-fail(v_665) then (if (not-caught-fail(v_674) && success?(is-true(success?(1-proj-2-tuple(v_674))))) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-2-tuple(v_683))))) then (if not-caught-fail(v_684) then (if not-caught-fail(v_685) then (v_684,5-proj-7-tuple(v_662),v_685) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {110}event SendMsg(alice,bob,stage_c,msg_c(alice,bob),true);
        {111}insert statestore(alice,bob,statepack_d(hs_686));
        {112}out(pub, message_c)
    ) | (
        {139}get statestore(=alice,=bob,statepack_d(hs_688: handshakestate)) in
        {114}in(pub, message_d: bitstring);
        {115}let v_689: bitstring = catch-fail(handshakestateunpack(hs_688)) in
        {116}let v_690: bitstring = catch-fail(deconcat3(message_d)) in
        {117}let v_691: bool = catch-fail(true) in
        {118}let v_692: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_689))) in
        {119}let v_693: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_689))) in
        {120}let v_694: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_693),(if (success?(5-proj-7-tuple(v_689)) && success?(2-proj-7-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),5-proj-7-tuple(v_689)) else fail-any) else fail-any))) in
        {121}let v_695: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_693),(if (success?(5-proj-7-tuple(v_689)) && success?(2-proj-7-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),5-proj-7-tuple(v_689)) else fail-any) else fail-any))) in
        {122}let v_696: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_693),(if (success?(5-proj-7-tuple(v_689)) && success?(2-proj-7-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),5-proj-7-tuple(v_689)) else fail-any) else fail-any))) in
        {123}let v_697: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_689)) && success?(2-proj-7-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),5-proj-7-tuple(v_689)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_693))) then (if not-caught-fail(v_694) then (if not-caught-fail(v_695) then (if not-caught-fail(v_696) then (v_694,v_695,v_696) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {124}let v_698: symmetricstate = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_689)) && success?(2-proj-7-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),5-proj-7-tuple(v_689)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_689))) then (if (not-caught-fail(v_693) && success?(is-true(success?(1-proj-3-tuple(v_693))))) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_697)) then cipherstatepack(2-proj-3-tuple(v_697),minnonce) else fail-any),1-proj-3-tuple(v_697),3-proj-3-tuple(v_693)) else fail-any) else fail-any) else fail-any)) in
        {125}let v_699: bitstring = catch-fail(symmetricstateunpack(v_698)) in
        {126}let v_700: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_699))) in
        {127}let v_701: aead = catch-fail(decrypt(1-proj-2-tuple(v_700),2-proj-2-tuple(v_700),3-proj-3-tuple(v_699),3-proj-3-tuple(v_690))) in
        {128}let v_702: bitstring = catch-fail(aeadunpack(v_701)) in
        {129}let v_703: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_699))) in
        {130}let v_704: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_700))) && success?(1-proj-3-tuple(v_699))) then (if (not-caught-fail(v_703) && success?(is-true(success?(1-proj-2-tuple(v_703))))) then cipherstatepack(1-proj-2-tuple(v_703),increment_nonce(2-proj-2-tuple(v_700))) else fail-any) else fail-any)) in
        {131}let v_705: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_690)) && (success?(3-proj-3-tuple(v_699)) && success?(1-proj-3-tuple(v_699)))) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then (if not-caught-fail(v_701) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-3-tuple(v_702))))) then (if not-caught-fail(v_704) then (v_704,3-proj-3-tuple(v_702),1-proj-3-tuple(v_702)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {132}let v_706: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_705),2-proj-3-tuple(v_699),3-proj-3-tuple(v_699)))) in
        {133}let v_707: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_690)) && success?(symmetricstatepack(1-proj-3-tuple(v_705),2-proj-3-tuple(v_699),3-proj-3-tuple(v_699)))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-3-tuple(v_706))))) then symmetricstatepack(1-proj-3-tuple(v_706),2-proj-3-tuple(v_706),hash(3-proj-3-tuple(v_706),3-proj-3-tuple(v_690))) else fail-any) else fail-any)) in
        {134}let v_708: bitstring = catch-fail((if success?(3-proj-3-tuple(v_690)) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-3-tuple(v_699))))) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then (if not-caught-fail(v_707) then (v_707,2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {135}let v_709: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_708),2-proj-7-tuple(v_689),3-proj-7-tuple(v_689),4-proj-7-tuple(v_689),5-proj-7-tuple(v_689),6-proj-7-tuple(v_689),7-proj-7-tuple(v_689))) in
        {136}let (hs_710: handshakestate,re_711: key,plaintext_d: bitstring,valid_712: bool) = (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-7-tuple(v_689))))) then (if (not-caught-fail(v_690) && success?(is-true(success?(1-proj-3-tuple(v_690))))) then (if not-caught-fail(v_691) then (if not-caught-fail(v_698) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-3-tuple(v_708))))) then (if (v_691 && 3-proj-3-tuple(v_708)) then (if not-caught-fail(v_709) then (v_709,getpublickey(3-proj-7-tuple(v_689)),2-proj-3-tuple(v_708),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {137}event RecvMsg(alice,bob,stage_d,plaintext_d,valid_712);
        {138}insert statestore(alice,bob,statepack_e(hs_710))
    ) | (
        {157}get statestore(=alice,=bob,statepack_e(hs_713: handshakestate)) in
        {140}let v_714: bitstring = catch-fail(handshakestateunpack(hs_713)) in
        {141}let v_715: bitstring = catch-fail((empty,empty,empty)) in
        {142}let v_716: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_714))) in
        {143}let v_717: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_716))) in
        {144}let v_718: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_717),2-proj-2-tuple(v_717),3-proj-3-tuple(v_716),msg_e(alice,bob))) in
        {145}let v_719: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_716))) in
        {146}let v_720: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_717))) && success?(1-proj-3-tuple(v_716))) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then cipherstatepack(1-proj-2-tuple(v_719),increment_nonce(2-proj-2-tuple(v_717))) else fail-any) else fail-any)) in
        {147}let v_721: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_716)) && success?(1-proj-3-tuple(v_716))) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-2-tuple(v_717))))) then (if not-caught-fail(v_718) then (if not-caught-fail(v_720) then (v_720,v_718) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {148}let v_722: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_721),2-proj-3-tuple(v_716),3-proj-3-tuple(v_716)))) in
        {149}let v_723: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_721)) && success?(symmetricstatepack(1-proj-2-tuple(v_721),2-proj-3-tuple(v_716),3-proj-3-tuple(v_716)))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-3-tuple(v_722))))) then symmetricstatepack(1-proj-3-tuple(v_722),2-proj-3-tuple(v_722),hash(3-proj-3-tuple(v_722),2-proj-2-tuple(v_721))) else fail-any) else fail-any)) in
        {150}let v_724: bitstring = catch-fail((if success?(1-proj-7-tuple(v_714)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-3-tuple(v_716))))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-2-tuple(v_721))))) then (if not-caught-fail(v_723) then (v_723,2-proj-2-tuple(v_721)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {151}let v_725: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_724),2-proj-7-tuple(v_714),3-proj-7-tuple(v_714),4-proj-7-tuple(v_714),5-proj-7-tuple(v_714),6-proj-7-tuple(v_714),7-proj-7-tuple(v_714))) in
        {152}let v_726: bitstring = catch-fail(concat3(1-proj-3-tuple(v_715),2-proj-3-tuple(v_715),2-proj-2-tuple(v_724))) in
        {153}let (hs_727: handshakestate,re_728: key,message_e: bitstring) = (if (not-caught-fail(v_714) && success?(is-true(success?(1-proj-7-tuple(v_714))))) then (if (not-caught-fail(v_715) && success?(is-true(success?(1-proj-3-tuple(v_715))))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-2-tuple(v_724))))) then (if not-caught-fail(v_725) then (if not-caught-fail(v_726) then (v_725,5-proj-7-tuple(v_714),v_726) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {154}event SendMsg(alice,bob,stage_e,msg_e(alice,bob),true);
        {155}insert statestore(alice,bob,statepack_f(hs_727));
        {156}out(pub, message_e)
    ) | (
        {185}get statestore(=alice,=bob,statepack_f(hs_729: handshakestate)) in
        {158}in(pub, message_f: bitstring);
        {159}let v_730: bitstring = catch-fail(handshakestateunpack(hs_729)) in
        {160}let v_731: bitstring = catch-fail(deconcat3(message_f)) in
        {161}let v_732: bool = catch-fail(true) in
        {162}let v_733: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_730))) in
        {163}let v_734: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_733))) in
        {164}let v_735: aead = catch-fail(decrypt(1-proj-2-tuple(v_734),2-proj-2-tuple(v_734),3-proj-3-tuple(v_733),3-proj-3-tuple(v_731))) in
        {165}let v_736: bitstring = catch-fail(aeadunpack(v_735)) in
        {166}let v_737: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_733))) in
        {167}let v_738: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_734))) && success?(1-proj-3-tuple(v_733))) then (if (not-caught-fail(v_737) && success?(is-true(success?(1-proj-2-tuple(v_737))))) then cipherstatepack(1-proj-2-tuple(v_737),increment_nonce(2-proj-2-tuple(v_734))) else fail-any) else fail-any)) in
        {168}let v_739: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_731)) && (success?(3-proj-3-tuple(v_733)) && success?(1-proj-3-tuple(v_733)))) then (if (not-caught-fail(v_734) && success?(is-true(success?(1-proj-2-tuple(v_734))))) then (if not-caught-fail(v_735) then (if (not-caught-fail(v_736) && success?(is-true(success?(1-proj-3-tuple(v_736))))) then (if not-caught-fail(v_738) then (v_738,3-proj-3-tuple(v_736),1-proj-3-tuple(v_736)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {169}let v_740: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_739),2-proj-3-tuple(v_733),3-proj-3-tuple(v_733)))) in
        {170}let v_741: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_731)) && success?(symmetricstatepack(1-proj-3-tuple(v_739),2-proj-3-tuple(v_733),3-proj-3-tuple(v_733)))) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-3-tuple(v_740))))) then symmetricstatepack(1-proj-3-tuple(v_740),2-proj-3-tuple(v_740),hash(3-proj-3-tuple(v_740),3-proj-3-tuple(v_731))) else fail-any) else fail-any)) in
        {171}let v_742: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_731)) && success?(1-proj-7-tuple(v_730))) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-3-tuple(v_733))))) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then (if not-caught-fail(v_741) then (v_741,2-proj-3-tuple(v_739),3-proj-3-tuple(v_739)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {172}let v_743: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_742),2-proj-7-tuple(v_730),3-proj-7-tuple(v_730),4-proj-7-tuple(v_730),5-proj-7-tuple(v_730),6-proj-7-tuple(v_730),7-proj-7-tuple(v_730))) in
        {173}let v_744: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_742))) in
        {174}let v_745: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_744),zero)) in
        {175}let v_746: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_744),zero)) in
        {176}let v_747: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_744),zero)) in
        {177}let v_748: bitstring = catch-fail((if success?(2-proj-3-tuple(v_744)) then (if not-caught-fail(v_745) then (if not-caught-fail(v_746) then (if not-caught-fail(v_747) then (v_745,v_746,v_747) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {178}let v_749: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_748)) then cipherstatepack(1-proj-3-tuple(v_748),minnonce) else fail-any)) in
        {179}let v_750: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_748)) then cipherstatepack(2-proj-3-tuple(v_748),minnonce) else fail-any)) in
        {180}let v_751: bitstring = catch-fail((if success?(1-proj-3-tuple(v_742)) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-3-tuple(v_744))))) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-3-tuple(v_748))))) then (if not-caught-fail(v_749) then (if not-caught-fail(v_750) then (1-proj-3-tuple(v_742),v_749,v_750) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {181}let (hs_752: handshakestate,re_753: key,plaintext_f: bitstring,valid_754: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-7-tuple(v_730))))) then (if (not-caught-fail(v_731) && success?(is-true(success?(1-proj-3-tuple(v_731))))) then (if not-caught-fail(v_732) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-3-tuple(v_742))))) then (if (v_732 && 3-proj-3-tuple(v_742)) then (if not-caught-fail(v_743) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-3-tuple(v_751))))) then (v_743,getpublickey(3-proj-7-tuple(v_730)),2-proj-3-tuple(v_742),true,2-proj-3-tuple(v_751),3-proj-3-tuple(v_751)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {182}event RecvMsg(alice,bob,stage_f,plaintext_f,valid_754);
        {183}insert statestore(alice,bob,statepack_g(hs_752));
        {184}event RecvEnd(valid_754)
    ) | (
        {186}event LeakS(phase0,alice);
        {187}out(pub, key_s(alice))
    ) | (
        {188}phase 1;
        {189}event LeakS(phase1,alice);
        {190}out(pub, key_s(alice))
    )
) | (
    {191}let s_755: keypair = keypairpack(empty,empty) in
    {192}out(pub, getpublickey(s_755));
    (
        {193}let e_756: keypair = keypairpack(empty,empty) in
        {194}let rs_757: key = empty in
        {195}let re_758: key = empty in
        {196}let v_759: bitstring = catch-fail(hash(somename,empty)) in
        {197}let v_760: key = catch-fail(v_759) in
        {198}let v_761: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {199}let v_762: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (if not-caught-fail(v_761) then symmetricstatepack(v_761,v_760,v_759) else fail-any) else fail-any) else fail-any))) in
        {200}let v_763: symmetricstate = catch-fail((if success?((if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (if not-caught-fail(v_761) then symmetricstatepack(v_761,v_760,v_759) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then symmetricstatepack(1-proj-3-tuple(v_762),2-proj-3-tuple(v_762),hash(3-proj-3-tuple(v_762),empty)) else fail-any) else fail-any)) in
        {201}let hs_764: handshakestate = (if not-caught-fail(v_763) then handshakestatepack(v_763,s_755,e_756,rs_757,re_758,empty,true) else fail-any) in
        {202}insert statestore(alice,charlie,statepack_a(hs_764))
    ) | (
        {225}get statestore(=alice,=charlie,statepack_a(hs_765: handshakestate)) in
        {203}let v_766: bitstring = catch-fail(handshakestateunpack(hs_765)) in
        {204}let v_767: bitstring = catch-fail((empty,empty,empty)) in
        {205}let v_768: key = catch-fail(dhexp(key_e(alice,charlie),g)) in
        {206}let v_769: keypair = catch-fail((if not-caught-fail(v_768) then keypairpack(v_768,key_e(alice,charlie)) else fail-any)) in
        {207}let v_770: bitstring = catch-fail(getpublickey(v_769)) in
        {208}let v_771: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_766))) in
        {209}let v_772: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_766)) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-3-tuple(v_771))))) then symmetricstatepack(1-proj-3-tuple(v_771),2-proj-3-tuple(v_771),hash(3-proj-3-tuple(v_771),v_770)) else fail-any) else fail-any)) in
        {210}let v_773: bitstring = catch-fail(symmetricstateunpack(v_772)) in
        {211}let v_774: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {212}let v_775: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_774),2-proj-2-tuple(v_774),3-proj-3-tuple(v_773),msg_a(alice,charlie))) in
        {213}let v_776: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {214}let v_777: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_774))) && success?(1-proj-3-tuple(v_773))) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-2-tuple(v_776))))) then cipherstatepack(1-proj-2-tuple(v_776),increment_nonce(2-proj-2-tuple(v_774))) else fail-any) else fail-any)) in
        {215}let v_778: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_773)) && success?(1-proj-3-tuple(v_773))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-2-tuple(v_774))))) then (if not-caught-fail(v_775) then (if not-caught-fail(v_777) then (v_777,v_775) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {216}let v_779: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_778),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) in
        {217}let v_780: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_778)) && success?(symmetricstatepack(1-proj-2-tuple(v_778),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-3-tuple(v_779))))) then symmetricstatepack(1-proj-3-tuple(v_779),2-proj-3-tuple(v_779),hash(3-proj-3-tuple(v_779),2-proj-2-tuple(v_778))) else fail-any) else fail-any)) in
        {218}let v_781: bitstring = catch-fail((if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-2-tuple(v_778))))) then (if not-caught-fail(v_780) then (v_780,2-proj-2-tuple(v_778)) else fail-any) else fail-any) else fail-any)) in
        {219}let v_782: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_781),2-proj-7-tuple(v_766),v_769,4-proj-7-tuple(v_766),5-proj-7-tuple(v_766),6-proj-7-tuple(v_766),7-proj-7-tuple(v_766))) in
        {220}let v_783: bitstring = catch-fail(concat3(v_770,2-proj-3-tuple(v_767),2-proj-2-tuple(v_781))) in
        {221}let (hs_784: handshakestate,re_785: key,message_a_786: bitstring) = (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-7-tuple(v_766))))) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-3-tuple(v_767))))) then (if not-caught-fail(v_769) then (if not-caught-fail(v_770) then (if not-caught-fail(v_772) then (if (not-caught-fail(v_781) && success?(is-true(success?(1-proj-2-tuple(v_781))))) then (if not-caught-fail(v_782) then (if not-caught-fail(v_783) then (v_782,5-proj-7-tuple(v_766),v_783) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {222}event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true);
        {223}insert statestore(alice,charlie,statepack_b(hs_784));
        {224}out(pub, message_a_786)
    ) | (
        {273}get statestore(=alice,=charlie,statepack_b(hs_787: handshakestate)) in
        {226}in(pub, message_b_788: bitstring);
        {227}let v_789: bitstring = catch-fail(handshakestateunpack(hs_787)) in
        {228}let v_790: bitstring = catch-fail(deconcat3(message_b_788)) in
        {229}let v_791: bool = catch-fail(true) in
        {230}let v_792: key = catch-fail(1-proj-3-tuple(v_790)) in
        {231}let v_793: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_789))) in
        {232}let v_794: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_789)) then (if (not-caught-fail(v_793) && success?(is-true(success?(1-proj-3-tuple(v_793))))) then symmetricstatepack(1-proj-3-tuple(v_793),2-proj-3-tuple(v_793),hash(3-proj-3-tuple(v_793),v_792)) else fail-any) else fail-any)) in
        {233}let v_795: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_789))) in
        {234}let v_796: bitstring = catch-fail(symmetricstateunpack(v_794)) in
        {235}let v_797: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_796),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then dhexp(2-proj-2-tuple(v_795),v_792) else fail-any) else fail-any))) in
        {236}let v_798: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_796),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then dhexp(2-proj-2-tuple(v_795),v_792) else fail-any) else fail-any))) in
        {237}let v_799: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_796),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then dhexp(2-proj-2-tuple(v_795),v_792) else fail-any) else fail-any))) in
        {238}let v_800: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then dhexp(2-proj-2-tuple(v_795),v_792) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_796))) then (if not-caught-fail(v_797) then (if not-caught-fail(v_798) then (if not-caught-fail(v_799) then (v_797,v_798,v_799) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {239}let v_801: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then dhexp(2-proj-2-tuple(v_795),v_792) else fail-any) else fail-any)) then (if (not-caught-fail(v_796) && success?(is-true(success?(1-proj-3-tuple(v_796))))) then (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-3-tuple(v_800))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_800)) then cipherstatepack(2-proj-3-tuple(v_800),minnonce) else fail-any),1-proj-3-tuple(v_800),3-proj-3-tuple(v_796)) else fail-any) else fail-any) else fail-any)) in
        {240}let v_802: bitstring = catch-fail(symmetricstateunpack(v_801)) in
        {241}let v_803: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_802))) in
        {242}let v_804: aead = catch-fail(decrypt(1-proj-2-tuple(v_803),2-proj-2-tuple(v_803),3-proj-3-tuple(v_802),2-proj-3-tuple(v_790))) in
        {243}let v_805: bitstring = catch-fail(aeadunpack(v_804)) in
        {244}let v_806: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_802))) in
        {245}let v_807: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_803))) && success?(1-proj-3-tuple(v_802))) then (if (not-caught-fail(v_806) && success?(is-true(success?(1-proj-2-tuple(v_806))))) then cipherstatepack(1-proj-2-tuple(v_806),increment_nonce(2-proj-2-tuple(v_803))) else fail-any) else fail-any)) in
        {246}let v_808: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_790)) && (success?(3-proj-3-tuple(v_802)) && success?(1-proj-3-tuple(v_802)))) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then (if not-caught-fail(v_804) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then (if not-caught-fail(v_807) then (v_807,3-proj-3-tuple(v_805),1-proj-3-tuple(v_805)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {247}let v_809: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_808),2-proj-3-tuple(v_802),3-proj-3-tuple(v_802)))) in
        {248}let v_810: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_790)) && success?(symmetricstatepack(1-proj-3-tuple(v_808),2-proj-3-tuple(v_802),3-proj-3-tuple(v_802)))) then (if (not-caught-fail(v_809) && success?(is-true(success?(1-proj-3-tuple(v_809))))) then symmetricstatepack(1-proj-3-tuple(v_809),2-proj-3-tuple(v_809),hash(3-proj-3-tuple(v_809),2-proj-3-tuple(v_790))) else fail-any) else fail-any)) in
        {249}let v_811: bitstring = catch-fail((if success?(2-proj-3-tuple(v_790)) then (if (not-caught-fail(v_802) && success?(is-true(success?(1-proj-3-tuple(v_802))))) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then (if not-caught-fail(v_810) then (v_810,2-proj-3-tuple(v_808),3-proj-3-tuple(v_808)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {250}let v_812: key = catch-fail(2-proj-3-tuple(v_811)) in
        {251}let v_813: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_789))) in
        {252}let v_814: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_811))) in
        {253}let v_815: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_814),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then dhexp(2-proj-2-tuple(v_813),v_812) else fail-any) else fail-any))) in
        {254}let v_816: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_814),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then dhexp(2-proj-2-tuple(v_813),v_812) else fail-any) else fail-any))) in
        {255}let v_817: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_814),(if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then dhexp(2-proj-2-tuple(v_813),v_812) else fail-any) else fail-any))) in
        {256}let v_818: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then dhexp(2-proj-2-tuple(v_813),v_812) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_814))) then (if not-caught-fail(v_815) then (if not-caught-fail(v_816) then (if not-caught-fail(v_817) then (v_815,v_816,v_817) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {257}let v_819: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_789)) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then dhexp(2-proj-2-tuple(v_813),v_812) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_811))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-3-tuple(v_814))))) then (if (not-caught-fail(v_818) && success?(is-true(success?(1-proj-3-tuple(v_818))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_818)) then cipherstatepack(2-proj-3-tuple(v_818),minnonce) else fail-any),1-proj-3-tuple(v_818),3-proj-3-tuple(v_814)) else fail-any) else fail-any) else fail-any)) in
        {258}let v_820: bitstring = catch-fail(symmetricstateunpack(v_819)) in
        {259}let v_821: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_820))) in
        {260}let v_822: aead = catch-fail(decrypt(1-proj-2-tuple(v_821),2-proj-2-tuple(v_821),3-proj-3-tuple(v_820),3-proj-3-tuple(v_790))) in
        {261}let v_823: bitstring = catch-fail(aeadunpack(v_822)) in
        {262}let v_824: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_820))) in
        {263}let v_825: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_821))) && success?(1-proj-3-tuple(v_820))) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-2-tuple(v_824))))) then cipherstatepack(1-proj-2-tuple(v_824),increment_nonce(2-proj-2-tuple(v_821))) else fail-any) else fail-any)) in
        {264}let v_826: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_790)) && (success?(3-proj-3-tuple(v_820)) && success?(1-proj-3-tuple(v_820)))) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then (if not-caught-fail(v_822) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (if not-caught-fail(v_825) then (v_825,3-proj-3-tuple(v_823),1-proj-3-tuple(v_823)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {265}let v_827: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_826),2-proj-3-tuple(v_820),3-proj-3-tuple(v_820)))) in
        {266}let v_828: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_790)) && success?(symmetricstatepack(1-proj-3-tuple(v_826),2-proj-3-tuple(v_820),3-proj-3-tuple(v_820)))) then (if (not-caught-fail(v_827) && success?(is-true(success?(1-proj-3-tuple(v_827))))) then symmetricstatepack(1-proj-3-tuple(v_827),2-proj-3-tuple(v_827),hash(3-proj-3-tuple(v_827),3-proj-3-tuple(v_790))) else fail-any) else fail-any)) in
        {267}let v_829: bitstring = catch-fail((if success?(3-proj-3-tuple(v_790)) then (if (not-caught-fail(v_820) && success?(is-true(success?(1-proj-3-tuple(v_820))))) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then (if not-caught-fail(v_828) then (v_828,2-proj-3-tuple(v_826),3-proj-3-tuple(v_826)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {268}let v_830: key = catch-fail(dhexp(key_s(charlie),g)) in
        {269}let v_831: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_829),2-proj-7-tuple(v_789),3-proj-7-tuple(v_789),v_812,v_792,6-proj-7-tuple(v_789),7-proj-7-tuple(v_789))) in
        {270}let (hs_832: handshakestate,re_833: key,plaintext_b_834: bitstring,valid_835: bool) = (if (not-caught-fail(v_789) && success?(is-true(success?(1-proj-7-tuple(v_789))))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then (if not-caught-fail(v_791) then (if not-caught-fail(v_792) then (if not-caught-fail(v_794) then (if not-caught-fail(v_801) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-3-tuple(v_811))))) then (if not-caught-fail(v_812) then (if not-caught-fail(v_819) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then (if ((3-proj-3-tuple(v_811) && 3-proj-3-tuple(v_829)) && (v_812 = getpublickey((if not-caught-fail(v_830) then keypairpack(v_830,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_831) then (v_831,getpublickey(3-proj-7-tuple(v_789)),2-proj-3-tuple(v_829),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {271}event RecvMsg(alice,charlie,stage_b,plaintext_b_834,valid_835);
        {272}insert statestore(alice,charlie,statepack_c(hs_832))
    ) | (
        {302}get statestore(=alice,=charlie,statepack_c(hs_836: handshakestate)) in
        {274}let v_837: bitstring = catch-fail(handshakestateunpack(hs_836)) in
        {275}let v_838: bitstring = catch-fail((empty,empty,empty)) in
        {276}let v_839: key = catch-fail(dhexp(key_s(alice),g)) in
        {277}let v_840: keypair = catch-fail((if not-caught-fail(v_839) then keypairpack(v_839,key_s(alice)) else fail-any)) in
        {278}let v_841: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_837))) in
        {279}let v_842: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_841))) in
        {280}let v_843: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_842),2-proj-2-tuple(v_842),3-proj-3-tuple(v_841),getpublickey(v_840))) in
        {281}let v_844: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_841))) in
        {282}let v_845: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_842))) && success?(1-proj-3-tuple(v_841))) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-2-tuple(v_844))))) then cipherstatepack(1-proj-2-tuple(v_844),increment_nonce(2-proj-2-tuple(v_842))) else fail-any) else fail-any)) in
        {283}let v_846: bitstring = catch-fail((if (success?(getpublickey(v_840)) && (success?(3-proj-3-tuple(v_841)) && success?(1-proj-3-tuple(v_841)))) then (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-2-tuple(v_842))))) then (if not-caught-fail(v_843) then (if not-caught-fail(v_845) then (v_845,v_843) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {284}let v_847: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_846),2-proj-3-tuple(v_841),3-proj-3-tuple(v_841)))) in
        {285}let v_848: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_846)) && success?(symmetricstatepack(1-proj-2-tuple(v_846),2-proj-3-tuple(v_841),3-proj-3-tuple(v_841)))) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-3-tuple(v_847))))) then symmetricstatepack(1-proj-3-tuple(v_847),2-proj-3-tuple(v_847),hash(3-proj-3-tuple(v_847),2-proj-2-tuple(v_846))) else fail-any) else fail-any)) in
        {286}let v_849: bitstring = catch-fail((if (success?(getpublickey(v_840)) && success?(1-proj-7-tuple(v_837))) then (if (not-caught-fail(v_841) && success?(is-true(success?(1-proj-3-tuple(v_841))))) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-2-tuple(v_846))))) then (if not-caught-fail(v_848) then (v_848,2-proj-2-tuple(v_846)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {287}let v_850: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_849))) in
        {288}let v_851: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_850))) in
        {289}let v_852: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_851),2-proj-2-tuple(v_851),3-proj-3-tuple(v_850),msg_c(alice,charlie))) in
        {290}let v_853: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_850))) in
        {291}let v_854: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_851))) && success?(1-proj-3-tuple(v_850))) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-2-tuple(v_853))))) then cipherstatepack(1-proj-2-tuple(v_853),increment_nonce(2-proj-2-tuple(v_851))) else fail-any) else fail-any)) in
        {292}let v_855: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_850)) && success?(1-proj-3-tuple(v_850))) then (if (not-caught-fail(v_851) && success?(is-true(success?(1-proj-2-tuple(v_851))))) then (if not-caught-fail(v_852) then (if not-caught-fail(v_854) then (v_854,v_852) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {293}let v_856: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_855),2-proj-3-tuple(v_850),3-proj-3-tuple(v_850)))) in
        {294}let v_857: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_855)) && success?(symmetricstatepack(1-proj-2-tuple(v_855),2-proj-3-tuple(v_850),3-proj-3-tuple(v_850)))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-3-tuple(v_856))))) then symmetricstatepack(1-proj-3-tuple(v_856),2-proj-3-tuple(v_856),hash(3-proj-3-tuple(v_856),2-proj-2-tuple(v_855))) else fail-any) else fail-any)) in
        {295}let v_858: bitstring = catch-fail((if success?(1-proj-2-tuple(v_849)) then (if (not-caught-fail(v_850) && success?(is-true(success?(1-proj-3-tuple(v_850))))) then (if (not-caught-fail(v_855) && success?(is-true(success?(1-proj-2-tuple(v_855))))) then (if not-caught-fail(v_857) then (v_857,2-proj-2-tuple(v_855)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {296}let v_859: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_858),v_840,3-proj-7-tuple(v_837),4-proj-7-tuple(v_837),5-proj-7-tuple(v_837),6-proj-7-tuple(v_837),7-proj-7-tuple(v_837))) in
        {297}let v_860: bitstring = catch-fail(concat3(1-proj-3-tuple(v_838),2-proj-2-tuple(v_849),2-proj-2-tuple(v_858))) in
        {298}let (hs_861: handshakestate,re_862: key,message_c_863: bitstring) = (if (not-caught-fail(v_837) && success?(is-true(success?(1-proj-7-tuple(v_837))))) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-3-tuple(v_838))))) then (if not-caught-fail(v_840) then (if (not-caught-fail(v_849) && success?(is-true(success?(1-proj-2-tuple(v_849))))) then (if (not-caught-fail(v_858) && success?(is-true(success?(1-proj-2-tuple(v_858))))) then (if not-caught-fail(v_859) then (if not-caught-fail(v_860) then (v_859,5-proj-7-tuple(v_837),v_860) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {299}event SendMsg(alice,charlie,stage_c,msg_c(alice,charlie),true);
        {300}insert statestore(alice,charlie,statepack_d(hs_861));
        {301}out(pub, message_c_863)
    ) | (
        {328}get statestore(=alice,=charlie,statepack_d(hs_864: handshakestate)) in
        {303}in(pub, message_d_865: bitstring);
        {304}let v_866: bitstring = catch-fail(handshakestateunpack(hs_864)) in
        {305}let v_867: bitstring = catch-fail(deconcat3(message_d_865)) in
        {306}let v_868: bool = catch-fail(true) in
        {307}let v_869: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_866))) in
        {308}let v_870: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_866))) in
        {309}let v_871: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_870),(if (success?(5-proj-7-tuple(v_866)) && success?(2-proj-7-tuple(v_866))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then dhexp(2-proj-2-tuple(v_869),5-proj-7-tuple(v_866)) else fail-any) else fail-any))) in
        {310}let v_872: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_870),(if (success?(5-proj-7-tuple(v_866)) && success?(2-proj-7-tuple(v_866))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then dhexp(2-proj-2-tuple(v_869),5-proj-7-tuple(v_866)) else fail-any) else fail-any))) in
        {311}let v_873: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_870),(if (success?(5-proj-7-tuple(v_866)) && success?(2-proj-7-tuple(v_866))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then dhexp(2-proj-2-tuple(v_869),5-proj-7-tuple(v_866)) else fail-any) else fail-any))) in
        {312}let v_874: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_866)) && success?(2-proj-7-tuple(v_866))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then dhexp(2-proj-2-tuple(v_869),5-proj-7-tuple(v_866)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_870))) then (if not-caught-fail(v_871) then (if not-caught-fail(v_872) then (if not-caught-fail(v_873) then (v_871,v_872,v_873) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {313}let v_875: symmetricstate = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_866)) && success?(2-proj-7-tuple(v_866))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then dhexp(2-proj-2-tuple(v_869),5-proj-7-tuple(v_866)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_866))) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-3-tuple(v_870))))) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_874)) then cipherstatepack(2-proj-3-tuple(v_874),minnonce) else fail-any),1-proj-3-tuple(v_874),3-proj-3-tuple(v_870)) else fail-any) else fail-any) else fail-any)) in
        {314}let v_876: bitstring = catch-fail(symmetricstateunpack(v_875)) in
        {315}let v_877: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_876))) in
        {316}let v_878: aead = catch-fail(decrypt(1-proj-2-tuple(v_877),2-proj-2-tuple(v_877),3-proj-3-tuple(v_876),3-proj-3-tuple(v_867))) in
        {317}let v_879: bitstring = catch-fail(aeadunpack(v_878)) in
        {318}let v_880: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_876))) in
        {319}let v_881: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_877))) && success?(1-proj-3-tuple(v_876))) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-2-tuple(v_880))))) then cipherstatepack(1-proj-2-tuple(v_880),increment_nonce(2-proj-2-tuple(v_877))) else fail-any) else fail-any)) in
        {320}let v_882: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_867)) && (success?(3-proj-3-tuple(v_876)) && success?(1-proj-3-tuple(v_876)))) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then (if not-caught-fail(v_878) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-3-tuple(v_879))))) then (if not-caught-fail(v_881) then (v_881,3-proj-3-tuple(v_879),1-proj-3-tuple(v_879)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {321}let v_883: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_882),2-proj-3-tuple(v_876),3-proj-3-tuple(v_876)))) in
        {322}let v_884: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_867)) && success?(symmetricstatepack(1-proj-3-tuple(v_882),2-proj-3-tuple(v_876),3-proj-3-tuple(v_876)))) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then symmetricstatepack(1-proj-3-tuple(v_883),2-proj-3-tuple(v_883),hash(3-proj-3-tuple(v_883),3-proj-3-tuple(v_867))) else fail-any) else fail-any)) in
        {323}let v_885: bitstring = catch-fail((if success?(3-proj-3-tuple(v_867)) then (if (not-caught-fail(v_876) && success?(is-true(success?(1-proj-3-tuple(v_876))))) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-3-tuple(v_882))))) then (if not-caught-fail(v_884) then (v_884,2-proj-3-tuple(v_882),3-proj-3-tuple(v_882)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {324}let v_886: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_885),2-proj-7-tuple(v_866),3-proj-7-tuple(v_866),4-proj-7-tuple(v_866),5-proj-7-tuple(v_866),6-proj-7-tuple(v_866),7-proj-7-tuple(v_866))) in
        {325}let (hs_887: handshakestate,re_888: key,plaintext_d_889: bitstring,valid_890: bool) = (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-7-tuple(v_866))))) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-3-tuple(v_867))))) then (if not-caught-fail(v_868) then (if not-caught-fail(v_875) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-3-tuple(v_885))))) then (if (v_868 && 3-proj-3-tuple(v_885)) then (if not-caught-fail(v_886) then (v_886,getpublickey(3-proj-7-tuple(v_866)),2-proj-3-tuple(v_885),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {326}event RecvMsg(alice,charlie,stage_d,plaintext_d_889,valid_890);
        {327}insert statestore(alice,charlie,statepack_e(hs_887))
    ) | (
        {346}get statestore(=alice,=charlie,statepack_e(hs_891: handshakestate)) in
        {329}let v_892: bitstring = catch-fail(handshakestateunpack(hs_891)) in
        {330}let v_893: bitstring = catch-fail((empty,empty,empty)) in
        {331}let v_894: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_892))) in
        {332}let v_895: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_894))) in
        {333}let v_896: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_895),2-proj-2-tuple(v_895),3-proj-3-tuple(v_894),msg_e(alice,charlie))) in
        {334}let v_897: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_894))) in
        {335}let v_898: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_895))) && success?(1-proj-3-tuple(v_894))) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-2-tuple(v_897))))) then cipherstatepack(1-proj-2-tuple(v_897),increment_nonce(2-proj-2-tuple(v_895))) else fail-any) else fail-any)) in
        {336}let v_899: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_894)) && success?(1-proj-3-tuple(v_894))) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-2-tuple(v_895))))) then (if not-caught-fail(v_896) then (if not-caught-fail(v_898) then (v_898,v_896) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {337}let v_900: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_899),2-proj-3-tuple(v_894),3-proj-3-tuple(v_894)))) in
        {338}let v_901: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_899)) && success?(symmetricstatepack(1-proj-2-tuple(v_899),2-proj-3-tuple(v_894),3-proj-3-tuple(v_894)))) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-3-tuple(v_900))))) then symmetricstatepack(1-proj-3-tuple(v_900),2-proj-3-tuple(v_900),hash(3-proj-3-tuple(v_900),2-proj-2-tuple(v_899))) else fail-any) else fail-any)) in
        {339}let v_902: bitstring = catch-fail((if success?(1-proj-7-tuple(v_892)) then (if (not-caught-fail(v_894) && success?(is-true(success?(1-proj-3-tuple(v_894))))) then (if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-2-tuple(v_899))))) then (if not-caught-fail(v_901) then (v_901,2-proj-2-tuple(v_899)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {340}let v_903: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_902),2-proj-7-tuple(v_892),3-proj-7-tuple(v_892),4-proj-7-tuple(v_892),5-proj-7-tuple(v_892),6-proj-7-tuple(v_892),7-proj-7-tuple(v_892))) in
        {341}let v_904: bitstring = catch-fail(concat3(1-proj-3-tuple(v_893),2-proj-3-tuple(v_893),2-proj-2-tuple(v_902))) in
        {342}let (hs_905: handshakestate,re_906: key,message_e_907: bitstring) = (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-7-tuple(v_892))))) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-3-tuple(v_893))))) then (if (not-caught-fail(v_902) && success?(is-true(success?(1-proj-2-tuple(v_902))))) then (if not-caught-fail(v_903) then (if not-caught-fail(v_904) then (v_903,5-proj-7-tuple(v_892),v_904) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {343}event SendMsg(alice,charlie,stage_e,msg_e(alice,charlie),true);
        {344}insert statestore(alice,charlie,statepack_f(hs_905));
        {345}out(pub, message_e_907)
    ) | (
        {374}get statestore(=alice,=charlie,statepack_f(hs_908: handshakestate)) in
        {347}in(pub, message_f_909: bitstring);
        {348}let v_910: bitstring = catch-fail(handshakestateunpack(hs_908)) in
        {349}let v_911: bitstring = catch-fail(deconcat3(message_f_909)) in
        {350}let v_912: bool = catch-fail(true) in
        {351}let v_913: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_910))) in
        {352}let v_914: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_913))) in
        {353}let v_915: aead = catch-fail(decrypt(1-proj-2-tuple(v_914),2-proj-2-tuple(v_914),3-proj-3-tuple(v_913),3-proj-3-tuple(v_911))) in
        {354}let v_916: bitstring = catch-fail(aeadunpack(v_915)) in
        {355}let v_917: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_913))) in
        {356}let v_918: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_914))) && success?(1-proj-3-tuple(v_913))) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-2-tuple(v_917))))) then cipherstatepack(1-proj-2-tuple(v_917),increment_nonce(2-proj-2-tuple(v_914))) else fail-any) else fail-any)) in
        {357}let v_919: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_911)) && (success?(3-proj-3-tuple(v_913)) && success?(1-proj-3-tuple(v_913)))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-2-tuple(v_914))))) then (if not-caught-fail(v_915) then (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-3-tuple(v_916))))) then (if not-caught-fail(v_918) then (v_918,3-proj-3-tuple(v_916),1-proj-3-tuple(v_916)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {358}let v_920: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_919),2-proj-3-tuple(v_913),3-proj-3-tuple(v_913)))) in
        {359}let v_921: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_911)) && success?(symmetricstatepack(1-proj-3-tuple(v_919),2-proj-3-tuple(v_913),3-proj-3-tuple(v_913)))) then (if (not-caught-fail(v_920) && success?(is-true(success?(1-proj-3-tuple(v_920))))) then symmetricstatepack(1-proj-3-tuple(v_920),2-proj-3-tuple(v_920),hash(3-proj-3-tuple(v_920),3-proj-3-tuple(v_911))) else fail-any) else fail-any)) in
        {360}let v_922: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_911)) && success?(1-proj-7-tuple(v_910))) then (if (not-caught-fail(v_913) && success?(is-true(success?(1-proj-3-tuple(v_913))))) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-3-tuple(v_919))))) then (if not-caught-fail(v_921) then (v_921,2-proj-3-tuple(v_919),3-proj-3-tuple(v_919)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {361}let v_923: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_922),2-proj-7-tuple(v_910),3-proj-7-tuple(v_910),4-proj-7-tuple(v_910),5-proj-7-tuple(v_910),6-proj-7-tuple(v_910),7-proj-7-tuple(v_910))) in
        {362}let v_924: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_922))) in
        {363}let v_925: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_924),zero)) in
        {364}let v_926: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_924),zero)) in
        {365}let v_927: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_924),zero)) in
        {366}let v_928: bitstring = catch-fail((if success?(2-proj-3-tuple(v_924)) then (if not-caught-fail(v_925) then (if not-caught-fail(v_926) then (if not-caught-fail(v_927) then (v_925,v_926,v_927) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {367}let v_929: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_928)) then cipherstatepack(1-proj-3-tuple(v_928),minnonce) else fail-any)) in
        {368}let v_930: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_928)) then cipherstatepack(2-proj-3-tuple(v_928),minnonce) else fail-any)) in
        {369}let v_931: bitstring = catch-fail((if success?(1-proj-3-tuple(v_922)) then (if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-3-tuple(v_924))))) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then (if not-caught-fail(v_929) then (if not-caught-fail(v_930) then (1-proj-3-tuple(v_922),v_929,v_930) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {370}let (hs_932: handshakestate,re_933: key,plaintext_f_934: bitstring,valid_935: bool,cs1_936: cipherstate,cs2_937: cipherstate) = (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-7-tuple(v_910))))) then (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then (if not-caught-fail(v_912) then (if (not-caught-fail(v_922) && success?(is-true(success?(1-proj-3-tuple(v_922))))) then (if (v_912 && 3-proj-3-tuple(v_922)) then (if not-caught-fail(v_923) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-3-tuple(v_931))))) then (v_923,getpublickey(3-proj-7-tuple(v_910)),2-proj-3-tuple(v_922),true,2-proj-3-tuple(v_931),3-proj-3-tuple(v_931)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {371}event RecvMsg(alice,charlie,stage_f,plaintext_f_934,valid_935);
        {372}insert statestore(alice,charlie,statepack_g(hs_932));
        {373}event RecvEnd(valid_935)
    ) | (
        {375}event LeakS(phase0,alice);
        {376}out(pub, key_s(alice))
    ) | (
        {377}phase 1;
        {378}event LeakS(phase1,alice);
        {379}out(pub, key_s(alice))
    )
) | (
    {380}let s_938: keypair = keypairpack(empty,empty) in
    {381}out(pub, getpublickey(s_938));
    (
        {382}let e_939: keypair = keypairpack(empty,empty) in
        {383}let rs_940: key = empty in
        {384}let re_941: key = empty in
        {385}let v_942: bitstring = catch-fail(hash(somename,empty)) in
        {386}let v_943: key = catch-fail(v_942) in
        {387}let v_944: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {388}let v_945: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_942) then (if not-caught-fail(v_943) then (if not-caught-fail(v_944) then symmetricstatepack(v_944,v_943,v_942) else fail-any) else fail-any) else fail-any))) in
        {389}let v_946: symmetricstate = catch-fail((if success?((if not-caught-fail(v_942) then (if not-caught-fail(v_943) then (if not-caught-fail(v_944) then symmetricstatepack(v_944,v_943,v_942) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-3-tuple(v_945))))) then symmetricstatepack(1-proj-3-tuple(v_945),2-proj-3-tuple(v_945),hash(3-proj-3-tuple(v_945),empty)) else fail-any) else fail-any)) in
        {390}let hs_947: handshakestate = (if not-caught-fail(v_946) then handshakestatepack(v_946,s_938,e_939,rs_940,re_941,empty,false) else fail-any) in
        {391}insert statestore(bob,alice,statepack_a(hs_947))
    ) | (
        {413}get statestore(=bob,=alice,statepack_a(hs_948: handshakestate)) in
        {392}in(pub, message_a_949: bitstring);
        {393}let v_950: bitstring = catch-fail(handshakestateunpack(hs_948)) in
        {394}let v_951: bitstring = catch-fail(deconcat3(message_a_949)) in
        {395}let v_952: bool = catch-fail(true) in
        {396}let v_953: key = catch-fail(1-proj-3-tuple(v_951)) in
        {397}let v_954: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_950))) in
        {398}let v_955: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_950)) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-3-tuple(v_954))))) then symmetricstatepack(1-proj-3-tuple(v_954),2-proj-3-tuple(v_954),hash(3-proj-3-tuple(v_954),v_953)) else fail-any) else fail-any)) in
        {399}let v_956: bitstring = catch-fail(symmetricstateunpack(v_955)) in
        {400}let v_957: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {401}let v_958: aead = catch-fail(decrypt(1-proj-2-tuple(v_957),2-proj-2-tuple(v_957),3-proj-3-tuple(v_956),3-proj-3-tuple(v_951))) in
        {402}let v_959: bitstring = catch-fail(aeadunpack(v_958)) in
        {403}let v_960: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {404}let v_961: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_957))) && success?(1-proj-3-tuple(v_956))) then (if (not-caught-fail(v_960) && success?(is-true(success?(1-proj-2-tuple(v_960))))) then cipherstatepack(1-proj-2-tuple(v_960),increment_nonce(2-proj-2-tuple(v_957))) else fail-any) else fail-any)) in
        {405}let v_962: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_951)) && (success?(3-proj-3-tuple(v_956)) && success?(1-proj-3-tuple(v_956)))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then (if not-caught-fail(v_958) then (if (not-caught-fail(v_959) && success?(is-true(success?(1-proj-3-tuple(v_959))))) then (if not-caught-fail(v_961) then (v_961,3-proj-3-tuple(v_959),1-proj-3-tuple(v_959)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {406}let v_963: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) in
        {407}let v_964: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_951)) && success?(symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-3-tuple(v_963))))) then symmetricstatepack(1-proj-3-tuple(v_963),2-proj-3-tuple(v_963),hash(3-proj-3-tuple(v_963),3-proj-3-tuple(v_951))) else fail-any) else fail-any)) in
        {408}let v_965: bitstring = catch-fail((if success?(3-proj-3-tuple(v_951)) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then (if not-caught-fail(v_964) then (v_964,2-proj-3-tuple(v_962),3-proj-3-tuple(v_962)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {409}let v_966: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_965),2-proj-7-tuple(v_950),3-proj-7-tuple(v_950),4-proj-7-tuple(v_950),v_953,6-proj-7-tuple(v_950),7-proj-7-tuple(v_950))) in
        {410}let (hs_967: handshakestate,re_968: key,plaintext_a: bitstring,valid_969: bool) = (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-7-tuple(v_950))))) then (if (not-caught-fail(v_951) && success?(is-true(success?(1-proj-3-tuple(v_951))))) then (if not-caught-fail(v_952) then (if not-caught-fail(v_953) then (if not-caught-fail(v_955) then (if (not-caught-fail(v_965) && success?(is-true(success?(1-proj-3-tuple(v_965))))) then (if (v_952 && 3-proj-3-tuple(v_965)) then (if not-caught-fail(v_966) then (v_966,getpublickey(3-proj-7-tuple(v_950)),2-proj-3-tuple(v_965),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {411}event RecvMsg(bob,alice,stage_a,plaintext_a,valid_969);
        {412}insert statestore(bob,alice,statepack_b(hs_967))
    ) | (
        {461}get statestore(=bob,=alice,statepack_b(hs_970: handshakestate)) in
        {414}let v_971: bitstring = catch-fail(handshakestateunpack(hs_970)) in
        {415}let v_972: bitstring = catch-fail((empty,empty,empty)) in
        {416}let v_973: key = catch-fail(dhexp(key_e(bob,alice),g)) in
        {417}let v_974: keypair = catch-fail((if not-caught-fail(v_973) then keypairpack(v_973,key_e(bob,alice)) else fail-any)) in
        {418}let v_975: bitstring = catch-fail(getpublickey(v_974)) in
        {419}let v_976: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_971))) in
        {420}let v_977: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_971)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-3-tuple(v_976))))) then symmetricstatepack(1-proj-3-tuple(v_976),2-proj-3-tuple(v_976),hash(3-proj-3-tuple(v_976),v_975)) else fail-any) else fail-any)) in
        {421}let v_978: bitstring = catch-fail(keypairunpack(v_974)) in
        {422}let v_979: bitstring = catch-fail(symmetricstateunpack(v_977)) in
        {423}let v_980: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_979),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then dhexp(2-proj-2-tuple(v_978),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {424}let v_981: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_979),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then dhexp(2-proj-2-tuple(v_978),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {425}let v_982: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_979),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then dhexp(2-proj-2-tuple(v_978),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {426}let v_983: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then dhexp(2-proj-2-tuple(v_978),5-proj-7-tuple(v_971)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_979))) then (if not-caught-fail(v_980) then (if not-caught-fail(v_981) then (if not-caught-fail(v_982) then (v_980,v_981,v_982) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {427}let v_984: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then dhexp(2-proj-2-tuple(v_978),5-proj-7-tuple(v_971)) else fail-any) else fail-any)) then (if (not-caught-fail(v_979) && success?(is-true(success?(1-proj-3-tuple(v_979))))) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-3-tuple(v_983))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_983)) then cipherstatepack(2-proj-3-tuple(v_983),minnonce) else fail-any),1-proj-3-tuple(v_983),3-proj-3-tuple(v_979)) else fail-any) else fail-any) else fail-any)) in
        {428}let v_985: key = catch-fail(dhexp(key_s(bob),g)) in
        {429}let v_986: keypair = catch-fail((if not-caught-fail(v_985) then keypairpack(v_985,key_s(bob)) else fail-any)) in
        {430}let v_987: bitstring = catch-fail(symmetricstateunpack(v_984)) in
        {431}let v_988: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_987))) in
        {432}let v_989: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_988),2-proj-2-tuple(v_988),3-proj-3-tuple(v_987),getpublickey(v_986))) in
        {433}let v_990: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_987))) in
        {434}let v_991: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_988))) && success?(1-proj-3-tuple(v_987))) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then cipherstatepack(1-proj-2-tuple(v_990),increment_nonce(2-proj-2-tuple(v_988))) else fail-any) else fail-any)) in
        {435}let v_992: bitstring = catch-fail((if (success?(getpublickey(v_986)) && (success?(3-proj-3-tuple(v_987)) && success?(1-proj-3-tuple(v_987)))) then (if (not-caught-fail(v_988) && success?(is-true(success?(1-proj-2-tuple(v_988))))) then (if not-caught-fail(v_989) then (if not-caught-fail(v_991) then (v_991,v_989) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {436}let v_993: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_992),2-proj-3-tuple(v_987),3-proj-3-tuple(v_987)))) in
        {437}let v_994: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_992)) && success?(symmetricstatepack(1-proj-2-tuple(v_992),2-proj-3-tuple(v_987),3-proj-3-tuple(v_987)))) then (if (not-caught-fail(v_993) && success?(is-true(success?(1-proj-3-tuple(v_993))))) then symmetricstatepack(1-proj-3-tuple(v_993),2-proj-3-tuple(v_993),hash(3-proj-3-tuple(v_993),2-proj-2-tuple(v_992))) else fail-any) else fail-any)) in
        {438}let v_995: bitstring = catch-fail((if success?(getpublickey(v_986)) then (if (not-caught-fail(v_987) && success?(is-true(success?(1-proj-3-tuple(v_987))))) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-2-tuple(v_992))))) then (if not-caught-fail(v_994) then (v_994,2-proj-2-tuple(v_992)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {439}let v_996: bitstring = catch-fail(keypairunpack(v_986)) in
        {440}let v_997: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_995))) in
        {441}let v_998: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_997),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then dhexp(2-proj-2-tuple(v_996),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {442}let v_999: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_997),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then dhexp(2-proj-2-tuple(v_996),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {443}let v_1000: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_997),(if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then dhexp(2-proj-2-tuple(v_996),5-proj-7-tuple(v_971)) else fail-any) else fail-any))) in
        {444}let v_1001: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then dhexp(2-proj-2-tuple(v_996),5-proj-7-tuple(v_971)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_997))) then (if not-caught-fail(v_998) then (if not-caught-fail(v_999) then (if not-caught-fail(v_1000) then (v_998,v_999,v_1000) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {445}let v_1002: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_971)) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then dhexp(2-proj-2-tuple(v_996),5-proj-7-tuple(v_971)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_995))) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-3-tuple(v_1001))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1001)) then cipherstatepack(2-proj-3-tuple(v_1001),minnonce) else fail-any),1-proj-3-tuple(v_1001),3-proj-3-tuple(v_997)) else fail-any) else fail-any) else fail-any)) in
        {446}let v_1003: bitstring = catch-fail(symmetricstateunpack(v_1002)) in
        {447}let v_1004: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1003))) in
        {448}let v_1005: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1004),2-proj-2-tuple(v_1004),3-proj-3-tuple(v_1003),msg_b(bob,alice))) in
        {449}let v_1006: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1003))) in
        {450}let v_1007: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1004))) && success?(1-proj-3-tuple(v_1003))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-2-tuple(v_1006))))) then cipherstatepack(1-proj-2-tuple(v_1006),increment_nonce(2-proj-2-tuple(v_1004))) else fail-any) else fail-any)) in
        {451}let v_1008: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1003)) && success?(1-proj-3-tuple(v_1003))) then (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-2-tuple(v_1004))))) then (if not-caught-fail(v_1005) then (if not-caught-fail(v_1007) then (v_1007,v_1005) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {452}let v_1009: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1008),2-proj-3-tuple(v_1003),3-proj-3-tuple(v_1003)))) in
        {453}let v_1010: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1008)) && success?(symmetricstatepack(1-proj-2-tuple(v_1008),2-proj-3-tuple(v_1003),3-proj-3-tuple(v_1003)))) then (if (not-caught-fail(v_1009) && success?(is-true(success?(1-proj-3-tuple(v_1009))))) then symmetricstatepack(1-proj-3-tuple(v_1009),2-proj-3-tuple(v_1009),hash(3-proj-3-tuple(v_1009),2-proj-2-tuple(v_1008))) else fail-any) else fail-any)) in
        {454}let v_1011: bitstring = catch-fail((if (not-caught-fail(v_1003) && success?(is-true(success?(1-proj-3-tuple(v_1003))))) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-2-tuple(v_1008))))) then (if not-caught-fail(v_1010) then (v_1010,2-proj-2-tuple(v_1008)) else fail-any) else fail-any) else fail-any)) in
        {455}let v_1012: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1011),v_986,v_974,4-proj-7-tuple(v_971),5-proj-7-tuple(v_971),6-proj-7-tuple(v_971),7-proj-7-tuple(v_971))) in
        {456}let v_1013: bitstring = catch-fail(concat3(v_975,2-proj-2-tuple(v_995),2-proj-2-tuple(v_1011))) in
        {457}let (hs_1014: handshakestate,re_1015: key,message_b_1016: bitstring) = (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-7-tuple(v_971))))) then (if (not-caught-fail(v_972) && success?(is-true(success?(1-proj-3-tuple(v_972))))) then (if not-caught-fail(v_974) then (if not-caught-fail(v_975) then (if not-caught-fail(v_977) then (if not-caught-fail(v_984) then (if not-caught-fail(v_986) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-2-tuple(v_995))))) then (if not-caught-fail(v_1002) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-2-tuple(v_1011))))) then (if not-caught-fail(v_1012) then (if not-caught-fail(v_1013) then (v_1012,5-proj-7-tuple(v_971),v_1013) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {458}event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true);
        {459}insert statestore(bob,alice,statepack_c(hs_1014));
        {460}out(pub, message_b_1016)
    ) | (
        {492}get statestore(=bob,=alice,statepack_c(hs_1017: handshakestate)) in
        {462}in(pub, message_c_1018: bitstring);
        {463}let v_1019: bitstring = catch-fail(handshakestateunpack(hs_1017)) in
        {464}let v_1020: bitstring = catch-fail(deconcat3(message_c_1018)) in
        {465}let v_1021: bool = catch-fail(true) in
        {466}let v_1022: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1019))) in
        {467}let v_1023: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1022))) in
        {468}let v_1024: aead = catch-fail(decrypt(1-proj-2-tuple(v_1023),2-proj-2-tuple(v_1023),3-proj-3-tuple(v_1022),2-proj-3-tuple(v_1020))) in
        {469}let v_1025: bitstring = catch-fail(aeadunpack(v_1024)) in
        {470}let v_1026: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1022))) in
        {471}let v_1027: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1023))) && success?(1-proj-3-tuple(v_1022))) then (if (not-caught-fail(v_1026) && success?(is-true(success?(1-proj-2-tuple(v_1026))))) then cipherstatepack(1-proj-2-tuple(v_1026),increment_nonce(2-proj-2-tuple(v_1023))) else fail-any) else fail-any)) in
        {472}let v_1028: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1020)) && (success?(3-proj-3-tuple(v_1022)) && success?(1-proj-3-tuple(v_1022)))) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-2-tuple(v_1023))))) then (if not-caught-fail(v_1024) then (if (not-caught-fail(v_1025) && success?(is-true(success?(1-proj-3-tuple(v_1025))))) then (if not-caught-fail(v_1027) then (v_1027,3-proj-3-tuple(v_1025),1-proj-3-tuple(v_1025)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {473}let v_1029: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1028),2-proj-3-tuple(v_1022),3-proj-3-tuple(v_1022)))) in
        {474}let v_1030: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1020)) && success?(symmetricstatepack(1-proj-3-tuple(v_1028),2-proj-3-tuple(v_1022),3-proj-3-tuple(v_1022)))) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-3-tuple(v_1029))))) then symmetricstatepack(1-proj-3-tuple(v_1029),2-proj-3-tuple(v_1029),hash(3-proj-3-tuple(v_1029),2-proj-3-tuple(v_1020))) else fail-any) else fail-any)) in
        {475}let v_1031: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1020)) && success?(1-proj-7-tuple(v_1019))) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-3-tuple(v_1022))))) then (if (not-caught-fail(v_1028) && success?(is-true(success?(1-proj-3-tuple(v_1028))))) then (if not-caught-fail(v_1030) then (v_1030,2-proj-3-tuple(v_1028),3-proj-3-tuple(v_1028)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {476}let v_1032: key = catch-fail(2-proj-3-tuple(v_1031)) in
        {477}let v_1033: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1031))) in
        {478}let v_1034: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1033))) in
        {479}let v_1035: aead = catch-fail(decrypt(1-proj-2-tuple(v_1034),2-proj-2-tuple(v_1034),3-proj-3-tuple(v_1033),3-proj-3-tuple(v_1020))) in
        {480}let v_1036: bitstring = catch-fail(aeadunpack(v_1035)) in
        {481}let v_1037: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1033))) in
        {482}let v_1038: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1034))) && success?(1-proj-3-tuple(v_1033))) then (if (not-caught-fail(v_1037) && success?(is-true(success?(1-proj-2-tuple(v_1037))))) then cipherstatepack(1-proj-2-tuple(v_1037),increment_nonce(2-proj-2-tuple(v_1034))) else fail-any) else fail-any)) in
        {483}let v_1039: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1020)) && (success?(3-proj-3-tuple(v_1033)) && success?(1-proj-3-tuple(v_1033)))) then (if (not-caught-fail(v_1034) && success?(is-true(success?(1-proj-2-tuple(v_1034))))) then (if not-caught-fail(v_1035) then (if (not-caught-fail(v_1036) && success?(is-true(success?(1-proj-3-tuple(v_1036))))) then (if not-caught-fail(v_1038) then (v_1038,3-proj-3-tuple(v_1036),1-proj-3-tuple(v_1036)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {484}let v_1040: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1039),2-proj-3-tuple(v_1033),3-proj-3-tuple(v_1033)))) in
        {485}let v_1041: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1020)) && success?(symmetricstatepack(1-proj-3-tuple(v_1039),2-proj-3-tuple(v_1033),3-proj-3-tuple(v_1033)))) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-3-tuple(v_1040))))) then symmetricstatepack(1-proj-3-tuple(v_1040),2-proj-3-tuple(v_1040),hash(3-proj-3-tuple(v_1040),3-proj-3-tuple(v_1020))) else fail-any) else fail-any)) in
        {486}let v_1042: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1020)) && success?(1-proj-3-tuple(v_1031))) then (if (not-caught-fail(v_1033) && success?(is-true(success?(1-proj-3-tuple(v_1033))))) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then (if not-caught-fail(v_1041) then (v_1041,2-proj-3-tuple(v_1039),3-proj-3-tuple(v_1039)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {487}let v_1043: key = catch-fail(dhexp(key_s(alice),g)) in
        {488}let v_1044: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1042),2-proj-7-tuple(v_1019),3-proj-7-tuple(v_1019),v_1032,5-proj-7-tuple(v_1019),6-proj-7-tuple(v_1019),7-proj-7-tuple(v_1019))) in
        {489}let (hs_1045: handshakestate,re_1046: key,plaintext_c: bitstring,valid_1047: bool) = (if (not-caught-fail(v_1019) && success?(is-true(success?(1-proj-7-tuple(v_1019))))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then (if not-caught-fail(v_1021) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-3-tuple(v_1031))))) then (if not-caught-fail(v_1032) then (if (not-caught-fail(v_1042) && success?(is-true(success?(1-proj-3-tuple(v_1042))))) then (if ((3-proj-3-tuple(v_1031) && 3-proj-3-tuple(v_1042)) && (v_1032 = getpublickey((if not-caught-fail(v_1043) then keypairpack(v_1043,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_1044) then (v_1044,getpublickey(3-proj-7-tuple(v_1019)),2-proj-3-tuple(v_1042),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {490}event RecvMsg(bob,alice,stage_c,plaintext_c,valid_1047);
        {491}insert statestore(bob,alice,statepack_d(hs_1045))
    ) | (
        {517}get statestore(=bob,=alice,statepack_d(hs_1048: handshakestate)) in
        {493}let v_1049: bitstring = catch-fail(handshakestateunpack(hs_1048)) in
        {494}let v_1050: bitstring = catch-fail((empty,empty,empty)) in
        {495}let v_1051: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1049))) in
        {496}let v_1052: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1049))) in
        {497}let v_1053: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1052),(if (success?(4-proj-7-tuple(v_1049)) && success?(3-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then dhexp(2-proj-2-tuple(v_1051),4-proj-7-tuple(v_1049)) else fail-any) else fail-any))) in
        {498}let v_1054: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1052),(if (success?(4-proj-7-tuple(v_1049)) && success?(3-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then dhexp(2-proj-2-tuple(v_1051),4-proj-7-tuple(v_1049)) else fail-any) else fail-any))) in
        {499}let v_1055: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1052),(if (success?(4-proj-7-tuple(v_1049)) && success?(3-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then dhexp(2-proj-2-tuple(v_1051),4-proj-7-tuple(v_1049)) else fail-any) else fail-any))) in
        {500}let v_1056: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1049)) && success?(3-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then dhexp(2-proj-2-tuple(v_1051),4-proj-7-tuple(v_1049)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1052))) then (if not-caught-fail(v_1053) then (if not-caught-fail(v_1054) then (if not-caught-fail(v_1055) then (v_1053,v_1054,v_1055) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {501}let v_1057: symmetricstate = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1049)) && success?(3-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then dhexp(2-proj-2-tuple(v_1051),4-proj-7-tuple(v_1049)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_1049))) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-3-tuple(v_1052))))) then (if (not-caught-fail(v_1056) && success?(is-true(success?(1-proj-3-tuple(v_1056))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1056)) then cipherstatepack(2-proj-3-tuple(v_1056),minnonce) else fail-any),1-proj-3-tuple(v_1056),3-proj-3-tuple(v_1052)) else fail-any) else fail-any) else fail-any)) in
        {502}let v_1058: bitstring = catch-fail(symmetricstateunpack(v_1057)) in
        {503}let v_1059: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1058))) in
        {504}let v_1060: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1059),2-proj-2-tuple(v_1059),3-proj-3-tuple(v_1058),msg_d(bob,alice))) in
        {505}let v_1061: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1058))) in
        {506}let v_1062: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1059))) && success?(1-proj-3-tuple(v_1058))) then (if (not-caught-fail(v_1061) && success?(is-true(success?(1-proj-2-tuple(v_1061))))) then cipherstatepack(1-proj-2-tuple(v_1061),increment_nonce(2-proj-2-tuple(v_1059))) else fail-any) else fail-any)) in
        {507}let v_1063: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1058)) && success?(1-proj-3-tuple(v_1058))) then (if (not-caught-fail(v_1059) && success?(is-true(success?(1-proj-2-tuple(v_1059))))) then (if not-caught-fail(v_1060) then (if not-caught-fail(v_1062) then (v_1062,v_1060) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {508}let v_1064: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1063),2-proj-3-tuple(v_1058),3-proj-3-tuple(v_1058)))) in
        {509}let v_1065: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1063)) && success?(symmetricstatepack(1-proj-2-tuple(v_1063),2-proj-3-tuple(v_1058),3-proj-3-tuple(v_1058)))) then (if (not-caught-fail(v_1064) && success?(is-true(success?(1-proj-3-tuple(v_1064))))) then symmetricstatepack(1-proj-3-tuple(v_1064),2-proj-3-tuple(v_1064),hash(3-proj-3-tuple(v_1064),2-proj-2-tuple(v_1063))) else fail-any) else fail-any)) in
        {510}let v_1066: bitstring = catch-fail((if (not-caught-fail(v_1058) && success?(is-true(success?(1-proj-3-tuple(v_1058))))) then (if (not-caught-fail(v_1063) && success?(is-true(success?(1-proj-2-tuple(v_1063))))) then (if not-caught-fail(v_1065) then (v_1065,2-proj-2-tuple(v_1063)) else fail-any) else fail-any) else fail-any)) in
        {511}let v_1067: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1066),2-proj-7-tuple(v_1049),3-proj-7-tuple(v_1049),4-proj-7-tuple(v_1049),5-proj-7-tuple(v_1049),6-proj-7-tuple(v_1049),7-proj-7-tuple(v_1049))) in
        {512}let v_1068: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1050),2-proj-3-tuple(v_1050),2-proj-2-tuple(v_1066))) in
        {513}let (hs_1069: handshakestate,re_1070: key,message_d_1071: bitstring) = (if (not-caught-fail(v_1049) && success?(is-true(success?(1-proj-7-tuple(v_1049))))) then (if (not-caught-fail(v_1050) && success?(is-true(success?(1-proj-3-tuple(v_1050))))) then (if not-caught-fail(v_1057) then (if (not-caught-fail(v_1066) && success?(is-true(success?(1-proj-2-tuple(v_1066))))) then (if not-caught-fail(v_1067) then (if not-caught-fail(v_1068) then (v_1067,5-proj-7-tuple(v_1049),v_1068) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {514}event SendMsg(bob,alice,stage_d,msg_d(bob,alice),true);
        {515}insert statestore(bob,alice,statepack_e(hs_1069));
        {516}out(pub, message_d_1071)
    ) | (
        {536}get statestore(=bob,=alice,statepack_e(hs_1072: handshakestate)) in
        {518}in(pub, message_e_1073: bitstring);
        {519}let v_1074: bitstring = catch-fail(handshakestateunpack(hs_1072)) in
        {520}let v_1075: bitstring = catch-fail(deconcat3(message_e_1073)) in
        {521}let v_1076: bool = catch-fail(true) in
        {522}let v_1077: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1074))) in
        {523}let v_1078: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1077))) in
        {524}let v_1079: aead = catch-fail(decrypt(1-proj-2-tuple(v_1078),2-proj-2-tuple(v_1078),3-proj-3-tuple(v_1077),3-proj-3-tuple(v_1075))) in
        {525}let v_1080: bitstring = catch-fail(aeadunpack(v_1079)) in
        {526}let v_1081: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1077))) in
        {527}let v_1082: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1078))) && success?(1-proj-3-tuple(v_1077))) then (if (not-caught-fail(v_1081) && success?(is-true(success?(1-proj-2-tuple(v_1081))))) then cipherstatepack(1-proj-2-tuple(v_1081),increment_nonce(2-proj-2-tuple(v_1078))) else fail-any) else fail-any)) in
        {528}let v_1083: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1075)) && (success?(3-proj-3-tuple(v_1077)) && success?(1-proj-3-tuple(v_1077)))) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then (if not-caught-fail(v_1079) then (if (not-caught-fail(v_1080) && success?(is-true(success?(1-proj-3-tuple(v_1080))))) then (if not-caught-fail(v_1082) then (v_1082,3-proj-3-tuple(v_1080),1-proj-3-tuple(v_1080)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {529}let v_1084: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1083),2-proj-3-tuple(v_1077),3-proj-3-tuple(v_1077)))) in
        {530}let v_1085: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1075)) && success?(symmetricstatepack(1-proj-3-tuple(v_1083),2-proj-3-tuple(v_1077),3-proj-3-tuple(v_1077)))) then (if (not-caught-fail(v_1084) && success?(is-true(success?(1-proj-3-tuple(v_1084))))) then symmetricstatepack(1-proj-3-tuple(v_1084),2-proj-3-tuple(v_1084),hash(3-proj-3-tuple(v_1084),3-proj-3-tuple(v_1075))) else fail-any) else fail-any)) in
        {531}let v_1086: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1075)) && success?(1-proj-7-tuple(v_1074))) then (if (not-caught-fail(v_1077) && success?(is-true(success?(1-proj-3-tuple(v_1077))))) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then (if not-caught-fail(v_1085) then (v_1085,2-proj-3-tuple(v_1083),3-proj-3-tuple(v_1083)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {532}let v_1087: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1086),2-proj-7-tuple(v_1074),3-proj-7-tuple(v_1074),4-proj-7-tuple(v_1074),5-proj-7-tuple(v_1074),6-proj-7-tuple(v_1074),7-proj-7-tuple(v_1074))) in
        {533}let (hs_1088: handshakestate,re_1089: key,plaintext_e: bitstring,valid_1090: bool) = (if (not-caught-fail(v_1074) && success?(is-true(success?(1-proj-7-tuple(v_1074))))) then (if (not-caught-fail(v_1075) && success?(is-true(success?(1-proj-3-tuple(v_1075))))) then (if not-caught-fail(v_1076) then (if (not-caught-fail(v_1086) && success?(is-true(success?(1-proj-3-tuple(v_1086))))) then (if (v_1076 && 3-proj-3-tuple(v_1086)) then (if not-caught-fail(v_1087) then (v_1087,getpublickey(3-proj-7-tuple(v_1074)),2-proj-3-tuple(v_1086),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {534}event RecvMsg(bob,alice,stage_e,plaintext_e,valid_1090);
        {535}insert statestore(bob,alice,statepack_f(hs_1088))
    ) | (
        {562}get statestore(=bob,=alice,statepack_f(hs_1091: handshakestate)) in
        {537}let v_1092: bitstring = catch-fail(handshakestateunpack(hs_1091)) in
        {538}let v_1093: bitstring = catch-fail((empty,empty,empty)) in
        {539}let v_1094: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1092))) in
        {540}let v_1095: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1094))) in
        {541}let v_1096: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1095),2-proj-2-tuple(v_1095),3-proj-3-tuple(v_1094),msg_f(bob,alice))) in
        {542}let v_1097: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1094))) in
        {543}let v_1098: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1095))) && success?(1-proj-3-tuple(v_1094))) then (if (not-caught-fail(v_1097) && success?(is-true(success?(1-proj-2-tuple(v_1097))))) then cipherstatepack(1-proj-2-tuple(v_1097),increment_nonce(2-proj-2-tuple(v_1095))) else fail-any) else fail-any)) in
        {544}let v_1099: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1094)) && success?(1-proj-3-tuple(v_1094))) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then (if not-caught-fail(v_1096) then (if not-caught-fail(v_1098) then (v_1098,v_1096) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {545}let v_1100: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1099),2-proj-3-tuple(v_1094),3-proj-3-tuple(v_1094)))) in
        {546}let v_1101: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1099)) && success?(symmetricstatepack(1-proj-2-tuple(v_1099),2-proj-3-tuple(v_1094),3-proj-3-tuple(v_1094)))) then (if (not-caught-fail(v_1100) && success?(is-true(success?(1-proj-3-tuple(v_1100))))) then symmetricstatepack(1-proj-3-tuple(v_1100),2-proj-3-tuple(v_1100),hash(3-proj-3-tuple(v_1100),2-proj-2-tuple(v_1099))) else fail-any) else fail-any)) in
        {547}let v_1102: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1092)) then (if (not-caught-fail(v_1094) && success?(is-true(success?(1-proj-3-tuple(v_1094))))) then (if (not-caught-fail(v_1099) && success?(is-true(success?(1-proj-2-tuple(v_1099))))) then (if not-caught-fail(v_1101) then (v_1101,2-proj-2-tuple(v_1099)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {548}let v_1103: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1102),2-proj-7-tuple(v_1092),3-proj-7-tuple(v_1092),4-proj-7-tuple(v_1092),5-proj-7-tuple(v_1092),6-proj-7-tuple(v_1092),7-proj-7-tuple(v_1092))) in
        {549}let v_1104: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1093),2-proj-3-tuple(v_1093),2-proj-2-tuple(v_1102))) in
        {550}let v_1105: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1102))) in
        {551}let v_1106: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1105),zero)) in
        {552}let v_1107: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1105),zero)) in
        {553}let v_1108: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1105),zero)) in
        {554}let v_1109: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1105)) then (if not-caught-fail(v_1106) then (if not-caught-fail(v_1107) then (if not-caught-fail(v_1108) then (v_1106,v_1107,v_1108) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {555}let v_1110: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1109)) then cipherstatepack(1-proj-3-tuple(v_1109),minnonce) else fail-any)) in
        {556}let v_1111: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1109)) then cipherstatepack(2-proj-3-tuple(v_1109),minnonce) else fail-any)) in
        {557}let v_1112: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1102)) then (if (not-caught-fail(v_1105) && success?(is-true(success?(1-proj-3-tuple(v_1105))))) then (if (not-caught-fail(v_1109) && success?(is-true(success?(1-proj-3-tuple(v_1109))))) then (if not-caught-fail(v_1110) then (if not-caught-fail(v_1111) then (1-proj-2-tuple(v_1102),v_1110,v_1111) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {558}let (hs_1113: handshakestate,re_1114: key,message_f_1115: bitstring,cs1_1116: cipherstate,cs2_1117: cipherstate) = (if (not-caught-fail(v_1092) && success?(is-true(success?(1-proj-7-tuple(v_1092))))) then (if (not-caught-fail(v_1093) && success?(is-true(success?(1-proj-3-tuple(v_1093))))) then (if (not-caught-fail(v_1102) && success?(is-true(success?(1-proj-2-tuple(v_1102))))) then (if not-caught-fail(v_1103) then (if not-caught-fail(v_1104) then (if (not-caught-fail(v_1112) && success?(is-true(success?(1-proj-3-tuple(v_1112))))) then (v_1103,5-proj-7-tuple(v_1092),v_1104,2-proj-3-tuple(v_1112),3-proj-3-tuple(v_1112)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {559}event SendMsg(bob,alice,stage_f,msg_f(bob,alice),true);
        {560}insert statestore(bob,alice,statepack_g(hs_1113));
        {561}out(pub, message_f_1115)
    ) | (
        {563}event LeakS(phase0,bob);
        {564}out(pub, key_s(bob))
    ) | (
        {565}phase 1;
        {566}event LeakS(phase1,bob);
        {567}out(pub, key_s(bob))
    )
) | (
    {568}let s_1118: keypair = keypairpack(empty,empty) in
    {569}out(pub, getpublickey(s_1118));
    (
        {570}let e_1119: keypair = keypairpack(empty,empty) in
        {571}let rs_1120: key = empty in
        {572}let re_1121: key = empty in
        {573}let v_1122: bitstring = catch-fail(hash(somename,empty)) in
        {574}let v_1123: key = catch-fail(v_1122) in
        {575}let v_1124: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {576}let v_1125: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_1122) then (if not-caught-fail(v_1123) then (if not-caught-fail(v_1124) then symmetricstatepack(v_1124,v_1123,v_1122) else fail-any) else fail-any) else fail-any))) in
        {577}let v_1126: symmetricstate = catch-fail((if success?((if not-caught-fail(v_1122) then (if not-caught-fail(v_1123) then (if not-caught-fail(v_1124) then symmetricstatepack(v_1124,v_1123,v_1122) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_1125) && success?(is-true(success?(1-proj-3-tuple(v_1125))))) then symmetricstatepack(1-proj-3-tuple(v_1125),2-proj-3-tuple(v_1125),hash(3-proj-3-tuple(v_1125),empty)) else fail-any) else fail-any)) in
        {578}let hs_1127: handshakestate = (if not-caught-fail(v_1126) then handshakestatepack(v_1126,s_1118,e_1119,rs_1120,re_1121,empty,false) else fail-any) in
        {579}insert statestore(bob,charlie,statepack_a(hs_1127))
    ) | (
        {601}get statestore(=bob,=charlie,statepack_a(hs_1128: handshakestate)) in
        {580}in(pub, message_a_1129: bitstring);
        {581}let v_1130: bitstring = catch-fail(handshakestateunpack(hs_1128)) in
        {582}let v_1131: bitstring = catch-fail(deconcat3(message_a_1129)) in
        {583}let v_1132: bool = catch-fail(true) in
        {584}let v_1133: key = catch-fail(1-proj-3-tuple(v_1131)) in
        {585}let v_1134: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1130))) in
        {586}let v_1135: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1130)) then (if (not-caught-fail(v_1134) && success?(is-true(success?(1-proj-3-tuple(v_1134))))) then symmetricstatepack(1-proj-3-tuple(v_1134),2-proj-3-tuple(v_1134),hash(3-proj-3-tuple(v_1134),v_1133)) else fail-any) else fail-any)) in
        {587}let v_1136: bitstring = catch-fail(symmetricstateunpack(v_1135)) in
        {588}let v_1137: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1136))) in
        {589}let v_1138: aead = catch-fail(decrypt(1-proj-2-tuple(v_1137),2-proj-2-tuple(v_1137),3-proj-3-tuple(v_1136),3-proj-3-tuple(v_1131))) in
        {590}let v_1139: bitstring = catch-fail(aeadunpack(v_1138)) in
        {591}let v_1140: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1136))) in
        {592}let v_1141: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1137))) && success?(1-proj-3-tuple(v_1136))) then (if (not-caught-fail(v_1140) && success?(is-true(success?(1-proj-2-tuple(v_1140))))) then cipherstatepack(1-proj-2-tuple(v_1140),increment_nonce(2-proj-2-tuple(v_1137))) else fail-any) else fail-any)) in
        {593}let v_1142: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1131)) && (success?(3-proj-3-tuple(v_1136)) && success?(1-proj-3-tuple(v_1136)))) then (if (not-caught-fail(v_1137) && success?(is-true(success?(1-proj-2-tuple(v_1137))))) then (if not-caught-fail(v_1138) then (if (not-caught-fail(v_1139) && success?(is-true(success?(1-proj-3-tuple(v_1139))))) then (if not-caught-fail(v_1141) then (v_1141,3-proj-3-tuple(v_1139),1-proj-3-tuple(v_1139)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {594}let v_1143: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1142),2-proj-3-tuple(v_1136),3-proj-3-tuple(v_1136)))) in
        {595}let v_1144: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1131)) && success?(symmetricstatepack(1-proj-3-tuple(v_1142),2-proj-3-tuple(v_1136),3-proj-3-tuple(v_1136)))) then (if (not-caught-fail(v_1143) && success?(is-true(success?(1-proj-3-tuple(v_1143))))) then symmetricstatepack(1-proj-3-tuple(v_1143),2-proj-3-tuple(v_1143),hash(3-proj-3-tuple(v_1143),3-proj-3-tuple(v_1131))) else fail-any) else fail-any)) in
        {596}let v_1145: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1131)) then (if (not-caught-fail(v_1136) && success?(is-true(success?(1-proj-3-tuple(v_1136))))) then (if (not-caught-fail(v_1142) && success?(is-true(success?(1-proj-3-tuple(v_1142))))) then (if not-caught-fail(v_1144) then (v_1144,2-proj-3-tuple(v_1142),3-proj-3-tuple(v_1142)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {597}let v_1146: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1145),2-proj-7-tuple(v_1130),3-proj-7-tuple(v_1130),4-proj-7-tuple(v_1130),v_1133,6-proj-7-tuple(v_1130),7-proj-7-tuple(v_1130))) in
        {598}let (hs_1147: handshakestate,re_1148: key,plaintext_a_1149: bitstring,valid_1150: bool) = (if (not-caught-fail(v_1130) && success?(is-true(success?(1-proj-7-tuple(v_1130))))) then (if (not-caught-fail(v_1131) && success?(is-true(success?(1-proj-3-tuple(v_1131))))) then (if not-caught-fail(v_1132) then (if not-caught-fail(v_1133) then (if not-caught-fail(v_1135) then (if (not-caught-fail(v_1145) && success?(is-true(success?(1-proj-3-tuple(v_1145))))) then (if (v_1132 && 3-proj-3-tuple(v_1145)) then (if not-caught-fail(v_1146) then (v_1146,getpublickey(3-proj-7-tuple(v_1130)),2-proj-3-tuple(v_1145),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {599}event RecvMsg(bob,charlie,stage_a,plaintext_a_1149,valid_1150);
        {600}insert statestore(bob,charlie,statepack_b(hs_1147))
    ) | (
        {649}get statestore(=bob,=charlie,statepack_b(hs_1151: handshakestate)) in
        {602}let v_1152: bitstring = catch-fail(handshakestateunpack(hs_1151)) in
        {603}let v_1153: bitstring = catch-fail((empty,empty,empty)) in
        {604}let v_1154: key = catch-fail(dhexp(key_e(bob,charlie),g)) in
        {605}let v_1155: keypair = catch-fail((if not-caught-fail(v_1154) then keypairpack(v_1154,key_e(bob,charlie)) else fail-any)) in
        {606}let v_1156: bitstring = catch-fail(getpublickey(v_1155)) in
        {607}let v_1157: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1152))) in
        {608}let v_1158: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1157) && success?(is-true(success?(1-proj-3-tuple(v_1157))))) then symmetricstatepack(1-proj-3-tuple(v_1157),2-proj-3-tuple(v_1157),hash(3-proj-3-tuple(v_1157),v_1156)) else fail-any) else fail-any)) in
        {609}let v_1159: bitstring = catch-fail(keypairunpack(v_1155)) in
        {610}let v_1160: bitstring = catch-fail(symmetricstateunpack(v_1158)) in
        {611}let v_1161: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1160),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1159) && success?(is-true(success?(1-proj-2-tuple(v_1159))))) then dhexp(2-proj-2-tuple(v_1159),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {612}let v_1162: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1160),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1159) && success?(is-true(success?(1-proj-2-tuple(v_1159))))) then dhexp(2-proj-2-tuple(v_1159),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {613}let v_1163: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1160),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1159) && success?(is-true(success?(1-proj-2-tuple(v_1159))))) then dhexp(2-proj-2-tuple(v_1159),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {614}let v_1164: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1159) && success?(is-true(success?(1-proj-2-tuple(v_1159))))) then dhexp(2-proj-2-tuple(v_1159),5-proj-7-tuple(v_1152)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1160))) then (if not-caught-fail(v_1161) then (if not-caught-fail(v_1162) then (if not-caught-fail(v_1163) then (v_1161,v_1162,v_1163) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {615}let v_1165: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1159) && success?(is-true(success?(1-proj-2-tuple(v_1159))))) then dhexp(2-proj-2-tuple(v_1159),5-proj-7-tuple(v_1152)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1160) && success?(is-true(success?(1-proj-3-tuple(v_1160))))) then (if (not-caught-fail(v_1164) && success?(is-true(success?(1-proj-3-tuple(v_1164))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1164)) then cipherstatepack(2-proj-3-tuple(v_1164),minnonce) else fail-any),1-proj-3-tuple(v_1164),3-proj-3-tuple(v_1160)) else fail-any) else fail-any) else fail-any)) in
        {616}let v_1166: key = catch-fail(dhexp(key_s(bob),g)) in
        {617}let v_1167: keypair = catch-fail((if not-caught-fail(v_1166) then keypairpack(v_1166,key_s(bob)) else fail-any)) in
        {618}let v_1168: bitstring = catch-fail(symmetricstateunpack(v_1165)) in
        {619}let v_1169: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1168))) in
        {620}let v_1170: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1169),2-proj-2-tuple(v_1169),3-proj-3-tuple(v_1168),getpublickey(v_1167))) in
        {621}let v_1171: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1168))) in
        {622}let v_1172: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1169))) && success?(1-proj-3-tuple(v_1168))) then (if (not-caught-fail(v_1171) && success?(is-true(success?(1-proj-2-tuple(v_1171))))) then cipherstatepack(1-proj-2-tuple(v_1171),increment_nonce(2-proj-2-tuple(v_1169))) else fail-any) else fail-any)) in
        {623}let v_1173: bitstring = catch-fail((if (success?(getpublickey(v_1167)) && (success?(3-proj-3-tuple(v_1168)) && success?(1-proj-3-tuple(v_1168)))) then (if (not-caught-fail(v_1169) && success?(is-true(success?(1-proj-2-tuple(v_1169))))) then (if not-caught-fail(v_1170) then (if not-caught-fail(v_1172) then (v_1172,v_1170) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {624}let v_1174: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1173),2-proj-3-tuple(v_1168),3-proj-3-tuple(v_1168)))) in
        {625}let v_1175: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1173)) && success?(symmetricstatepack(1-proj-2-tuple(v_1173),2-proj-3-tuple(v_1168),3-proj-3-tuple(v_1168)))) then (if (not-caught-fail(v_1174) && success?(is-true(success?(1-proj-3-tuple(v_1174))))) then symmetricstatepack(1-proj-3-tuple(v_1174),2-proj-3-tuple(v_1174),hash(3-proj-3-tuple(v_1174),2-proj-2-tuple(v_1173))) else fail-any) else fail-any)) in
        {626}let v_1176: bitstring = catch-fail((if success?(getpublickey(v_1167)) then (if (not-caught-fail(v_1168) && success?(is-true(success?(1-proj-3-tuple(v_1168))))) then (if (not-caught-fail(v_1173) && success?(is-true(success?(1-proj-2-tuple(v_1173))))) then (if not-caught-fail(v_1175) then (v_1175,2-proj-2-tuple(v_1173)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {627}let v_1177: bitstring = catch-fail(keypairunpack(v_1167)) in
        {628}let v_1178: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1176))) in
        {629}let v_1179: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1178),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-2-tuple(v_1177))))) then dhexp(2-proj-2-tuple(v_1177),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {630}let v_1180: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1178),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-2-tuple(v_1177))))) then dhexp(2-proj-2-tuple(v_1177),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {631}let v_1181: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1178),(if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-2-tuple(v_1177))))) then dhexp(2-proj-2-tuple(v_1177),5-proj-7-tuple(v_1152)) else fail-any) else fail-any))) in
        {632}let v_1182: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-2-tuple(v_1177))))) then dhexp(2-proj-2-tuple(v_1177),5-proj-7-tuple(v_1152)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1178))) then (if not-caught-fail(v_1179) then (if not-caught-fail(v_1180) then (if not-caught-fail(v_1181) then (v_1179,v_1180,v_1181) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {633}let v_1183: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1152)) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-2-tuple(v_1177))))) then dhexp(2-proj-2-tuple(v_1177),5-proj-7-tuple(v_1152)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_1176))) then (if (not-caught-fail(v_1178) && success?(is-true(success?(1-proj-3-tuple(v_1178))))) then (if (not-caught-fail(v_1182) && success?(is-true(success?(1-proj-3-tuple(v_1182))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1182)) then cipherstatepack(2-proj-3-tuple(v_1182),minnonce) else fail-any),1-proj-3-tuple(v_1182),3-proj-3-tuple(v_1178)) else fail-any) else fail-any) else fail-any)) in
        {634}let v_1184: bitstring = catch-fail(symmetricstateunpack(v_1183)) in
        {635}let v_1185: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1184))) in
        {636}let v_1186: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1185),2-proj-2-tuple(v_1185),3-proj-3-tuple(v_1184),msg_b(bob,charlie))) in
        {637}let v_1187: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1184))) in
        {638}let v_1188: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1185))) && success?(1-proj-3-tuple(v_1184))) then (if (not-caught-fail(v_1187) && success?(is-true(success?(1-proj-2-tuple(v_1187))))) then cipherstatepack(1-proj-2-tuple(v_1187),increment_nonce(2-proj-2-tuple(v_1185))) else fail-any) else fail-any)) in
        {639}let v_1189: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1184)) && success?(1-proj-3-tuple(v_1184))) then (if (not-caught-fail(v_1185) && success?(is-true(success?(1-proj-2-tuple(v_1185))))) then (if not-caught-fail(v_1186) then (if not-caught-fail(v_1188) then (v_1188,v_1186) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {640}let v_1190: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1189),2-proj-3-tuple(v_1184),3-proj-3-tuple(v_1184)))) in
        {641}let v_1191: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1189)) && success?(symmetricstatepack(1-proj-2-tuple(v_1189),2-proj-3-tuple(v_1184),3-proj-3-tuple(v_1184)))) then (if (not-caught-fail(v_1190) && success?(is-true(success?(1-proj-3-tuple(v_1190))))) then symmetricstatepack(1-proj-3-tuple(v_1190),2-proj-3-tuple(v_1190),hash(3-proj-3-tuple(v_1190),2-proj-2-tuple(v_1189))) else fail-any) else fail-any)) in
        {642}let v_1192: bitstring = catch-fail((if (not-caught-fail(v_1184) && success?(is-true(success?(1-proj-3-tuple(v_1184))))) then (if (not-caught-fail(v_1189) && success?(is-true(success?(1-proj-2-tuple(v_1189))))) then (if not-caught-fail(v_1191) then (v_1191,2-proj-2-tuple(v_1189)) else fail-any) else fail-any) else fail-any)) in
        {643}let v_1193: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1192),v_1167,v_1155,4-proj-7-tuple(v_1152),5-proj-7-tuple(v_1152),6-proj-7-tuple(v_1152),7-proj-7-tuple(v_1152))) in
        {644}let v_1194: bitstring = catch-fail(concat3(v_1156,2-proj-2-tuple(v_1176),2-proj-2-tuple(v_1192))) in
        {645}let (hs_1195: handshakestate,re_1196: key,message_b_1197: bitstring) = (if (not-caught-fail(v_1152) && success?(is-true(success?(1-proj-7-tuple(v_1152))))) then (if (not-caught-fail(v_1153) && success?(is-true(success?(1-proj-3-tuple(v_1153))))) then (if not-caught-fail(v_1155) then (if not-caught-fail(v_1156) then (if not-caught-fail(v_1158) then (if not-caught-fail(v_1165) then (if not-caught-fail(v_1167) then (if (not-caught-fail(v_1176) && success?(is-true(success?(1-proj-2-tuple(v_1176))))) then (if not-caught-fail(v_1183) then (if (not-caught-fail(v_1192) && success?(is-true(success?(1-proj-2-tuple(v_1192))))) then (if not-caught-fail(v_1193) then (if not-caught-fail(v_1194) then (v_1193,5-proj-7-tuple(v_1152),v_1194) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {646}event SendMsg(bob,charlie,stage_b,msg_b(bob,charlie),true);
        {647}insert statestore(bob,charlie,statepack_c(hs_1195));
        {648}out(pub, message_b_1197)
    ) | (
        {680}get statestore(=bob,=charlie,statepack_c(hs_1198: handshakestate)) in
        {650}in(pub, message_c_1199: bitstring);
        {651}let v_1200: bitstring = catch-fail(handshakestateunpack(hs_1198)) in
        {652}let v_1201: bitstring = catch-fail(deconcat3(message_c_1199)) in
        {653}let v_1202: bool = catch-fail(true) in
        {654}let v_1203: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1200))) in
        {655}let v_1204: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1203))) in
        {656}let v_1205: aead = catch-fail(decrypt(1-proj-2-tuple(v_1204),2-proj-2-tuple(v_1204),3-proj-3-tuple(v_1203),2-proj-3-tuple(v_1201))) in
        {657}let v_1206: bitstring = catch-fail(aeadunpack(v_1205)) in
        {658}let v_1207: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1203))) in
        {659}let v_1208: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1204))) && success?(1-proj-3-tuple(v_1203))) then (if (not-caught-fail(v_1207) && success?(is-true(success?(1-proj-2-tuple(v_1207))))) then cipherstatepack(1-proj-2-tuple(v_1207),increment_nonce(2-proj-2-tuple(v_1204))) else fail-any) else fail-any)) in
        {660}let v_1209: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1201)) && (success?(3-proj-3-tuple(v_1203)) && success?(1-proj-3-tuple(v_1203)))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then (if not-caught-fail(v_1205) then (if (not-caught-fail(v_1206) && success?(is-true(success?(1-proj-3-tuple(v_1206))))) then (if not-caught-fail(v_1208) then (v_1208,3-proj-3-tuple(v_1206),1-proj-3-tuple(v_1206)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {661}let v_1210: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1209),2-proj-3-tuple(v_1203),3-proj-3-tuple(v_1203)))) in
        {662}let v_1211: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1201)) && success?(symmetricstatepack(1-proj-3-tuple(v_1209),2-proj-3-tuple(v_1203),3-proj-3-tuple(v_1203)))) then (if (not-caught-fail(v_1210) && success?(is-true(success?(1-proj-3-tuple(v_1210))))) then symmetricstatepack(1-proj-3-tuple(v_1210),2-proj-3-tuple(v_1210),hash(3-proj-3-tuple(v_1210),2-proj-3-tuple(v_1201))) else fail-any) else fail-any)) in
        {663}let v_1212: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1201)) && success?(1-proj-7-tuple(v_1200))) then (if (not-caught-fail(v_1203) && success?(is-true(success?(1-proj-3-tuple(v_1203))))) then (if (not-caught-fail(v_1209) && success?(is-true(success?(1-proj-3-tuple(v_1209))))) then (if not-caught-fail(v_1211) then (v_1211,2-proj-3-tuple(v_1209),3-proj-3-tuple(v_1209)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {664}let v_1213: key = catch-fail(2-proj-3-tuple(v_1212)) in
        {665}let v_1214: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1212))) in
        {666}let v_1215: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1214))) in
        {667}let v_1216: aead = catch-fail(decrypt(1-proj-2-tuple(v_1215),2-proj-2-tuple(v_1215),3-proj-3-tuple(v_1214),3-proj-3-tuple(v_1201))) in
        {668}let v_1217: bitstring = catch-fail(aeadunpack(v_1216)) in
        {669}let v_1218: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1214))) in
        {670}let v_1219: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1215))) && success?(1-proj-3-tuple(v_1214))) then (if (not-caught-fail(v_1218) && success?(is-true(success?(1-proj-2-tuple(v_1218))))) then cipherstatepack(1-proj-2-tuple(v_1218),increment_nonce(2-proj-2-tuple(v_1215))) else fail-any) else fail-any)) in
        {671}let v_1220: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1201)) && (success?(3-proj-3-tuple(v_1214)) && success?(1-proj-3-tuple(v_1214)))) then (if (not-caught-fail(v_1215) && success?(is-true(success?(1-proj-2-tuple(v_1215))))) then (if not-caught-fail(v_1216) then (if (not-caught-fail(v_1217) && success?(is-true(success?(1-proj-3-tuple(v_1217))))) then (if not-caught-fail(v_1219) then (v_1219,3-proj-3-tuple(v_1217),1-proj-3-tuple(v_1217)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {672}let v_1221: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1220),2-proj-3-tuple(v_1214),3-proj-3-tuple(v_1214)))) in
        {673}let v_1222: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1201)) && success?(symmetricstatepack(1-proj-3-tuple(v_1220),2-proj-3-tuple(v_1214),3-proj-3-tuple(v_1214)))) then (if (not-caught-fail(v_1221) && success?(is-true(success?(1-proj-3-tuple(v_1221))))) then symmetricstatepack(1-proj-3-tuple(v_1221),2-proj-3-tuple(v_1221),hash(3-proj-3-tuple(v_1221),3-proj-3-tuple(v_1201))) else fail-any) else fail-any)) in
        {674}let v_1223: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1201)) && success?(1-proj-3-tuple(v_1212))) then (if (not-caught-fail(v_1214) && success?(is-true(success?(1-proj-3-tuple(v_1214))))) then (if (not-caught-fail(v_1220) && success?(is-true(success?(1-proj-3-tuple(v_1220))))) then (if not-caught-fail(v_1222) then (v_1222,2-proj-3-tuple(v_1220),3-proj-3-tuple(v_1220)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {675}let v_1224: key = catch-fail(dhexp(key_s(charlie),g)) in
        {676}let v_1225: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1223),2-proj-7-tuple(v_1200),3-proj-7-tuple(v_1200),v_1213,5-proj-7-tuple(v_1200),6-proj-7-tuple(v_1200),7-proj-7-tuple(v_1200))) in
        {677}let (hs_1226: handshakestate,re_1227: key,plaintext_c_1228: bitstring,valid_1229: bool) = (if (not-caught-fail(v_1200) && success?(is-true(success?(1-proj-7-tuple(v_1200))))) then (if (not-caught-fail(v_1201) && success?(is-true(success?(1-proj-3-tuple(v_1201))))) then (if not-caught-fail(v_1202) then (if (not-caught-fail(v_1212) && success?(is-true(success?(1-proj-3-tuple(v_1212))))) then (if not-caught-fail(v_1213) then (if (not-caught-fail(v_1223) && success?(is-true(success?(1-proj-3-tuple(v_1223))))) then (if ((3-proj-3-tuple(v_1212) && 3-proj-3-tuple(v_1223)) && (v_1213 = getpublickey((if not-caught-fail(v_1224) then keypairpack(v_1224,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1225) then (v_1225,getpublickey(3-proj-7-tuple(v_1200)),2-proj-3-tuple(v_1223),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {678}event RecvMsg(bob,charlie,stage_c,plaintext_c_1228,valid_1229);
        {679}insert statestore(bob,charlie,statepack_d(hs_1226))
    ) | (
        {705}get statestore(=bob,=charlie,statepack_d(hs_1230: handshakestate)) in
        {681}let v_1231: bitstring = catch-fail(handshakestateunpack(hs_1230)) in
        {682}let v_1232: bitstring = catch-fail((empty,empty,empty)) in
        {683}let v_1233: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1231))) in
        {684}let v_1234: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1231))) in
        {685}let v_1235: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1234),(if (success?(4-proj-7-tuple(v_1231)) && success?(3-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1233) && success?(is-true(success?(1-proj-2-tuple(v_1233))))) then dhexp(2-proj-2-tuple(v_1233),4-proj-7-tuple(v_1231)) else fail-any) else fail-any))) in
        {686}let v_1236: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1234),(if (success?(4-proj-7-tuple(v_1231)) && success?(3-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1233) && success?(is-true(success?(1-proj-2-tuple(v_1233))))) then dhexp(2-proj-2-tuple(v_1233),4-proj-7-tuple(v_1231)) else fail-any) else fail-any))) in
        {687}let v_1237: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1234),(if (success?(4-proj-7-tuple(v_1231)) && success?(3-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1233) && success?(is-true(success?(1-proj-2-tuple(v_1233))))) then dhexp(2-proj-2-tuple(v_1233),4-proj-7-tuple(v_1231)) else fail-any) else fail-any))) in
        {688}let v_1238: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1231)) && success?(3-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1233) && success?(is-true(success?(1-proj-2-tuple(v_1233))))) then dhexp(2-proj-2-tuple(v_1233),4-proj-7-tuple(v_1231)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1234))) then (if not-caught-fail(v_1235) then (if not-caught-fail(v_1236) then (if not-caught-fail(v_1237) then (v_1235,v_1236,v_1237) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {689}let v_1239: symmetricstate = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1231)) && success?(3-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1233) && success?(is-true(success?(1-proj-2-tuple(v_1233))))) then dhexp(2-proj-2-tuple(v_1233),4-proj-7-tuple(v_1231)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_1231))) then (if (not-caught-fail(v_1234) && success?(is-true(success?(1-proj-3-tuple(v_1234))))) then (if (not-caught-fail(v_1238) && success?(is-true(success?(1-proj-3-tuple(v_1238))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1238)) then cipherstatepack(2-proj-3-tuple(v_1238),minnonce) else fail-any),1-proj-3-tuple(v_1238),3-proj-3-tuple(v_1234)) else fail-any) else fail-any) else fail-any)) in
        {690}let v_1240: bitstring = catch-fail(symmetricstateunpack(v_1239)) in
        {691}let v_1241: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1240))) in
        {692}let v_1242: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1241),2-proj-2-tuple(v_1241),3-proj-3-tuple(v_1240),msg_d(bob,charlie))) in
        {693}let v_1243: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1240))) in
        {694}let v_1244: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1241))) && success?(1-proj-3-tuple(v_1240))) then (if (not-caught-fail(v_1243) && success?(is-true(success?(1-proj-2-tuple(v_1243))))) then cipherstatepack(1-proj-2-tuple(v_1243),increment_nonce(2-proj-2-tuple(v_1241))) else fail-any) else fail-any)) in
        {695}let v_1245: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1240)) && success?(1-proj-3-tuple(v_1240))) then (if (not-caught-fail(v_1241) && success?(is-true(success?(1-proj-2-tuple(v_1241))))) then (if not-caught-fail(v_1242) then (if not-caught-fail(v_1244) then (v_1244,v_1242) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {696}let v_1246: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1245),2-proj-3-tuple(v_1240),3-proj-3-tuple(v_1240)))) in
        {697}let v_1247: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1245)) && success?(symmetricstatepack(1-proj-2-tuple(v_1245),2-proj-3-tuple(v_1240),3-proj-3-tuple(v_1240)))) then (if (not-caught-fail(v_1246) && success?(is-true(success?(1-proj-3-tuple(v_1246))))) then symmetricstatepack(1-proj-3-tuple(v_1246),2-proj-3-tuple(v_1246),hash(3-proj-3-tuple(v_1246),2-proj-2-tuple(v_1245))) else fail-any) else fail-any)) in
        {698}let v_1248: bitstring = catch-fail((if (not-caught-fail(v_1240) && success?(is-true(success?(1-proj-3-tuple(v_1240))))) then (if (not-caught-fail(v_1245) && success?(is-true(success?(1-proj-2-tuple(v_1245))))) then (if not-caught-fail(v_1247) then (v_1247,2-proj-2-tuple(v_1245)) else fail-any) else fail-any) else fail-any)) in
        {699}let v_1249: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1248),2-proj-7-tuple(v_1231),3-proj-7-tuple(v_1231),4-proj-7-tuple(v_1231),5-proj-7-tuple(v_1231),6-proj-7-tuple(v_1231),7-proj-7-tuple(v_1231))) in
        {700}let v_1250: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1232),2-proj-3-tuple(v_1232),2-proj-2-tuple(v_1248))) in
        {701}let (hs_1251: handshakestate,re_1252: key,message_d_1253: bitstring) = (if (not-caught-fail(v_1231) && success?(is-true(success?(1-proj-7-tuple(v_1231))))) then (if (not-caught-fail(v_1232) && success?(is-true(success?(1-proj-3-tuple(v_1232))))) then (if not-caught-fail(v_1239) then (if (not-caught-fail(v_1248) && success?(is-true(success?(1-proj-2-tuple(v_1248))))) then (if not-caught-fail(v_1249) then (if not-caught-fail(v_1250) then (v_1249,5-proj-7-tuple(v_1231),v_1250) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {702}event SendMsg(bob,charlie,stage_d,msg_d(bob,charlie),true);
        {703}insert statestore(bob,charlie,statepack_e(hs_1251));
        {704}out(pub, message_d_1253)
    ) | (
        {724}get statestore(=bob,=charlie,statepack_e(hs_1254: handshakestate)) in
        {706}in(pub, message_e_1255: bitstring);
        {707}let v_1256: bitstring = catch-fail(handshakestateunpack(hs_1254)) in
        {708}let v_1257: bitstring = catch-fail(deconcat3(message_e_1255)) in
        {709}let v_1258: bool = catch-fail(true) in
        {710}let v_1259: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1256))) in
        {711}let v_1260: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1259))) in
        {712}let v_1261: aead = catch-fail(decrypt(1-proj-2-tuple(v_1260),2-proj-2-tuple(v_1260),3-proj-3-tuple(v_1259),3-proj-3-tuple(v_1257))) in
        {713}let v_1262: bitstring = catch-fail(aeadunpack(v_1261)) in
        {714}let v_1263: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1259))) in
        {715}let v_1264: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1260))) && success?(1-proj-3-tuple(v_1259))) then (if (not-caught-fail(v_1263) && success?(is-true(success?(1-proj-2-tuple(v_1263))))) then cipherstatepack(1-proj-2-tuple(v_1263),increment_nonce(2-proj-2-tuple(v_1260))) else fail-any) else fail-any)) in
        {716}let v_1265: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1257)) && (success?(3-proj-3-tuple(v_1259)) && success?(1-proj-3-tuple(v_1259)))) then (if (not-caught-fail(v_1260) && success?(is-true(success?(1-proj-2-tuple(v_1260))))) then (if not-caught-fail(v_1261) then (if (not-caught-fail(v_1262) && success?(is-true(success?(1-proj-3-tuple(v_1262))))) then (if not-caught-fail(v_1264) then (v_1264,3-proj-3-tuple(v_1262),1-proj-3-tuple(v_1262)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {717}let v_1266: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1265),2-proj-3-tuple(v_1259),3-proj-3-tuple(v_1259)))) in
        {718}let v_1267: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1257)) && success?(symmetricstatepack(1-proj-3-tuple(v_1265),2-proj-3-tuple(v_1259),3-proj-3-tuple(v_1259)))) then (if (not-caught-fail(v_1266) && success?(is-true(success?(1-proj-3-tuple(v_1266))))) then symmetricstatepack(1-proj-3-tuple(v_1266),2-proj-3-tuple(v_1266),hash(3-proj-3-tuple(v_1266),3-proj-3-tuple(v_1257))) else fail-any) else fail-any)) in
        {719}let v_1268: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1257)) && success?(1-proj-7-tuple(v_1256))) then (if (not-caught-fail(v_1259) && success?(is-true(success?(1-proj-3-tuple(v_1259))))) then (if (not-caught-fail(v_1265) && success?(is-true(success?(1-proj-3-tuple(v_1265))))) then (if not-caught-fail(v_1267) then (v_1267,2-proj-3-tuple(v_1265),3-proj-3-tuple(v_1265)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {720}let v_1269: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1268),2-proj-7-tuple(v_1256),3-proj-7-tuple(v_1256),4-proj-7-tuple(v_1256),5-proj-7-tuple(v_1256),6-proj-7-tuple(v_1256),7-proj-7-tuple(v_1256))) in
        {721}let (hs_1270: handshakestate,re_1271: key,plaintext_e_1272: bitstring,valid_1273: bool) = (if (not-caught-fail(v_1256) && success?(is-true(success?(1-proj-7-tuple(v_1256))))) then (if (not-caught-fail(v_1257) && success?(is-true(success?(1-proj-3-tuple(v_1257))))) then (if not-caught-fail(v_1258) then (if (not-caught-fail(v_1268) && success?(is-true(success?(1-proj-3-tuple(v_1268))))) then (if (v_1258 && 3-proj-3-tuple(v_1268)) then (if not-caught-fail(v_1269) then (v_1269,getpublickey(3-proj-7-tuple(v_1256)),2-proj-3-tuple(v_1268),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {722}event RecvMsg(bob,charlie,stage_e,plaintext_e_1272,valid_1273);
        {723}insert statestore(bob,charlie,statepack_f(hs_1270))
    ) | (
        {750}get statestore(=bob,=charlie,statepack_f(hs_1274: handshakestate)) in
        {725}let v_1275: bitstring = catch-fail(handshakestateunpack(hs_1274)) in
        {726}let v_1276: bitstring = catch-fail((empty,empty,empty)) in
        {727}let v_1277: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1275))) in
        {728}let v_1278: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1277))) in
        {729}let v_1279: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1278),2-proj-2-tuple(v_1278),3-proj-3-tuple(v_1277),msg_f(bob,charlie))) in
        {730}let v_1280: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1277))) in
        {731}let v_1281: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1278))) && success?(1-proj-3-tuple(v_1277))) then (if (not-caught-fail(v_1280) && success?(is-true(success?(1-proj-2-tuple(v_1280))))) then cipherstatepack(1-proj-2-tuple(v_1280),increment_nonce(2-proj-2-tuple(v_1278))) else fail-any) else fail-any)) in
        {732}let v_1282: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1277)) && success?(1-proj-3-tuple(v_1277))) then (if (not-caught-fail(v_1278) && success?(is-true(success?(1-proj-2-tuple(v_1278))))) then (if not-caught-fail(v_1279) then (if not-caught-fail(v_1281) then (v_1281,v_1279) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {733}let v_1283: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1282),2-proj-3-tuple(v_1277),3-proj-3-tuple(v_1277)))) in
        {734}let v_1284: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1282)) && success?(symmetricstatepack(1-proj-2-tuple(v_1282),2-proj-3-tuple(v_1277),3-proj-3-tuple(v_1277)))) then (if (not-caught-fail(v_1283) && success?(is-true(success?(1-proj-3-tuple(v_1283))))) then symmetricstatepack(1-proj-3-tuple(v_1283),2-proj-3-tuple(v_1283),hash(3-proj-3-tuple(v_1283),2-proj-2-tuple(v_1282))) else fail-any) else fail-any)) in
        {735}let v_1285: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1275)) then (if (not-caught-fail(v_1277) && success?(is-true(success?(1-proj-3-tuple(v_1277))))) then (if (not-caught-fail(v_1282) && success?(is-true(success?(1-proj-2-tuple(v_1282))))) then (if not-caught-fail(v_1284) then (v_1284,2-proj-2-tuple(v_1282)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {736}let v_1286: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1285),2-proj-7-tuple(v_1275),3-proj-7-tuple(v_1275),4-proj-7-tuple(v_1275),5-proj-7-tuple(v_1275),6-proj-7-tuple(v_1275),7-proj-7-tuple(v_1275))) in
        {737}let v_1287: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1276),2-proj-3-tuple(v_1276),2-proj-2-tuple(v_1285))) in
        {738}let v_1288: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1285))) in
        {739}let v_1289: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1288),zero)) in
        {740}let v_1290: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1288),zero)) in
        {741}let v_1291: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1288),zero)) in
        {742}let v_1292: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1288)) then (if not-caught-fail(v_1289) then (if not-caught-fail(v_1290) then (if not-caught-fail(v_1291) then (v_1289,v_1290,v_1291) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {743}let v_1293: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1292)) then cipherstatepack(1-proj-3-tuple(v_1292),minnonce) else fail-any)) in
        {744}let v_1294: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1292)) then cipherstatepack(2-proj-3-tuple(v_1292),minnonce) else fail-any)) in
        {745}let v_1295: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1285)) then (if (not-caught-fail(v_1288) && success?(is-true(success?(1-proj-3-tuple(v_1288))))) then (if (not-caught-fail(v_1292) && success?(is-true(success?(1-proj-3-tuple(v_1292))))) then (if not-caught-fail(v_1293) then (if not-caught-fail(v_1294) then (1-proj-2-tuple(v_1285),v_1293,v_1294) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {746}let (hs_1296: handshakestate,re_1297: key,message_f_1298: bitstring,cs1_1299: cipherstate,cs2_1300: cipherstate) = (if (not-caught-fail(v_1275) && success?(is-true(success?(1-proj-7-tuple(v_1275))))) then (if (not-caught-fail(v_1276) && success?(is-true(success?(1-proj-3-tuple(v_1276))))) then (if (not-caught-fail(v_1285) && success?(is-true(success?(1-proj-2-tuple(v_1285))))) then (if not-caught-fail(v_1286) then (if not-caught-fail(v_1287) then (if (not-caught-fail(v_1295) && success?(is-true(success?(1-proj-3-tuple(v_1295))))) then (v_1286,5-proj-7-tuple(v_1275),v_1287,2-proj-3-tuple(v_1295),3-proj-3-tuple(v_1295)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {747}event SendMsg(bob,charlie,stage_f,msg_f(bob,charlie),true);
        {748}insert statestore(bob,charlie,statepack_g(hs_1296));
        {749}out(pub, message_f_1298)
    ) | (
        {751}event LeakS(phase0,bob);
        {752}out(pub, key_s(bob))
    ) | (
        {753}phase 1;
        {754}event LeakS(phase1,bob);
        {755}out(pub, key_s(bob))
    )
) | (
    {756}out(pub, (key_s(charlie),key_e(charlie,alice),key_e(charlie,bob)))
)

-- Query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1381,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1381,stage_a,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1381,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1381,stage_b,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1381,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1381,stage_c,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1381,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1381,stage_d,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,c_1381,stage_e,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,c_1381,stage_e,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_e(alice,bob)); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_f,m,true)) ==> event(SendMsg(bob,alice,stage_f,m,true)); event(RecvMsg(alice,bob,stage_f,m,true)) ==> event(SendMsg(bob,c_1381,stage_f,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_f,m,true)) ==> event(SendMsg(bob,c_1381,stage_f,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_f,m,true)) ==> event(SendMsg(bob,alice,stage_f,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_f,m,true)) ==> event(SendMsg(bob,alice,stage_f,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_f(bob,alice)); attacker_p1(msg_f(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_f(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_f(bob,alice)) ==> event(LeakS(phase0,alice))
Completing...
200 rules inserted. The rule base contains 200 rules. 228 rules in the queue.
400 rules inserted. The rule base contains 400 rules. 97 rules in the queue.
600 rules inserted. The rule base contains 589 rules. 158 rules in the queue.
800 rules inserted. The rule base contains 789 rules. 327 rules in the queue.
1000 rules inserted. The rule base contains 955 rules. 248 rules in the queue.
1200 rules inserted. The rule base contains 1140 rules. 311 rules in the queue.
1400 rules inserted. The rule base contains 1328 rules. 389 rules in the queue.
1600 rules inserted. The rule base contains 1522 rules. 494 rules in the queue.
1800 rules inserted. The rule base contains 1682 rules. 605 rules in the queue.
2000 rules inserted. The rule base contains 1833 rules. 599 rules in the queue.
2200 rules inserted. The rule base contains 1976 rules. 613 rules in the queue.
2400 rules inserted. The rule base contains 2082 rules. 623 rules in the queue.
2600 rules inserted. The rule base contains 2264 rules. 834 rules in the queue.
2800 rules inserted. The rule base contains 2428 rules. 820 rules in the queue.
3000 rules inserted. The rule base contains 2591 rules. 954 rules in the queue.
3200 rules inserted. The rule base contains 2774 rules. 1053 rules in the queue.
3400 rules inserted. The rule base contains 2958 rules. 1289 rules in the queue.
3600 rules inserted. The rule base contains 3112 rules. 1295 rules in the queue.
3800 rules inserted. The rule base contains 3306 rules. 1515 rules in the queue.
4000 rules inserted. The rule base contains 3449 rules. 1544 rules in the queue.
4200 rules inserted. The rule base contains 3565 rules. 1567 rules in the queue.
4400 rules inserted. The rule base contains 3704 rules. 1545 rules in the queue.
4600 rules inserted. The rule base contains 3872 rules. 1444 rules in the queue.
4800 rules inserted. The rule base contains 3945 rules. 1486 rules in the queue.
5000 rules inserted. The rule base contains 4061 rules. 1460 rules in the queue.
5200 rules inserted. The rule base contains 4229 rules. 1360 rules in the queue.
5400 rules inserted. The rule base contains 4340 rules. 1405 rules in the queue.
5600 rules inserted. The rule base contains 4520 rules. 1443 rules in the queue.
5800 rules inserted. The rule base contains 4700 rules. 1497 rules in the queue.
6000 rules inserted. The rule base contains 4888 rules. 1645 rules in the queue.
6200 rules inserted. The rule base contains 4944 rules. 1700 rules in the queue.
6400 rules inserted. The rule base contains 5098 rules. 1694 rules in the queue.
6600 rules inserted. The rule base contains 5164 rules. 1882 rules in the queue.
6800 rules inserted. The rule base contains 5321 rules. 1908 rules in the queue.
7000 rules inserted. The rule base contains 5476 rules. 1934 rules in the queue.
7200 rules inserted. The rule base contains 5628 rules. 1954 rules in the queue.
7400 rules inserted. The rule base contains 5776 rules. 1968 rules in the queue.
7600 rules inserted. The rule base contains 5976 rules. 1905 rules in the queue.
7800 rules inserted. The rule base contains 6076 rules. 1892 rules in the queue.
8000 rules inserted. The rule base contains 6200 rules. 1909 rules in the queue.
8200 rules inserted. The rule base contains 6359 rules. 1871 rules in the queue.
8400 rules inserted. The rule base contains 6545 rules. 1857 rules in the queue.
8600 rules inserted. The rule base contains 6600 rules. 1888 rules in the queue.
8800 rules inserted. The rule base contains 6750 rules. 1920 rules in the queue.
9000 rules inserted. The rule base contains 6900 rules. 1946 rules in the queue.
9200 rules inserted. The rule base contains 7044 rules. 1969 rules in the queue.
9400 rules inserted. The rule base contains 7203 rules. 2000 rules in the queue.
9600 rules inserted. The rule base contains 7307 rules. 2048 rules in the queue.
9800 rules inserted. The rule base contains 7314 rules. 2084 rules in the queue.
10000 rules inserted. The rule base contains 7464 rules. 2109 rules in the queue.
10200 rules inserted. The rule base contains 7564 rules. 2135 rules in the queue.
10400 rules inserted. The rule base contains 7416 rules. 2169 rules in the queue.
10600 rules inserted. The rule base contains 7553 rules. 2145 rules in the queue.
10800 rules inserted. The rule base contains 7684 rules. 2117 rules in the queue.
11000 rules inserted. The rule base contains 7816 rules. 2088 rules in the queue.
11200 rules inserted. The rule base contains 7940 rules. 2060 rules in the queue.
11400 rules inserted. The rule base contains 8031 rules. 1973 rules in the queue.
11600 rules inserted. The rule base contains 8130 rules. 1967 rules in the queue.
11800 rules inserted. The rule base contains 8210 rules. 1934 rules in the queue.
12000 rules inserted. The rule base contains 8334 rules. 1869 rules in the queue.
12200 rules inserted. The rule base contains 8441 rules. 1858 rules in the queue.
12400 rules inserted. The rule base contains 8543 rules. 1855 rules in the queue.
12600 rules inserted. The rule base contains 8653 rules. 1853 rules in the queue.
12800 rules inserted. The rule base contains 8767 rules. 1851 rules in the queue.
13000 rules inserted. The rule base contains 8884 rules. 1849 rules in the queue.
13200 rules inserted. The rule base contains 8991 rules. 1838 rules in the queue.
13400 rules inserted. The rule base contains 9022 rules. 1848 rules in the queue.
13600 rules inserted. The rule base contains 9169 rules. 1833 rules in the queue.
13800 rules inserted. The rule base contains 9247 rules. 1825 rules in the queue.
14000 rules inserted. The rule base contains 9227 rules. 1796 rules in the queue.
14200 rules inserted. The rule base contains 9334 rules. 1826 rules in the queue.
14400 rules inserted. The rule base contains 9449 rules. 1857 rules in the queue.
14600 rules inserted. The rule base contains 9579 rules. 1868 rules in the queue.
14800 rules inserted. The rule base contains 9714 rules. 1890 rules in the queue.
15000 rules inserted. The rule base contains 9845 rules. 1900 rules in the queue.
15200 rules inserted. The rule base contains 9945 rules. 1953 rules in the queue.
15400 rules inserted. The rule base contains 10104 rules. 1977 rules in the queue.
15600 rules inserted. The rule base contains 10226 rules. 1970 rules in the queue.
15800 rules inserted. The rule base contains 10281 rules. 1945 rules in the queue.
16000 rules inserted. The rule base contains 10398 rules. 1951 rules in the queue.
16200 rules inserted. The rule base contains 10488 rules. 1947 rules in the queue.
16400 rules inserted. The rule base contains 10595 rules. 1935 rules in the queue.
16600 rules inserted. The rule base contains 10712 rules. 1934 rules in the queue.
16800 rules inserted. The rule base contains 10758 rules. 1952 rules in the queue.
17000 rules inserted. The rule base contains 10917 rules. 1970 rules in the queue.
17200 rules inserted. The rule base contains 11101 rules. 1973 rules in the queue.
17400 rules inserted. The rule base contains 11234 rules. 1988 rules in the queue.
17600 rules inserted. The rule base contains 11265 rules. 1954 rules in the queue.
17800 rules inserted. The rule base contains 11368 rules. 1947 rules in the queue.
18000 rules inserted. The rule base contains 11500 rules. 1936 rules in the queue.
18200 rules inserted. The rule base contains 11639 rules. 1936 rules in the queue.
18400 rules inserted. The rule base contains 11780 rules. 1932 rules in the queue.
18600 rules inserted. The rule base contains 11953 rules. 1924 rules in the queue.
18800 rules inserted. The rule base contains 11943 rules. 1924 rules in the queue.
19000 rules inserted. The rule base contains 12072 rules. 1927 rules in the queue.
19200 rules inserted. The rule base contains 12239 rules. 1923 rules in the queue.
19400 rules inserted. The rule base contains 12311 rules. 1935 rules in the queue.
19600 rules inserted. The rule base contains 12362 rules. 1882 rules in the queue.
19800 rules inserted. The rule base contains 12449 rules. 1874 rules in the queue.
20000 rules inserted. The rule base contains 12512 rules. 1866 rules in the queue.
20200 rules inserted. The rule base contains 12601 rules. 1862 rules in the queue.
20400 rules inserted. The rule base contains 12698 rules. 1879 rules in the queue.
20600 rules inserted. The rule base contains 12630 rules. 1886 rules in the queue.
20800 rules inserted. The rule base contains 12712 rules. 1867 rules in the queue.
21000 rules inserted. The rule base contains 12834 rules. 1874 rules in the queue.
21200 rules inserted. The rule base contains 12857 rules. 1881 rules in the queue.
21400 rules inserted. The rule base contains 12810 rules. 1877 rules in the queue.
21600 rules inserted. The rule base contains 12934 rules. 1863 rules in the queue.
21800 rules inserted. The rule base contains 13070 rules. 1853 rules in the queue.
22000 rules inserted. The rule base contains 13211 rules. 1856 rules in the queue.
22200 rules inserted. The rule base contains 13376 rules. 1849 rules in the queue.
22400 rules inserted. The rule base contains 13263 rules. 1858 rules in the queue.
22600 rules inserted. The rule base contains 13363 rules. 1855 rules in the queue.
22800 rules inserted. The rule base contains 13530 rules. 1848 rules in the queue.
23000 rules inserted. The rule base contains 13519 rules. 1852 rules in the queue.
23200 rules inserted. The rule base contains 13578 rules. 1877 rules in the queue.
23400 rules inserted. The rule base contains 13623 rules. 1879 rules in the queue.
23600 rules inserted. The rule base contains 13679 rules. 1870 rules in the queue.
23800 rules inserted. The rule base contains 13768 rules. 1873 rules in the queue.
24000 rules inserted. The rule base contains 13854 rules. 1884 rules in the queue.
24200 rules inserted. The rule base contains 13585 rules. 1985 rules in the queue.
24400 rules inserted. The rule base contains 13683 rules. 1992 rules in the queue.
24600 rules inserted. The rule base contains 13876 rules. 1998 rules in the queue.
24800 rules inserted. The rule base contains 13650 rules. 2030 rules in the queue.
25000 rules inserted. The rule base contains 13767 rules. 2120 rules in the queue.
25200 rules inserted. The rule base contains 13882 rules. 2113 rules in the queue.
25400 rules inserted. The rule base contains 14012 rules. 2104 rules in the queue.
25600 rules inserted. The rule base contains 14150 rules. 2118 rules in the queue.
25800 rules inserted. The rule base contains 14173 rules. 2080 rules in the queue.
26000 rules inserted. The rule base contains 14141 rules. 2036 rules in the queue.
26200 rules inserted. The rule base contains 14263 rules. 2036 rules in the queue.
26400 rules inserted. The rule base contains 14405 rules. 2031 rules in the queue.
26600 rules inserted. The rule base contains 14410 rules. 1988 rules in the queue.
26800 rules inserted. The rule base contains 14487 rules. 2031 rules in the queue.
27000 rules inserted. The rule base contains 14625 rules. 2021 rules in the queue.
27200 rules inserted. The rule base contains 14736 rules. 2020 rules in the queue.
27400 rules inserted. The rule base contains 14854 rules. 1991 rules in the queue.
27600 rules inserted. The rule base contains 14992 rules. 1996 rules in the queue.
27800 rules inserted. The rule base contains 14957 rules. 1952 rules in the queue.
28000 rules inserted. The rule base contains 14879 rules. 1910 rules in the queue.
28200 rules inserted. The rule base contains 15038 rules. 1895 rules in the queue.
28400 rules inserted. The rule base contains 15075 rules. 1828 rules in the queue.
28600 rules inserted. The rule base contains 14988 rules. 1837 rules in the queue.
28800 rules inserted. The rule base contains 15175 rules. 1832 rules in the queue.
29000 rules inserted. The rule base contains 15324 rules. 1835 rules in the queue.
29200 rules inserted. The rule base contains 15465 rules. 1826 rules in the queue.
29400 rules inserted. The rule base contains 15601 rules. 1831 rules in the queue.
29600 rules inserted. The rule base contains 15590 rules. 1774 rules in the queue.
29800 rules inserted. The rule base contains 15430 rules. 1693 rules in the queue.
30000 rules inserted. The rule base contains 15518 rules. 1678 rules in the queue.
30200 rules inserted. The rule base contains 15507 rules. 1643 rules in the queue.
30400 rules inserted. The rule base contains 15422 rules. 1631 rules in the queue.
30600 rules inserted. The rule base contains 15594 rules. 1642 rules in the queue.
30800 rules inserted. The rule base contains 15706 rules. 1611 rules in the queue.
31000 rules inserted. The rule base contains 15823 rules. 1592 rules in the queue.
31200 rules inserted. The rule base contains 15889 rules. 1577 rules in the queue.
31400 rules inserted. The rule base contains 15182 rules. 1503 rules in the queue.
31600 rules inserted. The rule base contains 15254 rules. 1508 rules in the queue.
31800 rules inserted. The rule base contains 14525 rules. 1448 rules in the queue.
32000 rules inserted. The rule base contains 14657 rules. 1440 rules in the queue.
32200 rules inserted. The rule base contains 14795 rules. 1460 rules in the queue.
32400 rules inserted. The rule base contains 14949 rules. 1493 rules in the queue.
32600 rules inserted. The rule base contains 15104 rules. 1535 rules in the queue.
32800 rules inserted. The rule base contains 15154 rules. 1527 rules in the queue.
33000 rules inserted. The rule base contains 15316 rules. 1571 rules in the queue.
33200 rules inserted. The rule base contains 15341 rules. 1549 rules in the queue.
33400 rules inserted. The rule base contains 15455 rules. 1556 rules in the queue.
33600 rules inserted. The rule base contains 15579 rules. 1570 rules in the queue.
33800 rules inserted. The rule base contains 15638 rules. 1544 rules in the queue.
34000 rules inserted. The rule base contains 15738 rules. 1541 rules in the queue.
34200 rules inserted. The rule base contains 15828 rules. 1507 rules in the queue.
34400 rules inserted. The rule base contains 15853 rules. 1484 rules in the queue.
34600 rules inserted. The rule base contains 15945 rules. 1484 rules in the queue.
34800 rules inserted. The rule base contains 16091 rules. 1451 rules in the queue.
35000 rules inserted. The rule base contains 16209 rules. 1456 rules in the queue.
35200 rules inserted. The rule base contains 16307 rules. 1449 rules in the queue.
35400 rules inserted. The rule base contains 16419 rules. 1446 rules in the queue.
35600 rules inserted. The rule base contains 16470 rules. 1439 rules in the queue.
35800 rules inserted. The rule base contains 16459 rules. 1428 rules in the queue.
36000 rules inserted. The rule base contains 16451 rules. 1422 rules in the queue.
36200 rules inserted. The rule base contains 16517 rules. 1426 rules in the queue.
36400 rules inserted. The rule base contains 16653 rules. 1440 rules in the queue.
36600 rules inserted. The rule base contains 16790 rules. 1489 rules in the queue.
36800 rules inserted. The rule base contains 16893 rules. 1506 rules in the queue.
37000 rules inserted. The rule base contains 16972 rules. 1537 rules in the queue.
37200 rules inserted. The rule base contains 17026 rules. 1492 rules in the queue.
37400 rules inserted. The rule base contains 17080 rules. 1430 rules in the queue.
37600 rules inserted. The rule base contains 16931 rules. 1404 rules in the queue.
37800 rules inserted. The rule base contains 17115 rules. 1420 rules in the queue.
38000 rules inserted. The rule base contains 17230 rules. 1401 rules in the queue.
38200 rules inserted. The rule base contains 17325 rules. 1323 rules in the queue.
38400 rules inserted. The rule base contains 17413 rules. 1262 rules in the queue.
38600 rules inserted. The rule base contains 17483 rules. 1159 rules in the queue.
38800 rules inserted. The rule base contains 17562 rules. 1056 rules in the queue.
39000 rules inserted. The rule base contains 17739 rules. 1072 rules in the queue.
39200 rules inserted. The rule base contains 17915 rules. 1088 rules in the queue.
39400 rules inserted. The rule base contains 18097 rules. 1109 rules in the queue.
39600 rules inserted. The rule base contains 18296 rules. 1118 rules in the queue.
39800 rules inserted. The rule base contains 18391 rules. 1062 rules in the queue.
40000 rules inserted. The rule base contains 18540 rules. 1102 rules in the queue.
40200 rules inserted. The rule base contains 18708 rules. 1158 rules in the queue.
40400 rules inserted. The rule base contains 18852 rules. 1188 rules in the queue.
40600 rules inserted. The rule base contains 18939 rules. 1208 rules in the queue.
40800 rules inserted. The rule base contains 19031 rules. 1224 rules in the queue.
41000 rules inserted. The rule base contains 19076 rules. 1251 rules in the queue.
41200 rules inserted. The rule base contains 19242 rules. 1336 rules in the queue.
41400 rules inserted. The rule base contains 19392 rules. 1358 rules in the queue.
41600 rules inserted. The rule base contains 19514 rules. 1386 rules in the queue.
41800 rules inserted. The rule base contains 19594 rules. 1398 rules in the queue.
42000 rules inserted. The rule base contains 19670 rules. 1443 rules in the queue.
42200 rules inserted. The rule base contains 19817 rules. 1494 rules in the queue.
42400 rules inserted. The rule base contains 19973 rules. 1502 rules in the queue.
42600 rules inserted. The rule base contains 20120 rules. 1514 rules in the queue.
42800 rules inserted. The rule base contains 20245 rules. 1529 rules in the queue.
43000 rules inserted. The rule base contains 20354 rules. 1536 rules in the queue.
43200 rules inserted. The rule base contains 20427 rules. 1536 rules in the queue.
43400 rules inserted. The rule base contains 20528 rules. 1629 rules in the queue.
43600 rules inserted. The rule base contains 20707 rules. 1720 rules in the queue.
43800 rules inserted. The rule base contains 20853 rules. 1719 rules in the queue.
44000 rules inserted. The rule base contains 21033 rules. 1746 rules in the queue.
44200 rules inserted. The rule base contains 21171 rules. 1756 rules in the queue.
44400 rules inserted. The rule base contains 21322 rules. 1745 rules in the queue.
44600 rules inserted. The rule base contains 21477 rules. 1687 rules in the queue.
44800 rules inserted. The rule base contains 21609 rules. 1622 rules in the queue.
45000 rules inserted. The rule base contains 21785 rules. 1625 rules in the queue.
45200 rules inserted. The rule base contains 21961 rules. 1639 rules in the queue.
45400 rules inserted. The rule base contains 22120 rules. 1648 rules in the queue.
45600 rules inserted. The rule base contains 22294 rules. 1654 rules in the queue.
45800 rules inserted. The rule base contains 22443 rules. 1666 rules in the queue.
46000 rules inserted. The rule base contains 22595 rules. 1664 rules in the queue.
46200 rules inserted. The rule base contains 22685 rules. 1632 rules in the queue.
46400 rules inserted. The rule base contains 22767 rules. 1613 rules in the queue.
46600 rules inserted. The rule base contains 22919 rules. 1589 rules in the queue.
46800 rules inserted. The rule base contains 23091 rules. 1583 rules in the queue.
47000 rules inserted. The rule base contains 23186 rules. 1548 rules in the queue.
47200 rules inserted. The rule base contains 23338 rules. 1533 rules in the queue.
47400 rules inserted. The rule base contains 23436 rules. 1502 rules in the queue.
47600 rules inserted. The rule base contains 23563 rules. 1497 rules in the queue.
47800 rules inserted. The rule base contains 23621 rules. 1514 rules in the queue.
48000 rules inserted. The rule base contains 23693 rules. 1503 rules in the queue.
48200 rules inserted. The rule base contains 23887 rules. 1544 rules in the queue.
48400 rules inserted. The rule base contains 24027 rules. 1556 rules in the queue.
48600 rules inserted. The rule base contains 24104 rules. 1528 rules in the queue.
48800 rules inserted. The rule base contains 24173 rules. 1520 rules in the queue.
49000 rules inserted. The rule base contains 24253 rules. 1488 rules in the queue.
49200 rules inserted. The rule base contains 24333 rules. 1502 rules in the queue.
49400 rules inserted. The rule base contains 24389 rules. 1493 rules in the queue.
49600 rules inserted. The rule base contains 24510 rules. 1523 rules in the queue.
49800 rules inserted. The rule base contains 24668 rules. 1555 rules in the queue.
50000 rules inserted. The rule base contains 24816 rules. 1550 rules in the queue.
50200 rules inserted. The rule base contains 24913 rules. 1544 rules in the queue.
50400 rules inserted. The rule base contains 25040 rules. 1538 rules in the queue.
50600 rules inserted. The rule base contains 25172 rules. 1531 rules in the queue.
50800 rules inserted. The rule base contains 25285 rules. 1412 rules in the queue.
51000 rules inserted. The rule base contains 25423 rules. 1349 rules in the queue.
51200 rules inserted. The rule base contains 25581 rules. 1366 rules in the queue.
51400 rules inserted. The rule base contains 25716 rules. 1355 rules in the queue.
51600 rules inserted. The rule base contains 25879 rules. 1323 rules in the queue.
51800 rules inserted. The rule base contains 26007 rules. 1281 rules in the queue.
52000 rules inserted. The rule base contains 26157 rules. 1255 rules in the queue.
52200 rules inserted. The rule base contains 26273 rules. 1174 rules in the queue.
52400 rules inserted. The rule base contains 26471 rules. 1188 rules in the queue.
52600 rules inserted. The rule base contains 26671 rules. 1202 rules in the queue.
52800 rules inserted. The rule base contains 26686 rules. 1167 rules in the queue.
53000 rules inserted. The rule base contains 26699 rules. 1138 rules in the queue.
53200 rules inserted. The rule base contains 26813 rules. 1076 rules in the queue.
53400 rules inserted. The rule base contains 26975 rules. 1074 rules in the queue.
53600 rules inserted. The rule base contains 27165 rules. 1101 rules in the queue.
53800 rules inserted. The rule base contains 27359 rules. 1126 rules in the queue.
54000 rules inserted. The rule base contains 27462 rules. 1581 rules in the queue.
54200 rules inserted. The rule base contains 27625 rules. 2075 rules in the queue.
54400 rules inserted. The rule base contains 27761 rules. 2085 rules in the queue.
54600 rules inserted. The rule base contains 27952 rules. 2157 rules in the queue.
54800 rules inserted. The rule base contains 28134 rules. 2169 rules in the queue.
55000 rules inserted. The rule base contains 27717 rules. 2169 rules in the queue.
55200 rules inserted. The rule base contains 27915 rules. 1971 rules in the queue.
55400 rules inserted. The rule base contains 27974 rules. 2348 rules in the queue.
55600 rules inserted. The rule base contains 28092 rules. 2495 rules in the queue.
55800 rules inserted. The rule base contains 27645 rules. 2409 rules in the queue.
56000 rules inserted. The rule base contains 27808 rules. 2246 rules in the queue.
56200 rules inserted. The rule base contains 27878 rules. 2651 rules in the queue.
56400 rules inserted. The rule base contains 28001 rules. 2634 rules in the queue.
56600 rules inserted. The rule base contains 28135 rules. 2661 rules in the queue.
56800 rules inserted. The rule base contains 28284 rules. 2723 rules in the queue.
57000 rules inserted. The rule base contains 28430 rules. 2779 rules in the queue.
57200 rules inserted. The rule base contains 28553 rules. 2714 rules in the queue.
57400 rules inserted. The rule base contains 28682 rules. 2649 rules in the queue.
57600 rules inserted. The rule base contains 28682 rules. 2649 rules in the queue.
57800 rules inserted. The rule base contains 28628 rules. 2684 rules in the queue.
58000 rules inserted. The rule base contains 28710 rules. 2778 rules in the queue.
58200 rules inserted. The rule base contains 28786 rules. 2780 rules in the queue.
58400 rules inserted. The rule base contains 28955 rules. 2649 rules in the queue.
58600 rules inserted. The rule base contains 28971 rules. 2633 rules in the queue.
58800 rules inserted. The rule base contains 28900 rules. 2629 rules in the queue.
59000 rules inserted. The rule base contains 28991 rules. 2617 rules in the queue.
59200 rules inserted. The rule base contains 29083 rules. 2595 rules in the queue.
59400 rules inserted. The rule base contains 29200 rules. 2619 rules in the queue.
59600 rules inserted. The rule base contains 29301 rules. 2609 rules in the queue.
59800 rules inserted. The rule base contains 29374 rules. 2615 rules in the queue.
60000 rules inserted. The rule base contains 29410 rules. 2618 rules in the queue.
60200 rules inserted. The rule base contains 29415 rules. 2617 rules in the queue.
