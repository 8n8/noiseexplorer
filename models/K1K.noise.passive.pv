(* ---------------------------------------------------------------- *)
(* PARAMETERS                                                       *)
(* ---------------------------------------------------------------- *)

set redundancyElim = no.
set expandIfTermsToTerms = true.
set attacker = passive.

(* ---------------------------------------------------------------- *)
(* TYPES                                                            *)
(* ---------------------------------------------------------------- *)

type phasen.
type principal.
type state.
type stage.

type key.
type nonce.
type keypair.
type aead.
type token.

type cipherstate.
type symmetricstate.
type handshakestate.

type handshakepattern.

table statestore(principal, principal, state).

fun statepack_a(handshakestate): state [data].
fun statepack_b(handshakestate): state [data].
fun statepack_c(handshakestate): state [data].
fun statepack_d(handshakestate): state [data].
fun statepack_e(handshakestate): state [data].
fun statepack_f(handshakestate): state [data].
fun statepack_g(handshakestate): state [data].
fun statepack_h(handshakestate): state [data].
fun statepack_i(handshakestate): state [data].

fun msg_a(principal, principal):bitstring [private].
fun msg_b(principal, principal):bitstring [private].
fun msg_c(principal, principal):bitstring [private].
fun msg_d(principal, principal):bitstring [private].
fun msg_e(principal, principal):bitstring [private].
fun msg_f(principal, principal):bitstring [private].
fun msg_g(principal, principal):bitstring [private].
fun msg_h(principal, principal):bitstring [private].

fun key_s(principal):key [private].
fun key_e(principal, principal):key [private].
const key_psk:key [private].

fun key2bit(key):bitstring     [typeConverter].
fun bit2key(bitstring):key     [typeConverter].

fun nonce2bit(nonce):bitstring [typeConverter].
fun bit2nonce(bitstring):nonce [typeConverter].

fun token2bit(token):bitstring [typeConverter].
fun bit2token(bitstring):token [typeConverter].

fun keypairpack(key, key):keypair [data].
reduc forall public_key:key, private_key:key;
	keypairunpack(keypairpack(public_key, private_key))
		= (public_key, private_key).
reduc forall public_key:key, private_key:key;
	getpublickey(keypairpack(public_key, private_key))
		= public_key.
	
fun aeadpack(bool, bitstring, bitstring):aead [data].
reduc forall b:bool, ad:bitstring, plaintext:bitstring;
	aeadunpack(aeadpack(b, ad, plaintext)) = (b, ad, plaintext).

fun cipherstatepack(key, nonce):cipherstate [data].
reduc forall k:key, n:nonce;
	cipherstateunpack(cipherstatepack(k, n)) = (k, n).

fun symmetricstatepack(cipherstate, key, bitstring):symmetricstate [data].
reduc forall cs:cipherstate, k:key, h:bitstring;
	symmetricstateunpack(symmetricstatepack(cs, k, h)) = (cs, k, h).

fun handshakestatepack(symmetricstate, keypair, keypair, key, key, key, bool):handshakestate [data].
reduc forall ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, i:bool;
	handshakestateunpack(handshakestatepack(ss, s, e, rs, re, psk, i)) =
		(ss, s, e, rs, re, psk, i).

(* ---------------------------------------------------------------- *)
(* CONSTANTS                                                        *)
(* ---------------------------------------------------------------- *)

const zero:bitstring     [data].
const one:bitstring      [data].
const two:bitstring      [data].
const three:bitstring    [data].
const four:bitstring     [data].
const five:bitstring     [data].
const six:bitstring      [data].
const seven:bitstring    [data].
const noise:bitstring    [data].

const phase0:phasen      [data].
const phase1:phasen      [data].

const stage_a:stage      [data].
const stage_b:stage      [data].
const stage_c:stage      [data].
const stage_d:stage      [data].
const stage_e:stage      [data].
const stage_f:stage      [data].
const stage_g:stage      [data].
const stage_h:stage      [data].

const alice:principal    [data].
const bob:principal      [data].
const charlie:principal  [data].

const g:key              [data].
const minnonce:nonce     [data].
const maxnonce:nonce     [data].

const empty:bitstring    [data].
const somename:bitstring [data].

const notoken:token      [data].

(* ---------------------------------------------------------------- *)
(* STRING CONCATENATION                                             *)
(* ---------------------------------------------------------------- *)

fun concat2(bitstring, bitstring): bitstring [data].
reduc forall a:bitstring, b:bitstring;
	deconcat2(concat2(a, b)) = (a, b).

fun concat3(bitstring, bitstring, bitstring): bitstring [data].
reduc forall a:bitstring, b:bitstring, c:bitstring;
	deconcat3(concat3(a, b, c)) = (a, b, c).

fun concat4(bitstring, bitstring, bitstring, bitstring): bitstring [data].
	reduc forall a:bitstring, b:bitstring, c:bitstring, d:bitstring;
		deconcat4(concat4(a, b, c, d)) = (a, b, c, d).

(* ---------------------------------------------------------------- *)
(* PRIMITIVES                                                       *)
(* ---------------------------------------------------------------- *)

fun increment_nonce(nonce):nonce.
fun decrement_nonce(nonce):nonce reduc
	forall n:nonce;
		decrement_nonce(increment_nonce(n)) = n.

fun dhexp(key, key):key.
equation forall a:key, b:key;
	dhexp(b, dhexp(a, g)) = dhexp(a, dhexp(b, g)).

letfun dh(my_keypair:keypair, pubkey:key) =
	let (my_public_key:key, my_private_key:key) = keypairunpack(my_keypair) in
	dhexp(my_private_key, pubkey).

letfun generate_keypair(basis:key) =
	let public_key = dhexp(basis, g) in
	keypairpack(public_key, basis).

fun encrypt(key, nonce, bitstring, bitstring):bitstring.

fun decrypt(key, nonce, bitstring, bitstring):aead reduc
	forall k:key, n:nonce, ad:bitstring, plaintext:bitstring;
		decrypt(k, n, ad, encrypt(k, n, ad, plaintext)) = aeadpack(true, ad, plaintext).
		
fun hash(bitstring, bitstring):bitstring.

(*
letfun hmac_hash(k:key, data:bitstring) =
	bit2key(hash(concat2(key2bit(k), data))).

letfun hkdf(chaining_key:key, input_key_material:key) =
	let ikm_bitstring = key2bit(input_key_material) in
	let temp_key = hmac_hash(chaining_key, ikm_bitstring) in
	let output1 = hmac_hash(temp_key, one) in
	let output2 = hmac_hash(temp_key, concat2(key2bit(output1), two)) in
	let output3 = hmac_hash(temp_key, concat2(key2bit(output2), three)) in
  (output1, output2, output3).
*)

fun hmac_hash1(key, key):key.
fun hmac_hash2(key, key):key.
fun hmac_hash3(key, key):key.

letfun hkdf(chaining_key:key, input_key_material:key) =
	let output1 = hmac_hash1(chaining_key, input_key_material) in
	let output2 = hmac_hash2(chaining_key, input_key_material) in
	let output3 = hmac_hash3(chaining_key, input_key_material) in
  (output1, output2, output3).

(*
fun sign(key, bitstring): bitstring.
fun sigpk(key): key.
	
fun sigver(key, bitstring, bitstring): bool reduc
	forall sk:key, m:bitstring;
		sigver(sigpk(sk), sign(sk, m), m) = true
	otherwise forall pk:key, s:bitstring, m:bitstring;
		sigver(pk, s, m) = false.
*)

(* ---------------------------------------------------------------- *)
(* STATE MANAGEMENT                                                 *)
(* ---------------------------------------------------------------- *)

(* CipherState *)

letfun initializeKey(k:key) =
	cipherstatepack(k, minnonce).

letfun hasKey(cs:cipherstate) =
	let (k:key, n:nonce) = cipherstateunpack(cs) in
	(k <> bit2key(empty)).

letfun setNonce(cs:cipherstate, n:nonce) =
	let (k:key, o:nonce) = cipherstateunpack(cs) in
	cipherstatepack(k, n).

letfun encryptWithAd(cs:cipherstate, ad:bitstring, plaintext:bitstring) =
	let (k:key, n:nonce) = cipherstateunpack(cs) in
	let e = encrypt(k, n, ad, plaintext) in
	let csi = setNonce(cs, increment_nonce(n)) in
	(csi, e).

letfun decryptWithAd(cs:cipherstate, ad:bitstring, ciphertext:bitstring) =
	let (k:key, n:nonce) = cipherstateunpack(cs) in
	let d = decrypt(k, n, ad, ciphertext) in
	let (valid:bool, adi:bitstring, plaintext:bitstring) = aeadunpack(d) in
	let csi = setNonce(cs, increment_nonce(n)) in
	(csi, plaintext, valid).

letfun reKey(cs:cipherstate) =
	let (k:key, n:nonce) = cipherstateunpack(cs) in
	let ki = encrypt(k, maxnonce, empty, zero) in
	cipherstatepack(bit2key(ki), n).

(* SymmetricState *)

letfun initializeSymmetric(protocol_name:bitstring) =
	let h = hash(protocol_name, empty) in
	let ck = bit2key(h) in
	let cs = initializeKey(bit2key(empty)) in
	symmetricstatepack(cs, ck, h).

letfun mixKey(ss:symmetricstate, input_key_material:key) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	let (ck:key, temp_k:key, output_3:key) = hkdf(ck, input_key_material) in
	symmetricstatepack(initializeKey(temp_k), ck, h).

letfun mixHash(ss:symmetricstate, data:bitstring) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	symmetricstatepack(cs, ck, hash(h, data)).

letfun mixKeyAndHash(ss:symmetricstate, input_key_material:key) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	let (ck:key, temp_h:key, temp_k:key) = hkdf(ck, input_key_material) in
	let (cs:cipherstate, temp_ck:key, h:bitstring) = symmetricstateunpack(mixHash(symmetricstatepack(cs, ck, h), key2bit(temp_h))) in
	symmetricstatepack(initializeKey(temp_k), ck, h).
	
letfun getHandshakeHash(ss:symmetricstate) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	(ss, h).

letfun encryptAndHash(ss:symmetricstate, plaintext:bitstring) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	let (cs:cipherstate, ciphertext:bitstring) = encryptWithAd(cs, h, plaintext) in
	let ss = mixHash(symmetricstatepack(cs, ck, h), ciphertext) in
	(ss, ciphertext).

letfun decryptAndHash(ss:symmetricstate, ciphertext:bitstring) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	let (cs:cipherstate, plaintext:bitstring, valid:bool) = decryptWithAd(cs, h, ciphertext) in
	let ss = mixHash(symmetricstatepack(cs, ck, h), ciphertext) in
	(ss, plaintext, valid).

letfun split(ss:symmetricstate) =
	let (cs:cipherstate, ck:key, h:bitstring) = symmetricstateunpack(ss) in
	let (temp_k1:key, temp_k2:key, temp_k3:key) = hkdf(ck, bit2key(zero)) in
	let cs1 = initializeKey(temp_k1) in
	let cs2 = initializeKey(temp_k2) in
	(ss, cs1, cs2).

(* HandshakeState *)

letfun initialize_a(prologue:bitstring, s:keypair, e:keypair, rs:key, re:key, psk:key) =
	let ss = mixHash(initializeSymmetric(somename), prologue) in
	let ss = mixHash(ss, key2bit(getpublickey(s))) in
	let ss = mixHash(ss, key2bit(rs)) in
	handshakestatepack(ss, s, e, rs, re, psk, true).

letfun initialize_b(prologue:bitstring, s:keypair, e:keypair, rs:key, re:key, psk:key) =
	let ss = mixHash(initializeSymmetric(somename), prologue) in
	let ss = mixHash(ss, key2bit(rs)) in
	let ss = mixHash(ss, key2bit(getpublickey(s))) in
	handshakestatepack(ss, s, e, rs, re, psk, false).

letfun writeMessage_a(me:principal, them:principal, hs:handshakestate, payload:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = (empty, empty, empty) in
	let e = generate_keypair(key_e(me, them)) in
	let ne = key2bit(getpublickey(e)) in
	let ss = mixHash(ss, ne) in
	(* No PSK, so skipping mixKey. *)
	let ss = mixKey(ss, dh(e, rs)) in
	let (ss:symmetricstate, ciphertext2:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ciphertext1, ciphertext2) in
	(hs, re, message_buffer).

letfun writeMessage_b(me:principal, them:principal, hs:handshakestate, payload:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = (empty, empty, empty) in
	let e = generate_keypair(key_e(me, them)) in
	let ne = key2bit(getpublickey(e)) in
	let ss = mixHash(ss, ne) in
	(* No PSK, so skipping mixKey. *)
	let ss = mixKey(ss, dh(e, re)) in
	let (ss:symmetricstate, ciphertext2:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ciphertext1, ciphertext2) in
	(hs, re, message_buffer).

letfun writeMessage_c(me:principal, them:principal, hs:handshakestate, payload:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = (empty, empty, empty) in
	let ss = mixKey(ss, dh(s, re)) in
	let (ss:symmetricstate, ciphertext2:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ciphertext1, ciphertext2) in
	let (ssi:symmetricstate, cs1:cipherstate, cs2:cipherstate) = split(ss) in
	(hs, re, message_buffer, cs1, cs2).

letfun readMessage_a(me:principal, them:principal, hs:handshakestate, message:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = deconcat3(message) in
	let valid1 = true in
	let re = bit2key(ne) in
	let ss = mixHash(ss, key2bit(re)) in
	(* No PSK, so skipping mixKey. *)
	let ss = mixKey(ss, dh(s, re)) in
	let (ss:symmetricstate, plaintext2:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext2) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, getpublickey(e), plaintext2, true)
	).

letfun readMessage_b(me:principal, them:principal, hs:handshakestate, message:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = deconcat3(message) in
	let valid1 = true in
	let re = bit2key(ne) in
	let ss = mixHash(ss, key2bit(re)) in
	(* No PSK, so skipping mixKey. *)
	let ss = mixKey(ss, dh(e, re)) in
	let (ss:symmetricstate, plaintext2:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext2) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, getpublickey(e), plaintext2, true)
	).

letfun readMessage_c(me:principal, them:principal, hs:handshakestate, message:bitstring) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ciphertext1:bitstring, ciphertext2:bitstring) = deconcat3(message) in
	let valid1 = true in
	let ss = mixKey(ss, dh(e, rs)) in
	let (ss:symmetricstate, plaintext2:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext2) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		let (ssi:symmetricstate, cs1:cipherstate, cs2:cipherstate) = split(ss) in
		(hs, getpublickey(e), plaintext2, true, cs1, cs2)
	).

(* ---------------------------------------------------------------- *)
(* CHANNELS                                                         *)
(* ---------------------------------------------------------------- *)

const pub:channel.

(* ---------------------------------------------------------------- *)
(* EVENTS & QUERIES                                                 *)
(* ---------------------------------------------------------------- *)

event Error().
event SendEnd(bool).
event RecvEnd(bool).
event SendMsg(principal, principal, stage, bitstring, bool).
event RecvMsg(principal, principal, stage, bitstring, bool).
event LeakS(phasen, principal).
event LeakPsk(phasen, key).

query a:principal, b:principal, c:principal, s:stage, m:bitstring, p:phasen;
(* Message a: Authenticity sanity *)
	event(RecvMsg(bob, alice, stage_a, m, true)) ==> (event(SendMsg(alice, bob, stage_a, m, true)));
(* Message a: Authenticity 1 *)
	event(RecvMsg(bob, alice, stage_a, m, true)) ==> (event(SendMsg(alice, c, stage_a, m, true))) || (event(LeakS(phase0, alice)) || event(LeakS(phase0, bob)));
(* Message a: Authenticity 2 *)
	event(RecvMsg(bob, alice, stage_a, m, true)) ==> (event(SendMsg(alice, c, stage_a, m, true))) || (event(LeakS(phase0, alice)));
(* Message a: Authenticity 3 *)
	event(RecvMsg(bob, alice, stage_a, m, true)) ==> (event(SendMsg(alice, bob, stage_a, m, true))) || (event(LeakS(phase0, alice)) || event(LeakS(phase0, bob)));
(* Message a: Authenticity 4 *)
	event(RecvMsg(bob, alice, stage_a, m, true)) ==> (event(SendMsg(alice, bob, stage_a, m, true))) || (event(LeakS(phase0, alice)));
(* Message a: Confidentiality sanity *)
	attacker(msg_a(alice, bob));
(* Message a: Confidentiality 1 *)
	attacker(msg_a(alice, bob)) ==> (event(LeakS(phase0, bob))) || (event(LeakS(phase1, bob)));
(* Message a: Confidentiality 3 *)
	attacker(msg_a(alice, bob)) ==> (event(LeakS(phase0, bob))) || ((event(LeakS(phase1, bob)) && event(LeakS(p, alice))));
(* Message a: Confidentiality 5 *)
	attacker(msg_a(alice, bob)) ==> (event(LeakS(phase0, bob)));
(* Message b: Authenticity sanity *)
	event(RecvMsg(alice, bob, stage_b, m, true)) ==> (event(SendMsg(bob, alice, stage_b, m, true)));
(* Message b: Authenticity 1 *)
	event(RecvMsg(alice, bob, stage_b, m, true)) ==> (event(SendMsg(bob, c, stage_b, m, true))) || (event(LeakS(phase0, bob)) || event(LeakS(phase0, alice)));
(* Message b: Authenticity 2 *)
	event(RecvMsg(alice, bob, stage_b, m, true)) ==> (event(SendMsg(bob, c, stage_b, m, true))) || (event(LeakS(phase0, bob)));
(* Message b: Authenticity 3 *)
	event(RecvMsg(alice, bob, stage_b, m, true)) ==> (event(SendMsg(bob, alice, stage_b, m, true))) || (event(LeakS(phase0, bob)) || event(LeakS(phase0, alice)));
(* Message b: Authenticity 4 *)
	event(RecvMsg(alice, bob, stage_b, m, true)) ==> (event(SendMsg(bob, alice, stage_b, m, true))) || (event(LeakS(phase0, bob)));
(* Message b: Confidentiality sanity *)
	attacker(msg_b(bob, alice));
(* Message b: Confidentiality 1 *)
	attacker(msg_b(bob, alice)) ==> (event(LeakS(phase0, alice))) || (event(LeakS(phase1, alice)));
(* Message b: Confidentiality 3 *)
	attacker(msg_b(bob, alice)) ==> (event(LeakS(phase0, alice))) || ((event(LeakS(phase1, alice)) && event(LeakS(p, bob))));
(* Message b: Confidentiality 5 *)
	attacker(msg_b(bob, alice)) ==> (event(LeakS(phase0, alice)));
(* Message c: Authenticity sanity *)
	event(RecvMsg(bob, alice, stage_c, m, true)) ==> (event(SendMsg(alice, bob, stage_c, m, true)));
(* Message c: Authenticity 1 *)
	event(RecvMsg(bob, alice, stage_c, m, true)) ==> (event(SendMsg(alice, c, stage_c, m, true))) || (event(LeakS(phase0, alice)) || event(LeakS(phase0, bob)));
(* Message c: Authenticity 2 *)
	event(RecvMsg(bob, alice, stage_c, m, true)) ==> (event(SendMsg(alice, c, stage_c, m, true))) || (event(LeakS(phase0, alice)));
(* Message c: Authenticity 3 *)
	event(RecvMsg(bob, alice, stage_c, m, true)) ==> (event(SendMsg(alice, bob, stage_c, m, true))) || (event(LeakS(phase0, alice)) || event(LeakS(phase0, bob)));
(* Message c: Authenticity 4 *)
	event(RecvMsg(bob, alice, stage_c, m, true)) ==> (event(SendMsg(alice, bob, stage_c, m, true))) || (event(LeakS(phase0, alice)));
(* Message c: Confidentiality sanity *)
	attacker(msg_c(alice, bob));
(* Message c: Confidentiality 1 *)
	attacker(msg_c(alice, bob)) ==> (event(LeakS(phase0, bob))) || (event(LeakS(phase1, bob)));
(* Message c: Confidentiality 3 *)
	attacker(msg_c(alice, bob)) ==> (event(LeakS(phase0, bob))) || ((event(LeakS(phase1, bob)) && event(LeakS(p, alice))));
(* Message c: Confidentiality 5 *)
	attacker(msg_c(alice, bob)) ==> (event(LeakS(phase0, bob)));
	event(RecvEnd(true)).

(* ---------------------------------------------------------------- *)
(* PROCESSES                                                        *)
(* ---------------------------------------------------------------- *)

(*
K1K:
	-> s
	<- s
	...
	-> e, es
	<- e, ee
	-> se
*)


let initiator(me:principal, them:principal) =
	let s = generate_keypair(key_s(me)) in
	out(pub, getpublickey(s));
	((
		let e = keypairpack(bit2key(empty), bit2key(empty)) in
		let rs = getpublickey(generate_keypair(key_s(them))) in
		let re = bit2key(empty) in
		let hs:handshakestate = initialize_a(empty, s, e, rs, re, bit2key(empty)) in
		insert statestore(me, them, statepack_a(hs))
	)
	| (
		get statestore(=me, =them, statepack_a(hs)) in
		let (hs:handshakestate, re:key, message_a:bitstring) = writeMessage_a(me, them, hs, msg_a(me, them)) in
		event SendMsg(me, them, stage_a, msg_a(me, them), true);
		insert statestore(me, them, statepack_b(hs));
		out(pub, message_a)
	)
	| (
		get statestore(=me, =them, statepack_b(hs)) in
		in(pub, message_b:bitstring);
		let (hs:handshakestate, re:key, plaintext_b:bitstring, valid:bool) = readMessage_b(me, them, hs, message_b) in
		event RecvMsg(me, them, stage_b, plaintext_b, valid);
		insert statestore(me, them, statepack_c(hs));
		0
	)
	| (
		get statestore(=me, =them, statepack_c(hs)) in
		let (hs:handshakestate, re:key, message_c:bitstring, cs1:cipherstate, cs2:cipherstate) = writeMessage_c(me, them, hs, msg_c(me, them)) in
		event SendMsg(me, them, stage_c, msg_c(me, them), true);
		insert statestore(me, them, statepack_d(hs));
		out(pub, message_c)
	)
	| (
		event LeakS(phase0, me);
		out(pub, key_s(me))
	)
	| (
		phase 1;
		event LeakS(phase1, me);
		out(pub, key_s(me))
	)).

let responder(me:principal, them:principal) =
	let s = generate_keypair(key_s(me)) in
	out(pub, getpublickey(s));
	((
		let e = keypairpack(bit2key(empty), bit2key(empty)) in
		let rs = getpublickey(generate_keypair(key_s(them))) in
		let re = bit2key(empty) in
		let hs:handshakestate = initialize_b(empty, s, e, rs, re, bit2key(empty)) in
		insert statestore(me, them, statepack_a(hs))
	)
	| (
		get statestore(=me, =them, statepack_a(hs)) in
		in(pub, message_a:bitstring);
		let (hs:handshakestate, re:key, plaintext_a:bitstring, valid:bool) = readMessage_a(me, them, hs, message_a) in
		event RecvMsg(me, them, stage_a, plaintext_a, valid);
		insert statestore(me, them, statepack_b(hs));
		0
	)
	| (
		get statestore(=me, =them, statepack_b(hs)) in
		let (hs:handshakestate, re:key, message_b:bitstring) = writeMessage_b(me, them, hs, msg_b(me, them)) in
		event SendMsg(me, them, stage_b, msg_b(me, them), true);
		insert statestore(me, them, statepack_c(hs));
		out(pub, message_b)
	)
	| (
		get statestore(=me, =them, statepack_c(hs)) in
		in(pub, message_c:bitstring);
		let (hs:handshakestate, re:key, plaintext_c:bitstring, valid:bool, cs1:cipherstate, cs2:cipherstate) = readMessage_c(me, them, hs, message_c) in
		event RecvMsg(me, them, stage_c, plaintext_c, valid);
		insert statestore(me, them, statepack_d(hs));
		event RecvEnd(valid)
	)
	| (
		event LeakS(phase0, me);
		out(pub, key_s(me))
	)
	| (
		phase 1;
		event LeakS(phase1, me);
		out(pub, key_s(me))
	)).

(* ---------------------------------------------------------------- *)
(* TOP-LEVEL PROCESS                                                *)
(* ---------------------------------------------------------------- *)

process
  !(
		initiator(alice, bob)
		|
		initiator(alice, charlie)
		|
		responder(bob, alice)
		|
		responder(bob, charlie)
		|
		out(pub, (key_s(charlie), key_e(charlie, alice), key_e(charlie, bob)))
	)

