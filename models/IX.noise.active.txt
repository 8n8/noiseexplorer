File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 271, character 6:
Warning: identifier e rebound.
File "IX.noise.active.pv", line 272, characters 6-7:
Warning: identifier ne rebound.
File "IX.noise.active.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 275, character 6:
Warning: identifier s rebound.
File "IX.noise.active.pv", line 276, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 276, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IX.noise.active.pv", line 277, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 277, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 278, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 285, character 6:
Warning: identifier e rebound.
File "IX.noise.active.pv", line 286, characters 6-7:
Warning: identifier ne rebound.
File "IX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "IX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 304, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 320, characters 6-7:
Warning: identifier re rebound.
File "IX.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 323, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 323, characters 48-53:
Warning: identifier valid1 rebound.
File "IX.noise.active.pv", line 324, characters 6-7:
Warning: identifier rs rebound.
File "IX.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 327, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 335, characters 6-7:
Warning: identifier re rebound.
File "IX.noise.active.pv", line 336, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 338, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 340, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 340, characters 48-53:
Warning: identifier valid1 rebound.
File "IX.noise.active.pv", line 341, characters 6-7:
Warning: identifier rs rebound.
File "IX.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 354, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 356, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 511, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 513, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 503, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 504, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 304, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 496, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 335, characters 6-7:
Warning: identifier re rebound.
File "IX.noise.active.pv", line 336, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 338, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 340, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 340, characters 48-53:
Warning: identifier valid1 rebound.
File "IX.noise.active.pv", line 341, characters 6-7:
Warning: identifier rs rebound.
File "IX.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 488, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 271, character 6:
Warning: identifier e rebound.
File "IX.noise.active.pv", line 272, characters 6-7:
Warning: identifier ne rebound.
File "IX.noise.active.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 275, character 6:
Warning: identifier s rebound.
File "IX.noise.active.pv", line 276, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 276, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IX.noise.active.pv", line 277, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 277, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 278, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 564, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 565, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 555, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 557, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 354, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 356, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 548, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 285, character 6:
Warning: identifier e rebound.
File "IX.noise.active.pv", line 286, characters 6-7:
Warning: identifier ne rebound.
File "IX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "IX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 541, characters 8-9:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 320, characters 6-7:
Warning: identifier re rebound.
File "IX.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 323, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 323, characters 48-53:
Warning: identifier valid1 rebound.
File "IX.noise.active.pv", line 324, characters 6-7:
Warning: identifier rs rebound.
File "IX.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 327, characters 7-8:
Warning: identifier hs rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_538: keypair = keypairpack(empty,empty) in
    {5}out(pub, getpublickey(s_538));
    (
        {6}let e_539: keypair = keypairpack(empty,empty) in
        {7}let rs_540: key = empty in
        {8}let re_541: key = empty in
        {9}let v_542: bitstring = catch-fail(hash(somename,empty)) in
        {10}let v_543: key = catch-fail(v_542) in
        {11}let v_544: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {12}let v_545: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_542) then (if not-caught-fail(v_543) then (if not-caught-fail(v_544) then symmetricstatepack(v_544,v_543,v_542) else fail-any) else fail-any) else fail-any))) in
        {13}let v_546: symmetricstate = catch-fail((if success?((if not-caught-fail(v_542) then (if not-caught-fail(v_543) then (if not-caught-fail(v_544) then symmetricstatepack(v_544,v_543,v_542) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_545) && success?(is-true(success?(1-proj-3-tuple(v_545))))) then symmetricstatepack(1-proj-3-tuple(v_545),2-proj-3-tuple(v_545),hash(3-proj-3-tuple(v_545),empty)) else fail-any) else fail-any)) in
        {14}let hs: handshakestate = (if not-caught-fail(v_546) then handshakestatepack(v_546,s_538,e_539,rs_540,re_541,empty,true) else fail-any) in
        {15}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {49}get statestore(=alice,=bob,=sid,statepack_a(hs_547: handshakestate)) in
        {16}let v_548: bitstring = catch-fail(handshakestateunpack(hs_547)) in
        {17}let v_549: bitstring = catch-fail((empty,empty,empty)) in
        {18}let v_550: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {19}let v_551: keypair = catch-fail((if not-caught-fail(v_550) then keypairpack(v_550,key_e(alice,bob,sid)) else fail-any)) in
        {20}let v_552: bitstring = catch-fail(getpublickey(v_551)) in
        {21}let v_553: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_548))) in
        {22}let v_554: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_548)) then (if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-3-tuple(v_553))))) then symmetricstatepack(1-proj-3-tuple(v_553),2-proj-3-tuple(v_553),hash(3-proj-3-tuple(v_553),v_552)) else fail-any) else fail-any)) in
        {23}let v_555: key = catch-fail(dhexp(key_s(alice),g)) in
        {24}let v_556: keypair = catch-fail((if not-caught-fail(v_555) then keypairpack(v_555,key_s(alice)) else fail-any)) in
        {25}let v_557: bitstring = catch-fail(symmetricstateunpack(v_554)) in
        {26}let v_558: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_557))) in
        {27}let v_559: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_558),2-proj-2-tuple(v_558),3-proj-3-tuple(v_557),getpublickey(v_556))) in
        {28}let v_560: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_557))) in
        {29}let v_561: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_558))) && success?(1-proj-3-tuple(v_557))) then (if (not-caught-fail(v_560) && success?(is-true(success?(1-proj-2-tuple(v_560))))) then cipherstatepack(1-proj-2-tuple(v_560),increment_nonce(2-proj-2-tuple(v_558))) else fail-any) else fail-any)) in
        {30}let v_562: bitstring = catch-fail((if (success?(getpublickey(v_556)) && (success?(3-proj-3-tuple(v_557)) && success?(1-proj-3-tuple(v_557)))) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then (if not-caught-fail(v_559) then (if not-caught-fail(v_561) then (v_561,v_559) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {31}let v_563: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_562),2-proj-3-tuple(v_557),3-proj-3-tuple(v_557)))) in
        {32}let v_564: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_562)) && success?(symmetricstatepack(1-proj-2-tuple(v_562),2-proj-3-tuple(v_557),3-proj-3-tuple(v_557)))) then (if (not-caught-fail(v_563) && success?(is-true(success?(1-proj-3-tuple(v_563))))) then symmetricstatepack(1-proj-3-tuple(v_563),2-proj-3-tuple(v_563),hash(3-proj-3-tuple(v_563),2-proj-2-tuple(v_562))) else fail-any) else fail-any)) in
        {33}let v_565: bitstring = catch-fail((if success?(getpublickey(v_556)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-3-tuple(v_557))))) then (if (not-caught-fail(v_562) && success?(is-true(success?(1-proj-2-tuple(v_562))))) then (if not-caught-fail(v_564) then (v_564,2-proj-2-tuple(v_562)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {34}let v_566: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_565))) in
        {35}let v_567: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_566))) in
        {36}let v_568: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_567),2-proj-2-tuple(v_567),3-proj-3-tuple(v_566),msg_a(alice,bob))) in
        {37}let v_569: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_566))) in
        {38}let v_570: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_567))) && success?(1-proj-3-tuple(v_566))) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then cipherstatepack(1-proj-2-tuple(v_569),increment_nonce(2-proj-2-tuple(v_567))) else fail-any) else fail-any)) in
        {39}let v_571: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_566)) && success?(1-proj-3-tuple(v_566))) then (if (not-caught-fail(v_567) && success?(is-true(success?(1-proj-2-tuple(v_567))))) then (if not-caught-fail(v_568) then (if not-caught-fail(v_570) then (v_570,v_568) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {40}let v_572: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_571),2-proj-3-tuple(v_566),3-proj-3-tuple(v_566)))) in
        {41}let v_573: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_571)) && success?(symmetricstatepack(1-proj-2-tuple(v_571),2-proj-3-tuple(v_566),3-proj-3-tuple(v_566)))) then (if (not-caught-fail(v_572) && success?(is-true(success?(1-proj-3-tuple(v_572))))) then symmetricstatepack(1-proj-3-tuple(v_572),2-proj-3-tuple(v_572),hash(3-proj-3-tuple(v_572),2-proj-2-tuple(v_571))) else fail-any) else fail-any)) in
        {42}let v_574: bitstring = catch-fail((if success?(1-proj-2-tuple(v_565)) then (if (not-caught-fail(v_566) && success?(is-true(success?(1-proj-3-tuple(v_566))))) then (if (not-caught-fail(v_571) && success?(is-true(success?(1-proj-2-tuple(v_571))))) then (if not-caught-fail(v_573) then (v_573,2-proj-2-tuple(v_571)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {43}let v_575: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_574),v_556,v_551,4-proj-7-tuple(v_548),5-proj-7-tuple(v_548),6-proj-7-tuple(v_548),7-proj-7-tuple(v_548))) in
        {44}let v_576: bitstring = catch-fail(concat3(v_552,2-proj-2-tuple(v_565),2-proj-2-tuple(v_574))) in
        {45}let (hs_577: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_548) && success?(is-true(success?(1-proj-7-tuple(v_548))))) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-3-tuple(v_549))))) then (if not-caught-fail(v_551) then (if not-caught-fail(v_552) then (if not-caught-fail(v_554) then (if not-caught-fail(v_556) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then (if not-caught-fail(v_575) then (if not-caught-fail(v_576) then (v_575,v_576) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {46}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob));
        {47}insert statestore(alice,bob,sid,statepack_b(hs_577));
        {48}out(pub, message_a)
    ) | (
        {112}get statestore(=alice,=bob,=sid,statepack_b(hs_578: handshakestate)) in
        {50}in(pub, message_b: bitstring);
        {51}let v_579: bitstring = catch-fail(handshakestateunpack(hs_578)) in
        {52}let v_580: bitstring = catch-fail(deconcat3(message_b)) in
        {53}let v_581: bool = catch-fail(true) in
        {54}let v_582: key = catch-fail(1-proj-3-tuple(v_580)) in
        {55}let v_583: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_579))) in
        {56}let v_584: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_579)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-3-tuple(v_583))))) then symmetricstatepack(1-proj-3-tuple(v_583),2-proj-3-tuple(v_583),hash(3-proj-3-tuple(v_583),v_582)) else fail-any) else fail-any)) in
        {57}let v_585: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_579))) in
        {58}let v_586: bitstring = catch-fail(symmetricstateunpack(v_584)) in
        {59}let v_587: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_586),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then dhexp(2-proj-2-tuple(v_585),v_582) else fail-any) else fail-any))) in
        {60}let v_588: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_586),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then dhexp(2-proj-2-tuple(v_585),v_582) else fail-any) else fail-any))) in
        {61}let v_589: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_586),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then dhexp(2-proj-2-tuple(v_585),v_582) else fail-any) else fail-any))) in
        {62}let v_590: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then dhexp(2-proj-2-tuple(v_585),v_582) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_586))) then (if not-caught-fail(v_587) then (if not-caught-fail(v_588) then (if not-caught-fail(v_589) then (v_587,v_588,v_589) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {63}let v_591: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then dhexp(2-proj-2-tuple(v_585),v_582) else fail-any) else fail-any)) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then (if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_590)) then cipherstatepack(2-proj-3-tuple(v_590),minnonce) else fail-any),1-proj-3-tuple(v_590),3-proj-3-tuple(v_586)) else fail-any) else fail-any) else fail-any)) in
        {64}let v_592: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_579))) in
        {65}let v_593: bitstring = catch-fail(symmetricstateunpack(v_591)) in
        {66}let v_594: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_593),(if success?(2-proj-7-tuple(v_579)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then dhexp(2-proj-2-tuple(v_592),v_582) else fail-any) else fail-any))) in
        {67}let v_595: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_593),(if success?(2-proj-7-tuple(v_579)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then dhexp(2-proj-2-tuple(v_592),v_582) else fail-any) else fail-any))) in
        {68}let v_596: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_593),(if success?(2-proj-7-tuple(v_579)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then dhexp(2-proj-2-tuple(v_592),v_582) else fail-any) else fail-any))) in
        {69}let v_597: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_579)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then dhexp(2-proj-2-tuple(v_592),v_582) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_593))) then (if not-caught-fail(v_594) then (if not-caught-fail(v_595) then (if not-caught-fail(v_596) then (v_594,v_595,v_596) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {70}let v_598: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_579)) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then dhexp(2-proj-2-tuple(v_592),v_582) else fail-any) else fail-any)) then (if (not-caught-fail(v_593) && success?(is-true(success?(1-proj-3-tuple(v_593))))) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_597)) then cipherstatepack(2-proj-3-tuple(v_597),minnonce) else fail-any),1-proj-3-tuple(v_597),3-proj-3-tuple(v_593)) else fail-any) else fail-any) else fail-any)) in
        {71}let v_599: bitstring = catch-fail(symmetricstateunpack(v_598)) in
        {72}let v_600: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_599))) in
        {73}let v_601: aead = catch-fail(decrypt(1-proj-2-tuple(v_600),2-proj-2-tuple(v_600),3-proj-3-tuple(v_599),2-proj-3-tuple(v_580))) in
        {74}let v_602: bitstring = catch-fail(aeadunpack(v_601)) in
        {75}let v_603: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_599))) in
        {76}let v_604: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_600))) && success?(1-proj-3-tuple(v_599))) then (if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-2-tuple(v_603))))) then cipherstatepack(1-proj-2-tuple(v_603),increment_nonce(2-proj-2-tuple(v_600))) else fail-any) else fail-any)) in
        {77}let v_605: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_580)) && (success?(3-proj-3-tuple(v_599)) && success?(1-proj-3-tuple(v_599)))) then (if (not-caught-fail(v_600) && success?(is-true(success?(1-proj-2-tuple(v_600))))) then (if not-caught-fail(v_601) then (if (not-caught-fail(v_602) && success?(is-true(success?(1-proj-3-tuple(v_602))))) then (if not-caught-fail(v_604) then (v_604,3-proj-3-tuple(v_602),1-proj-3-tuple(v_602)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {78}let v_606: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_605),2-proj-3-tuple(v_599),3-proj-3-tuple(v_599)))) in
        {79}let v_607: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_580)) && success?(symmetricstatepack(1-proj-3-tuple(v_605),2-proj-3-tuple(v_599),3-proj-3-tuple(v_599)))) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-3-tuple(v_606))))) then symmetricstatepack(1-proj-3-tuple(v_606),2-proj-3-tuple(v_606),hash(3-proj-3-tuple(v_606),2-proj-3-tuple(v_580))) else fail-any) else fail-any)) in
        {80}let v_608: bitstring = catch-fail((if success?(2-proj-3-tuple(v_580)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-3-tuple(v_599))))) then (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-3-tuple(v_605))))) then (if not-caught-fail(v_607) then (v_607,2-proj-3-tuple(v_605),3-proj-3-tuple(v_605)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {81}let v_609: key = catch-fail(2-proj-3-tuple(v_608)) in
        {82}let v_610: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_579))) in
        {83}let v_611: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_608))) in
        {84}let v_612: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_609) else fail-any) else fail-any))) in
        {85}let v_613: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_609) else fail-any) else fail-any))) in
        {86}let v_614: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_609) else fail-any) else fail-any))) in
        {87}let v_615: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_609) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_611))) then (if not-caught-fail(v_612) then (if not-caught-fail(v_613) then (if not-caught-fail(v_614) then (v_612,v_613,v_614) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {88}let v_616: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_579)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_609) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_608))) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-3-tuple(v_611))))) then (if (not-caught-fail(v_615) && success?(is-true(success?(1-proj-3-tuple(v_615))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_615)) then cipherstatepack(2-proj-3-tuple(v_615),minnonce) else fail-any),1-proj-3-tuple(v_615),3-proj-3-tuple(v_611)) else fail-any) else fail-any) else fail-any)) in
        {89}let v_617: bitstring = catch-fail(symmetricstateunpack(v_616)) in
        {90}let v_618: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {91}let v_619: aead = catch-fail(decrypt(1-proj-2-tuple(v_618),2-proj-2-tuple(v_618),3-proj-3-tuple(v_617),3-proj-3-tuple(v_580))) in
        {92}let v_620: bitstring = catch-fail(aeadunpack(v_619)) in
        {93}let v_621: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {94}let v_622: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_618))) && success?(1-proj-3-tuple(v_617))) then (if (not-caught-fail(v_621) && success?(is-true(success?(1-proj-2-tuple(v_621))))) then cipherstatepack(1-proj-2-tuple(v_621),increment_nonce(2-proj-2-tuple(v_618))) else fail-any) else fail-any)) in
        {95}let v_623: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_580)) && (success?(3-proj-3-tuple(v_617)) && success?(1-proj-3-tuple(v_617)))) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-2-tuple(v_618))))) then (if not-caught-fail(v_619) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then (if not-caught-fail(v_622) then (v_622,3-proj-3-tuple(v_620),1-proj-3-tuple(v_620)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {96}let v_624: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_623),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) in
        {97}let v_625: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_580)) && success?(symmetricstatepack(1-proj-3-tuple(v_623),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-3-tuple(v_624))))) then symmetricstatepack(1-proj-3-tuple(v_624),2-proj-3-tuple(v_624),hash(3-proj-3-tuple(v_624),3-proj-3-tuple(v_580))) else fail-any) else fail-any)) in
        {98}let v_626: bitstring = catch-fail((if success?(3-proj-3-tuple(v_580)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-3-tuple(v_617))))) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-3-tuple(v_623))))) then (if not-caught-fail(v_625) then (v_625,2-proj-3-tuple(v_623),3-proj-3-tuple(v_623)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {99}let v_627: key = catch-fail(dhexp(key_s(bob),g)) in
        {100}let v_628: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_626),2-proj-7-tuple(v_579),3-proj-7-tuple(v_579),v_609,v_582,6-proj-7-tuple(v_579),7-proj-7-tuple(v_579))) in
        {101}let v_629: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_626))) in
        {102}let v_630: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_629),zero)) in
        {103}let v_631: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_629),zero)) in
        {104}let v_632: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_629),zero)) in
        {105}let v_633: bitstring = catch-fail((if success?(2-proj-3-tuple(v_629)) then (if not-caught-fail(v_630) then (if not-caught-fail(v_631) then (if not-caught-fail(v_632) then (v_630,v_631,v_632) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {106}let v_634: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_633)) then cipherstatepack(1-proj-3-tuple(v_633),minnonce) else fail-any)) in
        {107}let v_635: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_633)) then cipherstatepack(2-proj-3-tuple(v_633),minnonce) else fail-any)) in
        {108}let v_636: bitstring = catch-fail((if success?(1-proj-3-tuple(v_626)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-3-tuple(v_629))))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-3-tuple(v_633))))) then (if not-caught-fail(v_634) then (if not-caught-fail(v_635) then (1-proj-3-tuple(v_626),v_634,v_635) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {109}let (hs_637: handshakestate,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_579) && success?(is-true(success?(1-proj-7-tuple(v_579))))) then (if (not-caught-fail(v_580) && success?(is-true(success?(1-proj-3-tuple(v_580))))) then (if not-caught-fail(v_581) then (if not-caught-fail(v_582) then (if not-caught-fail(v_584) then (if not-caught-fail(v_591) then (if not-caught-fail(v_598) then (if (not-caught-fail(v_608) && success?(is-true(success?(1-proj-3-tuple(v_608))))) then (if not-caught-fail(v_609) then (if not-caught-fail(v_616) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-3-tuple(v_626))))) then (if ((3-proj-3-tuple(v_608) && 3-proj-3-tuple(v_626)) && (v_609 = getpublickey((if not-caught-fail(v_627) then keypairpack(v_627,key_s(bob)) else fail-any)))) then (if not-caught-fail(v_628) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then (v_628,2-proj-3-tuple(v_626),true,2-proj-3-tuple(v_636),3-proj-3-tuple(v_636)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {110}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {111}insert statestore(alice,bob,sid,statepack_c(hs_637,cs1,cs2))
    ) | (
        {113}!
        {132}get statestore(=alice,=bob,=sid,statepack_c(hs_638: handshakestate,cs1_639: cipherstate,cs2_640: cipherstate)) in
        {114}let hs_641: handshakestate = handshakestatesetcs(hs_638,cs1_639) in
        {115}let v_642: bitstring = catch-fail(handshakestateunpack(hs_641)) in
        {116}let v_643: bitstring = catch-fail((empty,empty,empty)) in
        {117}let v_644: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_642))) in
        {118}let v_645: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_644))) in
        {119}let v_646: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_645),2-proj-2-tuple(v_645),3-proj-3-tuple(v_644),msg_c(alice,bob))) in
        {120}let v_647: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_644))) in
        {121}let v_648: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_645))) && success?(1-proj-3-tuple(v_644))) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-2-tuple(v_647))))) then cipherstatepack(1-proj-2-tuple(v_647),increment_nonce(2-proj-2-tuple(v_645))) else fail-any) else fail-any)) in
        {122}let v_649: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_644)) && success?(1-proj-3-tuple(v_644))) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-2-tuple(v_645))))) then (if not-caught-fail(v_646) then (if not-caught-fail(v_648) then (v_648,v_646) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {123}let v_650: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_649),2-proj-3-tuple(v_644),3-proj-3-tuple(v_644)))) in
        {124}let v_651: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_649)) && success?(symmetricstatepack(1-proj-2-tuple(v_649),2-proj-3-tuple(v_644),3-proj-3-tuple(v_644)))) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-3-tuple(v_650))))) then symmetricstatepack(1-proj-3-tuple(v_650),2-proj-3-tuple(v_650),hash(3-proj-3-tuple(v_650),2-proj-2-tuple(v_649))) else fail-any) else fail-any)) in
        {125}let v_652: bitstring = catch-fail((if success?(1-proj-7-tuple(v_642)) then (if (not-caught-fail(v_644) && success?(is-true(success?(1-proj-3-tuple(v_644))))) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-2-tuple(v_649))))) then (if not-caught-fail(v_651) then (v_651,2-proj-2-tuple(v_649)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {126}let v_653: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_652),2-proj-7-tuple(v_642),3-proj-7-tuple(v_642),4-proj-7-tuple(v_642),5-proj-7-tuple(v_642),6-proj-7-tuple(v_642),7-proj-7-tuple(v_642))) in
        {127}let v_654: bitstring = catch-fail(concat3(1-proj-3-tuple(v_643),2-proj-3-tuple(v_643),2-proj-2-tuple(v_652))) in
        {128}let (hs_655: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-7-tuple(v_642))))) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-3-tuple(v_643))))) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-2-tuple(v_652))))) then (if not-caught-fail(v_653) then (if not-caught-fail(v_654) then (v_653,v_654) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {129}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob));
        {130}insert statestore(alice,bob,sid,statepack_d(hs_655,handshakestategetcs(hs_655),cs2_640));
        {131}out(pub, message_c)
    ) | (
        {133}!
        {153}get statestore(=alice,=bob,=sid,statepack_d(hs_656: handshakestate,cs1_657: cipherstate,cs2_658: cipherstate)) in
        {134}let hs_659: handshakestate = handshakestatesetcs(hs_656,cs2_658) in
        {135}in(pub, message_d: bitstring);
        {136}let v_660: bitstring = catch-fail(handshakestateunpack(hs_659)) in
        {137}let v_661: bitstring = catch-fail(deconcat3(message_d)) in
        {138}let v_662: bool = catch-fail(true) in
        {139}let v_663: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_660))) in
        {140}let v_664: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_663))) in
        {141}let v_665: aead = catch-fail(decrypt(1-proj-2-tuple(v_664),2-proj-2-tuple(v_664),3-proj-3-tuple(v_663),3-proj-3-tuple(v_661))) in
        {142}let v_666: bitstring = catch-fail(aeadunpack(v_665)) in
        {143}let v_667: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_663))) in
        {144}let v_668: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_664))) && success?(1-proj-3-tuple(v_663))) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-2-tuple(v_667))))) then cipherstatepack(1-proj-2-tuple(v_667),increment_nonce(2-proj-2-tuple(v_664))) else fail-any) else fail-any)) in
        {145}let v_669: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_661)) && (success?(3-proj-3-tuple(v_663)) && success?(1-proj-3-tuple(v_663)))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then (if not-caught-fail(v_665) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then (if not-caught-fail(v_668) then (v_668,3-proj-3-tuple(v_666),1-proj-3-tuple(v_666)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {146}let v_670: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_669),2-proj-3-tuple(v_663),3-proj-3-tuple(v_663)))) in
        {147}let v_671: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_661)) && success?(symmetricstatepack(1-proj-3-tuple(v_669),2-proj-3-tuple(v_663),3-proj-3-tuple(v_663)))) then (if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then symmetricstatepack(1-proj-3-tuple(v_670),2-proj-3-tuple(v_670),hash(3-proj-3-tuple(v_670),3-proj-3-tuple(v_661))) else fail-any) else fail-any)) in
        {148}let v_672: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_661)) && success?(1-proj-7-tuple(v_660))) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-3-tuple(v_663))))) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-3-tuple(v_669))))) then (if not-caught-fail(v_671) then (v_671,2-proj-3-tuple(v_669),3-proj-3-tuple(v_669)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {149}let v_673: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_672),2-proj-7-tuple(v_660),3-proj-7-tuple(v_660),4-proj-7-tuple(v_660),5-proj-7-tuple(v_660),6-proj-7-tuple(v_660),7-proj-7-tuple(v_660))) in
        {150}let (hs_674: handshakestate,plaintext_d: bitstring,valid_675: bool) = (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-7-tuple(v_660))))) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-3-tuple(v_661))))) then (if not-caught-fail(v_662) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-3-tuple(v_672))))) then (if (v_662 && 3-proj-3-tuple(v_672)) then (if not-caught-fail(v_673) then (v_673,2-proj-3-tuple(v_672),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {151}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {152}event RecvEnd(valid_675)
    ) | (
        {154}event LeakS(phase0,alice);
        {155}out(pub, key_s(alice))
    ) | (
        {156}phase 1;
        {157}event LeakS(phase1,alice);
        {158}out(pub, key_s(alice))
    )
) | (
    {159}let s_676: keypair = keypairpack(empty,empty) in
    {160}out(pub, getpublickey(s_676));
    (
        {161}let e_677: keypair = keypairpack(empty,empty) in
        {162}let rs_678: key = empty in
        {163}let re_679: key = empty in
        {164}let v_680: bitstring = catch-fail(hash(somename,empty)) in
        {165}let v_681: key = catch-fail(v_680) in
        {166}let v_682: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {167}let v_683: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_680) then (if not-caught-fail(v_681) then (if not-caught-fail(v_682) then symmetricstatepack(v_682,v_681,v_680) else fail-any) else fail-any) else fail-any))) in
        {168}let v_684: symmetricstate = catch-fail((if success?((if not-caught-fail(v_680) then (if not-caught-fail(v_681) then (if not-caught-fail(v_682) then symmetricstatepack(v_682,v_681,v_680) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-3-tuple(v_683))))) then symmetricstatepack(1-proj-3-tuple(v_683),2-proj-3-tuple(v_683),hash(3-proj-3-tuple(v_683),empty)) else fail-any) else fail-any)) in
        {169}let hs_685: handshakestate = (if not-caught-fail(v_684) then handshakestatepack(v_684,s_676,e_677,rs_678,re_679,empty,true) else fail-any) in
        {170}insert statestore(alice,charlie,sid,statepack_a(hs_685))
    ) | (
        {204}get statestore(=alice,=charlie,=sid,statepack_a(hs_686: handshakestate)) in
        {171}let v_687: bitstring = catch-fail(handshakestateunpack(hs_686)) in
        {172}let v_688: bitstring = catch-fail((empty,empty,empty)) in
        {173}let v_689: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {174}let v_690: keypair = catch-fail((if not-caught-fail(v_689) then keypairpack(v_689,key_e(alice,charlie,sid)) else fail-any)) in
        {175}let v_691: bitstring = catch-fail(getpublickey(v_690)) in
        {176}let v_692: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_687))) in
        {177}let v_693: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_687)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-3-tuple(v_692))))) then symmetricstatepack(1-proj-3-tuple(v_692),2-proj-3-tuple(v_692),hash(3-proj-3-tuple(v_692),v_691)) else fail-any) else fail-any)) in
        {178}let v_694: key = catch-fail(dhexp(key_s(alice),g)) in
        {179}let v_695: keypair = catch-fail((if not-caught-fail(v_694) then keypairpack(v_694,key_s(alice)) else fail-any)) in
        {180}let v_696: bitstring = catch-fail(symmetricstateunpack(v_693)) in
        {181}let v_697: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_696))) in
        {182}let v_698: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_697),2-proj-2-tuple(v_697),3-proj-3-tuple(v_696),getpublickey(v_695))) in
        {183}let v_699: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_696))) in
        {184}let v_700: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_697))) && success?(1-proj-3-tuple(v_696))) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-2-tuple(v_699))))) then cipherstatepack(1-proj-2-tuple(v_699),increment_nonce(2-proj-2-tuple(v_697))) else fail-any) else fail-any)) in
        {185}let v_701: bitstring = catch-fail((if (success?(getpublickey(v_695)) && (success?(3-proj-3-tuple(v_696)) && success?(1-proj-3-tuple(v_696)))) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-2-tuple(v_697))))) then (if not-caught-fail(v_698) then (if not-caught-fail(v_700) then (v_700,v_698) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {186}let v_702: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_701),2-proj-3-tuple(v_696),3-proj-3-tuple(v_696)))) in
        {187}let v_703: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_701)) && success?(symmetricstatepack(1-proj-2-tuple(v_701),2-proj-3-tuple(v_696),3-proj-3-tuple(v_696)))) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-3-tuple(v_702))))) then symmetricstatepack(1-proj-3-tuple(v_702),2-proj-3-tuple(v_702),hash(3-proj-3-tuple(v_702),2-proj-2-tuple(v_701))) else fail-any) else fail-any)) in
        {188}let v_704: bitstring = catch-fail((if success?(getpublickey(v_695)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-3-tuple(v_696))))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-2-tuple(v_701))))) then (if not-caught-fail(v_703) then (v_703,2-proj-2-tuple(v_701)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {189}let v_705: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_704))) in
        {190}let v_706: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {191}let v_707: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_706),2-proj-2-tuple(v_706),3-proj-3-tuple(v_705),msg_a(alice,charlie))) in
        {192}let v_708: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {193}let v_709: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_706))) && success?(1-proj-3-tuple(v_705))) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-2-tuple(v_708))))) then cipherstatepack(1-proj-2-tuple(v_708),increment_nonce(2-proj-2-tuple(v_706))) else fail-any) else fail-any)) in
        {194}let v_710: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_705)) && success?(1-proj-3-tuple(v_705))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-2-tuple(v_706))))) then (if not-caught-fail(v_707) then (if not-caught-fail(v_709) then (v_709,v_707) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {195}let v_711: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_710),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) in
        {196}let v_712: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_710)) && success?(symmetricstatepack(1-proj-2-tuple(v_710),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-3-tuple(v_711))))) then symmetricstatepack(1-proj-3-tuple(v_711),2-proj-3-tuple(v_711),hash(3-proj-3-tuple(v_711),2-proj-2-tuple(v_710))) else fail-any) else fail-any)) in
        {197}let v_713: bitstring = catch-fail((if success?(1-proj-2-tuple(v_704)) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then (if not-caught-fail(v_712) then (v_712,2-proj-2-tuple(v_710)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {198}let v_714: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_713),v_695,v_690,4-proj-7-tuple(v_687),5-proj-7-tuple(v_687),6-proj-7-tuple(v_687),7-proj-7-tuple(v_687))) in
        {199}let v_715: bitstring = catch-fail(concat3(v_691,2-proj-2-tuple(v_704),2-proj-2-tuple(v_713))) in
        {200}let (hs_716: handshakestate,message_a_717: bitstring) = (if (not-caught-fail(v_687) && success?(is-true(success?(1-proj-7-tuple(v_687))))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-3-tuple(v_688))))) then (if not-caught-fail(v_690) then (if not-caught-fail(v_691) then (if not-caught-fail(v_693) then (if not-caught-fail(v_695) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-2-tuple(v_704))))) then (if (not-caught-fail(v_713) && success?(is-true(success?(1-proj-2-tuple(v_713))))) then (if not-caught-fail(v_714) then (if not-caught-fail(v_715) then (v_714,v_715) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {201}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie));
        {202}insert statestore(alice,charlie,sid,statepack_b(hs_716));
        {203}out(pub, message_a_717)
    ) | (
        {267}get statestore(=alice,=charlie,=sid,statepack_b(hs_718: handshakestate)) in
        {205}in(pub, message_b_719: bitstring);
        {206}let v_720: bitstring = catch-fail(handshakestateunpack(hs_718)) in
        {207}let v_721: bitstring = catch-fail(deconcat3(message_b_719)) in
        {208}let v_722: bool = catch-fail(true) in
        {209}let v_723: key = catch-fail(1-proj-3-tuple(v_721)) in
        {210}let v_724: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_720))) in
        {211}let v_725: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_720)) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-3-tuple(v_724))))) then symmetricstatepack(1-proj-3-tuple(v_724),2-proj-3-tuple(v_724),hash(3-proj-3-tuple(v_724),v_723)) else fail-any) else fail-any)) in
        {212}let v_726: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_720))) in
        {213}let v_727: bitstring = catch-fail(symmetricstateunpack(v_725)) in
        {214}let v_728: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_727),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then dhexp(2-proj-2-tuple(v_726),v_723) else fail-any) else fail-any))) in
        {215}let v_729: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_727),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then dhexp(2-proj-2-tuple(v_726),v_723) else fail-any) else fail-any))) in
        {216}let v_730: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_727),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then dhexp(2-proj-2-tuple(v_726),v_723) else fail-any) else fail-any))) in
        {217}let v_731: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then dhexp(2-proj-2-tuple(v_726),v_723) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_727))) then (if not-caught-fail(v_728) then (if not-caught-fail(v_729) then (if not-caught-fail(v_730) then (v_728,v_729,v_730) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {218}let v_732: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then dhexp(2-proj-2-tuple(v_726),v_723) else fail-any) else fail-any)) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-3-tuple(v_727))))) then (if (not-caught-fail(v_731) && success?(is-true(success?(1-proj-3-tuple(v_731))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_731)) then cipherstatepack(2-proj-3-tuple(v_731),minnonce) else fail-any),1-proj-3-tuple(v_731),3-proj-3-tuple(v_727)) else fail-any) else fail-any) else fail-any)) in
        {219}let v_733: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_720))) in
        {220}let v_734: bitstring = catch-fail(symmetricstateunpack(v_732)) in
        {221}let v_735: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_734),(if success?(2-proj-7-tuple(v_720)) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then dhexp(2-proj-2-tuple(v_733),v_723) else fail-any) else fail-any))) in
        {222}let v_736: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_734),(if success?(2-proj-7-tuple(v_720)) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then dhexp(2-proj-2-tuple(v_733),v_723) else fail-any) else fail-any))) in
        {223}let v_737: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_734),(if success?(2-proj-7-tuple(v_720)) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then dhexp(2-proj-2-tuple(v_733),v_723) else fail-any) else fail-any))) in
        {224}let v_738: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_720)) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then dhexp(2-proj-2-tuple(v_733),v_723) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_734))) then (if not-caught-fail(v_735) then (if not-caught-fail(v_736) then (if not-caught-fail(v_737) then (v_735,v_736,v_737) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {225}let v_739: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_720)) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then dhexp(2-proj-2-tuple(v_733),v_723) else fail-any) else fail-any)) then (if (not-caught-fail(v_734) && success?(is-true(success?(1-proj-3-tuple(v_734))))) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-3-tuple(v_738))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_738)) then cipherstatepack(2-proj-3-tuple(v_738),minnonce) else fail-any),1-proj-3-tuple(v_738),3-proj-3-tuple(v_734)) else fail-any) else fail-any) else fail-any)) in
        {226}let v_740: bitstring = catch-fail(symmetricstateunpack(v_739)) in
        {227}let v_741: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_740))) in
        {228}let v_742: aead = catch-fail(decrypt(1-proj-2-tuple(v_741),2-proj-2-tuple(v_741),3-proj-3-tuple(v_740),2-proj-3-tuple(v_721))) in
        {229}let v_743: bitstring = catch-fail(aeadunpack(v_742)) in
        {230}let v_744: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_740))) in
        {231}let v_745: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_741))) && success?(1-proj-3-tuple(v_740))) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-2-tuple(v_744))))) then cipherstatepack(1-proj-2-tuple(v_744),increment_nonce(2-proj-2-tuple(v_741))) else fail-any) else fail-any)) in
        {232}let v_746: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_721)) && (success?(3-proj-3-tuple(v_740)) && success?(1-proj-3-tuple(v_740)))) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then (if not-caught-fail(v_742) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then (if not-caught-fail(v_745) then (v_745,3-proj-3-tuple(v_743),1-proj-3-tuple(v_743)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {233}let v_747: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_746),2-proj-3-tuple(v_740),3-proj-3-tuple(v_740)))) in
        {234}let v_748: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_721)) && success?(symmetricstatepack(1-proj-3-tuple(v_746),2-proj-3-tuple(v_740),3-proj-3-tuple(v_740)))) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-3-tuple(v_747))))) then symmetricstatepack(1-proj-3-tuple(v_747),2-proj-3-tuple(v_747),hash(3-proj-3-tuple(v_747),2-proj-3-tuple(v_721))) else fail-any) else fail-any)) in
        {235}let v_749: bitstring = catch-fail((if success?(2-proj-3-tuple(v_721)) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-3-tuple(v_740))))) then (if (not-caught-fail(v_746) && success?(is-true(success?(1-proj-3-tuple(v_746))))) then (if not-caught-fail(v_748) then (v_748,2-proj-3-tuple(v_746),3-proj-3-tuple(v_746)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {236}let v_750: key = catch-fail(2-proj-3-tuple(v_749)) in
        {237}let v_751: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_720))) in
        {238}let v_752: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_749))) in
        {239}let v_753: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_752),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then dhexp(2-proj-2-tuple(v_751),v_750) else fail-any) else fail-any))) in
        {240}let v_754: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_752),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then dhexp(2-proj-2-tuple(v_751),v_750) else fail-any) else fail-any))) in
        {241}let v_755: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_752),(if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then dhexp(2-proj-2-tuple(v_751),v_750) else fail-any) else fail-any))) in
        {242}let v_756: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then dhexp(2-proj-2-tuple(v_751),v_750) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_752))) then (if not-caught-fail(v_753) then (if not-caught-fail(v_754) then (if not-caught-fail(v_755) then (v_753,v_754,v_755) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {243}let v_757: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_720)) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then dhexp(2-proj-2-tuple(v_751),v_750) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_749))) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-3-tuple(v_752))))) then (if (not-caught-fail(v_756) && success?(is-true(success?(1-proj-3-tuple(v_756))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_756)) then cipherstatepack(2-proj-3-tuple(v_756),minnonce) else fail-any),1-proj-3-tuple(v_756),3-proj-3-tuple(v_752)) else fail-any) else fail-any) else fail-any)) in
        {244}let v_758: bitstring = catch-fail(symmetricstateunpack(v_757)) in
        {245}let v_759: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_758))) in
        {246}let v_760: aead = catch-fail(decrypt(1-proj-2-tuple(v_759),2-proj-2-tuple(v_759),3-proj-3-tuple(v_758),3-proj-3-tuple(v_721))) in
        {247}let v_761: bitstring = catch-fail(aeadunpack(v_760)) in
        {248}let v_762: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_758))) in
        {249}let v_763: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_759))) && success?(1-proj-3-tuple(v_758))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-2-tuple(v_762))))) then cipherstatepack(1-proj-2-tuple(v_762),increment_nonce(2-proj-2-tuple(v_759))) else fail-any) else fail-any)) in
        {250}let v_764: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_721)) && (success?(3-proj-3-tuple(v_758)) && success?(1-proj-3-tuple(v_758)))) then (if (not-caught-fail(v_759) && success?(is-true(success?(1-proj-2-tuple(v_759))))) then (if not-caught-fail(v_760) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-3-tuple(v_761))))) then (if not-caught-fail(v_763) then (v_763,3-proj-3-tuple(v_761),1-proj-3-tuple(v_761)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {251}let v_765: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_764),2-proj-3-tuple(v_758),3-proj-3-tuple(v_758)))) in
        {252}let v_766: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_721)) && success?(symmetricstatepack(1-proj-3-tuple(v_764),2-proj-3-tuple(v_758),3-proj-3-tuple(v_758)))) then (if (not-caught-fail(v_765) && success?(is-true(success?(1-proj-3-tuple(v_765))))) then symmetricstatepack(1-proj-3-tuple(v_765),2-proj-3-tuple(v_765),hash(3-proj-3-tuple(v_765),3-proj-3-tuple(v_721))) else fail-any) else fail-any)) in
        {253}let v_767: bitstring = catch-fail((if success?(3-proj-3-tuple(v_721)) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-3-tuple(v_758))))) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-3-tuple(v_764))))) then (if not-caught-fail(v_766) then (v_766,2-proj-3-tuple(v_764),3-proj-3-tuple(v_764)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {254}let v_768: key = catch-fail(dhexp(key_s(charlie),g)) in
        {255}let v_769: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_767),2-proj-7-tuple(v_720),3-proj-7-tuple(v_720),v_750,v_723,6-proj-7-tuple(v_720),7-proj-7-tuple(v_720))) in
        {256}let v_770: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_767))) in
        {257}let v_771: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_770),zero)) in
        {258}let v_772: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_770),zero)) in
        {259}let v_773: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_770),zero)) in
        {260}let v_774: bitstring = catch-fail((if success?(2-proj-3-tuple(v_770)) then (if not-caught-fail(v_771) then (if not-caught-fail(v_772) then (if not-caught-fail(v_773) then (v_771,v_772,v_773) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {261}let v_775: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_774)) then cipherstatepack(1-proj-3-tuple(v_774),minnonce) else fail-any)) in
        {262}let v_776: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_774)) then cipherstatepack(2-proj-3-tuple(v_774),minnonce) else fail-any)) in
        {263}let v_777: bitstring = catch-fail((if success?(1-proj-3-tuple(v_767)) then (if (not-caught-fail(v_770) && success?(is-true(success?(1-proj-3-tuple(v_770))))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then (if not-caught-fail(v_775) then (if not-caught-fail(v_776) then (1-proj-3-tuple(v_767),v_775,v_776) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {264}let (hs_778: handshakestate,plaintext_b_779: bitstring,valid_780: bool,cs1_781: cipherstate,cs2_782: cipherstate) = (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-7-tuple(v_720))))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-3-tuple(v_721))))) then (if not-caught-fail(v_722) then (if not-caught-fail(v_723) then (if not-caught-fail(v_725) then (if not-caught-fail(v_732) then (if not-caught-fail(v_739) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-3-tuple(v_749))))) then (if not-caught-fail(v_750) then (if not-caught-fail(v_757) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-3-tuple(v_767))))) then (if ((3-proj-3-tuple(v_749) && 3-proj-3-tuple(v_767)) && (v_750 = getpublickey((if not-caught-fail(v_768) then keypairpack(v_768,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_769) then (if (not-caught-fail(v_777) && success?(is-true(success?(1-proj-3-tuple(v_777))))) then (v_769,2-proj-3-tuple(v_767),true,2-proj-3-tuple(v_777),3-proj-3-tuple(v_777)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {265}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_779);
        {266}insert statestore(alice,charlie,sid,statepack_c(hs_778,cs1_781,cs2_782))
    ) | (
        {268}!
        {287}get statestore(=alice,=charlie,=sid,statepack_c(hs_783: handshakestate,cs1_784: cipherstate,cs2_785: cipherstate)) in
        {269}let hs_786: handshakestate = handshakestatesetcs(hs_783,cs1_784) in
        {270}let v_787: bitstring = catch-fail(handshakestateunpack(hs_786)) in
        {271}let v_788: bitstring = catch-fail((empty,empty,empty)) in
        {272}let v_789: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_787))) in
        {273}let v_790: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_789))) in
        {274}let v_791: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_790),2-proj-2-tuple(v_790),3-proj-3-tuple(v_789),msg_c(alice,charlie))) in
        {275}let v_792: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_789))) in
        {276}let v_793: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_790))) && success?(1-proj-3-tuple(v_789))) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-2-tuple(v_792))))) then cipherstatepack(1-proj-2-tuple(v_792),increment_nonce(2-proj-2-tuple(v_790))) else fail-any) else fail-any)) in
        {277}let v_794: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_789)) && success?(1-proj-3-tuple(v_789))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-2-tuple(v_790))))) then (if not-caught-fail(v_791) then (if not-caught-fail(v_793) then (v_793,v_791) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {278}let v_795: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_794),2-proj-3-tuple(v_789),3-proj-3-tuple(v_789)))) in
        {279}let v_796: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_794)) && success?(symmetricstatepack(1-proj-2-tuple(v_794),2-proj-3-tuple(v_789),3-proj-3-tuple(v_789)))) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-3-tuple(v_795))))) then symmetricstatepack(1-proj-3-tuple(v_795),2-proj-3-tuple(v_795),hash(3-proj-3-tuple(v_795),2-proj-2-tuple(v_794))) else fail-any) else fail-any)) in
        {280}let v_797: bitstring = catch-fail((if success?(1-proj-7-tuple(v_787)) then (if (not-caught-fail(v_789) && success?(is-true(success?(1-proj-3-tuple(v_789))))) then (if (not-caught-fail(v_794) && success?(is-true(success?(1-proj-2-tuple(v_794))))) then (if not-caught-fail(v_796) then (v_796,2-proj-2-tuple(v_794)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {281}let v_798: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_797),2-proj-7-tuple(v_787),3-proj-7-tuple(v_787),4-proj-7-tuple(v_787),5-proj-7-tuple(v_787),6-proj-7-tuple(v_787),7-proj-7-tuple(v_787))) in
        {282}let v_799: bitstring = catch-fail(concat3(1-proj-3-tuple(v_788),2-proj-3-tuple(v_788),2-proj-2-tuple(v_797))) in
        {283}let (hs_800: handshakestate,message_c_801: bitstring) = (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-7-tuple(v_787))))) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-3-tuple(v_788))))) then (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-2-tuple(v_797))))) then (if not-caught-fail(v_798) then (if not-caught-fail(v_799) then (v_798,v_799) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {284}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie));
        {285}insert statestore(alice,charlie,sid,statepack_d(hs_800,handshakestategetcs(hs_800),cs2_785));
        {286}out(pub, message_c_801)
    ) | (
        {288}!
        {308}get statestore(=alice,=charlie,=sid,statepack_d(hs_802: handshakestate,cs1_803: cipherstate,cs2_804: cipherstate)) in
        {289}let hs_805: handshakestate = handshakestatesetcs(hs_802,cs2_804) in
        {290}in(pub, message_d_806: bitstring);
        {291}let v_807: bitstring = catch-fail(handshakestateunpack(hs_805)) in
        {292}let v_808: bitstring = catch-fail(deconcat3(message_d_806)) in
        {293}let v_809: bool = catch-fail(true) in
        {294}let v_810: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_807))) in
        {295}let v_811: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {296}let v_812: aead = catch-fail(decrypt(1-proj-2-tuple(v_811),2-proj-2-tuple(v_811),3-proj-3-tuple(v_810),3-proj-3-tuple(v_808))) in
        {297}let v_813: bitstring = catch-fail(aeadunpack(v_812)) in
        {298}let v_814: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {299}let v_815: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_811))) && success?(1-proj-3-tuple(v_810))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then cipherstatepack(1-proj-2-tuple(v_814),increment_nonce(2-proj-2-tuple(v_811))) else fail-any) else fail-any)) in
        {300}let v_816: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_808)) && (success?(3-proj-3-tuple(v_810)) && success?(1-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-2-tuple(v_811))))) then (if not-caught-fail(v_812) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-3-tuple(v_813))))) then (if not-caught-fail(v_815) then (v_815,3-proj-3-tuple(v_813),1-proj-3-tuple(v_813)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {301}let v_817: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) in
        {302}let v_818: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_808)) && success?(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then symmetricstatepack(1-proj-3-tuple(v_817),2-proj-3-tuple(v_817),hash(3-proj-3-tuple(v_817),3-proj-3-tuple(v_808))) else fail-any) else fail-any)) in
        {303}let v_819: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_808)) && success?(1-proj-7-tuple(v_807))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-3-tuple(v_816))))) then (if not-caught-fail(v_818) then (v_818,2-proj-3-tuple(v_816),3-proj-3-tuple(v_816)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {304}let v_820: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_819),2-proj-7-tuple(v_807),3-proj-7-tuple(v_807),4-proj-7-tuple(v_807),5-proj-7-tuple(v_807),6-proj-7-tuple(v_807),7-proj-7-tuple(v_807))) in
        {305}let (hs_821: handshakestate,plaintext_d_822: bitstring,valid_823: bool) = (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-7-tuple(v_807))))) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then (if not-caught-fail(v_809) then (if (not-caught-fail(v_819) && success?(is-true(success?(1-proj-3-tuple(v_819))))) then (if (v_809 && 3-proj-3-tuple(v_819)) then (if not-caught-fail(v_820) then (v_820,2-proj-3-tuple(v_819),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {306}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_822);
        {307}event RecvEnd(valid_823)
    ) | (
        {309}event LeakS(phase0,alice);
        {310}out(pub, key_s(alice))
    ) | (
        {311}phase 1;
        {312}event LeakS(phase1,alice);
        {313}out(pub, key_s(alice))
    )
) | (
    {314}let s_824: keypair = keypairpack(empty,empty) in
    {315}out(pub, getpublickey(s_824));
    (
        {316}let e_825: keypair = keypairpack(empty,empty) in
        {317}let rs_826: key = empty in
        {318}let re_827: key = empty in
        {319}let v_828: bitstring = catch-fail(hash(somename,empty)) in
        {320}let v_829: key = catch-fail(v_828) in
        {321}let v_830: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {322}let v_831: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_828) then (if not-caught-fail(v_829) then (if not-caught-fail(v_830) then symmetricstatepack(v_830,v_829,v_828) else fail-any) else fail-any) else fail-any))) in
        {323}let v_832: symmetricstate = catch-fail((if success?((if not-caught-fail(v_828) then (if not-caught-fail(v_829) then (if not-caught-fail(v_830) then symmetricstatepack(v_830,v_829,v_828) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-3-tuple(v_831))))) then symmetricstatepack(1-proj-3-tuple(v_831),2-proj-3-tuple(v_831),hash(3-proj-3-tuple(v_831),empty)) else fail-any) else fail-any)) in
        {324}let hs_833: handshakestate = (if not-caught-fail(v_832) then handshakestatepack(v_832,s_824,e_825,rs_826,re_827,empty,false) else fail-any) in
        {325}insert statestore(bob,alice,sid,statepack_a(hs_833))
    ) | (
        {359}get statestore(=bob,=alice,=sid,statepack_a(hs_834: handshakestate)) in
        {326}in(pub, message_a_835: bitstring);
        {327}let v_836: bitstring = catch-fail(handshakestateunpack(hs_834)) in
        {328}let v_837: bitstring = catch-fail(deconcat3(message_a_835)) in
        {329}let v_838: bool = catch-fail(true) in
        {330}let v_839: key = catch-fail(1-proj-3-tuple(v_837)) in
        {331}let v_840: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_836))) in
        {332}let v_841: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_836)) then (if (not-caught-fail(v_840) && success?(is-true(success?(1-proj-3-tuple(v_840))))) then symmetricstatepack(1-proj-3-tuple(v_840),2-proj-3-tuple(v_840),hash(3-proj-3-tuple(v_840),v_839)) else fail-any) else fail-any)) in
        {333}let v_842: bitstring = catch-fail(symmetricstateunpack(v_841)) in
        {334}let v_843: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_842))) in
        {335}let v_844: aead = catch-fail(decrypt(1-proj-2-tuple(v_843),2-proj-2-tuple(v_843),3-proj-3-tuple(v_842),2-proj-3-tuple(v_837))) in
        {336}let v_845: bitstring = catch-fail(aeadunpack(v_844)) in
        {337}let v_846: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_842))) in
        {338}let v_847: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_843))) && success?(1-proj-3-tuple(v_842))) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-2-tuple(v_846))))) then cipherstatepack(1-proj-2-tuple(v_846),increment_nonce(2-proj-2-tuple(v_843))) else fail-any) else fail-any)) in
        {339}let v_848: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_837)) && (success?(3-proj-3-tuple(v_842)) && success?(1-proj-3-tuple(v_842)))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-2-tuple(v_843))))) then (if not-caught-fail(v_844) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-3-tuple(v_845))))) then (if not-caught-fail(v_847) then (v_847,3-proj-3-tuple(v_845),1-proj-3-tuple(v_845)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {340}let v_849: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_848),2-proj-3-tuple(v_842),3-proj-3-tuple(v_842)))) in
        {341}let v_850: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_837)) && success?(symmetricstatepack(1-proj-3-tuple(v_848),2-proj-3-tuple(v_842),3-proj-3-tuple(v_842)))) then (if (not-caught-fail(v_849) && success?(is-true(success?(1-proj-3-tuple(v_849))))) then symmetricstatepack(1-proj-3-tuple(v_849),2-proj-3-tuple(v_849),hash(3-proj-3-tuple(v_849),2-proj-3-tuple(v_837))) else fail-any) else fail-any)) in
        {342}let v_851: bitstring = catch-fail((if success?(2-proj-3-tuple(v_837)) then (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-3-tuple(v_842))))) then (if (not-caught-fail(v_848) && success?(is-true(success?(1-proj-3-tuple(v_848))))) then (if not-caught-fail(v_850) then (v_850,2-proj-3-tuple(v_848),3-proj-3-tuple(v_848)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {343}let v_852: key = catch-fail(2-proj-3-tuple(v_851)) in
        {344}let v_853: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_851))) in
        {345}let v_854: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_853))) in
        {346}let v_855: aead = catch-fail(decrypt(1-proj-2-tuple(v_854),2-proj-2-tuple(v_854),3-proj-3-tuple(v_853),3-proj-3-tuple(v_837))) in
        {347}let v_856: bitstring = catch-fail(aeadunpack(v_855)) in
        {348}let v_857: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_853))) in
        {349}let v_858: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_854))) && success?(1-proj-3-tuple(v_853))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-2-tuple(v_857))))) then cipherstatepack(1-proj-2-tuple(v_857),increment_nonce(2-proj-2-tuple(v_854))) else fail-any) else fail-any)) in
        {350}let v_859: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_837)) && (success?(3-proj-3-tuple(v_853)) && success?(1-proj-3-tuple(v_853)))) then (if (not-caught-fail(v_854) && success?(is-true(success?(1-proj-2-tuple(v_854))))) then (if not-caught-fail(v_855) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-3-tuple(v_856))))) then (if not-caught-fail(v_858) then (v_858,3-proj-3-tuple(v_856),1-proj-3-tuple(v_856)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {351}let v_860: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_859),2-proj-3-tuple(v_853),3-proj-3-tuple(v_853)))) in
        {352}let v_861: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_837)) && success?(symmetricstatepack(1-proj-3-tuple(v_859),2-proj-3-tuple(v_853),3-proj-3-tuple(v_853)))) then (if (not-caught-fail(v_860) && success?(is-true(success?(1-proj-3-tuple(v_860))))) then symmetricstatepack(1-proj-3-tuple(v_860),2-proj-3-tuple(v_860),hash(3-proj-3-tuple(v_860),3-proj-3-tuple(v_837))) else fail-any) else fail-any)) in
        {353}let v_862: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_837)) && success?(1-proj-3-tuple(v_851))) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-3-tuple(v_853))))) then (if (not-caught-fail(v_859) && success?(is-true(success?(1-proj-3-tuple(v_859))))) then (if not-caught-fail(v_861) then (v_861,2-proj-3-tuple(v_859),3-proj-3-tuple(v_859)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {354}let v_863: key = catch-fail(dhexp(key_s(alice),g)) in
        {355}let v_864: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_862),2-proj-7-tuple(v_836),3-proj-7-tuple(v_836),v_852,v_839,6-proj-7-tuple(v_836),7-proj-7-tuple(v_836))) in
        {356}let (hs_865: handshakestate,plaintext_a: bitstring,valid_866: bool) = (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-7-tuple(v_836))))) then (if (not-caught-fail(v_837) && success?(is-true(success?(1-proj-3-tuple(v_837))))) then (if not-caught-fail(v_838) then (if not-caught-fail(v_839) then (if not-caught-fail(v_841) then (if (not-caught-fail(v_851) && success?(is-true(success?(1-proj-3-tuple(v_851))))) then (if not-caught-fail(v_852) then (if (not-caught-fail(v_862) && success?(is-true(success?(1-proj-3-tuple(v_862))))) then (if ((3-proj-3-tuple(v_851) && 3-proj-3-tuple(v_862)) && (v_852 = getpublickey((if not-caught-fail(v_863) then keypairpack(v_863,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_864) then (v_864,2-proj-3-tuple(v_862),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {357}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {358}insert statestore(bob,alice,sid,statepack_b(hs_865))
    ) | (
        {422}get statestore(=bob,=alice,=sid,statepack_b(hs_867: handshakestate)) in
        {360}let v_868: bitstring = catch-fail(handshakestateunpack(hs_867)) in
        {361}let v_869: bitstring = catch-fail((empty,empty,empty)) in
        {362}let v_870: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {363}let v_871: keypair = catch-fail((if not-caught-fail(v_870) then keypairpack(v_870,key_e(bob,alice,sid)) else fail-any)) in
        {364}let v_872: bitstring = catch-fail(getpublickey(v_871)) in
        {365}let v_873: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_868))) in
        {366}let v_874: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_868)) then (if (not-caught-fail(v_873) && success?(is-true(success?(1-proj-3-tuple(v_873))))) then symmetricstatepack(1-proj-3-tuple(v_873),2-proj-3-tuple(v_873),hash(3-proj-3-tuple(v_873),v_872)) else fail-any) else fail-any)) in
        {367}let v_875: bitstring = catch-fail(keypairunpack(v_871)) in
        {368}let v_876: bitstring = catch-fail(symmetricstateunpack(v_874)) in
        {369}let v_877: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_876),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-2-tuple(v_875))))) then dhexp(2-proj-2-tuple(v_875),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {370}let v_878: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_876),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-2-tuple(v_875))))) then dhexp(2-proj-2-tuple(v_875),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {371}let v_879: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_876),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-2-tuple(v_875))))) then dhexp(2-proj-2-tuple(v_875),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {372}let v_880: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-2-tuple(v_875))))) then dhexp(2-proj-2-tuple(v_875),5-proj-7-tuple(v_868)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_876))) then (if not-caught-fail(v_877) then (if not-caught-fail(v_878) then (if not-caught-fail(v_879) then (v_877,v_878,v_879) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {373}let v_881: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-2-tuple(v_875))))) then dhexp(2-proj-2-tuple(v_875),5-proj-7-tuple(v_868)) else fail-any) else fail-any)) then (if (not-caught-fail(v_876) && success?(is-true(success?(1-proj-3-tuple(v_876))))) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-3-tuple(v_880))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_880)) then cipherstatepack(2-proj-3-tuple(v_880),minnonce) else fail-any),1-proj-3-tuple(v_880),3-proj-3-tuple(v_876)) else fail-any) else fail-any) else fail-any)) in
        {374}let v_882: bitstring = catch-fail(keypairunpack(v_871)) in
        {375}let v_883: bitstring = catch-fail(symmetricstateunpack(v_881)) in
        {376}let v_884: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_883),(if success?(4-proj-7-tuple(v_868)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),4-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {377}let v_885: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_883),(if success?(4-proj-7-tuple(v_868)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),4-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {378}let v_886: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_883),(if success?(4-proj-7-tuple(v_868)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),4-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {379}let v_887: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_868)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),4-proj-7-tuple(v_868)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_883))) then (if not-caught-fail(v_884) then (if not-caught-fail(v_885) then (if not-caught-fail(v_886) then (v_884,v_885,v_886) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {380}let v_888: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_868)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),4-proj-7-tuple(v_868)) else fail-any) else fail-any)) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-3-tuple(v_887))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_887)) then cipherstatepack(2-proj-3-tuple(v_887),minnonce) else fail-any),1-proj-3-tuple(v_887),3-proj-3-tuple(v_883)) else fail-any) else fail-any) else fail-any)) in
        {381}let v_889: key = catch-fail(dhexp(key_s(bob),g)) in
        {382}let v_890: keypair = catch-fail((if not-caught-fail(v_889) then keypairpack(v_889,key_s(bob)) else fail-any)) in
        {383}let v_891: bitstring = catch-fail(symmetricstateunpack(v_888)) in
        {384}let v_892: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_891))) in
        {385}let v_893: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_892),2-proj-2-tuple(v_892),3-proj-3-tuple(v_891),getpublickey(v_890))) in
        {386}let v_894: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_891))) in
        {387}let v_895: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_892))) && success?(1-proj-3-tuple(v_891))) then (if (not-caught-fail(v_894) && success?(is-true(success?(1-proj-2-tuple(v_894))))) then cipherstatepack(1-proj-2-tuple(v_894),increment_nonce(2-proj-2-tuple(v_892))) else fail-any) else fail-any)) in
        {388}let v_896: bitstring = catch-fail((if (success?(getpublickey(v_890)) && (success?(3-proj-3-tuple(v_891)) && success?(1-proj-3-tuple(v_891)))) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then (if not-caught-fail(v_893) then (if not-caught-fail(v_895) then (v_895,v_893) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {389}let v_897: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_896),2-proj-3-tuple(v_891),3-proj-3-tuple(v_891)))) in
        {390}let v_898: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_896)) && success?(symmetricstatepack(1-proj-2-tuple(v_896),2-proj-3-tuple(v_891),3-proj-3-tuple(v_891)))) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-3-tuple(v_897))))) then symmetricstatepack(1-proj-3-tuple(v_897),2-proj-3-tuple(v_897),hash(3-proj-3-tuple(v_897),2-proj-2-tuple(v_896))) else fail-any) else fail-any)) in
        {391}let v_899: bitstring = catch-fail((if success?(getpublickey(v_890)) then (if (not-caught-fail(v_891) && success?(is-true(success?(1-proj-3-tuple(v_891))))) then (if (not-caught-fail(v_896) && success?(is-true(success?(1-proj-2-tuple(v_896))))) then (if not-caught-fail(v_898) then (v_898,2-proj-2-tuple(v_896)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {392}let v_900: bitstring = catch-fail(keypairunpack(v_890)) in
        {393}let v_901: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_899))) in
        {394}let v_902: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_901),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then dhexp(2-proj-2-tuple(v_900),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {395}let v_903: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_901),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then dhexp(2-proj-2-tuple(v_900),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {396}let v_904: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_901),(if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then dhexp(2-proj-2-tuple(v_900),5-proj-7-tuple(v_868)) else fail-any) else fail-any))) in
        {397}let v_905: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then dhexp(2-proj-2-tuple(v_900),5-proj-7-tuple(v_868)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_901))) then (if not-caught-fail(v_902) then (if not-caught-fail(v_903) then (if not-caught-fail(v_904) then (v_902,v_903,v_904) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {398}let v_906: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_868)) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then dhexp(2-proj-2-tuple(v_900),5-proj-7-tuple(v_868)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_899))) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-3-tuple(v_901))))) then (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-3-tuple(v_905))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_905)) then cipherstatepack(2-proj-3-tuple(v_905),minnonce) else fail-any),1-proj-3-tuple(v_905),3-proj-3-tuple(v_901)) else fail-any) else fail-any) else fail-any)) in
        {399}let v_907: bitstring = catch-fail(symmetricstateunpack(v_906)) in
        {400}let v_908: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_907))) in
        {401}let v_909: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_908),2-proj-2-tuple(v_908),3-proj-3-tuple(v_907),msg_b(bob,alice))) in
        {402}let v_910: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_907))) in
        {403}let v_911: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_908))) && success?(1-proj-3-tuple(v_907))) then (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-2-tuple(v_910))))) then cipherstatepack(1-proj-2-tuple(v_910),increment_nonce(2-proj-2-tuple(v_908))) else fail-any) else fail-any)) in
        {404}let v_912: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_907)) && success?(1-proj-3-tuple(v_907))) then (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-2-tuple(v_908))))) then (if not-caught-fail(v_909) then (if not-caught-fail(v_911) then (v_911,v_909) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {405}let v_913: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_912),2-proj-3-tuple(v_907),3-proj-3-tuple(v_907)))) in
        {406}let v_914: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_912)) && success?(symmetricstatepack(1-proj-2-tuple(v_912),2-proj-3-tuple(v_907),3-proj-3-tuple(v_907)))) then (if (not-caught-fail(v_913) && success?(is-true(success?(1-proj-3-tuple(v_913))))) then symmetricstatepack(1-proj-3-tuple(v_913),2-proj-3-tuple(v_913),hash(3-proj-3-tuple(v_913),2-proj-2-tuple(v_912))) else fail-any) else fail-any)) in
        {407}let v_915: bitstring = catch-fail((if (not-caught-fail(v_907) && success?(is-true(success?(1-proj-3-tuple(v_907))))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-2-tuple(v_912))))) then (if not-caught-fail(v_914) then (v_914,2-proj-2-tuple(v_912)) else fail-any) else fail-any) else fail-any)) in
        {408}let v_916: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_915),v_890,v_871,4-proj-7-tuple(v_868),5-proj-7-tuple(v_868),6-proj-7-tuple(v_868),7-proj-7-tuple(v_868))) in
        {409}let v_917: bitstring = catch-fail(concat3(v_872,2-proj-2-tuple(v_899),2-proj-2-tuple(v_915))) in
        {410}let v_918: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_915))) in
        {411}let v_919: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_918),zero)) in
        {412}let v_920: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_918),zero)) in
        {413}let v_921: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_918),zero)) in
        {414}let v_922: bitstring = catch-fail((if success?(2-proj-3-tuple(v_918)) then (if not-caught-fail(v_919) then (if not-caught-fail(v_920) then (if not-caught-fail(v_921) then (v_919,v_920,v_921) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {415}let v_923: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_922)) then cipherstatepack(1-proj-3-tuple(v_922),minnonce) else fail-any)) in
        {416}let v_924: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_922)) then cipherstatepack(2-proj-3-tuple(v_922),minnonce) else fail-any)) in
        {417}let v_925: bitstring = catch-fail((if success?(1-proj-2-tuple(v_915)) then (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-3-tuple(v_918))))) then (if (not-caught-fail(v_922) && success?(is-true(success?(1-proj-3-tuple(v_922))))) then (if not-caught-fail(v_923) then (if not-caught-fail(v_924) then (1-proj-2-tuple(v_915),v_923,v_924) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {418}let (hs_926: handshakestate,message_b_927: bitstring,cs1_928: cipherstate,cs2_929: cipherstate) = (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-7-tuple(v_868))))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-3-tuple(v_869))))) then (if not-caught-fail(v_871) then (if not-caught-fail(v_872) then (if not-caught-fail(v_874) then (if not-caught-fail(v_881) then (if not-caught-fail(v_888) then (if not-caught-fail(v_890) then (if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-2-tuple(v_899))))) then (if not-caught-fail(v_906) then (if (not-caught-fail(v_915) && success?(is-true(success?(1-proj-2-tuple(v_915))))) then (if not-caught-fail(v_916) then (if not-caught-fail(v_917) then (if (not-caught-fail(v_925) && success?(is-true(success?(1-proj-3-tuple(v_925))))) then (v_916,v_917,2-proj-3-tuple(v_925),3-proj-3-tuple(v_925)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {419}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice));
        {420}insert statestore(bob,alice,sid,statepack_c(hs_926,cs1_928,cs2_929));
        {421}out(pub, message_b_927)
    ) | (
        {423}!
        {443}get statestore(=bob,=alice,=sid,statepack_c(hs_930: handshakestate,cs1_931: cipherstate,cs2_932: cipherstate)) in
        {424}let hs_933: handshakestate = handshakestatesetcs(hs_930,cs1_931) in
        {425}in(pub, message_c_934: bitstring);
        {426}let v_935: bitstring = catch-fail(handshakestateunpack(hs_933)) in
        {427}let v_936: bitstring = catch-fail(deconcat3(message_c_934)) in
        {428}let v_937: bool = catch-fail(true) in
        {429}let v_938: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_935))) in
        {430}let v_939: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_938))) in
        {431}let v_940: aead = catch-fail(decrypt(1-proj-2-tuple(v_939),2-proj-2-tuple(v_939),3-proj-3-tuple(v_938),3-proj-3-tuple(v_936))) in
        {432}let v_941: bitstring = catch-fail(aeadunpack(v_940)) in
        {433}let v_942: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_938))) in
        {434}let v_943: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_939))) && success?(1-proj-3-tuple(v_938))) then (if (not-caught-fail(v_942) && success?(is-true(success?(1-proj-2-tuple(v_942))))) then cipherstatepack(1-proj-2-tuple(v_942),increment_nonce(2-proj-2-tuple(v_939))) else fail-any) else fail-any)) in
        {435}let v_944: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_936)) && (success?(3-proj-3-tuple(v_938)) && success?(1-proj-3-tuple(v_938)))) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then (if not-caught-fail(v_940) then (if (not-caught-fail(v_941) && success?(is-true(success?(1-proj-3-tuple(v_941))))) then (if not-caught-fail(v_943) then (v_943,3-proj-3-tuple(v_941),1-proj-3-tuple(v_941)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {436}let v_945: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_944),2-proj-3-tuple(v_938),3-proj-3-tuple(v_938)))) in
        {437}let v_946: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_936)) && success?(symmetricstatepack(1-proj-3-tuple(v_944),2-proj-3-tuple(v_938),3-proj-3-tuple(v_938)))) then (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-3-tuple(v_945))))) then symmetricstatepack(1-proj-3-tuple(v_945),2-proj-3-tuple(v_945),hash(3-proj-3-tuple(v_945),3-proj-3-tuple(v_936))) else fail-any) else fail-any)) in
        {438}let v_947: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_936)) && success?(1-proj-7-tuple(v_935))) then (if (not-caught-fail(v_938) && success?(is-true(success?(1-proj-3-tuple(v_938))))) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then (if not-caught-fail(v_946) then (v_946,2-proj-3-tuple(v_944),3-proj-3-tuple(v_944)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {439}let v_948: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_947),2-proj-7-tuple(v_935),3-proj-7-tuple(v_935),4-proj-7-tuple(v_935),5-proj-7-tuple(v_935),6-proj-7-tuple(v_935),7-proj-7-tuple(v_935))) in
        {440}let (hs_949: handshakestate,plaintext_c: bitstring,valid_950: bool) = (if (not-caught-fail(v_935) && success?(is-true(success?(1-proj-7-tuple(v_935))))) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then (if not-caught-fail(v_937) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then (if (v_937 && 3-proj-3-tuple(v_947)) then (if not-caught-fail(v_948) then (v_948,2-proj-3-tuple(v_947),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {441}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {442}insert statestore(bob,alice,sid,statepack_d(hs_949,handshakestategetcs(hs_949),cs2_932))
    ) | (
        {444}!
        {462}get statestore(=bob,=alice,=sid,statepack_d(hs_951: handshakestate,cs1_952: cipherstate,cs2_953: cipherstate)) in
        {445}let hs_954: handshakestate = handshakestatesetcs(hs_951,cs2_953) in
        {446}let v_955: bitstring = catch-fail(handshakestateunpack(hs_954)) in
        {447}let v_956: bitstring = catch-fail((empty,empty,empty)) in
        {448}let v_957: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_955))) in
        {449}let v_958: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_957))) in
        {450}let v_959: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_958),2-proj-2-tuple(v_958),3-proj-3-tuple(v_957),msg_d(bob,alice))) in
        {451}let v_960: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_957))) in
        {452}let v_961: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_958))) && success?(1-proj-3-tuple(v_957))) then (if (not-caught-fail(v_960) && success?(is-true(success?(1-proj-2-tuple(v_960))))) then cipherstatepack(1-proj-2-tuple(v_960),increment_nonce(2-proj-2-tuple(v_958))) else fail-any) else fail-any)) in
        {453}let v_962: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_957)) && success?(1-proj-3-tuple(v_957))) then (if (not-caught-fail(v_958) && success?(is-true(success?(1-proj-2-tuple(v_958))))) then (if not-caught-fail(v_959) then (if not-caught-fail(v_961) then (v_961,v_959) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {454}let v_963: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_962),2-proj-3-tuple(v_957),3-proj-3-tuple(v_957)))) in
        {455}let v_964: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_962)) && success?(symmetricstatepack(1-proj-2-tuple(v_962),2-proj-3-tuple(v_957),3-proj-3-tuple(v_957)))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-3-tuple(v_963))))) then symmetricstatepack(1-proj-3-tuple(v_963),2-proj-3-tuple(v_963),hash(3-proj-3-tuple(v_963),2-proj-2-tuple(v_962))) else fail-any) else fail-any)) in
        {456}let v_965: bitstring = catch-fail((if success?(1-proj-7-tuple(v_955)) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-3-tuple(v_957))))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-2-tuple(v_962))))) then (if not-caught-fail(v_964) then (v_964,2-proj-2-tuple(v_962)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {457}let v_966: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_965),2-proj-7-tuple(v_955),3-proj-7-tuple(v_955),4-proj-7-tuple(v_955),5-proj-7-tuple(v_955),6-proj-7-tuple(v_955),7-proj-7-tuple(v_955))) in
        {458}let v_967: bitstring = catch-fail(concat3(1-proj-3-tuple(v_956),2-proj-3-tuple(v_956),2-proj-2-tuple(v_965))) in
        {459}let (hs_968: handshakestate,message_d_969: bitstring) = (if (not-caught-fail(v_955) && success?(is-true(success?(1-proj-7-tuple(v_955))))) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if (not-caught-fail(v_965) && success?(is-true(success?(1-proj-2-tuple(v_965))))) then (if not-caught-fail(v_966) then (if not-caught-fail(v_967) then (v_966,v_967) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {460}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice));
        {461}out(pub, message_d_969)
    ) | (
        {463}event LeakS(phase0,bob);
        {464}out(pub, key_s(bob))
    ) | (
        {465}phase 1;
        {466}event LeakS(phase1,bob);
        {467}out(pub, key_s(bob))
    )
) | (
    {468}let s_970: keypair = keypairpack(empty,empty) in
    {469}out(pub, getpublickey(s_970));
    (
        {470}let e_971: keypair = keypairpack(empty,empty) in
        {471}let rs_972: key = empty in
        {472}let re_973: key = empty in
        {473}let v_974: bitstring = catch-fail(hash(somename,empty)) in
        {474}let v_975: key = catch-fail(v_974) in
        {475}let v_976: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {476}let v_977: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_974) then (if not-caught-fail(v_975) then (if not-caught-fail(v_976) then symmetricstatepack(v_976,v_975,v_974) else fail-any) else fail-any) else fail-any))) in
        {477}let v_978: symmetricstate = catch-fail((if success?((if not-caught-fail(v_974) then (if not-caught-fail(v_975) then (if not-caught-fail(v_976) then symmetricstatepack(v_976,v_975,v_974) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-3-tuple(v_977))))) then symmetricstatepack(1-proj-3-tuple(v_977),2-proj-3-tuple(v_977),hash(3-proj-3-tuple(v_977),empty)) else fail-any) else fail-any)) in
        {478}let hs_979: handshakestate = (if not-caught-fail(v_978) then handshakestatepack(v_978,s_970,e_971,rs_972,re_973,empty,false) else fail-any) in
        {479}insert statestore(bob,charlie,sid,statepack_a(hs_979))
    ) | (
        {513}get statestore(=bob,=charlie,=sid,statepack_a(hs_980: handshakestate)) in
        {480}in(pub, message_a_981: bitstring);
        {481}let v_982: bitstring = catch-fail(handshakestateunpack(hs_980)) in
        {482}let v_983: bitstring = catch-fail(deconcat3(message_a_981)) in
        {483}let v_984: bool = catch-fail(true) in
        {484}let v_985: key = catch-fail(1-proj-3-tuple(v_983)) in
        {485}let v_986: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_982))) in
        {486}let v_987: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_982)) then (if (not-caught-fail(v_986) && success?(is-true(success?(1-proj-3-tuple(v_986))))) then symmetricstatepack(1-proj-3-tuple(v_986),2-proj-3-tuple(v_986),hash(3-proj-3-tuple(v_986),v_985)) else fail-any) else fail-any)) in
        {487}let v_988: bitstring = catch-fail(symmetricstateunpack(v_987)) in
        {488}let v_989: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_988))) in
        {489}let v_990: aead = catch-fail(decrypt(1-proj-2-tuple(v_989),2-proj-2-tuple(v_989),3-proj-3-tuple(v_988),2-proj-3-tuple(v_983))) in
        {490}let v_991: bitstring = catch-fail(aeadunpack(v_990)) in
        {491}let v_992: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_988))) in
        {492}let v_993: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_989))) && success?(1-proj-3-tuple(v_988))) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-2-tuple(v_992))))) then cipherstatepack(1-proj-2-tuple(v_992),increment_nonce(2-proj-2-tuple(v_989))) else fail-any) else fail-any)) in
        {493}let v_994: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_983)) && (success?(3-proj-3-tuple(v_988)) && success?(1-proj-3-tuple(v_988)))) then (if (not-caught-fail(v_989) && success?(is-true(success?(1-proj-2-tuple(v_989))))) then (if not-caught-fail(v_990) then (if (not-caught-fail(v_991) && success?(is-true(success?(1-proj-3-tuple(v_991))))) then (if not-caught-fail(v_993) then (v_993,3-proj-3-tuple(v_991),1-proj-3-tuple(v_991)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {494}let v_995: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_994),2-proj-3-tuple(v_988),3-proj-3-tuple(v_988)))) in
        {495}let v_996: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_983)) && success?(symmetricstatepack(1-proj-3-tuple(v_994),2-proj-3-tuple(v_988),3-proj-3-tuple(v_988)))) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then symmetricstatepack(1-proj-3-tuple(v_995),2-proj-3-tuple(v_995),hash(3-proj-3-tuple(v_995),2-proj-3-tuple(v_983))) else fail-any) else fail-any)) in
        {496}let v_997: bitstring = catch-fail((if success?(2-proj-3-tuple(v_983)) then (if (not-caught-fail(v_988) && success?(is-true(success?(1-proj-3-tuple(v_988))))) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-3-tuple(v_994))))) then (if not-caught-fail(v_996) then (v_996,2-proj-3-tuple(v_994),3-proj-3-tuple(v_994)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {497}let v_998: key = catch-fail(2-proj-3-tuple(v_997)) in
        {498}let v_999: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_997))) in
        {499}let v_1000: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_999))) in
        {500}let v_1001: aead = catch-fail(decrypt(1-proj-2-tuple(v_1000),2-proj-2-tuple(v_1000),3-proj-3-tuple(v_999),3-proj-3-tuple(v_983))) in
        {501}let v_1002: bitstring = catch-fail(aeadunpack(v_1001)) in
        {502}let v_1003: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_999))) in
        {503}let v_1004: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1000))) && success?(1-proj-3-tuple(v_999))) then (if (not-caught-fail(v_1003) && success?(is-true(success?(1-proj-2-tuple(v_1003))))) then cipherstatepack(1-proj-2-tuple(v_1003),increment_nonce(2-proj-2-tuple(v_1000))) else fail-any) else fail-any)) in
        {504}let v_1005: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_983)) && (success?(3-proj-3-tuple(v_999)) && success?(1-proj-3-tuple(v_999)))) then (if (not-caught-fail(v_1000) && success?(is-true(success?(1-proj-2-tuple(v_1000))))) then (if not-caught-fail(v_1001) then (if (not-caught-fail(v_1002) && success?(is-true(success?(1-proj-3-tuple(v_1002))))) then (if not-caught-fail(v_1004) then (v_1004,3-proj-3-tuple(v_1002),1-proj-3-tuple(v_1002)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {505}let v_1006: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1005),2-proj-3-tuple(v_999),3-proj-3-tuple(v_999)))) in
        {506}let v_1007: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_983)) && success?(symmetricstatepack(1-proj-3-tuple(v_1005),2-proj-3-tuple(v_999),3-proj-3-tuple(v_999)))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-3-tuple(v_1006))))) then symmetricstatepack(1-proj-3-tuple(v_1006),2-proj-3-tuple(v_1006),hash(3-proj-3-tuple(v_1006),3-proj-3-tuple(v_983))) else fail-any) else fail-any)) in
        {507}let v_1008: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_983)) && success?(1-proj-3-tuple(v_997))) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then (if (not-caught-fail(v_1005) && success?(is-true(success?(1-proj-3-tuple(v_1005))))) then (if not-caught-fail(v_1007) then (v_1007,2-proj-3-tuple(v_1005),3-proj-3-tuple(v_1005)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {508}let v_1009: key = catch-fail(dhexp(key_s(charlie),g)) in
        {509}let v_1010: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1008),2-proj-7-tuple(v_982),3-proj-7-tuple(v_982),v_998,v_985,6-proj-7-tuple(v_982),7-proj-7-tuple(v_982))) in
        {510}let (hs_1011: handshakestate,plaintext_a_1012: bitstring,valid_1013: bool) = (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-7-tuple(v_982))))) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-3-tuple(v_983))))) then (if not-caught-fail(v_984) then (if not-caught-fail(v_985) then (if not-caught-fail(v_987) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then (if not-caught-fail(v_998) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-3-tuple(v_1008))))) then (if ((3-proj-3-tuple(v_997) && 3-proj-3-tuple(v_1008)) && (v_998 = getpublickey((if not-caught-fail(v_1009) then keypairpack(v_1009,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1010) then (v_1010,2-proj-3-tuple(v_1008),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {511}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_1012);
        {512}insert statestore(bob,charlie,sid,statepack_b(hs_1011))
    ) | (
        {576}get statestore(=bob,=charlie,=sid,statepack_b(hs_1014: handshakestate)) in
        {514}let v_1015: bitstring = catch-fail(handshakestateunpack(hs_1014)) in
        {515}let v_1016: bitstring = catch-fail((empty,empty,empty)) in
        {516}let v_1017: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {517}let v_1018: keypair = catch-fail((if not-caught-fail(v_1017) then keypairpack(v_1017,key_e(bob,charlie,sid)) else fail-any)) in
        {518}let v_1019: bitstring = catch-fail(getpublickey(v_1018)) in
        {519}let v_1020: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1015))) in
        {520}let v_1021: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then symmetricstatepack(1-proj-3-tuple(v_1020),2-proj-3-tuple(v_1020),hash(3-proj-3-tuple(v_1020),v_1019)) else fail-any) else fail-any)) in
        {521}let v_1022: bitstring = catch-fail(keypairunpack(v_1018)) in
        {522}let v_1023: bitstring = catch-fail(symmetricstateunpack(v_1021)) in
        {523}let v_1024: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1023),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {524}let v_1025: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1023),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {525}let v_1026: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1023),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {526}let v_1027: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),5-proj-7-tuple(v_1015)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1023))) then (if not-caught-fail(v_1024) then (if not-caught-fail(v_1025) then (if not-caught-fail(v_1026) then (v_1024,v_1025,v_1026) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {527}let v_1028: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),5-proj-7-tuple(v_1015)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-3-tuple(v_1023))))) then (if (not-caught-fail(v_1027) && success?(is-true(success?(1-proj-3-tuple(v_1027))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1027)) then cipherstatepack(2-proj-3-tuple(v_1027),minnonce) else fail-any),1-proj-3-tuple(v_1027),3-proj-3-tuple(v_1023)) else fail-any) else fail-any) else fail-any)) in
        {528}let v_1029: bitstring = catch-fail(keypairunpack(v_1018)) in
        {529}let v_1030: bitstring = catch-fail(symmetricstateunpack(v_1028)) in
        {530}let v_1031: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1030),(if success?(4-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-2-tuple(v_1029))))) then dhexp(2-proj-2-tuple(v_1029),4-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {531}let v_1032: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1030),(if success?(4-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-2-tuple(v_1029))))) then dhexp(2-proj-2-tuple(v_1029),4-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {532}let v_1033: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1030),(if success?(4-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-2-tuple(v_1029))))) then dhexp(2-proj-2-tuple(v_1029),4-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {533}let v_1034: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-2-tuple(v_1029))))) then dhexp(2-proj-2-tuple(v_1029),4-proj-7-tuple(v_1015)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1030))) then (if not-caught-fail(v_1031) then (if not-caught-fail(v_1032) then (if not-caught-fail(v_1033) then (v_1031,v_1032,v_1033) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {534}let v_1035: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-2-tuple(v_1029))))) then dhexp(2-proj-2-tuple(v_1029),4-proj-7-tuple(v_1015)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-3-tuple(v_1030))))) then (if (not-caught-fail(v_1034) && success?(is-true(success?(1-proj-3-tuple(v_1034))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1034)) then cipherstatepack(2-proj-3-tuple(v_1034),minnonce) else fail-any),1-proj-3-tuple(v_1034),3-proj-3-tuple(v_1030)) else fail-any) else fail-any) else fail-any)) in
        {535}let v_1036: key = catch-fail(dhexp(key_s(bob),g)) in
        {536}let v_1037: keypair = catch-fail((if not-caught-fail(v_1036) then keypairpack(v_1036,key_s(bob)) else fail-any)) in
        {537}let v_1038: bitstring = catch-fail(symmetricstateunpack(v_1035)) in
        {538}let v_1039: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1038))) in
        {539}let v_1040: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1039),2-proj-2-tuple(v_1039),3-proj-3-tuple(v_1038),getpublickey(v_1037))) in
        {540}let v_1041: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1038))) in
        {541}let v_1042: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1039))) && success?(1-proj-3-tuple(v_1038))) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then cipherstatepack(1-proj-2-tuple(v_1041),increment_nonce(2-proj-2-tuple(v_1039))) else fail-any) else fail-any)) in
        {542}let v_1043: bitstring = catch-fail((if (success?(getpublickey(v_1037)) && (success?(3-proj-3-tuple(v_1038)) && success?(1-proj-3-tuple(v_1038)))) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-2-tuple(v_1039))))) then (if not-caught-fail(v_1040) then (if not-caught-fail(v_1042) then (v_1042,v_1040) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {543}let v_1044: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1043),2-proj-3-tuple(v_1038),3-proj-3-tuple(v_1038)))) in
        {544}let v_1045: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1043)) && success?(symmetricstatepack(1-proj-2-tuple(v_1043),2-proj-3-tuple(v_1038),3-proj-3-tuple(v_1038)))) then (if (not-caught-fail(v_1044) && success?(is-true(success?(1-proj-3-tuple(v_1044))))) then symmetricstatepack(1-proj-3-tuple(v_1044),2-proj-3-tuple(v_1044),hash(3-proj-3-tuple(v_1044),2-proj-2-tuple(v_1043))) else fail-any) else fail-any)) in
        {545}let v_1046: bitstring = catch-fail((if success?(getpublickey(v_1037)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-3-tuple(v_1038))))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-2-tuple(v_1043))))) then (if not-caught-fail(v_1045) then (v_1045,2-proj-2-tuple(v_1043)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {546}let v_1047: bitstring = catch-fail(keypairunpack(v_1037)) in
        {547}let v_1048: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1046))) in
        {548}let v_1049: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1048),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then dhexp(2-proj-2-tuple(v_1047),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {549}let v_1050: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1048),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then dhexp(2-proj-2-tuple(v_1047),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {550}let v_1051: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1048),(if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then dhexp(2-proj-2-tuple(v_1047),5-proj-7-tuple(v_1015)) else fail-any) else fail-any))) in
        {551}let v_1052: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then dhexp(2-proj-2-tuple(v_1047),5-proj-7-tuple(v_1015)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1048))) then (if not-caught-fail(v_1049) then (if not-caught-fail(v_1050) then (if not-caught-fail(v_1051) then (v_1049,v_1050,v_1051) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {552}let v_1053: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1015)) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then dhexp(2-proj-2-tuple(v_1047),5-proj-7-tuple(v_1015)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_1046))) then (if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-3-tuple(v_1048))))) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-3-tuple(v_1052))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1052)) then cipherstatepack(2-proj-3-tuple(v_1052),minnonce) else fail-any),1-proj-3-tuple(v_1052),3-proj-3-tuple(v_1048)) else fail-any) else fail-any) else fail-any)) in
        {553}let v_1054: bitstring = catch-fail(symmetricstateunpack(v_1053)) in
        {554}let v_1055: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1054))) in
        {555}let v_1056: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1055),2-proj-2-tuple(v_1055),3-proj-3-tuple(v_1054),msg_b(bob,charlie))) in
        {556}let v_1057: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1054))) in
        {557}let v_1058: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1055))) && success?(1-proj-3-tuple(v_1054))) then (if (not-caught-fail(v_1057) && success?(is-true(success?(1-proj-2-tuple(v_1057))))) then cipherstatepack(1-proj-2-tuple(v_1057),increment_nonce(2-proj-2-tuple(v_1055))) else fail-any) else fail-any)) in
        {558}let v_1059: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1054)) && success?(1-proj-3-tuple(v_1054))) then (if (not-caught-fail(v_1055) && success?(is-true(success?(1-proj-2-tuple(v_1055))))) then (if not-caught-fail(v_1056) then (if not-caught-fail(v_1058) then (v_1058,v_1056) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {559}let v_1060: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1059),2-proj-3-tuple(v_1054),3-proj-3-tuple(v_1054)))) in
        {560}let v_1061: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1059)) && success?(symmetricstatepack(1-proj-2-tuple(v_1059),2-proj-3-tuple(v_1054),3-proj-3-tuple(v_1054)))) then (if (not-caught-fail(v_1060) && success?(is-true(success?(1-proj-3-tuple(v_1060))))) then symmetricstatepack(1-proj-3-tuple(v_1060),2-proj-3-tuple(v_1060),hash(3-proj-3-tuple(v_1060),2-proj-2-tuple(v_1059))) else fail-any) else fail-any)) in
        {561}let v_1062: bitstring = catch-fail((if (not-caught-fail(v_1054) && success?(is-true(success?(1-proj-3-tuple(v_1054))))) then (if (not-caught-fail(v_1059) && success?(is-true(success?(1-proj-2-tuple(v_1059))))) then (if not-caught-fail(v_1061) then (v_1061,2-proj-2-tuple(v_1059)) else fail-any) else fail-any) else fail-any)) in
        {562}let v_1063: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1062),v_1037,v_1018,4-proj-7-tuple(v_1015),5-proj-7-tuple(v_1015),6-proj-7-tuple(v_1015),7-proj-7-tuple(v_1015))) in
        {563}let v_1064: bitstring = catch-fail(concat3(v_1019,2-proj-2-tuple(v_1046),2-proj-2-tuple(v_1062))) in
        {564}let v_1065: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1062))) in
        {565}let v_1066: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1065),zero)) in
        {566}let v_1067: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1065),zero)) in
        {567}let v_1068: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1065),zero)) in
        {568}let v_1069: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1065)) then (if not-caught-fail(v_1066) then (if not-caught-fail(v_1067) then (if not-caught-fail(v_1068) then (v_1066,v_1067,v_1068) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {569}let v_1070: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1069)) then cipherstatepack(1-proj-3-tuple(v_1069),minnonce) else fail-any)) in
        {570}let v_1071: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1069)) then cipherstatepack(2-proj-3-tuple(v_1069),minnonce) else fail-any)) in
        {571}let v_1072: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1062)) then (if (not-caught-fail(v_1065) && success?(is-true(success?(1-proj-3-tuple(v_1065))))) then (if (not-caught-fail(v_1069) && success?(is-true(success?(1-proj-3-tuple(v_1069))))) then (if not-caught-fail(v_1070) then (if not-caught-fail(v_1071) then (1-proj-2-tuple(v_1062),v_1070,v_1071) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {572}let (hs_1073: handshakestate,message_b_1074: bitstring,cs1_1075: cipherstate,cs2_1076: cipherstate) = (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-7-tuple(v_1015))))) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-3-tuple(v_1016))))) then (if not-caught-fail(v_1018) then (if not-caught-fail(v_1019) then (if not-caught-fail(v_1021) then (if not-caught-fail(v_1028) then (if not-caught-fail(v_1035) then (if not-caught-fail(v_1037) then (if (not-caught-fail(v_1046) && success?(is-true(success?(1-proj-2-tuple(v_1046))))) then (if not-caught-fail(v_1053) then (if (not-caught-fail(v_1062) && success?(is-true(success?(1-proj-2-tuple(v_1062))))) then (if not-caught-fail(v_1063) then (if not-caught-fail(v_1064) then (if (not-caught-fail(v_1072) && success?(is-true(success?(1-proj-3-tuple(v_1072))))) then (v_1063,v_1064,2-proj-3-tuple(v_1072),3-proj-3-tuple(v_1072)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {573}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie));
        {574}insert statestore(bob,charlie,sid,statepack_c(hs_1073,cs1_1075,cs2_1076));
        {575}out(pub, message_b_1074)
    ) | (
        {577}!
        {597}get statestore(=bob,=charlie,=sid,statepack_c(hs_1077: handshakestate,cs1_1078: cipherstate,cs2_1079: cipherstate)) in
        {578}let hs_1080: handshakestate = handshakestatesetcs(hs_1077,cs1_1078) in
        {579}in(pub, message_c_1081: bitstring);
        {580}let v_1082: bitstring = catch-fail(handshakestateunpack(hs_1080)) in
        {581}let v_1083: bitstring = catch-fail(deconcat3(message_c_1081)) in
        {582}let v_1084: bool = catch-fail(true) in
        {583}let v_1085: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1082))) in
        {584}let v_1086: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1085))) in
        {585}let v_1087: aead = catch-fail(decrypt(1-proj-2-tuple(v_1086),2-proj-2-tuple(v_1086),3-proj-3-tuple(v_1085),3-proj-3-tuple(v_1083))) in
        {586}let v_1088: bitstring = catch-fail(aeadunpack(v_1087)) in
        {587}let v_1089: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1085))) in
        {588}let v_1090: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1086))) && success?(1-proj-3-tuple(v_1085))) then (if (not-caught-fail(v_1089) && success?(is-true(success?(1-proj-2-tuple(v_1089))))) then cipherstatepack(1-proj-2-tuple(v_1089),increment_nonce(2-proj-2-tuple(v_1086))) else fail-any) else fail-any)) in
        {589}let v_1091: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1083)) && (success?(3-proj-3-tuple(v_1085)) && success?(1-proj-3-tuple(v_1085)))) then (if (not-caught-fail(v_1086) && success?(is-true(success?(1-proj-2-tuple(v_1086))))) then (if not-caught-fail(v_1087) then (if (not-caught-fail(v_1088) && success?(is-true(success?(1-proj-3-tuple(v_1088))))) then (if not-caught-fail(v_1090) then (v_1090,3-proj-3-tuple(v_1088),1-proj-3-tuple(v_1088)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {590}let v_1092: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1091),2-proj-3-tuple(v_1085),3-proj-3-tuple(v_1085)))) in
        {591}let v_1093: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1083)) && success?(symmetricstatepack(1-proj-3-tuple(v_1091),2-proj-3-tuple(v_1085),3-proj-3-tuple(v_1085)))) then (if (not-caught-fail(v_1092) && success?(is-true(success?(1-proj-3-tuple(v_1092))))) then symmetricstatepack(1-proj-3-tuple(v_1092),2-proj-3-tuple(v_1092),hash(3-proj-3-tuple(v_1092),3-proj-3-tuple(v_1083))) else fail-any) else fail-any)) in
        {592}let v_1094: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1083)) && success?(1-proj-7-tuple(v_1082))) then (if (not-caught-fail(v_1085) && success?(is-true(success?(1-proj-3-tuple(v_1085))))) then (if (not-caught-fail(v_1091) && success?(is-true(success?(1-proj-3-tuple(v_1091))))) then (if not-caught-fail(v_1093) then (v_1093,2-proj-3-tuple(v_1091),3-proj-3-tuple(v_1091)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {593}let v_1095: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1094),2-proj-7-tuple(v_1082),3-proj-7-tuple(v_1082),4-proj-7-tuple(v_1082),5-proj-7-tuple(v_1082),6-proj-7-tuple(v_1082),7-proj-7-tuple(v_1082))) in
        {594}let (hs_1096: handshakestate,plaintext_c_1097: bitstring,valid_1098: bool) = (if (not-caught-fail(v_1082) && success?(is-true(success?(1-proj-7-tuple(v_1082))))) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then (if not-caught-fail(v_1084) then (if (not-caught-fail(v_1094) && success?(is-true(success?(1-proj-3-tuple(v_1094))))) then (if (v_1084 && 3-proj-3-tuple(v_1094)) then (if not-caught-fail(v_1095) then (v_1095,2-proj-3-tuple(v_1094),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {595}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1097);
        {596}insert statestore(bob,charlie,sid,statepack_d(hs_1096,handshakestategetcs(hs_1096),cs2_1079))
    ) | (
        {598}!
        {616}get statestore(=bob,=charlie,=sid,statepack_d(hs_1099: handshakestate,cs1_1100: cipherstate,cs2_1101: cipherstate)) in
        {599}let hs_1102: handshakestate = handshakestatesetcs(hs_1099,cs2_1101) in
        {600}let v_1103: bitstring = catch-fail(handshakestateunpack(hs_1102)) in
        {601}let v_1104: bitstring = catch-fail((empty,empty,empty)) in
        {602}let v_1105: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1103))) in
        {603}let v_1106: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1105))) in
        {604}let v_1107: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1106),2-proj-2-tuple(v_1106),3-proj-3-tuple(v_1105),msg_d(bob,charlie))) in
        {605}let v_1108: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1105))) in
        {606}let v_1109: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1106))) && success?(1-proj-3-tuple(v_1105))) then (if (not-caught-fail(v_1108) && success?(is-true(success?(1-proj-2-tuple(v_1108))))) then cipherstatepack(1-proj-2-tuple(v_1108),increment_nonce(2-proj-2-tuple(v_1106))) else fail-any) else fail-any)) in
        {607}let v_1110: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1105)) && success?(1-proj-3-tuple(v_1105))) then (if (not-caught-fail(v_1106) && success?(is-true(success?(1-proj-2-tuple(v_1106))))) then (if not-caught-fail(v_1107) then (if not-caught-fail(v_1109) then (v_1109,v_1107) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {608}let v_1111: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1110),2-proj-3-tuple(v_1105),3-proj-3-tuple(v_1105)))) in
        {609}let v_1112: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1110)) && success?(symmetricstatepack(1-proj-2-tuple(v_1110),2-proj-3-tuple(v_1105),3-proj-3-tuple(v_1105)))) then (if (not-caught-fail(v_1111) && success?(is-true(success?(1-proj-3-tuple(v_1111))))) then symmetricstatepack(1-proj-3-tuple(v_1111),2-proj-3-tuple(v_1111),hash(3-proj-3-tuple(v_1111),2-proj-2-tuple(v_1110))) else fail-any) else fail-any)) in
        {610}let v_1113: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1103)) then (if (not-caught-fail(v_1105) && success?(is-true(success?(1-proj-3-tuple(v_1105))))) then (if (not-caught-fail(v_1110) && success?(is-true(success?(1-proj-2-tuple(v_1110))))) then (if not-caught-fail(v_1112) then (v_1112,2-proj-2-tuple(v_1110)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {611}let v_1114: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1113),2-proj-7-tuple(v_1103),3-proj-7-tuple(v_1103),4-proj-7-tuple(v_1103),5-proj-7-tuple(v_1103),6-proj-7-tuple(v_1103),7-proj-7-tuple(v_1103))) in
        {612}let v_1115: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1104),2-proj-3-tuple(v_1104),2-proj-2-tuple(v_1113))) in
        {613}let (hs_1116: handshakestate,message_d_1117: bitstring) = (if (not-caught-fail(v_1103) && success?(is-true(success?(1-proj-7-tuple(v_1103))))) then (if (not-caught-fail(v_1104) && success?(is-true(success?(1-proj-3-tuple(v_1104))))) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then (if not-caught-fail(v_1114) then (if not-caught-fail(v_1115) then (v_1114,v_1115) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {614}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie));
        {615}out(pub, message_d_1117)
    ) | (
        {617}event LeakS(phase0,bob);
        {618}out(pub, key_s(bob))
    ) | (
        {619}phase 1;
        {620}event LeakS(phase1,bob);
        {621}out(pub, key_s(bob))
    )
)

