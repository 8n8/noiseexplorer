File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 237, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 238, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 238, character 36:
Warning: identifier h rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 279, character 6:
Warning: identifier e rebound.
File "X1K.noise.active.pv", line 280, characters 6-7:
Warning: identifier ne rebound.
File "X1K.noise.active.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 283, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 284, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 284, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 285, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "X1K.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "X1K.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 297, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 298, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 305, character 6:
Warning: identifier s rebound.
File "X1K.noise.active.pv", line 306, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 306, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1K.noise.active.pv", line 307, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 307, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 308, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 316, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 316, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 317, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 325, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 326, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 333, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 333, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 334, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 342, characters 6-7:
Warning: identifier re rebound.
File "X1K.noise.active.pv", line 343, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 346, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 348, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 356, characters 6-7:
Warning: identifier re rebound.
File "X1K.noise.active.pv", line 357, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 359, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 360, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 362, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 370, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 370, characters 48-53:
Warning: identifier valid1 rebound.
File "X1K.noise.active.pv", line 371, characters 6-7:
Warning: identifier rs rebound.
File "X1K.noise.active.pv", line 372, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 374, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 382, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 383, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 385, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 394, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 396, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 404, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 406, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 606, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 608, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 404, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 406, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 598, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 599, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 325, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 326, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 591, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 382, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 383, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 385, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 583, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 305, character 6:
Warning: identifier s rebound.
File "X1K.noise.active.pv", line 306, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 306, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "X1K.noise.active.pv", line 307, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 307, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 308, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 576, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 356, characters 6-7:
Warning: identifier re rebound.
File "X1K.noise.active.pv", line 357, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 359, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 360, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 362, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 568, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 279, character 6:
Warning: identifier e rebound.
File "X1K.noise.active.pv", line 280, characters 6-7:
Warning: identifier ne rebound.
File "X1K.noise.active.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 283, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 284, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 284, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 285, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 674, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 675, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 333, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 333, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 334, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 665, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 667, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 394, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 396, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 658, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 316, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 316, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 317, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 651, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 370, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 370, characters 48-53:
Warning: identifier valid1 rebound.
File "X1K.noise.active.pv", line 371, characters 6-7:
Warning: identifier rs rebound.
File "X1K.noise.active.pv", line 372, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 374, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 643, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "X1K.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "X1K.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 297, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "X1K.noise.active.pv", line 298, characters 6-7:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 636, characters 8-9:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 342, characters 6-7:
Warning: identifier re rebound.
File "X1K.noise.active.pv", line 343, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 346, characters 7-8:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 348, characters 7-8:
Warning: identifier hs rebound.
File "X1K.noise.active.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "X1K.noise.active.pv", line 253, characters 7-8:
Warning: identifier cs rebound.
File "X1K.noise.active.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "X1K.noise.active.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_593: keypair = keypairpack(empty,empty) in
    {5}out(pub, getpublickey(s_593));
    (
        {6}let e_594: keypair = keypairpack(empty,empty) in
        {7}let v_595: key = catch-fail(dhexp(key_s(bob),g)) in
        {8}let rs_596: key = getpublickey((if not-caught-fail(v_595) then keypairpack(v_595,key_s(bob)) else fail-any)) in
        {9}let re_597: key = empty in
        {10}let v_598: bitstring = catch-fail(hash(somename,empty)) in
        {11}let v_599: key = catch-fail(v_598) in
        {12}let v_600: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {13}let v_601: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_598) then (if not-caught-fail(v_599) then (if not-caught-fail(v_600) then symmetricstatepack(v_600,v_599,v_598) else fail-any) else fail-any) else fail-any))) in
        {14}let v_602: symmetricstate = catch-fail((if success?((if not-caught-fail(v_598) then (if not-caught-fail(v_599) then (if not-caught-fail(v_600) then symmetricstatepack(v_600,v_599,v_598) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-3-tuple(v_601))))) then symmetricstatepack(1-proj-3-tuple(v_601),2-proj-3-tuple(v_601),hash(3-proj-3-tuple(v_601),empty)) else fail-any) else fail-any)) in
        {15}let v_603: bitstring = catch-fail(symmetricstateunpack(v_602)) in
        {16}let v_604: symmetricstate = catch-fail((if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-3-tuple(v_603))))) then symmetricstatepack(1-proj-3-tuple(v_603),2-proj-3-tuple(v_603),hash(3-proj-3-tuple(v_603),rs_596)) else fail-any)) in
        {17}let hs: handshakestate = (if not-caught-fail(v_602) then (if not-caught-fail(v_604) then handshakestatepack(v_604,s_593,e_594,rs_596,re_597,empty,true) else fail-any) else fail-any) in
        {18}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {48}get statestore(=alice,=bob,=sid,statepack_a(hs_605: handshakestate)) in
        {19}let v_606: bitstring = catch-fail(handshakestateunpack(hs_605)) in
        {20}let v_607: bitstring = catch-fail((empty,empty,empty)) in
        {21}let v_608: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {22}let v_609: keypair = catch-fail((if not-caught-fail(v_608) then keypairpack(v_608,key_e(alice,bob,sid)) else fail-any)) in
        {23}let v_610: bitstring = catch-fail(getpublickey(v_609)) in
        {24}let v_611: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_606))) in
        {25}let v_612: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_606)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-3-tuple(v_611))))) then symmetricstatepack(1-proj-3-tuple(v_611),2-proj-3-tuple(v_611),hash(3-proj-3-tuple(v_611),v_610)) else fail-any) else fail-any)) in
        {26}let v_613: bitstring = catch-fail(keypairunpack(v_609)) in
        {27}let v_614: bitstring = catch-fail(symmetricstateunpack(v_612)) in
        {28}let v_615: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_614),(if success?(4-proj-7-tuple(v_606)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-2-tuple(v_613))))) then dhexp(2-proj-2-tuple(v_613),4-proj-7-tuple(v_606)) else fail-any) else fail-any))) in
        {29}let v_616: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_614),(if success?(4-proj-7-tuple(v_606)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-2-tuple(v_613))))) then dhexp(2-proj-2-tuple(v_613),4-proj-7-tuple(v_606)) else fail-any) else fail-any))) in
        {30}let v_617: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_614),(if success?(4-proj-7-tuple(v_606)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-2-tuple(v_613))))) then dhexp(2-proj-2-tuple(v_613),4-proj-7-tuple(v_606)) else fail-any) else fail-any))) in
        {31}let v_618: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_606)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-2-tuple(v_613))))) then dhexp(2-proj-2-tuple(v_613),4-proj-7-tuple(v_606)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_614))) then (if not-caught-fail(v_615) then (if not-caught-fail(v_616) then (if not-caught-fail(v_617) then (v_615,v_616,v_617) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {32}let v_619: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_606)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-2-tuple(v_613))))) then dhexp(2-proj-2-tuple(v_613),4-proj-7-tuple(v_606)) else fail-any) else fail-any)) then (if (not-caught-fail(v_614) && success?(is-true(success?(1-proj-3-tuple(v_614))))) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-3-tuple(v_618))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_618)) then cipherstatepack(2-proj-3-tuple(v_618),minnonce) else fail-any),1-proj-3-tuple(v_618),3-proj-3-tuple(v_614)) else fail-any) else fail-any) else fail-any)) in
        {33}let v_620: bitstring = catch-fail(symmetricstateunpack(v_619)) in
        {34}let v_621: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_620))) in
        {35}let v_622: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_621),2-proj-2-tuple(v_621),3-proj-3-tuple(v_620),msg_a(alice,bob,sid))) in
        {36}let v_623: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_620))) in
        {37}let v_624: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_621))) && success?(1-proj-3-tuple(v_620))) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-2-tuple(v_623))))) then cipherstatepack(1-proj-2-tuple(v_623),increment_nonce(2-proj-2-tuple(v_621))) else fail-any) else fail-any)) in
        {38}let v_625: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_620)) && success?(1-proj-3-tuple(v_620))) then (if (not-caught-fail(v_621) && success?(is-true(success?(1-proj-2-tuple(v_621))))) then (if not-caught-fail(v_622) then (if not-caught-fail(v_624) then (v_624,v_622) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {39}let v_626: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_625),2-proj-3-tuple(v_620),3-proj-3-tuple(v_620)))) in
        {40}let v_627: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_625)) && success?(symmetricstatepack(1-proj-2-tuple(v_625),2-proj-3-tuple(v_620),3-proj-3-tuple(v_620)))) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-3-tuple(v_626))))) then symmetricstatepack(1-proj-3-tuple(v_626),2-proj-3-tuple(v_626),hash(3-proj-3-tuple(v_626),2-proj-2-tuple(v_625))) else fail-any) else fail-any)) in
        {41}let v_628: bitstring = catch-fail((if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then (if not-caught-fail(v_627) then (v_627,2-proj-2-tuple(v_625)) else fail-any) else fail-any) else fail-any)) in
        {42}let v_629: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_628),2-proj-7-tuple(v_606),v_609,4-proj-7-tuple(v_606),5-proj-7-tuple(v_606),6-proj-7-tuple(v_606),7-proj-7-tuple(v_606))) in
        {43}let v_630: bitstring = catch-fail(concat3(v_610,2-proj-3-tuple(v_607),2-proj-2-tuple(v_628))) in
        {44}let (hs_631: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-7-tuple(v_606))))) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-3-tuple(v_607))))) then (if not-caught-fail(v_609) then (if not-caught-fail(v_610) then (if not-caught-fail(v_612) then (if not-caught-fail(v_619) then (if (not-caught-fail(v_628) && success?(is-true(success?(1-proj-2-tuple(v_628))))) then (if not-caught-fail(v_629) then (if not-caught-fail(v_630) then (v_629,v_630) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {45}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {46}insert statestore(alice,bob,sid,statepack_b(hs_631));
        {47}out(pub, message_a)
    ) | (
        {77}get statestore(=alice,=bob,=sid,statepack_b(hs_632: handshakestate)) in
        {49}in(pub, message_b: bitstring);
        {50}let v_633: bitstring = catch-fail(handshakestateunpack(hs_632)) in
        {51}let v_634: bitstring = catch-fail(deconcat3(message_b)) in
        {52}let v_635: bool = catch-fail(true) in
        {53}let v_636: key = catch-fail(1-proj-3-tuple(v_634)) in
        {54}let v_637: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_633))) in
        {55}let v_638: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_633)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-3-tuple(v_637))))) then symmetricstatepack(1-proj-3-tuple(v_637),2-proj-3-tuple(v_637),hash(3-proj-3-tuple(v_637),v_636)) else fail-any) else fail-any)) in
        {56}let v_639: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_633))) in
        {57}let v_640: bitstring = catch-fail(symmetricstateunpack(v_638)) in
        {58}let v_641: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_640),(if success?(3-proj-7-tuple(v_633)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-2-tuple(v_639))))) then dhexp(2-proj-2-tuple(v_639),v_636) else fail-any) else fail-any))) in
        {59}let v_642: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_640),(if success?(3-proj-7-tuple(v_633)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-2-tuple(v_639))))) then dhexp(2-proj-2-tuple(v_639),v_636) else fail-any) else fail-any))) in
        {60}let v_643: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_640),(if success?(3-proj-7-tuple(v_633)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-2-tuple(v_639))))) then dhexp(2-proj-2-tuple(v_639),v_636) else fail-any) else fail-any))) in
        {61}let v_644: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_633)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-2-tuple(v_639))))) then dhexp(2-proj-2-tuple(v_639),v_636) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_640))) then (if not-caught-fail(v_641) then (if not-caught-fail(v_642) then (if not-caught-fail(v_643) then (v_641,v_642,v_643) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {62}let v_645: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_633)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-2-tuple(v_639))))) then dhexp(2-proj-2-tuple(v_639),v_636) else fail-any) else fail-any)) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-3-tuple(v_640))))) then (if (not-caught-fail(v_644) && success?(is-true(success?(1-proj-3-tuple(v_644))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_644)) then cipherstatepack(2-proj-3-tuple(v_644),minnonce) else fail-any),1-proj-3-tuple(v_644),3-proj-3-tuple(v_640)) else fail-any) else fail-any) else fail-any)) in
        {63}let v_646: bitstring = catch-fail(symmetricstateunpack(v_645)) in
        {64}let v_647: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_646))) in
        {65}let v_648: aead = catch-fail(decrypt(1-proj-2-tuple(v_647),2-proj-2-tuple(v_647),3-proj-3-tuple(v_646),3-proj-3-tuple(v_634))) in
        {66}let v_649: bitstring = catch-fail(aeadunpack(v_648)) in
        {67}let v_650: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_646))) in
        {68}let v_651: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_647))) && success?(1-proj-3-tuple(v_646))) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-2-tuple(v_650))))) then cipherstatepack(1-proj-2-tuple(v_650),increment_nonce(2-proj-2-tuple(v_647))) else fail-any) else fail-any)) in
        {69}let v_652: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_634)) && (success?(3-proj-3-tuple(v_646)) && success?(1-proj-3-tuple(v_646)))) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-2-tuple(v_647))))) then (if not-caught-fail(v_648) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-3-tuple(v_649))))) then (if not-caught-fail(v_651) then (v_651,3-proj-3-tuple(v_649),1-proj-3-tuple(v_649)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {70}let v_653: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_652),2-proj-3-tuple(v_646),3-proj-3-tuple(v_646)))) in
        {71}let v_654: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_634)) && success?(symmetricstatepack(1-proj-3-tuple(v_652),2-proj-3-tuple(v_646),3-proj-3-tuple(v_646)))) then (if (not-caught-fail(v_653) && success?(is-true(success?(1-proj-3-tuple(v_653))))) then symmetricstatepack(1-proj-3-tuple(v_653),2-proj-3-tuple(v_653),hash(3-proj-3-tuple(v_653),3-proj-3-tuple(v_634))) else fail-any) else fail-any)) in
        {72}let v_655: bitstring = catch-fail((if success?(3-proj-3-tuple(v_634)) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-3-tuple(v_646))))) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-3-tuple(v_652))))) then (if not-caught-fail(v_654) then (v_654,2-proj-3-tuple(v_652),3-proj-3-tuple(v_652)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {73}let v_656: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_655),2-proj-7-tuple(v_633),3-proj-7-tuple(v_633),4-proj-7-tuple(v_633),v_636,6-proj-7-tuple(v_633),7-proj-7-tuple(v_633))) in
        {74}let (hs_657: handshakestate,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-7-tuple(v_633))))) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then (if not-caught-fail(v_635) then (if not-caught-fail(v_636) then (if not-caught-fail(v_638) then (if not-caught-fail(v_645) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-3-tuple(v_655))))) then (if (v_635 && 3-proj-3-tuple(v_655)) then (if not-caught-fail(v_656) then (v_656,2-proj-3-tuple(v_655),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {75}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {76}insert statestore(alice,bob,sid,statepack_c(hs_657))
    ) | (
        {106}get statestore(=alice,=bob,=sid,statepack_c(hs_658: handshakestate)) in
        {78}let v_659: bitstring = catch-fail(handshakestateunpack(hs_658)) in
        {79}let v_660: bitstring = catch-fail((empty,empty,empty)) in
        {80}let v_661: key = catch-fail(dhexp(key_s(alice),g)) in
        {81}let v_662: keypair = catch-fail((if not-caught-fail(v_661) then keypairpack(v_661,key_s(alice)) else fail-any)) in
        {82}let v_663: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_659))) in
        {83}let v_664: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_663))) in
        {84}let v_665: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_664),2-proj-2-tuple(v_664),3-proj-3-tuple(v_663),getpublickey(v_662))) in
        {85}let v_666: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_663))) in
        {86}let v_667: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_664))) && success?(1-proj-3-tuple(v_663))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then cipherstatepack(1-proj-2-tuple(v_666),increment_nonce(2-proj-2-tuple(v_664))) else fail-any) else fail-any)) in
        {87}let v_668: bitstring = catch-fail((if (success?(getpublickey(v_662)) && (success?(3-proj-3-tuple(v_663)) && success?(1-proj-3-tuple(v_663)))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then (if not-caught-fail(v_665) then (if not-caught-fail(v_667) then (v_667,v_665) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {88}let v_669: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_668),2-proj-3-tuple(v_663),3-proj-3-tuple(v_663)))) in
        {89}let v_670: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_668)) && success?(symmetricstatepack(1-proj-2-tuple(v_668),2-proj-3-tuple(v_663),3-proj-3-tuple(v_663)))) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-3-tuple(v_669))))) then symmetricstatepack(1-proj-3-tuple(v_669),2-proj-3-tuple(v_669),hash(3-proj-3-tuple(v_669),2-proj-2-tuple(v_668))) else fail-any) else fail-any)) in
        {90}let v_671: bitstring = catch-fail((if (success?(getpublickey(v_662)) && success?(1-proj-7-tuple(v_659))) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-3-tuple(v_663))))) then (if (not-caught-fail(v_668) && success?(is-true(success?(1-proj-2-tuple(v_668))))) then (if not-caught-fail(v_670) then (v_670,2-proj-2-tuple(v_668)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {91}let v_672: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_671))) in
        {92}let v_673: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_672))) in
        {93}let v_674: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_673),2-proj-2-tuple(v_673),3-proj-3-tuple(v_672),msg_c(alice,bob,sid))) in
        {94}let v_675: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_672))) in
        {95}let v_676: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_673))) && success?(1-proj-3-tuple(v_672))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-2-tuple(v_675))))) then cipherstatepack(1-proj-2-tuple(v_675),increment_nonce(2-proj-2-tuple(v_673))) else fail-any) else fail-any)) in
        {96}let v_677: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_672)) && success?(1-proj-3-tuple(v_672))) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then (if not-caught-fail(v_674) then (if not-caught-fail(v_676) then (v_676,v_674) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {97}let v_678: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_677),2-proj-3-tuple(v_672),3-proj-3-tuple(v_672)))) in
        {98}let v_679: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_677)) && success?(symmetricstatepack(1-proj-2-tuple(v_677),2-proj-3-tuple(v_672),3-proj-3-tuple(v_672)))) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-3-tuple(v_678))))) then symmetricstatepack(1-proj-3-tuple(v_678),2-proj-3-tuple(v_678),hash(3-proj-3-tuple(v_678),2-proj-2-tuple(v_677))) else fail-any) else fail-any)) in
        {99}let v_680: bitstring = catch-fail((if success?(1-proj-2-tuple(v_671)) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-3-tuple(v_672))))) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-2-tuple(v_677))))) then (if not-caught-fail(v_679) then (v_679,2-proj-2-tuple(v_677)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {100}let v_681: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_680),v_662,3-proj-7-tuple(v_659),4-proj-7-tuple(v_659),5-proj-7-tuple(v_659),6-proj-7-tuple(v_659),7-proj-7-tuple(v_659))) in
        {101}let v_682: bitstring = catch-fail(concat3(1-proj-3-tuple(v_660),2-proj-2-tuple(v_671),2-proj-2-tuple(v_680))) in
        {102}let (hs_683: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-7-tuple(v_659))))) then (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-3-tuple(v_660))))) then (if not-caught-fail(v_662) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-2-tuple(v_680))))) then (if not-caught-fail(v_681) then (if not-caught-fail(v_682) then (v_681,v_682) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {103}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {104}insert statestore(alice,bob,sid,statepack_d(hs_683));
        {105}out(pub, message_c)
    ) | (
        {140}get statestore(=alice,=bob,=sid,statepack_d(hs_684: handshakestate)) in
        {107}in(pub, message_d: bitstring);
        {108}let v_685: bitstring = catch-fail(handshakestateunpack(hs_684)) in
        {109}let v_686: bitstring = catch-fail(deconcat3(message_d)) in
        {110}let v_687: bool = catch-fail(true) in
        {111}let v_688: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_685))) in
        {112}let v_689: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_685))) in
        {113}let v_690: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_689),(if (success?(5-proj-7-tuple(v_685)) && success?(2-proj-7-tuple(v_685))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-2-tuple(v_688))))) then dhexp(2-proj-2-tuple(v_688),5-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {114}let v_691: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_689),(if (success?(5-proj-7-tuple(v_685)) && success?(2-proj-7-tuple(v_685))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-2-tuple(v_688))))) then dhexp(2-proj-2-tuple(v_688),5-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {115}let v_692: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_689),(if (success?(5-proj-7-tuple(v_685)) && success?(2-proj-7-tuple(v_685))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-2-tuple(v_688))))) then dhexp(2-proj-2-tuple(v_688),5-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {116}let v_693: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_685)) && success?(2-proj-7-tuple(v_685))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-2-tuple(v_688))))) then dhexp(2-proj-2-tuple(v_688),5-proj-7-tuple(v_685)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_689))) then (if not-caught-fail(v_690) then (if not-caught-fail(v_691) then (if not-caught-fail(v_692) then (v_690,v_691,v_692) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {117}let v_694: symmetricstate = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_685)) && success?(2-proj-7-tuple(v_685))) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-2-tuple(v_688))))) then dhexp(2-proj-2-tuple(v_688),5-proj-7-tuple(v_685)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_685))) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-3-tuple(v_689))))) then (if (not-caught-fail(v_693) && success?(is-true(success?(1-proj-3-tuple(v_693))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_693)) then cipherstatepack(2-proj-3-tuple(v_693),minnonce) else fail-any),1-proj-3-tuple(v_693),3-proj-3-tuple(v_689)) else fail-any) else fail-any) else fail-any)) in
        {118}let v_695: bitstring = catch-fail(symmetricstateunpack(v_694)) in
        {119}let v_696: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_695))) in
        {120}let v_697: aead = catch-fail(decrypt(1-proj-2-tuple(v_696),2-proj-2-tuple(v_696),3-proj-3-tuple(v_695),3-proj-3-tuple(v_686))) in
        {121}let v_698: bitstring = catch-fail(aeadunpack(v_697)) in
        {122}let v_699: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_695))) in
        {123}let v_700: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_696))) && success?(1-proj-3-tuple(v_695))) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-2-tuple(v_699))))) then cipherstatepack(1-proj-2-tuple(v_699),increment_nonce(2-proj-2-tuple(v_696))) else fail-any) else fail-any)) in
        {124}let v_701: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_686)) && (success?(3-proj-3-tuple(v_695)) && success?(1-proj-3-tuple(v_695)))) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then (if not-caught-fail(v_697) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-3-tuple(v_698))))) then (if not-caught-fail(v_700) then (v_700,3-proj-3-tuple(v_698),1-proj-3-tuple(v_698)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {125}let v_702: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_701),2-proj-3-tuple(v_695),3-proj-3-tuple(v_695)))) in
        {126}let v_703: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_686)) && success?(symmetricstatepack(1-proj-3-tuple(v_701),2-proj-3-tuple(v_695),3-proj-3-tuple(v_695)))) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-3-tuple(v_702))))) then symmetricstatepack(1-proj-3-tuple(v_702),2-proj-3-tuple(v_702),hash(3-proj-3-tuple(v_702),3-proj-3-tuple(v_686))) else fail-any) else fail-any)) in
        {127}let v_704: bitstring = catch-fail((if success?(3-proj-3-tuple(v_686)) then (if (not-caught-fail(v_695) && success?(is-true(success?(1-proj-3-tuple(v_695))))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if not-caught-fail(v_703) then (v_703,2-proj-3-tuple(v_701),3-proj-3-tuple(v_701)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {128}let v_705: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_704),2-proj-7-tuple(v_685),3-proj-7-tuple(v_685),4-proj-7-tuple(v_685),5-proj-7-tuple(v_685),6-proj-7-tuple(v_685),7-proj-7-tuple(v_685))) in
        {129}let v_706: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_704))) in
        {130}let v_707: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_706),zero)) in
        {131}let v_708: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_706),zero)) in
        {132}let v_709: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_706),zero)) in
        {133}let v_710: bitstring = catch-fail((if success?(2-proj-3-tuple(v_706)) then (if not-caught-fail(v_707) then (if not-caught-fail(v_708) then (if not-caught-fail(v_709) then (v_707,v_708,v_709) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {134}let v_711: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_710)) then cipherstatepack(1-proj-3-tuple(v_710),minnonce) else fail-any)) in
        {135}let v_712: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_710)) then cipherstatepack(2-proj-3-tuple(v_710),minnonce) else fail-any)) in
        {136}let v_713: bitstring = catch-fail((if success?(1-proj-3-tuple(v_704)) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-3-tuple(v_706))))) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-3-tuple(v_710))))) then (if not-caught-fail(v_711) then (if not-caught-fail(v_712) then (1-proj-3-tuple(v_704),v_711,v_712) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {137}let (hs_714: handshakestate,plaintext_d: bitstring,valid_715: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-7-tuple(v_685))))) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then (if not-caught-fail(v_687) then (if not-caught-fail(v_694) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then (if (v_687 && 3-proj-3-tuple(v_704)) then (if not-caught-fail(v_705) then (if (not-caught-fail(v_713) && success?(is-true(success?(1-proj-3-tuple(v_713))))) then (v_705,2-proj-3-tuple(v_704),true,2-proj-3-tuple(v_713),3-proj-3-tuple(v_713)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {138}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {139}insert statestore(alice,bob,sid,statepack_e(hs_714,cs1,cs2))
    ) | (
        {141}!
        {160}get statestore(=alice,=bob,=sid,statepack_e(hs_716: handshakestate,cs1_717: cipherstate,cs2_718: cipherstate)) in
        {142}let hs_719: handshakestate = handshakestatesetcs(hs_716,cs1_717) in
        {143}let v_720: bitstring = catch-fail(handshakestateunpack(hs_719)) in
        {144}let v_721: bitstring = catch-fail((empty,empty,empty)) in
        {145}let v_722: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_720))) in
        {146}let v_723: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_722))) in
        {147}let v_724: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_723),2-proj-2-tuple(v_723),3-proj-3-tuple(v_722),msg_e(alice,bob,sid))) in
        {148}let v_725: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_722))) in
        {149}let v_726: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_723))) && success?(1-proj-3-tuple(v_722))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then cipherstatepack(1-proj-2-tuple(v_725),increment_nonce(2-proj-2-tuple(v_723))) else fail-any) else fail-any)) in
        {150}let v_727: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_722)) && success?(1-proj-3-tuple(v_722))) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-2-tuple(v_723))))) then (if not-caught-fail(v_724) then (if not-caught-fail(v_726) then (v_726,v_724) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {151}let v_728: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_727),2-proj-3-tuple(v_722),3-proj-3-tuple(v_722)))) in
        {152}let v_729: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_727)) && success?(symmetricstatepack(1-proj-2-tuple(v_727),2-proj-3-tuple(v_722),3-proj-3-tuple(v_722)))) then (if (not-caught-fail(v_728) && success?(is-true(success?(1-proj-3-tuple(v_728))))) then symmetricstatepack(1-proj-3-tuple(v_728),2-proj-3-tuple(v_728),hash(3-proj-3-tuple(v_728),2-proj-2-tuple(v_727))) else fail-any) else fail-any)) in
        {153}let v_730: bitstring = catch-fail((if success?(1-proj-7-tuple(v_720)) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-3-tuple(v_722))))) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-2-tuple(v_727))))) then (if not-caught-fail(v_729) then (v_729,2-proj-2-tuple(v_727)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {154}let v_731: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_730),2-proj-7-tuple(v_720),3-proj-7-tuple(v_720),4-proj-7-tuple(v_720),5-proj-7-tuple(v_720),6-proj-7-tuple(v_720),7-proj-7-tuple(v_720))) in
        {155}let v_732: bitstring = catch-fail(concat3(1-proj-3-tuple(v_721),2-proj-3-tuple(v_721),2-proj-2-tuple(v_730))) in
        {156}let (hs_733: handshakestate,message_e: bitstring) = (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-7-tuple(v_720))))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-3-tuple(v_721))))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-2-tuple(v_730))))) then (if not-caught-fail(v_731) then (if not-caught-fail(v_732) then (v_731,v_732) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {157}event SendMsg(alice,bob,stagepack_e(sid),msg_e(alice,bob,sid));
        {158}insert statestore(alice,bob,sid,statepack_f(hs_733,handshakestategetcs(hs_733),cs2_718));
        {159}out(pub, message_e)
    ) | (
        {161}!
        {181}get statestore(=alice,=bob,=sid,statepack_f(hs_734: handshakestate,cs1_735: cipherstate,cs2_736: cipherstate)) in
        {162}let hs_737: handshakestate = handshakestatesetcs(hs_734,cs2_736) in
        {163}in(pub, message_f: bitstring);
        {164}let v_738: bitstring = catch-fail(handshakestateunpack(hs_737)) in
        {165}let v_739: bitstring = catch-fail(deconcat3(message_f)) in
        {166}let v_740: bool = catch-fail(true) in
        {167}let v_741: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_738))) in
        {168}let v_742: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_741))) in
        {169}let v_743: aead = catch-fail(decrypt(1-proj-2-tuple(v_742),2-proj-2-tuple(v_742),3-proj-3-tuple(v_741),3-proj-3-tuple(v_739))) in
        {170}let v_744: bitstring = catch-fail(aeadunpack(v_743)) in
        {171}let v_745: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_741))) in
        {172}let v_746: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_742))) && success?(1-proj-3-tuple(v_741))) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then cipherstatepack(1-proj-2-tuple(v_745),increment_nonce(2-proj-2-tuple(v_742))) else fail-any) else fail-any)) in
        {173}let v_747: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_739)) && (success?(3-proj-3-tuple(v_741)) && success?(1-proj-3-tuple(v_741)))) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-2-tuple(v_742))))) then (if not-caught-fail(v_743) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-3-tuple(v_744))))) then (if not-caught-fail(v_746) then (v_746,3-proj-3-tuple(v_744),1-proj-3-tuple(v_744)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {174}let v_748: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_747),2-proj-3-tuple(v_741),3-proj-3-tuple(v_741)))) in
        {175}let v_749: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_739)) && success?(symmetricstatepack(1-proj-3-tuple(v_747),2-proj-3-tuple(v_741),3-proj-3-tuple(v_741)))) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-3-tuple(v_748))))) then symmetricstatepack(1-proj-3-tuple(v_748),2-proj-3-tuple(v_748),hash(3-proj-3-tuple(v_748),3-proj-3-tuple(v_739))) else fail-any) else fail-any)) in
        {176}let v_750: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_739)) && success?(1-proj-7-tuple(v_738))) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-3-tuple(v_741))))) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-3-tuple(v_747))))) then (if not-caught-fail(v_749) then (v_749,2-proj-3-tuple(v_747),3-proj-3-tuple(v_747)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {177}let v_751: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_750),2-proj-7-tuple(v_738),3-proj-7-tuple(v_738),4-proj-7-tuple(v_738),5-proj-7-tuple(v_738),6-proj-7-tuple(v_738),7-proj-7-tuple(v_738))) in
        {178}let (hs_752: handshakestate,plaintext_f: bitstring,valid_753: bool) = (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-7-tuple(v_738))))) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then (if not-caught-fail(v_740) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then (if (v_740 && 3-proj-3-tuple(v_750)) then (if not-caught-fail(v_751) then (v_751,2-proj-3-tuple(v_750),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {179}event RecvMsg(alice,bob,stagepack_f(sid),plaintext_f);
        {180}event RecvEnd(valid_753)
    ) | (
        {182}event LeakS(phase0,alice);
        {183}out(pub, key_s(alice))
    ) | (
        {184}phase 1;
        {185}event LeakS(phase1,alice);
        {186}out(pub, key_s(alice))
    )
) | (
    {187}let s_754: keypair = keypairpack(empty,empty) in
    {188}out(pub, getpublickey(s_754));
    (
        {189}let e_755: keypair = keypairpack(empty,empty) in
        {190}let v_756: key = catch-fail(dhexp(key_s(charlie),g)) in
        {191}let rs_757: key = getpublickey((if not-caught-fail(v_756) then keypairpack(v_756,key_s(charlie)) else fail-any)) in
        {192}let re_758: key = empty in
        {193}let v_759: bitstring = catch-fail(hash(somename,empty)) in
        {194}let v_760: key = catch-fail(v_759) in
        {195}let v_761: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {196}let v_762: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (if not-caught-fail(v_761) then symmetricstatepack(v_761,v_760,v_759) else fail-any) else fail-any) else fail-any))) in
        {197}let v_763: symmetricstate = catch-fail((if success?((if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (if not-caught-fail(v_761) then symmetricstatepack(v_761,v_760,v_759) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then symmetricstatepack(1-proj-3-tuple(v_762),2-proj-3-tuple(v_762),hash(3-proj-3-tuple(v_762),empty)) else fail-any) else fail-any)) in
        {198}let v_764: bitstring = catch-fail(symmetricstateunpack(v_763)) in
        {199}let v_765: symmetricstate = catch-fail((if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-3-tuple(v_764))))) then symmetricstatepack(1-proj-3-tuple(v_764),2-proj-3-tuple(v_764),hash(3-proj-3-tuple(v_764),rs_757)) else fail-any)) in
        {200}let hs_766: handshakestate = (if not-caught-fail(v_763) then (if not-caught-fail(v_765) then handshakestatepack(v_765,s_754,e_755,rs_757,re_758,empty,true) else fail-any) else fail-any) in
        {201}insert statestore(alice,charlie,sid,statepack_a(hs_766))
    ) | (
        {231}get statestore(=alice,=charlie,=sid,statepack_a(hs_767: handshakestate)) in
        {202}let v_768: bitstring = catch-fail(handshakestateunpack(hs_767)) in
        {203}let v_769: bitstring = catch-fail((empty,empty,empty)) in
        {204}let v_770: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {205}let v_771: keypair = catch-fail((if not-caught-fail(v_770) then keypairpack(v_770,key_e(alice,charlie,sid)) else fail-any)) in
        {206}let v_772: bitstring = catch-fail(getpublickey(v_771)) in
        {207}let v_773: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_768))) in
        {208}let v_774: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_768)) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then symmetricstatepack(1-proj-3-tuple(v_773),2-proj-3-tuple(v_773),hash(3-proj-3-tuple(v_773),v_772)) else fail-any) else fail-any)) in
        {209}let v_775: bitstring = catch-fail(keypairunpack(v_771)) in
        {210}let v_776: bitstring = catch-fail(symmetricstateunpack(v_774)) in
        {211}let v_777: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_776),(if success?(4-proj-7-tuple(v_768)) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then dhexp(2-proj-2-tuple(v_775),4-proj-7-tuple(v_768)) else fail-any) else fail-any))) in
        {212}let v_778: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_776),(if success?(4-proj-7-tuple(v_768)) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then dhexp(2-proj-2-tuple(v_775),4-proj-7-tuple(v_768)) else fail-any) else fail-any))) in
        {213}let v_779: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_776),(if success?(4-proj-7-tuple(v_768)) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then dhexp(2-proj-2-tuple(v_775),4-proj-7-tuple(v_768)) else fail-any) else fail-any))) in
        {214}let v_780: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_768)) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then dhexp(2-proj-2-tuple(v_775),4-proj-7-tuple(v_768)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_776))) then (if not-caught-fail(v_777) then (if not-caught-fail(v_778) then (if not-caught-fail(v_779) then (v_777,v_778,v_779) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {215}let v_781: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_768)) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then dhexp(2-proj-2-tuple(v_775),4-proj-7-tuple(v_768)) else fail-any) else fail-any)) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-3-tuple(v_776))))) then (if (not-caught-fail(v_780) && success?(is-true(success?(1-proj-3-tuple(v_780))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_780)) then cipherstatepack(2-proj-3-tuple(v_780),minnonce) else fail-any),1-proj-3-tuple(v_780),3-proj-3-tuple(v_776)) else fail-any) else fail-any) else fail-any)) in
        {216}let v_782: bitstring = catch-fail(symmetricstateunpack(v_781)) in
        {217}let v_783: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_782))) in
        {218}let v_784: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_783),2-proj-2-tuple(v_783),3-proj-3-tuple(v_782),msg_a(alice,charlie,sid))) in
        {219}let v_785: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_782))) in
        {220}let v_786: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_783))) && success?(1-proj-3-tuple(v_782))) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then cipherstatepack(1-proj-2-tuple(v_785),increment_nonce(2-proj-2-tuple(v_783))) else fail-any) else fail-any)) in
        {221}let v_787: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_782)) && success?(1-proj-3-tuple(v_782))) then (if (not-caught-fail(v_783) && success?(is-true(success?(1-proj-2-tuple(v_783))))) then (if not-caught-fail(v_784) then (if not-caught-fail(v_786) then (v_786,v_784) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {222}let v_788: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_787),2-proj-3-tuple(v_782),3-proj-3-tuple(v_782)))) in
        {223}let v_789: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_787)) && success?(symmetricstatepack(1-proj-2-tuple(v_787),2-proj-3-tuple(v_782),3-proj-3-tuple(v_782)))) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-3-tuple(v_788))))) then symmetricstatepack(1-proj-3-tuple(v_788),2-proj-3-tuple(v_788),hash(3-proj-3-tuple(v_788),2-proj-2-tuple(v_787))) else fail-any) else fail-any)) in
        {224}let v_790: bitstring = catch-fail((if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-2-tuple(v_787))))) then (if not-caught-fail(v_789) then (v_789,2-proj-2-tuple(v_787)) else fail-any) else fail-any) else fail-any)) in
        {225}let v_791: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_790),2-proj-7-tuple(v_768),v_771,4-proj-7-tuple(v_768),5-proj-7-tuple(v_768),6-proj-7-tuple(v_768),7-proj-7-tuple(v_768))) in
        {226}let v_792: bitstring = catch-fail(concat3(v_772,2-proj-3-tuple(v_769),2-proj-2-tuple(v_790))) in
        {227}let (hs_793: handshakestate,message_a_794: bitstring) = (if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-7-tuple(v_768))))) then (if (not-caught-fail(v_769) && success?(is-true(success?(1-proj-3-tuple(v_769))))) then (if not-caught-fail(v_771) then (if not-caught-fail(v_772) then (if not-caught-fail(v_774) then (if not-caught-fail(v_781) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-2-tuple(v_790))))) then (if not-caught-fail(v_791) then (if not-caught-fail(v_792) then (v_791,v_792) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {228}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {229}insert statestore(alice,charlie,sid,statepack_b(hs_793));
        {230}out(pub, message_a_794)
    ) | (
        {260}get statestore(=alice,=charlie,=sid,statepack_b(hs_795: handshakestate)) in
        {232}in(pub, message_b_796: bitstring);
        {233}let v_797: bitstring = catch-fail(handshakestateunpack(hs_795)) in
        {234}let v_798: bitstring = catch-fail(deconcat3(message_b_796)) in
        {235}let v_799: bool = catch-fail(true) in
        {236}let v_800: key = catch-fail(1-proj-3-tuple(v_798)) in
        {237}let v_801: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_797))) in
        {238}let v_802: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_797)) then (if (not-caught-fail(v_801) && success?(is-true(success?(1-proj-3-tuple(v_801))))) then symmetricstatepack(1-proj-3-tuple(v_801),2-proj-3-tuple(v_801),hash(3-proj-3-tuple(v_801),v_800)) else fail-any) else fail-any)) in
        {239}let v_803: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_797))) in
        {240}let v_804: bitstring = catch-fail(symmetricstateunpack(v_802)) in
        {241}let v_805: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_804),(if success?(3-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {242}let v_806: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_804),(if success?(3-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {243}let v_807: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_804),(if success?(3-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {244}let v_808: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_804))) then (if not-caught-fail(v_805) then (if not-caught-fail(v_806) then (if not-caught-fail(v_807) then (v_805,v_806,v_807) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {245}let v_809: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any)) then (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-3-tuple(v_804))))) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_808)) then cipherstatepack(2-proj-3-tuple(v_808),minnonce) else fail-any),1-proj-3-tuple(v_808),3-proj-3-tuple(v_804)) else fail-any) else fail-any) else fail-any)) in
        {246}let v_810: bitstring = catch-fail(symmetricstateunpack(v_809)) in
        {247}let v_811: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {248}let v_812: aead = catch-fail(decrypt(1-proj-2-tuple(v_811),2-proj-2-tuple(v_811),3-proj-3-tuple(v_810),3-proj-3-tuple(v_798))) in
        {249}let v_813: bitstring = catch-fail(aeadunpack(v_812)) in
        {250}let v_814: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {251}let v_815: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_811))) && success?(1-proj-3-tuple(v_810))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then cipherstatepack(1-proj-2-tuple(v_814),increment_nonce(2-proj-2-tuple(v_811))) else fail-any) else fail-any)) in
        {252}let v_816: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_798)) && (success?(3-proj-3-tuple(v_810)) && success?(1-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-2-tuple(v_811))))) then (if not-caught-fail(v_812) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-3-tuple(v_813))))) then (if not-caught-fail(v_815) then (v_815,3-proj-3-tuple(v_813),1-proj-3-tuple(v_813)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {253}let v_817: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) in
        {254}let v_818: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_798)) && success?(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then symmetricstatepack(1-proj-3-tuple(v_817),2-proj-3-tuple(v_817),hash(3-proj-3-tuple(v_817),3-proj-3-tuple(v_798))) else fail-any) else fail-any)) in
        {255}let v_819: bitstring = catch-fail((if success?(3-proj-3-tuple(v_798)) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-3-tuple(v_816))))) then (if not-caught-fail(v_818) then (v_818,2-proj-3-tuple(v_816),3-proj-3-tuple(v_816)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {256}let v_820: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_819),2-proj-7-tuple(v_797),3-proj-7-tuple(v_797),4-proj-7-tuple(v_797),v_800,6-proj-7-tuple(v_797),7-proj-7-tuple(v_797))) in
        {257}let (hs_821: handshakestate,plaintext_b_822: bitstring,valid_823: bool) = (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-7-tuple(v_797))))) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-3-tuple(v_798))))) then (if not-caught-fail(v_799) then (if not-caught-fail(v_800) then (if not-caught-fail(v_802) then (if not-caught-fail(v_809) then (if (not-caught-fail(v_819) && success?(is-true(success?(1-proj-3-tuple(v_819))))) then (if (v_799 && 3-proj-3-tuple(v_819)) then (if not-caught-fail(v_820) then (v_820,2-proj-3-tuple(v_819),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {258}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_822);
        {259}insert statestore(alice,charlie,sid,statepack_c(hs_821))
    ) | (
        {289}get statestore(=alice,=charlie,=sid,statepack_c(hs_824: handshakestate)) in
        {261}let v_825: bitstring = catch-fail(handshakestateunpack(hs_824)) in
        {262}let v_826: bitstring = catch-fail((empty,empty,empty)) in
        {263}let v_827: key = catch-fail(dhexp(key_s(alice),g)) in
        {264}let v_828: keypair = catch-fail((if not-caught-fail(v_827) then keypairpack(v_827,key_s(alice)) else fail-any)) in
        {265}let v_829: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_825))) in
        {266}let v_830: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_829))) in
        {267}let v_831: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_830),2-proj-2-tuple(v_830),3-proj-3-tuple(v_829),getpublickey(v_828))) in
        {268}let v_832: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_829))) in
        {269}let v_833: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_830))) && success?(1-proj-3-tuple(v_829))) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then cipherstatepack(1-proj-2-tuple(v_832),increment_nonce(2-proj-2-tuple(v_830))) else fail-any) else fail-any)) in
        {270}let v_834: bitstring = catch-fail((if (success?(getpublickey(v_828)) && (success?(3-proj-3-tuple(v_829)) && success?(1-proj-3-tuple(v_829)))) then (if (not-caught-fail(v_830) && success?(is-true(success?(1-proj-2-tuple(v_830))))) then (if not-caught-fail(v_831) then (if not-caught-fail(v_833) then (v_833,v_831) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {271}let v_835: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_834),2-proj-3-tuple(v_829),3-proj-3-tuple(v_829)))) in
        {272}let v_836: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_834)) && success?(symmetricstatepack(1-proj-2-tuple(v_834),2-proj-3-tuple(v_829),3-proj-3-tuple(v_829)))) then (if (not-caught-fail(v_835) && success?(is-true(success?(1-proj-3-tuple(v_835))))) then symmetricstatepack(1-proj-3-tuple(v_835),2-proj-3-tuple(v_835),hash(3-proj-3-tuple(v_835),2-proj-2-tuple(v_834))) else fail-any) else fail-any)) in
        {273}let v_837: bitstring = catch-fail((if (success?(getpublickey(v_828)) && success?(1-proj-7-tuple(v_825))) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then (if not-caught-fail(v_836) then (v_836,2-proj-2-tuple(v_834)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {274}let v_838: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_837))) in
        {275}let v_839: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_838))) in
        {276}let v_840: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_839),2-proj-2-tuple(v_839),3-proj-3-tuple(v_838),msg_c(alice,charlie,sid))) in
        {277}let v_841: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_838))) in
        {278}let v_842: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_839))) && success?(1-proj-3-tuple(v_838))) then (if (not-caught-fail(v_841) && success?(is-true(success?(1-proj-2-tuple(v_841))))) then cipherstatepack(1-proj-2-tuple(v_841),increment_nonce(2-proj-2-tuple(v_839))) else fail-any) else fail-any)) in
        {279}let v_843: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_838)) && success?(1-proj-3-tuple(v_838))) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-2-tuple(v_839))))) then (if not-caught-fail(v_840) then (if not-caught-fail(v_842) then (v_842,v_840) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {280}let v_844: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_843),2-proj-3-tuple(v_838),3-proj-3-tuple(v_838)))) in
        {281}let v_845: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_843)) && success?(symmetricstatepack(1-proj-2-tuple(v_843),2-proj-3-tuple(v_838),3-proj-3-tuple(v_838)))) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-3-tuple(v_844))))) then symmetricstatepack(1-proj-3-tuple(v_844),2-proj-3-tuple(v_844),hash(3-proj-3-tuple(v_844),2-proj-2-tuple(v_843))) else fail-any) else fail-any)) in
        {282}let v_846: bitstring = catch-fail((if success?(1-proj-2-tuple(v_837)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-3-tuple(v_838))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-2-tuple(v_843))))) then (if not-caught-fail(v_845) then (v_845,2-proj-2-tuple(v_843)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {283}let v_847: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_846),v_828,3-proj-7-tuple(v_825),4-proj-7-tuple(v_825),5-proj-7-tuple(v_825),6-proj-7-tuple(v_825),7-proj-7-tuple(v_825))) in
        {284}let v_848: bitstring = catch-fail(concat3(1-proj-3-tuple(v_826),2-proj-2-tuple(v_837),2-proj-2-tuple(v_846))) in
        {285}let (hs_849: handshakestate,message_c_850: bitstring) = (if (not-caught-fail(v_825) && success?(is-true(success?(1-proj-7-tuple(v_825))))) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then (if not-caught-fail(v_828) then (if (not-caught-fail(v_837) && success?(is-true(success?(1-proj-2-tuple(v_837))))) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-2-tuple(v_846))))) then (if not-caught-fail(v_847) then (if not-caught-fail(v_848) then (v_847,v_848) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {286}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {287}insert statestore(alice,charlie,sid,statepack_d(hs_849));
        {288}out(pub, message_c_850)
    ) | (
        {323}get statestore(=alice,=charlie,=sid,statepack_d(hs_851: handshakestate)) in
        {290}in(pub, message_d_852: bitstring);
        {291}let v_853: bitstring = catch-fail(handshakestateunpack(hs_851)) in
        {292}let v_854: bitstring = catch-fail(deconcat3(message_d_852)) in
        {293}let v_855: bool = catch-fail(true) in
        {294}let v_856: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_853))) in
        {295}let v_857: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_853))) in
        {296}let v_858: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_857),(if (success?(5-proj-7-tuple(v_853)) && success?(2-proj-7-tuple(v_853))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_853)) else fail-any) else fail-any))) in
        {297}let v_859: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_857),(if (success?(5-proj-7-tuple(v_853)) && success?(2-proj-7-tuple(v_853))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_853)) else fail-any) else fail-any))) in
        {298}let v_860: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_857),(if (success?(5-proj-7-tuple(v_853)) && success?(2-proj-7-tuple(v_853))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_853)) else fail-any) else fail-any))) in
        {299}let v_861: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_853)) && success?(2-proj-7-tuple(v_853))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_853)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_857))) then (if not-caught-fail(v_858) then (if not-caught-fail(v_859) then (if not-caught-fail(v_860) then (v_858,v_859,v_860) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {300}let v_862: symmetricstate = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_853)) && success?(2-proj-7-tuple(v_853))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_853)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_853))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then (if (not-caught-fail(v_861) && success?(is-true(success?(1-proj-3-tuple(v_861))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_861)) then cipherstatepack(2-proj-3-tuple(v_861),minnonce) else fail-any),1-proj-3-tuple(v_861),3-proj-3-tuple(v_857)) else fail-any) else fail-any) else fail-any)) in
        {301}let v_863: bitstring = catch-fail(symmetricstateunpack(v_862)) in
        {302}let v_864: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {303}let v_865: aead = catch-fail(decrypt(1-proj-2-tuple(v_864),2-proj-2-tuple(v_864),3-proj-3-tuple(v_863),3-proj-3-tuple(v_854))) in
        {304}let v_866: bitstring = catch-fail(aeadunpack(v_865)) in
        {305}let v_867: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {306}let v_868: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_864))) && success?(1-proj-3-tuple(v_863))) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-2-tuple(v_867))))) then cipherstatepack(1-proj-2-tuple(v_867),increment_nonce(2-proj-2-tuple(v_864))) else fail-any) else fail-any)) in
        {307}let v_869: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_854)) && (success?(3-proj-3-tuple(v_863)) && success?(1-proj-3-tuple(v_863)))) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-2-tuple(v_864))))) then (if not-caught-fail(v_865) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then (if not-caught-fail(v_868) then (v_868,3-proj-3-tuple(v_866),1-proj-3-tuple(v_866)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {308}let v_870: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_869),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) in
        {309}let v_871: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_854)) && success?(symmetricstatepack(1-proj-3-tuple(v_869),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-3-tuple(v_870))))) then symmetricstatepack(1-proj-3-tuple(v_870),2-proj-3-tuple(v_870),hash(3-proj-3-tuple(v_870),3-proj-3-tuple(v_854))) else fail-any) else fail-any)) in
        {310}let v_872: bitstring = catch-fail((if success?(3-proj-3-tuple(v_854)) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-3-tuple(v_863))))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-3-tuple(v_869))))) then (if not-caught-fail(v_871) then (v_871,2-proj-3-tuple(v_869),3-proj-3-tuple(v_869)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {311}let v_873: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_872),2-proj-7-tuple(v_853),3-proj-7-tuple(v_853),4-proj-7-tuple(v_853),5-proj-7-tuple(v_853),6-proj-7-tuple(v_853),7-proj-7-tuple(v_853))) in
        {312}let v_874: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_872))) in
        {313}let v_875: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_874),zero)) in
        {314}let v_876: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_874),zero)) in
        {315}let v_877: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_874),zero)) in
        {316}let v_878: bitstring = catch-fail((if success?(2-proj-3-tuple(v_874)) then (if not-caught-fail(v_875) then (if not-caught-fail(v_876) then (if not-caught-fail(v_877) then (v_875,v_876,v_877) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {317}let v_879: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_878)) then cipherstatepack(1-proj-3-tuple(v_878),minnonce) else fail-any)) in
        {318}let v_880: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_878)) then cipherstatepack(2-proj-3-tuple(v_878),minnonce) else fail-any)) in
        {319}let v_881: bitstring = catch-fail((if success?(1-proj-3-tuple(v_872)) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-3-tuple(v_878))))) then (if not-caught-fail(v_879) then (if not-caught-fail(v_880) then (1-proj-3-tuple(v_872),v_879,v_880) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {320}let (hs_882: handshakestate,plaintext_d_883: bitstring,valid_884: bool,cs1_885: cipherstate,cs2_886: cipherstate) = (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-7-tuple(v_853))))) then (if (not-caught-fail(v_854) && success?(is-true(success?(1-proj-3-tuple(v_854))))) then (if not-caught-fail(v_855) then (if not-caught-fail(v_862) then (if (not-caught-fail(v_872) && success?(is-true(success?(1-proj-3-tuple(v_872))))) then (if (v_855 && 3-proj-3-tuple(v_872)) then (if not-caught-fail(v_873) then (if (not-caught-fail(v_881) && success?(is-true(success?(1-proj-3-tuple(v_881))))) then (v_873,2-proj-3-tuple(v_872),true,2-proj-3-tuple(v_881),3-proj-3-tuple(v_881)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {321}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_883);
        {322}insert statestore(alice,charlie,sid,statepack_e(hs_882,cs1_885,cs2_886))
    ) | (
        {324}!
        {343}get statestore(=alice,=charlie,=sid,statepack_e(hs_887: handshakestate,cs1_888: cipherstate,cs2_889: cipherstate)) in
        {325}let hs_890: handshakestate = handshakestatesetcs(hs_887,cs1_888) in
        {326}let v_891: bitstring = catch-fail(handshakestateunpack(hs_890)) in
        {327}let v_892: bitstring = catch-fail((empty,empty,empty)) in
        {328}let v_893: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_891))) in
        {329}let v_894: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_893))) in
        {330}let v_895: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_894),2-proj-2-tuple(v_894),3-proj-3-tuple(v_893),msg_e(alice,charlie,sid))) in
        {331}let v_896: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_893))) in
        {332}let v_897: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_894))) && success?(1-proj-3-tuple(v_893))) then (if (not-caught-fail(v_896) && success?(is-true(success?(1-proj-2-tuple(v_896))))) then cipherstatepack(1-proj-2-tuple(v_896),increment_nonce(2-proj-2-tuple(v_894))) else fail-any) else fail-any)) in
        {333}let v_898: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_893)) && success?(1-proj-3-tuple(v_893))) then (if (not-caught-fail(v_894) && success?(is-true(success?(1-proj-2-tuple(v_894))))) then (if not-caught-fail(v_895) then (if not-caught-fail(v_897) then (v_897,v_895) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {334}let v_899: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_898),2-proj-3-tuple(v_893),3-proj-3-tuple(v_893)))) in
        {335}let v_900: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_898)) && success?(symmetricstatepack(1-proj-2-tuple(v_898),2-proj-3-tuple(v_893),3-proj-3-tuple(v_893)))) then (if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-3-tuple(v_899))))) then symmetricstatepack(1-proj-3-tuple(v_899),2-proj-3-tuple(v_899),hash(3-proj-3-tuple(v_899),2-proj-2-tuple(v_898))) else fail-any) else fail-any)) in
        {336}let v_901: bitstring = catch-fail((if success?(1-proj-7-tuple(v_891)) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-3-tuple(v_893))))) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-2-tuple(v_898))))) then (if not-caught-fail(v_900) then (v_900,2-proj-2-tuple(v_898)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {337}let v_902: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_901),2-proj-7-tuple(v_891),3-proj-7-tuple(v_891),4-proj-7-tuple(v_891),5-proj-7-tuple(v_891),6-proj-7-tuple(v_891),7-proj-7-tuple(v_891))) in
        {338}let v_903: bitstring = catch-fail(concat3(1-proj-3-tuple(v_892),2-proj-3-tuple(v_892),2-proj-2-tuple(v_901))) in
        {339}let (hs_904: handshakestate,message_e_905: bitstring) = (if (not-caught-fail(v_891) && success?(is-true(success?(1-proj-7-tuple(v_891))))) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-2-tuple(v_901))))) then (if not-caught-fail(v_902) then (if not-caught-fail(v_903) then (v_902,v_903) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {340}event SendMsg(alice,charlie,stagepack_e(sid),msg_e(alice,charlie,sid));
        {341}insert statestore(alice,charlie,sid,statepack_f(hs_904,handshakestategetcs(hs_904),cs2_889));
        {342}out(pub, message_e_905)
    ) | (
        {344}!
        {364}get statestore(=alice,=charlie,=sid,statepack_f(hs_906: handshakestate,cs1_907: cipherstate,cs2_908: cipherstate)) in
        {345}let hs_909: handshakestate = handshakestatesetcs(hs_906,cs2_908) in
        {346}in(pub, message_f_910: bitstring);
        {347}let v_911: bitstring = catch-fail(handshakestateunpack(hs_909)) in
        {348}let v_912: bitstring = catch-fail(deconcat3(message_f_910)) in
        {349}let v_913: bool = catch-fail(true) in
        {350}let v_914: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_911))) in
        {351}let v_915: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_914))) in
        {352}let v_916: aead = catch-fail(decrypt(1-proj-2-tuple(v_915),2-proj-2-tuple(v_915),3-proj-3-tuple(v_914),3-proj-3-tuple(v_912))) in
        {353}let v_917: bitstring = catch-fail(aeadunpack(v_916)) in
        {354}let v_918: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_914))) in
        {355}let v_919: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_915))) && success?(1-proj-3-tuple(v_914))) then (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-2-tuple(v_918))))) then cipherstatepack(1-proj-2-tuple(v_918),increment_nonce(2-proj-2-tuple(v_915))) else fail-any) else fail-any)) in
        {356}let v_920: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_912)) && (success?(3-proj-3-tuple(v_914)) && success?(1-proj-3-tuple(v_914)))) then (if (not-caught-fail(v_915) && success?(is-true(success?(1-proj-2-tuple(v_915))))) then (if not-caught-fail(v_916) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then (if not-caught-fail(v_919) then (v_919,3-proj-3-tuple(v_917),1-proj-3-tuple(v_917)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {357}let v_921: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_920),2-proj-3-tuple(v_914),3-proj-3-tuple(v_914)))) in
        {358}let v_922: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_912)) && success?(symmetricstatepack(1-proj-3-tuple(v_920),2-proj-3-tuple(v_914),3-proj-3-tuple(v_914)))) then (if (not-caught-fail(v_921) && success?(is-true(success?(1-proj-3-tuple(v_921))))) then symmetricstatepack(1-proj-3-tuple(v_921),2-proj-3-tuple(v_921),hash(3-proj-3-tuple(v_921),3-proj-3-tuple(v_912))) else fail-any) else fail-any)) in
        {359}let v_923: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_912)) && success?(1-proj-7-tuple(v_911))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-3-tuple(v_914))))) then (if (not-caught-fail(v_920) && success?(is-true(success?(1-proj-3-tuple(v_920))))) then (if not-caught-fail(v_922) then (v_922,2-proj-3-tuple(v_920),3-proj-3-tuple(v_920)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {360}let v_924: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_923),2-proj-7-tuple(v_911),3-proj-7-tuple(v_911),4-proj-7-tuple(v_911),5-proj-7-tuple(v_911),6-proj-7-tuple(v_911),7-proj-7-tuple(v_911))) in
        {361}let (hs_925: handshakestate,plaintext_f_926: bitstring,valid_927: bool) = (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-7-tuple(v_911))))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-3-tuple(v_912))))) then (if not-caught-fail(v_913) then (if (not-caught-fail(v_923) && success?(is-true(success?(1-proj-3-tuple(v_923))))) then (if (v_913 && 3-proj-3-tuple(v_923)) then (if not-caught-fail(v_924) then (v_924,2-proj-3-tuple(v_923),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {362}event RecvMsg(alice,charlie,stagepack_f(sid),plaintext_f_926);
        {363}event RecvEnd(valid_927)
    ) | (
        {365}event LeakS(phase0,alice);
        {366}out(pub, key_s(alice))
    ) | (
        {367}phase 1;
        {368}event LeakS(phase1,alice);
        {369}out(pub, key_s(alice))
    )
) | (
    {370}let v_928: key = catch-fail(dhexp(key_s(bob),g)) in
    {371}let s_929: keypair = (if not-caught-fail(v_928) then keypairpack(v_928,key_s(bob)) else fail-any) in
    {372}out(pub, getpublickey(s_929));
    (
        {373}let e_930: keypair = keypairpack(empty,empty) in
        {374}let rs_931: key = empty in
        {375}let re_932: key = empty in
        {376}let v_933: bitstring = catch-fail(hash(somename,empty)) in
        {377}let v_934: key = catch-fail(v_933) in
        {378}let v_935: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {379}let v_936: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_933) then (if not-caught-fail(v_934) then (if not-caught-fail(v_935) then symmetricstatepack(v_935,v_934,v_933) else fail-any) else fail-any) else fail-any))) in
        {380}let v_937: symmetricstate = catch-fail((if success?((if not-caught-fail(v_933) then (if not-caught-fail(v_934) then (if not-caught-fail(v_935) then symmetricstatepack(v_935,v_934,v_933) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_936),hash(3-proj-3-tuple(v_936),empty)) else fail-any) else fail-any)) in
        {381}let v_938: bitstring = catch-fail(symmetricstateunpack(v_937)) in
        {382}let v_939: symmetricstate = catch-fail((if success?(getpublickey(s_929)) then (if (not-caught-fail(v_938) && success?(is-true(success?(1-proj-3-tuple(v_938))))) then symmetricstatepack(1-proj-3-tuple(v_938),2-proj-3-tuple(v_938),hash(3-proj-3-tuple(v_938),getpublickey(s_929))) else fail-any) else fail-any)) in
        {383}let hs_940: handshakestate = (if not-caught-fail(v_937) then (if not-caught-fail(v_939) then handshakestatepack(v_939,s_929,e_930,rs_931,re_932,empty,false) else fail-any) else fail-any) in
        {384}insert statestore(bob,alice,sid,statepack_a(hs_940))
    ) | (
        {413}get statestore(=bob,=alice,=sid,statepack_a(hs_941: handshakestate)) in
        {385}in(pub, message_a_942: bitstring);
        {386}let v_943: bitstring = catch-fail(handshakestateunpack(hs_941)) in
        {387}let v_944: bitstring = catch-fail(deconcat3(message_a_942)) in
        {388}let v_945: bool = catch-fail(true) in
        {389}let v_946: key = catch-fail(1-proj-3-tuple(v_944)) in
        {390}let v_947: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_943))) in
        {391}let v_948: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_943)) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then symmetricstatepack(1-proj-3-tuple(v_947),2-proj-3-tuple(v_947),hash(3-proj-3-tuple(v_947),v_946)) else fail-any) else fail-any)) in
        {392}let v_949: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_943))) in
        {393}let v_950: bitstring = catch-fail(symmetricstateunpack(v_948)) in
        {394}let v_951: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_950),(if success?(2-proj-7-tuple(v_943)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),v_946) else fail-any) else fail-any))) in
        {395}let v_952: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_950),(if success?(2-proj-7-tuple(v_943)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),v_946) else fail-any) else fail-any))) in
        {396}let v_953: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_950),(if success?(2-proj-7-tuple(v_943)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),v_946) else fail-any) else fail-any))) in
        {397}let v_954: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_943)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),v_946) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_950))) then (if not-caught-fail(v_951) then (if not-caught-fail(v_952) then (if not-caught-fail(v_953) then (v_951,v_952,v_953) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {398}let v_955: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_943)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),v_946) else fail-any) else fail-any)) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-3-tuple(v_950))))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-3-tuple(v_954))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_954)) then cipherstatepack(2-proj-3-tuple(v_954),minnonce) else fail-any),1-proj-3-tuple(v_954),3-proj-3-tuple(v_950)) else fail-any) else fail-any) else fail-any)) in
        {399}let v_956: bitstring = catch-fail(symmetricstateunpack(v_955)) in
        {400}let v_957: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {401}let v_958: aead = catch-fail(decrypt(1-proj-2-tuple(v_957),2-proj-2-tuple(v_957),3-proj-3-tuple(v_956),3-proj-3-tuple(v_944))) in
        {402}let v_959: bitstring = catch-fail(aeadunpack(v_958)) in
        {403}let v_960: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {404}let v_961: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_957))) && success?(1-proj-3-tuple(v_956))) then (if (not-caught-fail(v_960) && success?(is-true(success?(1-proj-2-tuple(v_960))))) then cipherstatepack(1-proj-2-tuple(v_960),increment_nonce(2-proj-2-tuple(v_957))) else fail-any) else fail-any)) in
        {405}let v_962: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_944)) && (success?(3-proj-3-tuple(v_956)) && success?(1-proj-3-tuple(v_956)))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then (if not-caught-fail(v_958) then (if (not-caught-fail(v_959) && success?(is-true(success?(1-proj-3-tuple(v_959))))) then (if not-caught-fail(v_961) then (v_961,3-proj-3-tuple(v_959),1-proj-3-tuple(v_959)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {406}let v_963: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) in
        {407}let v_964: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_944)) && success?(symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-3-tuple(v_963))))) then symmetricstatepack(1-proj-3-tuple(v_963),2-proj-3-tuple(v_963),hash(3-proj-3-tuple(v_963),3-proj-3-tuple(v_944))) else fail-any) else fail-any)) in
        {408}let v_965: bitstring = catch-fail((if success?(3-proj-3-tuple(v_944)) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then (if not-caught-fail(v_964) then (v_964,2-proj-3-tuple(v_962),3-proj-3-tuple(v_962)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {409}let v_966: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_965),2-proj-7-tuple(v_943),3-proj-7-tuple(v_943),4-proj-7-tuple(v_943),v_946,6-proj-7-tuple(v_943),7-proj-7-tuple(v_943))) in
        {410}let (hs_967: handshakestate,plaintext_a: bitstring,valid_968: bool) = (if (not-caught-fail(v_943) && success?(is-true(success?(1-proj-7-tuple(v_943))))) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then (if not-caught-fail(v_945) then (if not-caught-fail(v_946) then (if not-caught-fail(v_948) then (if not-caught-fail(v_955) then (if (not-caught-fail(v_965) && success?(is-true(success?(1-proj-3-tuple(v_965))))) then (if (v_945 && 3-proj-3-tuple(v_965)) then (if not-caught-fail(v_966) then (v_966,2-proj-3-tuple(v_965),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {411}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {412}insert statestore(bob,alice,sid,statepack_b(hs_967))
    ) | (
        {443}get statestore(=bob,=alice,=sid,statepack_b(hs_969: handshakestate)) in
        {414}let v_970: bitstring = catch-fail(handshakestateunpack(hs_969)) in
        {415}let v_971: bitstring = catch-fail((empty,empty,empty)) in
        {416}let v_972: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {417}let v_973: keypair = catch-fail((if not-caught-fail(v_972) then keypairpack(v_972,key_e(bob,alice,sid)) else fail-any)) in
        {418}let v_974: bitstring = catch-fail(getpublickey(v_973)) in
        {419}let v_975: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_970))) in
        {420}let v_976: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_970)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-3-tuple(v_975))))) then symmetricstatepack(1-proj-3-tuple(v_975),2-proj-3-tuple(v_975),hash(3-proj-3-tuple(v_975),v_974)) else fail-any) else fail-any)) in
        {421}let v_977: bitstring = catch-fail(keypairunpack(v_973)) in
        {422}let v_978: bitstring = catch-fail(symmetricstateunpack(v_976)) in
        {423}let v_979: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_978),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-2-tuple(v_977))))) then dhexp(2-proj-2-tuple(v_977),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {424}let v_980: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_978),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-2-tuple(v_977))))) then dhexp(2-proj-2-tuple(v_977),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {425}let v_981: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_978),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-2-tuple(v_977))))) then dhexp(2-proj-2-tuple(v_977),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {426}let v_982: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-2-tuple(v_977))))) then dhexp(2-proj-2-tuple(v_977),5-proj-7-tuple(v_970)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_978))) then (if not-caught-fail(v_979) then (if not-caught-fail(v_980) then (if not-caught-fail(v_981) then (v_979,v_980,v_981) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {427}let v_983: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-2-tuple(v_977))))) then dhexp(2-proj-2-tuple(v_977),5-proj-7-tuple(v_970)) else fail-any) else fail-any)) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-3-tuple(v_978))))) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-3-tuple(v_982))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_982)) then cipherstatepack(2-proj-3-tuple(v_982),minnonce) else fail-any),1-proj-3-tuple(v_982),3-proj-3-tuple(v_978)) else fail-any) else fail-any) else fail-any)) in
        {428}let v_984: bitstring = catch-fail(symmetricstateunpack(v_983)) in
        {429}let v_985: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_984))) in
        {430}let v_986: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_985),2-proj-2-tuple(v_985),3-proj-3-tuple(v_984),msg_b(bob,alice,sid))) in
        {431}let v_987: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_984))) in
        {432}let v_988: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_985))) && success?(1-proj-3-tuple(v_984))) then (if (not-caught-fail(v_987) && success?(is-true(success?(1-proj-2-tuple(v_987))))) then cipherstatepack(1-proj-2-tuple(v_987),increment_nonce(2-proj-2-tuple(v_985))) else fail-any) else fail-any)) in
        {433}let v_989: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_984)) && success?(1-proj-3-tuple(v_984))) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then (if not-caught-fail(v_986) then (if not-caught-fail(v_988) then (v_988,v_986) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {434}let v_990: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_989),2-proj-3-tuple(v_984),3-proj-3-tuple(v_984)))) in
        {435}let v_991: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_989)) && success?(symmetricstatepack(1-proj-2-tuple(v_989),2-proj-3-tuple(v_984),3-proj-3-tuple(v_984)))) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-3-tuple(v_990))))) then symmetricstatepack(1-proj-3-tuple(v_990),2-proj-3-tuple(v_990),hash(3-proj-3-tuple(v_990),2-proj-2-tuple(v_989))) else fail-any) else fail-any)) in
        {436}let v_992: bitstring = catch-fail((if (not-caught-fail(v_984) && success?(is-true(success?(1-proj-3-tuple(v_984))))) then (if (not-caught-fail(v_989) && success?(is-true(success?(1-proj-2-tuple(v_989))))) then (if not-caught-fail(v_991) then (v_991,2-proj-2-tuple(v_989)) else fail-any) else fail-any) else fail-any)) in
        {437}let v_993: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_992),2-proj-7-tuple(v_970),v_973,4-proj-7-tuple(v_970),5-proj-7-tuple(v_970),6-proj-7-tuple(v_970),7-proj-7-tuple(v_970))) in
        {438}let v_994: bitstring = catch-fail(concat3(v_974,2-proj-3-tuple(v_971),2-proj-2-tuple(v_992))) in
        {439}let (hs_995: handshakestate,message_b_996: bitstring) = (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-7-tuple(v_970))))) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-3-tuple(v_971))))) then (if not-caught-fail(v_973) then (if not-caught-fail(v_974) then (if not-caught-fail(v_976) then (if not-caught-fail(v_983) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-2-tuple(v_992))))) then (if not-caught-fail(v_993) then (if not-caught-fail(v_994) then (v_993,v_994) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {440}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {441}insert statestore(bob,alice,sid,statepack_c(hs_995));
        {442}out(pub, message_b_996)
    ) | (
        {474}get statestore(=bob,=alice,=sid,statepack_c(hs_997: handshakestate)) in
        {444}in(pub, message_c_998: bitstring);
        {445}let v_999: bitstring = catch-fail(handshakestateunpack(hs_997)) in
        {446}let v_1000: bitstring = catch-fail(deconcat3(message_c_998)) in
        {447}let v_1001: bool = catch-fail(true) in
        {448}let v_1002: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_999))) in
        {449}let v_1003: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1002))) in
        {450}let v_1004: aead = catch-fail(decrypt(1-proj-2-tuple(v_1003),2-proj-2-tuple(v_1003),3-proj-3-tuple(v_1002),2-proj-3-tuple(v_1000))) in
        {451}let v_1005: bitstring = catch-fail(aeadunpack(v_1004)) in
        {452}let v_1006: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1002))) in
        {453}let v_1007: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1003))) && success?(1-proj-3-tuple(v_1002))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-2-tuple(v_1006))))) then cipherstatepack(1-proj-2-tuple(v_1006),increment_nonce(2-proj-2-tuple(v_1003))) else fail-any) else fail-any)) in
        {454}let v_1008: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1000)) && (success?(3-proj-3-tuple(v_1002)) && success?(1-proj-3-tuple(v_1002)))) then (if (not-caught-fail(v_1003) && success?(is-true(success?(1-proj-2-tuple(v_1003))))) then (if not-caught-fail(v_1004) then (if (not-caught-fail(v_1005) && success?(is-true(success?(1-proj-3-tuple(v_1005))))) then (if not-caught-fail(v_1007) then (v_1007,3-proj-3-tuple(v_1005),1-proj-3-tuple(v_1005)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {455}let v_1009: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1008),2-proj-3-tuple(v_1002),3-proj-3-tuple(v_1002)))) in
        {456}let v_1010: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1000)) && success?(symmetricstatepack(1-proj-3-tuple(v_1008),2-proj-3-tuple(v_1002),3-proj-3-tuple(v_1002)))) then (if (not-caught-fail(v_1009) && success?(is-true(success?(1-proj-3-tuple(v_1009))))) then symmetricstatepack(1-proj-3-tuple(v_1009),2-proj-3-tuple(v_1009),hash(3-proj-3-tuple(v_1009),2-proj-3-tuple(v_1000))) else fail-any) else fail-any)) in
        {457}let v_1011: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1000)) && success?(1-proj-7-tuple(v_999))) then (if (not-caught-fail(v_1002) && success?(is-true(success?(1-proj-3-tuple(v_1002))))) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-3-tuple(v_1008))))) then (if not-caught-fail(v_1010) then (v_1010,2-proj-3-tuple(v_1008),3-proj-3-tuple(v_1008)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {458}let v_1012: key = catch-fail(2-proj-3-tuple(v_1011)) in
        {459}let v_1013: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1011))) in
        {460}let v_1014: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1013))) in
        {461}let v_1015: aead = catch-fail(decrypt(1-proj-2-tuple(v_1014),2-proj-2-tuple(v_1014),3-proj-3-tuple(v_1013),3-proj-3-tuple(v_1000))) in
        {462}let v_1016: bitstring = catch-fail(aeadunpack(v_1015)) in
        {463}let v_1017: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1013))) in
        {464}let v_1018: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1014))) && success?(1-proj-3-tuple(v_1013))) then (if (not-caught-fail(v_1017) && success?(is-true(success?(1-proj-2-tuple(v_1017))))) then cipherstatepack(1-proj-2-tuple(v_1017),increment_nonce(2-proj-2-tuple(v_1014))) else fail-any) else fail-any)) in
        {465}let v_1019: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1000)) && (success?(3-proj-3-tuple(v_1013)) && success?(1-proj-3-tuple(v_1013)))) then (if (not-caught-fail(v_1014) && success?(is-true(success?(1-proj-2-tuple(v_1014))))) then (if not-caught-fail(v_1015) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-3-tuple(v_1016))))) then (if not-caught-fail(v_1018) then (v_1018,3-proj-3-tuple(v_1016),1-proj-3-tuple(v_1016)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {466}let v_1020: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1019),2-proj-3-tuple(v_1013),3-proj-3-tuple(v_1013)))) in
        {467}let v_1021: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1000)) && success?(symmetricstatepack(1-proj-3-tuple(v_1019),2-proj-3-tuple(v_1013),3-proj-3-tuple(v_1013)))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then symmetricstatepack(1-proj-3-tuple(v_1020),2-proj-3-tuple(v_1020),hash(3-proj-3-tuple(v_1020),3-proj-3-tuple(v_1000))) else fail-any) else fail-any)) in
        {468}let v_1022: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1000)) && success?(1-proj-3-tuple(v_1011))) then (if (not-caught-fail(v_1013) && success?(is-true(success?(1-proj-3-tuple(v_1013))))) then (if (not-caught-fail(v_1019) && success?(is-true(success?(1-proj-3-tuple(v_1019))))) then (if not-caught-fail(v_1021) then (v_1021,2-proj-3-tuple(v_1019),3-proj-3-tuple(v_1019)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {469}let v_1023: key = catch-fail(dhexp(key_s(alice),g)) in
        {470}let v_1024: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1022),2-proj-7-tuple(v_999),3-proj-7-tuple(v_999),v_1012,5-proj-7-tuple(v_999),6-proj-7-tuple(v_999),7-proj-7-tuple(v_999))) in
        {471}let (hs_1025: handshakestate,plaintext_c: bitstring,valid_1026: bool) = (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-7-tuple(v_999))))) then (if (not-caught-fail(v_1000) && success?(is-true(success?(1-proj-3-tuple(v_1000))))) then (if not-caught-fail(v_1001) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-3-tuple(v_1011))))) then (if not-caught-fail(v_1012) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-3-tuple(v_1022))))) then (if ((3-proj-3-tuple(v_1011) && 3-proj-3-tuple(v_1022)) && (v_1012 = getpublickey((if not-caught-fail(v_1023) then keypairpack(v_1023,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_1024) then (v_1024,2-proj-3-tuple(v_1022),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {472}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {473}insert statestore(bob,alice,sid,statepack_d(hs_1025))
    ) | (
        {507}get statestore(=bob,=alice,=sid,statepack_d(hs_1027: handshakestate)) in
        {475}let v_1028: bitstring = catch-fail(handshakestateunpack(hs_1027)) in
        {476}let v_1029: bitstring = catch-fail((empty,empty,empty)) in
        {477}let v_1030: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1028))) in
        {478}let v_1031: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1028))) in
        {479}let v_1032: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1031),(if (success?(4-proj-7-tuple(v_1028)) && success?(3-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then dhexp(2-proj-2-tuple(v_1030),4-proj-7-tuple(v_1028)) else fail-any) else fail-any))) in
        {480}let v_1033: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1031),(if (success?(4-proj-7-tuple(v_1028)) && success?(3-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then dhexp(2-proj-2-tuple(v_1030),4-proj-7-tuple(v_1028)) else fail-any) else fail-any))) in
        {481}let v_1034: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1031),(if (success?(4-proj-7-tuple(v_1028)) && success?(3-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then dhexp(2-proj-2-tuple(v_1030),4-proj-7-tuple(v_1028)) else fail-any) else fail-any))) in
        {482}let v_1035: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1028)) && success?(3-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then dhexp(2-proj-2-tuple(v_1030),4-proj-7-tuple(v_1028)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1031))) then (if not-caught-fail(v_1032) then (if not-caught-fail(v_1033) then (if not-caught-fail(v_1034) then (v_1032,v_1033,v_1034) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {483}let v_1036: symmetricstate = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1028)) && success?(3-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then dhexp(2-proj-2-tuple(v_1030),4-proj-7-tuple(v_1028)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_1028))) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-3-tuple(v_1031))))) then (if (not-caught-fail(v_1035) && success?(is-true(success?(1-proj-3-tuple(v_1035))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1035)) then cipherstatepack(2-proj-3-tuple(v_1035),minnonce) else fail-any),1-proj-3-tuple(v_1035),3-proj-3-tuple(v_1031)) else fail-any) else fail-any) else fail-any)) in
        {484}let v_1037: bitstring = catch-fail(symmetricstateunpack(v_1036)) in
        {485}let v_1038: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1037))) in
        {486}let v_1039: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1038),2-proj-2-tuple(v_1038),3-proj-3-tuple(v_1037),msg_d(bob,alice,sid))) in
        {487}let v_1040: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1037))) in
        {488}let v_1041: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1038))) && success?(1-proj-3-tuple(v_1037))) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then cipherstatepack(1-proj-2-tuple(v_1040),increment_nonce(2-proj-2-tuple(v_1038))) else fail-any) else fail-any)) in
        {489}let v_1042: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1037)) && success?(1-proj-3-tuple(v_1037))) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then (if not-caught-fail(v_1039) then (if not-caught-fail(v_1041) then (v_1041,v_1039) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {490}let v_1043: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1042),2-proj-3-tuple(v_1037),3-proj-3-tuple(v_1037)))) in
        {491}let v_1044: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1042)) && success?(symmetricstatepack(1-proj-2-tuple(v_1042),2-proj-3-tuple(v_1037),3-proj-3-tuple(v_1037)))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-3-tuple(v_1043))))) then symmetricstatepack(1-proj-3-tuple(v_1043),2-proj-3-tuple(v_1043),hash(3-proj-3-tuple(v_1043),2-proj-2-tuple(v_1042))) else fail-any) else fail-any)) in
        {492}let v_1045: bitstring = catch-fail((if (not-caught-fail(v_1037) && success?(is-true(success?(1-proj-3-tuple(v_1037))))) then (if (not-caught-fail(v_1042) && success?(is-true(success?(1-proj-2-tuple(v_1042))))) then (if not-caught-fail(v_1044) then (v_1044,2-proj-2-tuple(v_1042)) else fail-any) else fail-any) else fail-any)) in
        {493}let v_1046: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1045),2-proj-7-tuple(v_1028),3-proj-7-tuple(v_1028),4-proj-7-tuple(v_1028),5-proj-7-tuple(v_1028),6-proj-7-tuple(v_1028),7-proj-7-tuple(v_1028))) in
        {494}let v_1047: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1029),2-proj-3-tuple(v_1029),2-proj-2-tuple(v_1045))) in
        {495}let v_1048: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1045))) in
        {496}let v_1049: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1048),zero)) in
        {497}let v_1050: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1048),zero)) in
        {498}let v_1051: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1048),zero)) in
        {499}let v_1052: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1048)) then (if not-caught-fail(v_1049) then (if not-caught-fail(v_1050) then (if not-caught-fail(v_1051) then (v_1049,v_1050,v_1051) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {500}let v_1053: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1052)) then cipherstatepack(1-proj-3-tuple(v_1052),minnonce) else fail-any)) in
        {501}let v_1054: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1052)) then cipherstatepack(2-proj-3-tuple(v_1052),minnonce) else fail-any)) in
        {502}let v_1055: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1045)) then (if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-3-tuple(v_1048))))) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-3-tuple(v_1052))))) then (if not-caught-fail(v_1053) then (if not-caught-fail(v_1054) then (1-proj-2-tuple(v_1045),v_1053,v_1054) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {503}let (hs_1056: handshakestate,message_d_1057: bitstring,cs1_1058: cipherstate,cs2_1059: cipherstate) = (if (not-caught-fail(v_1028) && success?(is-true(success?(1-proj-7-tuple(v_1028))))) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-3-tuple(v_1029))))) then (if not-caught-fail(v_1036) then (if (not-caught-fail(v_1045) && success?(is-true(success?(1-proj-2-tuple(v_1045))))) then (if not-caught-fail(v_1046) then (if not-caught-fail(v_1047) then (if (not-caught-fail(v_1055) && success?(is-true(success?(1-proj-3-tuple(v_1055))))) then (v_1046,v_1047,2-proj-3-tuple(v_1055),3-proj-3-tuple(v_1055)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {504}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice,sid));
        {505}insert statestore(bob,alice,sid,statepack_e(hs_1056,cs1_1058,cs2_1059));
        {506}out(pub, message_d_1057)
    ) | (
        {508}!
        {528}get statestore(=bob,=alice,=sid,statepack_e(hs_1060: handshakestate,cs1_1061: cipherstate,cs2_1062: cipherstate)) in
        {509}let hs_1063: handshakestate = handshakestatesetcs(hs_1060,cs1_1061) in
        {510}in(pub, message_e_1064: bitstring);
        {511}let v_1065: bitstring = catch-fail(handshakestateunpack(hs_1063)) in
        {512}let v_1066: bitstring = catch-fail(deconcat3(message_e_1064)) in
        {513}let v_1067: bool = catch-fail(true) in
        {514}let v_1068: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1065))) in
        {515}let v_1069: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1068))) in
        {516}let v_1070: aead = catch-fail(decrypt(1-proj-2-tuple(v_1069),2-proj-2-tuple(v_1069),3-proj-3-tuple(v_1068),3-proj-3-tuple(v_1066))) in
        {517}let v_1071: bitstring = catch-fail(aeadunpack(v_1070)) in
        {518}let v_1072: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1068))) in
        {519}let v_1073: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1069))) && success?(1-proj-3-tuple(v_1068))) then (if (not-caught-fail(v_1072) && success?(is-true(success?(1-proj-2-tuple(v_1072))))) then cipherstatepack(1-proj-2-tuple(v_1072),increment_nonce(2-proj-2-tuple(v_1069))) else fail-any) else fail-any)) in
        {520}let v_1074: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1066)) && (success?(3-proj-3-tuple(v_1068)) && success?(1-proj-3-tuple(v_1068)))) then (if (not-caught-fail(v_1069) && success?(is-true(success?(1-proj-2-tuple(v_1069))))) then (if not-caught-fail(v_1070) then (if (not-caught-fail(v_1071) && success?(is-true(success?(1-proj-3-tuple(v_1071))))) then (if not-caught-fail(v_1073) then (v_1073,3-proj-3-tuple(v_1071),1-proj-3-tuple(v_1071)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {521}let v_1075: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1074),2-proj-3-tuple(v_1068),3-proj-3-tuple(v_1068)))) in
        {522}let v_1076: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1066)) && success?(symmetricstatepack(1-proj-3-tuple(v_1074),2-proj-3-tuple(v_1068),3-proj-3-tuple(v_1068)))) then (if (not-caught-fail(v_1075) && success?(is-true(success?(1-proj-3-tuple(v_1075))))) then symmetricstatepack(1-proj-3-tuple(v_1075),2-proj-3-tuple(v_1075),hash(3-proj-3-tuple(v_1075),3-proj-3-tuple(v_1066))) else fail-any) else fail-any)) in
        {523}let v_1077: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1066)) && success?(1-proj-7-tuple(v_1065))) then (if (not-caught-fail(v_1068) && success?(is-true(success?(1-proj-3-tuple(v_1068))))) then (if (not-caught-fail(v_1074) && success?(is-true(success?(1-proj-3-tuple(v_1074))))) then (if not-caught-fail(v_1076) then (v_1076,2-proj-3-tuple(v_1074),3-proj-3-tuple(v_1074)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {524}let v_1078: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1077),2-proj-7-tuple(v_1065),3-proj-7-tuple(v_1065),4-proj-7-tuple(v_1065),5-proj-7-tuple(v_1065),6-proj-7-tuple(v_1065),7-proj-7-tuple(v_1065))) in
        {525}let (hs_1079: handshakestate,plaintext_e: bitstring,valid_1080: bool) = (if (not-caught-fail(v_1065) && success?(is-true(success?(1-proj-7-tuple(v_1065))))) then (if (not-caught-fail(v_1066) && success?(is-true(success?(1-proj-3-tuple(v_1066))))) then (if not-caught-fail(v_1067) then (if (not-caught-fail(v_1077) && success?(is-true(success?(1-proj-3-tuple(v_1077))))) then (if (v_1067 && 3-proj-3-tuple(v_1077)) then (if not-caught-fail(v_1078) then (v_1078,2-proj-3-tuple(v_1077),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {526}event RecvMsg(bob,alice,stagepack_e(sid),plaintext_e);
        {527}insert statestore(bob,alice,sid,statepack_f(hs_1079,handshakestategetcs(hs_1079),cs2_1062))
    ) | (
        {529}!
        {547}get statestore(=bob,=alice,=sid,statepack_f(hs_1081: handshakestate,cs1_1082: cipherstate,cs2_1083: cipherstate)) in
        {530}let hs_1084: handshakestate = handshakestatesetcs(hs_1081,cs2_1083) in
        {531}let v_1085: bitstring = catch-fail(handshakestateunpack(hs_1084)) in
        {532}let v_1086: bitstring = catch-fail((empty,empty,empty)) in
        {533}let v_1087: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1085))) in
        {534}let v_1088: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1087))) in
        {535}let v_1089: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1088),2-proj-2-tuple(v_1088),3-proj-3-tuple(v_1087),msg_f(bob,alice,sid))) in
        {536}let v_1090: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1087))) in
        {537}let v_1091: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1088))) && success?(1-proj-3-tuple(v_1087))) then (if (not-caught-fail(v_1090) && success?(is-true(success?(1-proj-2-tuple(v_1090))))) then cipherstatepack(1-proj-2-tuple(v_1090),increment_nonce(2-proj-2-tuple(v_1088))) else fail-any) else fail-any)) in
        {538}let v_1092: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1087)) && success?(1-proj-3-tuple(v_1087))) then (if (not-caught-fail(v_1088) && success?(is-true(success?(1-proj-2-tuple(v_1088))))) then (if not-caught-fail(v_1089) then (if not-caught-fail(v_1091) then (v_1091,v_1089) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {539}let v_1093: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1092),2-proj-3-tuple(v_1087),3-proj-3-tuple(v_1087)))) in
        {540}let v_1094: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1092)) && success?(symmetricstatepack(1-proj-2-tuple(v_1092),2-proj-3-tuple(v_1087),3-proj-3-tuple(v_1087)))) then (if (not-caught-fail(v_1093) && success?(is-true(success?(1-proj-3-tuple(v_1093))))) then symmetricstatepack(1-proj-3-tuple(v_1093),2-proj-3-tuple(v_1093),hash(3-proj-3-tuple(v_1093),2-proj-2-tuple(v_1092))) else fail-any) else fail-any)) in
        {541}let v_1095: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1085)) then (if (not-caught-fail(v_1087) && success?(is-true(success?(1-proj-3-tuple(v_1087))))) then (if (not-caught-fail(v_1092) && success?(is-true(success?(1-proj-2-tuple(v_1092))))) then (if not-caught-fail(v_1094) then (v_1094,2-proj-2-tuple(v_1092)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {542}let v_1096: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1095),2-proj-7-tuple(v_1085),3-proj-7-tuple(v_1085),4-proj-7-tuple(v_1085),5-proj-7-tuple(v_1085),6-proj-7-tuple(v_1085),7-proj-7-tuple(v_1085))) in
        {543}let v_1097: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1086),2-proj-3-tuple(v_1086),2-proj-2-tuple(v_1095))) in
        {544}let (hs_1098: handshakestate,message_f_1099: bitstring) = (if (not-caught-fail(v_1085) && success?(is-true(success?(1-proj-7-tuple(v_1085))))) then (if (not-caught-fail(v_1086) && success?(is-true(success?(1-proj-3-tuple(v_1086))))) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then (if not-caught-fail(v_1096) then (if not-caught-fail(v_1097) then (v_1096,v_1097) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {545}event SendMsg(bob,alice,stagepack_f(sid),msg_f(bob,alice,sid));
        {546}out(pub, message_f_1099)
    ) | (
        {548}event LeakS(phase0,bob);
        {549}out(pub, key_s(bob))
    ) | (
        {550}phase 1;
        {551}event LeakS(phase1,bob);
        {552}out(pub, key_s(bob))
    )
) | (
    {553}let v_1100: key = catch-fail(dhexp(key_s(bob),g)) in
    {554}let s_1101: keypair = (if not-caught-fail(v_1100) then keypairpack(v_1100,key_s(bob)) else fail-any) in
    {555}out(pub, getpublickey(s_1101));
    (
        {556}let e_1102: keypair = keypairpack(empty,empty) in
        {557}let rs_1103: key = empty in
        {558}let re_1104: key = empty in
        {559}let v_1105: bitstring = catch-fail(hash(somename,empty)) in
        {560}let v_1106: key = catch-fail(v_1105) in
        {561}let v_1107: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {562}let v_1108: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_1105) then (if not-caught-fail(v_1106) then (if not-caught-fail(v_1107) then symmetricstatepack(v_1107,v_1106,v_1105) else fail-any) else fail-any) else fail-any))) in
        {563}let v_1109: symmetricstate = catch-fail((if success?((if not-caught-fail(v_1105) then (if not-caught-fail(v_1106) then (if not-caught-fail(v_1107) then symmetricstatepack(v_1107,v_1106,v_1105) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_1108) && success?(is-true(success?(1-proj-3-tuple(v_1108))))) then symmetricstatepack(1-proj-3-tuple(v_1108),2-proj-3-tuple(v_1108),hash(3-proj-3-tuple(v_1108),empty)) else fail-any) else fail-any)) in
        {564}let v_1110: bitstring = catch-fail(symmetricstateunpack(v_1109)) in
        {565}let v_1111: symmetricstate = catch-fail((if success?(getpublickey(s_1101)) then (if (not-caught-fail(v_1110) && success?(is-true(success?(1-proj-3-tuple(v_1110))))) then symmetricstatepack(1-proj-3-tuple(v_1110),2-proj-3-tuple(v_1110),hash(3-proj-3-tuple(v_1110),getpublickey(s_1101))) else fail-any) else fail-any)) in
        {566}let hs_1112: handshakestate = (if not-caught-fail(v_1109) then (if not-caught-fail(v_1111) then handshakestatepack(v_1111,s_1101,e_1102,rs_1103,re_1104,empty,false) else fail-any) else fail-any) in
        {567}insert statestore(bob,charlie,sid,statepack_a(hs_1112))
    ) | (
        {596}get statestore(=bob,=charlie,=sid,statepack_a(hs_1113: handshakestate)) in
        {568}in(pub, message_a_1114: bitstring);
        {569}let v_1115: bitstring = catch-fail(handshakestateunpack(hs_1113)) in
        {570}let v_1116: bitstring = catch-fail(deconcat3(message_a_1114)) in
        {571}let v_1117: bool = catch-fail(true) in
        {572}let v_1118: key = catch-fail(1-proj-3-tuple(v_1116)) in
        {573}let v_1119: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1115))) in
        {574}let v_1120: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1119) && success?(is-true(success?(1-proj-3-tuple(v_1119))))) then symmetricstatepack(1-proj-3-tuple(v_1119),2-proj-3-tuple(v_1119),hash(3-proj-3-tuple(v_1119),v_1118)) else fail-any) else fail-any)) in
        {575}let v_1121: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_1115))) in
        {576}let v_1122: bitstring = catch-fail(symmetricstateunpack(v_1120)) in
        {577}let v_1123: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1122),(if success?(2-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then dhexp(2-proj-2-tuple(v_1121),v_1118) else fail-any) else fail-any))) in
        {578}let v_1124: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1122),(if success?(2-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then dhexp(2-proj-2-tuple(v_1121),v_1118) else fail-any) else fail-any))) in
        {579}let v_1125: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1122),(if success?(2-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then dhexp(2-proj-2-tuple(v_1121),v_1118) else fail-any) else fail-any))) in
        {580}let v_1126: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then dhexp(2-proj-2-tuple(v_1121),v_1118) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1122))) then (if not-caught-fail(v_1123) then (if not-caught-fail(v_1124) then (if not-caught-fail(v_1125) then (v_1123,v_1124,v_1125) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {581}let v_1127: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_1115)) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then dhexp(2-proj-2-tuple(v_1121),v_1118) else fail-any) else fail-any)) then (if (not-caught-fail(v_1122) && success?(is-true(success?(1-proj-3-tuple(v_1122))))) then (if (not-caught-fail(v_1126) && success?(is-true(success?(1-proj-3-tuple(v_1126))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1126)) then cipherstatepack(2-proj-3-tuple(v_1126),minnonce) else fail-any),1-proj-3-tuple(v_1126),3-proj-3-tuple(v_1122)) else fail-any) else fail-any) else fail-any)) in
        {582}let v_1128: bitstring = catch-fail(symmetricstateunpack(v_1127)) in
        {583}let v_1129: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1128))) in
        {584}let v_1130: aead = catch-fail(decrypt(1-proj-2-tuple(v_1129),2-proj-2-tuple(v_1129),3-proj-3-tuple(v_1128),3-proj-3-tuple(v_1116))) in
        {585}let v_1131: bitstring = catch-fail(aeadunpack(v_1130)) in
        {586}let v_1132: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1128))) in
        {587}let v_1133: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1129))) && success?(1-proj-3-tuple(v_1128))) then (if (not-caught-fail(v_1132) && success?(is-true(success?(1-proj-2-tuple(v_1132))))) then cipherstatepack(1-proj-2-tuple(v_1132),increment_nonce(2-proj-2-tuple(v_1129))) else fail-any) else fail-any)) in
        {588}let v_1134: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1116)) && (success?(3-proj-3-tuple(v_1128)) && success?(1-proj-3-tuple(v_1128)))) then (if (not-caught-fail(v_1129) && success?(is-true(success?(1-proj-2-tuple(v_1129))))) then (if not-caught-fail(v_1130) then (if (not-caught-fail(v_1131) && success?(is-true(success?(1-proj-3-tuple(v_1131))))) then (if not-caught-fail(v_1133) then (v_1133,3-proj-3-tuple(v_1131),1-proj-3-tuple(v_1131)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {589}let v_1135: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1134),2-proj-3-tuple(v_1128),3-proj-3-tuple(v_1128)))) in
        {590}let v_1136: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1116)) && success?(symmetricstatepack(1-proj-3-tuple(v_1134),2-proj-3-tuple(v_1128),3-proj-3-tuple(v_1128)))) then (if (not-caught-fail(v_1135) && success?(is-true(success?(1-proj-3-tuple(v_1135))))) then symmetricstatepack(1-proj-3-tuple(v_1135),2-proj-3-tuple(v_1135),hash(3-proj-3-tuple(v_1135),3-proj-3-tuple(v_1116))) else fail-any) else fail-any)) in
        {591}let v_1137: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1116)) then (if (not-caught-fail(v_1128) && success?(is-true(success?(1-proj-3-tuple(v_1128))))) then (if (not-caught-fail(v_1134) && success?(is-true(success?(1-proj-3-tuple(v_1134))))) then (if not-caught-fail(v_1136) then (v_1136,2-proj-3-tuple(v_1134),3-proj-3-tuple(v_1134)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {592}let v_1138: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1137),2-proj-7-tuple(v_1115),3-proj-7-tuple(v_1115),4-proj-7-tuple(v_1115),v_1118,6-proj-7-tuple(v_1115),7-proj-7-tuple(v_1115))) in
        {593}let (hs_1139: handshakestate,plaintext_a_1140: bitstring,valid_1141: bool) = (if (not-caught-fail(v_1115) && success?(is-true(success?(1-proj-7-tuple(v_1115))))) then (if (not-caught-fail(v_1116) && success?(is-true(success?(1-proj-3-tuple(v_1116))))) then (if not-caught-fail(v_1117) then (if not-caught-fail(v_1118) then (if not-caught-fail(v_1120) then (if not-caught-fail(v_1127) then (if (not-caught-fail(v_1137) && success?(is-true(success?(1-proj-3-tuple(v_1137))))) then (if (v_1117 && 3-proj-3-tuple(v_1137)) then (if not-caught-fail(v_1138) then (v_1138,2-proj-3-tuple(v_1137),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {594}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_1140);
        {595}insert statestore(bob,charlie,sid,statepack_b(hs_1139))
    ) | (
        {626}get statestore(=bob,=charlie,=sid,statepack_b(hs_1142: handshakestate)) in
        {597}let v_1143: bitstring = catch-fail(handshakestateunpack(hs_1142)) in
        {598}let v_1144: bitstring = catch-fail((empty,empty,empty)) in
        {599}let v_1145: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {600}let v_1146: keypair = catch-fail((if not-caught-fail(v_1145) then keypairpack(v_1145,key_e(bob,charlie,sid)) else fail-any)) in
        {601}let v_1147: bitstring = catch-fail(getpublickey(v_1146)) in
        {602}let v_1148: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1143))) in
        {603}let v_1149: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1148) && success?(is-true(success?(1-proj-3-tuple(v_1148))))) then symmetricstatepack(1-proj-3-tuple(v_1148),2-proj-3-tuple(v_1148),hash(3-proj-3-tuple(v_1148),v_1147)) else fail-any) else fail-any)) in
        {604}let v_1150: bitstring = catch-fail(keypairunpack(v_1146)) in
        {605}let v_1151: bitstring = catch-fail(symmetricstateunpack(v_1149)) in
        {606}let v_1152: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1151),(if success?(5-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),5-proj-7-tuple(v_1143)) else fail-any) else fail-any))) in
        {607}let v_1153: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1151),(if success?(5-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),5-proj-7-tuple(v_1143)) else fail-any) else fail-any))) in
        {608}let v_1154: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1151),(if success?(5-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),5-proj-7-tuple(v_1143)) else fail-any) else fail-any))) in
        {609}let v_1155: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),5-proj-7-tuple(v_1143)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1151))) then (if not-caught-fail(v_1152) then (if not-caught-fail(v_1153) then (if not-caught-fail(v_1154) then (v_1152,v_1153,v_1154) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {610}let v_1156: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1143)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),5-proj-7-tuple(v_1143)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1151) && success?(is-true(success?(1-proj-3-tuple(v_1151))))) then (if (not-caught-fail(v_1155) && success?(is-true(success?(1-proj-3-tuple(v_1155))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1155)) then cipherstatepack(2-proj-3-tuple(v_1155),minnonce) else fail-any),1-proj-3-tuple(v_1155),3-proj-3-tuple(v_1151)) else fail-any) else fail-any) else fail-any)) in
        {611}let v_1157: bitstring = catch-fail(symmetricstateunpack(v_1156)) in
        {612}let v_1158: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1157))) in
        {613}let v_1159: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1158),2-proj-2-tuple(v_1158),3-proj-3-tuple(v_1157),msg_b(bob,charlie,sid))) in
        {614}let v_1160: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1157))) in
        {615}let v_1161: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1158))) && success?(1-proj-3-tuple(v_1157))) then (if (not-caught-fail(v_1160) && success?(is-true(success?(1-proj-2-tuple(v_1160))))) then cipherstatepack(1-proj-2-tuple(v_1160),increment_nonce(2-proj-2-tuple(v_1158))) else fail-any) else fail-any)) in
        {616}let v_1162: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1157)) && success?(1-proj-3-tuple(v_1157))) then (if (not-caught-fail(v_1158) && success?(is-true(success?(1-proj-2-tuple(v_1158))))) then (if not-caught-fail(v_1159) then (if not-caught-fail(v_1161) then (v_1161,v_1159) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {617}let v_1163: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1162),2-proj-3-tuple(v_1157),3-proj-3-tuple(v_1157)))) in
        {618}let v_1164: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1162)) && success?(symmetricstatepack(1-proj-2-tuple(v_1162),2-proj-3-tuple(v_1157),3-proj-3-tuple(v_1157)))) then (if (not-caught-fail(v_1163) && success?(is-true(success?(1-proj-3-tuple(v_1163))))) then symmetricstatepack(1-proj-3-tuple(v_1163),2-proj-3-tuple(v_1163),hash(3-proj-3-tuple(v_1163),2-proj-2-tuple(v_1162))) else fail-any) else fail-any)) in
        {619}let v_1165: bitstring = catch-fail((if (not-caught-fail(v_1157) && success?(is-true(success?(1-proj-3-tuple(v_1157))))) then (if (not-caught-fail(v_1162) && success?(is-true(success?(1-proj-2-tuple(v_1162))))) then (if not-caught-fail(v_1164) then (v_1164,2-proj-2-tuple(v_1162)) else fail-any) else fail-any) else fail-any)) in
        {620}let v_1166: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1165),2-proj-7-tuple(v_1143),v_1146,4-proj-7-tuple(v_1143),5-proj-7-tuple(v_1143),6-proj-7-tuple(v_1143),7-proj-7-tuple(v_1143))) in
        {621}let v_1167: bitstring = catch-fail(concat3(v_1147,2-proj-3-tuple(v_1144),2-proj-2-tuple(v_1165))) in
        {622}let (hs_1168: handshakestate,message_b_1169: bitstring) = (if (not-caught-fail(v_1143) && success?(is-true(success?(1-proj-7-tuple(v_1143))))) then (if (not-caught-fail(v_1144) && success?(is-true(success?(1-proj-3-tuple(v_1144))))) then (if not-caught-fail(v_1146) then (if not-caught-fail(v_1147) then (if not-caught-fail(v_1149) then (if not-caught-fail(v_1156) then (if (not-caught-fail(v_1165) && success?(is-true(success?(1-proj-2-tuple(v_1165))))) then (if not-caught-fail(v_1166) then (if not-caught-fail(v_1167) then (v_1166,v_1167) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {623}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {624}insert statestore(bob,charlie,sid,statepack_c(hs_1168));
        {625}out(pub, message_b_1169)
    ) | (
        {657}get statestore(=bob,=charlie,=sid,statepack_c(hs_1170: handshakestate)) in
        {627}in(pub, message_c_1171: bitstring);
        {628}let v_1172: bitstring = catch-fail(handshakestateunpack(hs_1170)) in
        {629}let v_1173: bitstring = catch-fail(deconcat3(message_c_1171)) in
        {630}let v_1174: bool = catch-fail(true) in
        {631}let v_1175: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1172))) in
        {632}let v_1176: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1175))) in
        {633}let v_1177: aead = catch-fail(decrypt(1-proj-2-tuple(v_1176),2-proj-2-tuple(v_1176),3-proj-3-tuple(v_1175),2-proj-3-tuple(v_1173))) in
        {634}let v_1178: bitstring = catch-fail(aeadunpack(v_1177)) in
        {635}let v_1179: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1175))) in
        {636}let v_1180: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1176))) && success?(1-proj-3-tuple(v_1175))) then (if (not-caught-fail(v_1179) && success?(is-true(success?(1-proj-2-tuple(v_1179))))) then cipherstatepack(1-proj-2-tuple(v_1179),increment_nonce(2-proj-2-tuple(v_1176))) else fail-any) else fail-any)) in
        {637}let v_1181: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1173)) && (success?(3-proj-3-tuple(v_1175)) && success?(1-proj-3-tuple(v_1175)))) then (if (not-caught-fail(v_1176) && success?(is-true(success?(1-proj-2-tuple(v_1176))))) then (if not-caught-fail(v_1177) then (if (not-caught-fail(v_1178) && success?(is-true(success?(1-proj-3-tuple(v_1178))))) then (if not-caught-fail(v_1180) then (v_1180,3-proj-3-tuple(v_1178),1-proj-3-tuple(v_1178)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {638}let v_1182: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1181),2-proj-3-tuple(v_1175),3-proj-3-tuple(v_1175)))) in
        {639}let v_1183: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1173)) && success?(symmetricstatepack(1-proj-3-tuple(v_1181),2-proj-3-tuple(v_1175),3-proj-3-tuple(v_1175)))) then (if (not-caught-fail(v_1182) && success?(is-true(success?(1-proj-3-tuple(v_1182))))) then symmetricstatepack(1-proj-3-tuple(v_1182),2-proj-3-tuple(v_1182),hash(3-proj-3-tuple(v_1182),2-proj-3-tuple(v_1173))) else fail-any) else fail-any)) in
        {640}let v_1184: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1173)) && success?(1-proj-7-tuple(v_1172))) then (if (not-caught-fail(v_1175) && success?(is-true(success?(1-proj-3-tuple(v_1175))))) then (if (not-caught-fail(v_1181) && success?(is-true(success?(1-proj-3-tuple(v_1181))))) then (if not-caught-fail(v_1183) then (v_1183,2-proj-3-tuple(v_1181),3-proj-3-tuple(v_1181)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {641}let v_1185: key = catch-fail(2-proj-3-tuple(v_1184)) in
        {642}let v_1186: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1184))) in
        {643}let v_1187: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1186))) in
        {644}let v_1188: aead = catch-fail(decrypt(1-proj-2-tuple(v_1187),2-proj-2-tuple(v_1187),3-proj-3-tuple(v_1186),3-proj-3-tuple(v_1173))) in
        {645}let v_1189: bitstring = catch-fail(aeadunpack(v_1188)) in
        {646}let v_1190: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1186))) in
        {647}let v_1191: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1187))) && success?(1-proj-3-tuple(v_1186))) then (if (not-caught-fail(v_1190) && success?(is-true(success?(1-proj-2-tuple(v_1190))))) then cipherstatepack(1-proj-2-tuple(v_1190),increment_nonce(2-proj-2-tuple(v_1187))) else fail-any) else fail-any)) in
        {648}let v_1192: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1173)) && (success?(3-proj-3-tuple(v_1186)) && success?(1-proj-3-tuple(v_1186)))) then (if (not-caught-fail(v_1187) && success?(is-true(success?(1-proj-2-tuple(v_1187))))) then (if not-caught-fail(v_1188) then (if (not-caught-fail(v_1189) && success?(is-true(success?(1-proj-3-tuple(v_1189))))) then (if not-caught-fail(v_1191) then (v_1191,3-proj-3-tuple(v_1189),1-proj-3-tuple(v_1189)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {649}let v_1193: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1192),2-proj-3-tuple(v_1186),3-proj-3-tuple(v_1186)))) in
        {650}let v_1194: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1173)) && success?(symmetricstatepack(1-proj-3-tuple(v_1192),2-proj-3-tuple(v_1186),3-proj-3-tuple(v_1186)))) then (if (not-caught-fail(v_1193) && success?(is-true(success?(1-proj-3-tuple(v_1193))))) then symmetricstatepack(1-proj-3-tuple(v_1193),2-proj-3-tuple(v_1193),hash(3-proj-3-tuple(v_1193),3-proj-3-tuple(v_1173))) else fail-any) else fail-any)) in
        {651}let v_1195: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1173)) && success?(1-proj-3-tuple(v_1184))) then (if (not-caught-fail(v_1186) && success?(is-true(success?(1-proj-3-tuple(v_1186))))) then (if (not-caught-fail(v_1192) && success?(is-true(success?(1-proj-3-tuple(v_1192))))) then (if not-caught-fail(v_1194) then (v_1194,2-proj-3-tuple(v_1192),3-proj-3-tuple(v_1192)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {652}let v_1196: key = catch-fail(dhexp(key_s(charlie),g)) in
        {653}let v_1197: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1195),2-proj-7-tuple(v_1172),3-proj-7-tuple(v_1172),v_1185,5-proj-7-tuple(v_1172),6-proj-7-tuple(v_1172),7-proj-7-tuple(v_1172))) in
        {654}let (hs_1198: handshakestate,plaintext_c_1199: bitstring,valid_1200: bool) = (if (not-caught-fail(v_1172) && success?(is-true(success?(1-proj-7-tuple(v_1172))))) then (if (not-caught-fail(v_1173) && success?(is-true(success?(1-proj-3-tuple(v_1173))))) then (if not-caught-fail(v_1174) then (if (not-caught-fail(v_1184) && success?(is-true(success?(1-proj-3-tuple(v_1184))))) then (if not-caught-fail(v_1185) then (if (not-caught-fail(v_1195) && success?(is-true(success?(1-proj-3-tuple(v_1195))))) then (if ((3-proj-3-tuple(v_1184) && 3-proj-3-tuple(v_1195)) && (v_1185 = getpublickey((if not-caught-fail(v_1196) then keypairpack(v_1196,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1197) then (v_1197,2-proj-3-tuple(v_1195),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {655}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1199);
        {656}insert statestore(bob,charlie,sid,statepack_d(hs_1198))
    ) | (
        {690}get statestore(=bob,=charlie,=sid,statepack_d(hs_1201: handshakestate)) in
        {658}let v_1202: bitstring = catch-fail(handshakestateunpack(hs_1201)) in
        {659}let v_1203: bitstring = catch-fail((empty,empty,empty)) in
        {660}let v_1204: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1202))) in
        {661}let v_1205: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1202))) in
        {662}let v_1206: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1205),(if (success?(4-proj-7-tuple(v_1202)) && success?(3-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then dhexp(2-proj-2-tuple(v_1204),4-proj-7-tuple(v_1202)) else fail-any) else fail-any))) in
        {663}let v_1207: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1205),(if (success?(4-proj-7-tuple(v_1202)) && success?(3-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then dhexp(2-proj-2-tuple(v_1204),4-proj-7-tuple(v_1202)) else fail-any) else fail-any))) in
        {664}let v_1208: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1205),(if (success?(4-proj-7-tuple(v_1202)) && success?(3-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then dhexp(2-proj-2-tuple(v_1204),4-proj-7-tuple(v_1202)) else fail-any) else fail-any))) in
        {665}let v_1209: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1202)) && success?(3-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then dhexp(2-proj-2-tuple(v_1204),4-proj-7-tuple(v_1202)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1205))) then (if not-caught-fail(v_1206) then (if not-caught-fail(v_1207) then (if not-caught-fail(v_1208) then (v_1206,v_1207,v_1208) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {666}let v_1210: symmetricstate = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_1202)) && success?(3-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1204) && success?(is-true(success?(1-proj-2-tuple(v_1204))))) then dhexp(2-proj-2-tuple(v_1204),4-proj-7-tuple(v_1202)) else fail-any) else fail-any)) && success?(1-proj-7-tuple(v_1202))) then (if (not-caught-fail(v_1205) && success?(is-true(success?(1-proj-3-tuple(v_1205))))) then (if (not-caught-fail(v_1209) && success?(is-true(success?(1-proj-3-tuple(v_1209))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1209)) then cipherstatepack(2-proj-3-tuple(v_1209),minnonce) else fail-any),1-proj-3-tuple(v_1209),3-proj-3-tuple(v_1205)) else fail-any) else fail-any) else fail-any)) in
        {667}let v_1211: bitstring = catch-fail(symmetricstateunpack(v_1210)) in
        {668}let v_1212: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1211))) in
        {669}let v_1213: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1212),2-proj-2-tuple(v_1212),3-proj-3-tuple(v_1211),msg_d(bob,charlie,sid))) in
        {670}let v_1214: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1211))) in
        {671}let v_1215: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1212))) && success?(1-proj-3-tuple(v_1211))) then (if (not-caught-fail(v_1214) && success?(is-true(success?(1-proj-2-tuple(v_1214))))) then cipherstatepack(1-proj-2-tuple(v_1214),increment_nonce(2-proj-2-tuple(v_1212))) else fail-any) else fail-any)) in
        {672}let v_1216: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1211)) && success?(1-proj-3-tuple(v_1211))) then (if (not-caught-fail(v_1212) && success?(is-true(success?(1-proj-2-tuple(v_1212))))) then (if not-caught-fail(v_1213) then (if not-caught-fail(v_1215) then (v_1215,v_1213) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {673}let v_1217: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1216),2-proj-3-tuple(v_1211),3-proj-3-tuple(v_1211)))) in
        {674}let v_1218: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1216)) && success?(symmetricstatepack(1-proj-2-tuple(v_1216),2-proj-3-tuple(v_1211),3-proj-3-tuple(v_1211)))) then (if (not-caught-fail(v_1217) && success?(is-true(success?(1-proj-3-tuple(v_1217))))) then symmetricstatepack(1-proj-3-tuple(v_1217),2-proj-3-tuple(v_1217),hash(3-proj-3-tuple(v_1217),2-proj-2-tuple(v_1216))) else fail-any) else fail-any)) in
        {675}let v_1219: bitstring = catch-fail((if (not-caught-fail(v_1211) && success?(is-true(success?(1-proj-3-tuple(v_1211))))) then (if (not-caught-fail(v_1216) && success?(is-true(success?(1-proj-2-tuple(v_1216))))) then (if not-caught-fail(v_1218) then (v_1218,2-proj-2-tuple(v_1216)) else fail-any) else fail-any) else fail-any)) in
        {676}let v_1220: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1219),2-proj-7-tuple(v_1202),3-proj-7-tuple(v_1202),4-proj-7-tuple(v_1202),5-proj-7-tuple(v_1202),6-proj-7-tuple(v_1202),7-proj-7-tuple(v_1202))) in
        {677}let v_1221: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1203),2-proj-3-tuple(v_1203),2-proj-2-tuple(v_1219))) in
        {678}let v_1222: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1219))) in
        {679}let v_1223: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1222),zero)) in
        {680}let v_1224: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1222),zero)) in
        {681}let v_1225: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1222),zero)) in
        {682}let v_1226: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1222)) then (if not-caught-fail(v_1223) then (if not-caught-fail(v_1224) then (if not-caught-fail(v_1225) then (v_1223,v_1224,v_1225) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {683}let v_1227: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1226)) then cipherstatepack(1-proj-3-tuple(v_1226),minnonce) else fail-any)) in
        {684}let v_1228: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1226)) then cipherstatepack(2-proj-3-tuple(v_1226),minnonce) else fail-any)) in
        {685}let v_1229: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1219)) then (if (not-caught-fail(v_1222) && success?(is-true(success?(1-proj-3-tuple(v_1222))))) then (if (not-caught-fail(v_1226) && success?(is-true(success?(1-proj-3-tuple(v_1226))))) then (if not-caught-fail(v_1227) then (if not-caught-fail(v_1228) then (1-proj-2-tuple(v_1219),v_1227,v_1228) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {686}let (hs_1230: handshakestate,message_d_1231: bitstring,cs1_1232: cipherstate,cs2_1233: cipherstate) = (if (not-caught-fail(v_1202) && success?(is-true(success?(1-proj-7-tuple(v_1202))))) then (if (not-caught-fail(v_1203) && success?(is-true(success?(1-proj-3-tuple(v_1203))))) then (if not-caught-fail(v_1210) then (if (not-caught-fail(v_1219) && success?(is-true(success?(1-proj-2-tuple(v_1219))))) then (if not-caught-fail(v_1220) then (if not-caught-fail(v_1221) then (if (not-caught-fail(v_1229) && success?(is-true(success?(1-proj-3-tuple(v_1229))))) then (v_1220,v_1221,2-proj-3-tuple(v_1229),3-proj-3-tuple(v_1229)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {687}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie,sid));
        {688}insert statestore(bob,charlie,sid,statepack_e(hs_1230,cs1_1232,cs2_1233));
        {689}out(pub, message_d_1231)
    ) | (
        {691}!
        {711}get statestore(=bob,=charlie,=sid,statepack_e(hs_1234: handshakestate,cs1_1235: cipherstate,cs2_1236: cipherstate)) in
        {692}let hs_1237: handshakestate = handshakestatesetcs(hs_1234,cs1_1235) in
        {693}in(pub, message_e_1238: bitstring);
        {694}let v_1239: bitstring = catch-fail(handshakestateunpack(hs_1237)) in
        {695}let v_1240: bitstring = catch-fail(deconcat3(message_e_1238)) in
        {696}let v_1241: bool = catch-fail(true) in
        {697}let v_1242: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1239))) in
        {698}let v_1243: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1242))) in
        {699}let v_1244: aead = catch-fail(decrypt(1-proj-2-tuple(v_1243),2-proj-2-tuple(v_1243),3-proj-3-tuple(v_1242),3-proj-3-tuple(v_1240))) in
        {700}let v_1245: bitstring = catch-fail(aeadunpack(v_1244)) in
        {701}let v_1246: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1242))) in
        {702}let v_1247: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1243))) && success?(1-proj-3-tuple(v_1242))) then (if (not-caught-fail(v_1246) && success?(is-true(success?(1-proj-2-tuple(v_1246))))) then cipherstatepack(1-proj-2-tuple(v_1246),increment_nonce(2-proj-2-tuple(v_1243))) else fail-any) else fail-any)) in
        {703}let v_1248: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1240)) && (success?(3-proj-3-tuple(v_1242)) && success?(1-proj-3-tuple(v_1242)))) then (if (not-caught-fail(v_1243) && success?(is-true(success?(1-proj-2-tuple(v_1243))))) then (if not-caught-fail(v_1244) then (if (not-caught-fail(v_1245) && success?(is-true(success?(1-proj-3-tuple(v_1245))))) then (if not-caught-fail(v_1247) then (v_1247,3-proj-3-tuple(v_1245),1-proj-3-tuple(v_1245)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {704}let v_1249: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1248),2-proj-3-tuple(v_1242),3-proj-3-tuple(v_1242)))) in
        {705}let v_1250: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1240)) && success?(symmetricstatepack(1-proj-3-tuple(v_1248),2-proj-3-tuple(v_1242),3-proj-3-tuple(v_1242)))) then (if (not-caught-fail(v_1249) && success?(is-true(success?(1-proj-3-tuple(v_1249))))) then symmetricstatepack(1-proj-3-tuple(v_1249),2-proj-3-tuple(v_1249),hash(3-proj-3-tuple(v_1249),3-proj-3-tuple(v_1240))) else fail-any) else fail-any)) in
        {706}let v_1251: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1240)) && success?(1-proj-7-tuple(v_1239))) then (if (not-caught-fail(v_1242) && success?(is-true(success?(1-proj-3-tuple(v_1242))))) then (if (not-caught-fail(v_1248) && success?(is-true(success?(1-proj-3-tuple(v_1248))))) then (if not-caught-fail(v_1250) then (v_1250,2-proj-3-tuple(v_1248),3-proj-3-tuple(v_1248)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {707}let v_1252: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1251),2-proj-7-tuple(v_1239),3-proj-7-tuple(v_1239),4-proj-7-tuple(v_1239),5-proj-7-tuple(v_1239),6-proj-7-tuple(v_1239),7-proj-7-tuple(v_1239))) in
        {708}let (hs_1253: handshakestate,plaintext_e_1254: bitstring,valid_1255: bool) = (if (not-caught-fail(v_1239) && success?(is-true(success?(1-proj-7-tuple(v_1239))))) then (if (not-caught-fail(v_1240) && success?(is-true(success?(1-proj-3-tuple(v_1240))))) then (if not-caught-fail(v_1241) then (if (not-caught-fail(v_1251) && success?(is-true(success?(1-proj-3-tuple(v_1251))))) then (if (v_1241 && 3-proj-3-tuple(v_1251)) then (if not-caught-fail(v_1252) then (v_1252,2-proj-3-tuple(v_1251),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {709}event RecvMsg(bob,charlie,stagepack_e(sid),plaintext_e_1254);
        {710}insert statestore(bob,charlie,sid,statepack_f(hs_1253,handshakestategetcs(hs_1253),cs2_1236))
    ) | (
        {712}!
        {730}get statestore(=bob,=charlie,=sid,statepack_f(hs_1256: handshakestate,cs1_1257: cipherstate,cs2_1258: cipherstate)) in
        {713}let hs_1259: handshakestate = handshakestatesetcs(hs_1256,cs2_1258) in
        {714}let v_1260: bitstring = catch-fail(handshakestateunpack(hs_1259)) in
        {715}let v_1261: bitstring = catch-fail((empty,empty,empty)) in
        {716}let v_1262: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1260))) in
        {717}let v_1263: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1262))) in
        {718}let v_1264: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1263),2-proj-2-tuple(v_1263),3-proj-3-tuple(v_1262),msg_f(bob,charlie,sid))) in
        {719}let v_1265: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1262))) in
        {720}let v_1266: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1263))) && success?(1-proj-3-tuple(v_1262))) then (if (not-caught-fail(v_1265) && success?(is-true(success?(1-proj-2-tuple(v_1265))))) then cipherstatepack(1-proj-2-tuple(v_1265),increment_nonce(2-proj-2-tuple(v_1263))) else fail-any) else fail-any)) in
        {721}let v_1267: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1262)) && success?(1-proj-3-tuple(v_1262))) then (if (not-caught-fail(v_1263) && success?(is-true(success?(1-proj-2-tuple(v_1263))))) then (if not-caught-fail(v_1264) then (if not-caught-fail(v_1266) then (v_1266,v_1264) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {722}let v_1268: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1267),2-proj-3-tuple(v_1262),3-proj-3-tuple(v_1262)))) in
        {723}let v_1269: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1267)) && success?(symmetricstatepack(1-proj-2-tuple(v_1267),2-proj-3-tuple(v_1262),3-proj-3-tuple(v_1262)))) then (if (not-caught-fail(v_1268) && success?(is-true(success?(1-proj-3-tuple(v_1268))))) then symmetricstatepack(1-proj-3-tuple(v_1268),2-proj-3-tuple(v_1268),hash(3-proj-3-tuple(v_1268),2-proj-2-tuple(v_1267))) else fail-any) else fail-any)) in
        {724}let v_1270: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1260)) then (if (not-caught-fail(v_1262) && success?(is-true(success?(1-proj-3-tuple(v_1262))))) then (if (not-caught-fail(v_1267) && success?(is-true(success?(1-proj-2-tuple(v_1267))))) then (if not-caught-fail(v_1269) then (v_1269,2-proj-2-tuple(v_1267)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {725}let v_1271: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1270),2-proj-7-tuple(v_1260),3-proj-7-tuple(v_1260),4-proj-7-tuple(v_1260),5-proj-7-tuple(v_1260),6-proj-7-tuple(v_1260),7-proj-7-tuple(v_1260))) in
        {726}let v_1272: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1261),2-proj-3-tuple(v_1261),2-proj-2-tuple(v_1270))) in
        {727}let (hs_1273: handshakestate,message_f_1274: bitstring) = (if (not-caught-fail(v_1260) && success?(is-true(success?(1-proj-7-tuple(v_1260))))) then (if (not-caught-fail(v_1261) && success?(is-true(success?(1-proj-3-tuple(v_1261))))) then (if (not-caught-fail(v_1270) && success?(is-true(success?(1-proj-2-tuple(v_1270))))) then (if not-caught-fail(v_1271) then (if not-caught-fail(v_1272) then (v_1271,v_1272) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {728}event SendMsg(bob,charlie,stagepack_f(sid),msg_f(bob,charlie,sid));
        {729}out(pub, message_f_1274)
    ) | (
        {731}event LeakS(phase0,bob);
        {732}out(pub, key_s(bob))
    ) | (
        {733}phase 1;
        {734}event LeakS(phase1,bob);
        {735}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1377,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_e(alice,bob,sid_a)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_f(sid_b),m)); event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,c_1377,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_f(bob,alice,sid_b)); attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 143 rules in the queue.
400 rules inserted. The rule base contains 391 rules. 92 rules in the queue.
600 rules inserted. The rule base contains 585 rules. 246 rules in the queue.
800 rules inserted. The rule base contains 776 rules. 253 rules in the queue.
1000 rules inserted. The rule base contains 939 rules. 201 rules in the queue.
1200 rules inserted. The rule base contains 1122 rules. 331 rules in the queue.
1400 rules inserted. The rule base contains 1307 rules. 457 rules in the queue.
1600 rules inserted. The rule base contains 1453 rules. 489 rules in the queue.
1800 rules inserted. The rule base contains 1618 rules. 527 rules in the queue.
2000 rules inserted. The rule base contains 1800 rules. 584 rules in the queue.
2200 rules inserted. The rule base contains 1969 rules. 622 rules in the queue.
2400 rules inserted. The rule base contains 2161 rules. 734 rules in the queue.
2600 rules inserted. The rule base contains 2293 rules. 753 rules in the queue.
2800 rules inserted. The rule base contains 2423 rules. 752 rules in the queue.
3000 rules inserted. The rule base contains 2580 rules. 797 rules in the queue.
3200 rules inserted. The rule base contains 2736 rules. 858 rules in the queue.
3400 rules inserted. The rule base contains 2821 rules. 879 rules in the queue.
3600 rules inserted. The rule base contains 2945 rules. 919 rules in the queue.
