File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 249, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 250, character 36:
Warning: identifier h rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 285, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 296, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 296, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 297, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 305, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 306, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 307, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 309, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 311, character 6:
Warning: identifier s rebound.
File "KX.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.active.pv", line 313, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 314, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 314, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 315, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 331, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 340, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 353, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 354, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 356, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 357, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 358, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 358, characters 48-53:
Warning: identifier valid1 rebound.
File "KX.noise.active.pv", line 359, characters 6-7:
Warning: identifier rs rebound.
File "KX.noise.active.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 361, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 363, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 371, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 373, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 381, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 383, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 530, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 381, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 383, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 522, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 515, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 353, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 354, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 356, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 357, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 358, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 358, characters 48-53:
Warning: identifier valid1 rebound.
File "KX.noise.active.pv", line 359, characters 6-7:
Warning: identifier rs rebound.
File "KX.noise.active.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 361, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 363, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 507, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 296, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 296, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 297, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 580, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 331, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 573, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 371, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 373, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 565, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 305, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 306, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 307, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 309, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 311, character 6:
Warning: identifier s rebound.
File "KX.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.active.pv", line 313, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 314, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 314, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 315, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 558, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 340, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 285, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
(
    {3}let them: principal = bob in
    {4}let me: principal = alice in
    {5}let v_492: key = catch-fail(dhexp(key_s(me),g)) in
    {6}let s_493: keypair = (if not-caught-fail(v_492) then keypairpack(v_492,key_s(me)) else fail-any) in
    {7}out(pub, getpublickey(s_493));
    (
        {8}let e_494: keypair = keypairpack(empty,empty) in
        {9}let rs_495: key = empty in
        {10}let re_496: key = empty in
        {11}let v_497: bitstring = catch-fail(hash(somename,empty)) in
        {12}let v_498: key = catch-fail(v_497) in
        {13}let v_499: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {14}let v_500: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_497) then (if not-caught-fail(v_498) then (if not-caught-fail(v_499) then symmetricstatepack(v_499,v_498,v_497) else fail-any) else fail-any) else fail-any))) in
        {15}let v_501: symmetricstate = catch-fail((if success?((if not-caught-fail(v_497) then (if not-caught-fail(v_498) then (if not-caught-fail(v_499) then symmetricstatepack(v_499,v_498,v_497) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_500) && success?(is-true(success?(1-proj-3-tuple(v_500))))) then symmetricstatepack(1-proj-3-tuple(v_500),2-proj-3-tuple(v_500),hash(3-proj-3-tuple(v_500),empty)) else fail-any) else fail-any)) in
        {16}let v_502: bitstring = catch-fail(symmetricstateunpack(v_501)) in
        {17}let v_503: symmetricstate = catch-fail((if success?(getpublickey(s_493)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-3-tuple(v_502))))) then symmetricstatepack(1-proj-3-tuple(v_502),2-proj-3-tuple(v_502),hash(3-proj-3-tuple(v_502),getpublickey(s_493))) else fail-any) else fail-any)) in
        {18}let hs: handshakestate = (if not-caught-fail(v_501) then (if not-caught-fail(v_503) then handshakestatepack(v_503,s_493,e_494,rs_495,re_496,empty,true) else fail-any) else fail-any) in
        {19}insert statestore(me,them,statepack_a(hs))
    ) | (
        {43}get statestore(=me,=them,statepack_a(hs_504: handshakestate)) in
        {20}let v_505: bitstring = catch-fail(handshakestateunpack(hs_504)) in
        {21}let v_506: bitstring = catch-fail((empty,empty,empty)) in
        {22}new key_e[me,them]: key;
        {23}let v_507: key = catch-fail(dhexp(key_e,g)) in
        {24}let v_508: keypair = catch-fail((if not-caught-fail(v_507) then keypairpack(v_507,key_e) else fail-any)) in
        {25}let v_509: bitstring = catch-fail(getpublickey(v_508)) in
        {26}let v_510: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_505))) in
        {27}let v_511: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_505)) then (if (not-caught-fail(v_510) && success?(is-true(success?(1-proj-3-tuple(v_510))))) then symmetricstatepack(1-proj-3-tuple(v_510),2-proj-3-tuple(v_510),hash(3-proj-3-tuple(v_510),v_509)) else fail-any) else fail-any)) in
        {28}let v_512: bitstring = catch-fail(symmetricstateunpack(v_511)) in
        {29}let v_513: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_512))) in
        {30}let v_514: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_513),2-proj-2-tuple(v_513),3-proj-3-tuple(v_512),msg_a(me,them))) in
        {31}let v_515: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_512))) in
        {32}let v_516: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_513))) && success?(1-proj-3-tuple(v_512))) then (if (not-caught-fail(v_515) && success?(is-true(success?(1-proj-2-tuple(v_515))))) then cipherstatepack(1-proj-2-tuple(v_515),increment_nonce(2-proj-2-tuple(v_513))) else fail-any) else fail-any)) in
        {33}let v_517: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_512)) && success?(1-proj-3-tuple(v_512))) then (if (not-caught-fail(v_513) && success?(is-true(success?(1-proj-2-tuple(v_513))))) then (if not-caught-fail(v_514) then (if not-caught-fail(v_516) then (v_516,v_514) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {34}let v_518: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_517),2-proj-3-tuple(v_512),3-proj-3-tuple(v_512)))) in
        {35}let v_519: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_517)) && success?(symmetricstatepack(1-proj-2-tuple(v_517),2-proj-3-tuple(v_512),3-proj-3-tuple(v_512)))) then (if (not-caught-fail(v_518) && success?(is-true(success?(1-proj-3-tuple(v_518))))) then symmetricstatepack(1-proj-3-tuple(v_518),2-proj-3-tuple(v_518),hash(3-proj-3-tuple(v_518),2-proj-2-tuple(v_517))) else fail-any) else fail-any)) in
        {36}let v_520: bitstring = catch-fail((if (not-caught-fail(v_512) && success?(is-true(success?(1-proj-3-tuple(v_512))))) then (if (not-caught-fail(v_517) && success?(is-true(success?(1-proj-2-tuple(v_517))))) then (if not-caught-fail(v_519) then (v_519,2-proj-2-tuple(v_517)) else fail-any) else fail-any) else fail-any)) in
        {37}let v_521: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_520),2-proj-7-tuple(v_505),v_508,4-proj-7-tuple(v_505),5-proj-7-tuple(v_505),6-proj-7-tuple(v_505),7-proj-7-tuple(v_505))) in
        {38}let v_522: bitstring = catch-fail(concat3(v_509,2-proj-3-tuple(v_506),2-proj-2-tuple(v_520))) in
        {39}let (hs_523: handshakestate,re_524: key,message_a: bitstring) = (if (not-caught-fail(v_505) && success?(is-true(success?(1-proj-7-tuple(v_505))))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-3-tuple(v_506))))) then (if not-caught-fail(v_508) then (if not-caught-fail(v_509) then (if not-caught-fail(v_511) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then (if not-caught-fail(v_521) then (if not-caught-fail(v_522) then (v_521,5-proj-7-tuple(v_505),v_522) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {40}event SendMsg(me,them,stage_a,msg_a(me,them),true);
        {41}insert statestore(me,them,statepack_b(hs_523));
        {42}out(pub, message_a)
    ) | (
        {98}get statestore(=me,=them,statepack_b(hs_525: handshakestate)) in
        {44}in(pub, message_b: bitstring);
        {45}let v_526: bitstring = catch-fail(handshakestateunpack(hs_525)) in
        {46}let v_527: bitstring = catch-fail(deconcat3(message_b)) in
        {47}let v_528: bool = catch-fail(true) in
        {48}let v_529: key = catch-fail(1-proj-3-tuple(v_527)) in
        {49}let v_530: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_526))) in
        {50}let v_531: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_526)) then (if (not-caught-fail(v_530) && success?(is-true(success?(1-proj-3-tuple(v_530))))) then symmetricstatepack(1-proj-3-tuple(v_530),2-proj-3-tuple(v_530),hash(3-proj-3-tuple(v_530),v_529)) else fail-any) else fail-any)) in
        {51}let v_532: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_526))) in
        {52}let v_533: bitstring = catch-fail(symmetricstateunpack(v_531)) in
        {53}let v_534: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_533),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then dhexp(2-proj-2-tuple(v_532),v_529) else fail-any) else fail-any))) in
        {54}let v_535: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_533),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then dhexp(2-proj-2-tuple(v_532),v_529) else fail-any) else fail-any))) in
        {55}let v_536: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_533),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then dhexp(2-proj-2-tuple(v_532),v_529) else fail-any) else fail-any))) in
        {56}let v_537: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then dhexp(2-proj-2-tuple(v_532),v_529) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_533))) then (if not-caught-fail(v_534) then (if not-caught-fail(v_535) then (if not-caught-fail(v_536) then (v_534,v_535,v_536) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {57}let v_538: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then dhexp(2-proj-2-tuple(v_532),v_529) else fail-any) else fail-any)) then (if (not-caught-fail(v_533) && success?(is-true(success?(1-proj-3-tuple(v_533))))) then (if (not-caught-fail(v_537) && success?(is-true(success?(1-proj-3-tuple(v_537))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_537)) then cipherstatepack(2-proj-3-tuple(v_537),minnonce) else fail-any),1-proj-3-tuple(v_537),3-proj-3-tuple(v_533)) else fail-any) else fail-any) else fail-any)) in
        {58}let v_539: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_526))) in
        {59}let v_540: bitstring = catch-fail(symmetricstateunpack(v_538)) in
        {60}let v_541: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_540),(if success?(2-proj-7-tuple(v_526)) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-2-tuple(v_539))))) then dhexp(2-proj-2-tuple(v_539),v_529) else fail-any) else fail-any))) in
        {61}let v_542: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_540),(if success?(2-proj-7-tuple(v_526)) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-2-tuple(v_539))))) then dhexp(2-proj-2-tuple(v_539),v_529) else fail-any) else fail-any))) in
        {62}let v_543: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_540),(if success?(2-proj-7-tuple(v_526)) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-2-tuple(v_539))))) then dhexp(2-proj-2-tuple(v_539),v_529) else fail-any) else fail-any))) in
        {63}let v_544: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_526)) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-2-tuple(v_539))))) then dhexp(2-proj-2-tuple(v_539),v_529) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_540))) then (if not-caught-fail(v_541) then (if not-caught-fail(v_542) then (if not-caught-fail(v_543) then (v_541,v_542,v_543) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {64}let v_545: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_526)) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-2-tuple(v_539))))) then dhexp(2-proj-2-tuple(v_539),v_529) else fail-any) else fail-any)) then (if (not-caught-fail(v_540) && success?(is-true(success?(1-proj-3-tuple(v_540))))) then (if (not-caught-fail(v_544) && success?(is-true(success?(1-proj-3-tuple(v_544))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_544)) then cipherstatepack(2-proj-3-tuple(v_544),minnonce) else fail-any),1-proj-3-tuple(v_544),3-proj-3-tuple(v_540)) else fail-any) else fail-any) else fail-any)) in
        {65}let v_546: bitstring = catch-fail(symmetricstateunpack(v_545)) in
        {66}let v_547: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_546))) in
        {67}let v_548: aead = catch-fail(decrypt(1-proj-2-tuple(v_547),2-proj-2-tuple(v_547),3-proj-3-tuple(v_546),2-proj-3-tuple(v_527))) in
        {68}let v_549: bitstring = catch-fail(aeadunpack(v_548)) in
        {69}let v_550: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_546))) in
        {70}let v_551: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_547))) && success?(1-proj-3-tuple(v_546))) then (if (not-caught-fail(v_550) && success?(is-true(success?(1-proj-2-tuple(v_550))))) then cipherstatepack(1-proj-2-tuple(v_550),increment_nonce(2-proj-2-tuple(v_547))) else fail-any) else fail-any)) in
        {71}let v_552: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_527)) && (success?(3-proj-3-tuple(v_546)) && success?(1-proj-3-tuple(v_546)))) then (if (not-caught-fail(v_547) && success?(is-true(success?(1-proj-2-tuple(v_547))))) then (if not-caught-fail(v_548) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-3-tuple(v_549))))) then (if not-caught-fail(v_551) then (v_551,3-proj-3-tuple(v_549),1-proj-3-tuple(v_549)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {72}let v_553: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_552),2-proj-3-tuple(v_546),3-proj-3-tuple(v_546)))) in
        {73}let v_554: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_527)) && success?(symmetricstatepack(1-proj-3-tuple(v_552),2-proj-3-tuple(v_546),3-proj-3-tuple(v_546)))) then (if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-3-tuple(v_553))))) then symmetricstatepack(1-proj-3-tuple(v_553),2-proj-3-tuple(v_553),hash(3-proj-3-tuple(v_553),2-proj-3-tuple(v_527))) else fail-any) else fail-any)) in
        {74}let v_555: bitstring = catch-fail((if success?(2-proj-3-tuple(v_527)) then (if (not-caught-fail(v_546) && success?(is-true(success?(1-proj-3-tuple(v_546))))) then (if (not-caught-fail(v_552) && success?(is-true(success?(1-proj-3-tuple(v_552))))) then (if not-caught-fail(v_554) then (v_554,2-proj-3-tuple(v_552),3-proj-3-tuple(v_552)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {75}let v_556: key = catch-fail(2-proj-3-tuple(v_555)) in
        {76}let v_557: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_526))) in
        {77}let v_558: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_555))) in
        {78}let v_559: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_558),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then dhexp(2-proj-2-tuple(v_557),v_556) else fail-any) else fail-any))) in
        {79}let v_560: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_558),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then dhexp(2-proj-2-tuple(v_557),v_556) else fail-any) else fail-any))) in
        {80}let v_561: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_558),(if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then dhexp(2-proj-2-tuple(v_557),v_556) else fail-any) else fail-any))) in
        {81}let v_562: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then dhexp(2-proj-2-tuple(v_557),v_556) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_558))) then (if not-caught-fail(v_559) then (if not-caught-fail(v_560) then (if not-caught-fail(v_561) then (v_559,v_560,v_561) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {82}let v_563: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_526)) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then dhexp(2-proj-2-tuple(v_557),v_556) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_555))) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-3-tuple(v_558))))) then (if (not-caught-fail(v_562) && success?(is-true(success?(1-proj-3-tuple(v_562))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_562)) then cipherstatepack(2-proj-3-tuple(v_562),minnonce) else fail-any),1-proj-3-tuple(v_562),3-proj-3-tuple(v_558)) else fail-any) else fail-any) else fail-any)) in
        {83}let v_564: bitstring = catch-fail(symmetricstateunpack(v_563)) in
        {84}let v_565: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_564))) in
        {85}let v_566: aead = catch-fail(decrypt(1-proj-2-tuple(v_565),2-proj-2-tuple(v_565),3-proj-3-tuple(v_564),3-proj-3-tuple(v_527))) in
        {86}let v_567: bitstring = catch-fail(aeadunpack(v_566)) in
        {87}let v_568: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_564))) in
        {88}let v_569: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_565))) && success?(1-proj-3-tuple(v_564))) then (if (not-caught-fail(v_568) && success?(is-true(success?(1-proj-2-tuple(v_568))))) then cipherstatepack(1-proj-2-tuple(v_568),increment_nonce(2-proj-2-tuple(v_565))) else fail-any) else fail-any)) in
        {89}let v_570: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_527)) && (success?(3-proj-3-tuple(v_564)) && success?(1-proj-3-tuple(v_564)))) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then (if not-caught-fail(v_566) then (if (not-caught-fail(v_567) && success?(is-true(success?(1-proj-3-tuple(v_567))))) then (if not-caught-fail(v_569) then (v_569,3-proj-3-tuple(v_567),1-proj-3-tuple(v_567)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {90}let v_571: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_570),2-proj-3-tuple(v_564),3-proj-3-tuple(v_564)))) in
        {91}let v_572: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_527)) && success?(symmetricstatepack(1-proj-3-tuple(v_570),2-proj-3-tuple(v_564),3-proj-3-tuple(v_564)))) then (if (not-caught-fail(v_571) && success?(is-true(success?(1-proj-3-tuple(v_571))))) then symmetricstatepack(1-proj-3-tuple(v_571),2-proj-3-tuple(v_571),hash(3-proj-3-tuple(v_571),3-proj-3-tuple(v_527))) else fail-any) else fail-any)) in
        {92}let v_573: bitstring = catch-fail((if success?(3-proj-3-tuple(v_527)) then (if (not-caught-fail(v_564) && success?(is-true(success?(1-proj-3-tuple(v_564))))) then (if (not-caught-fail(v_570) && success?(is-true(success?(1-proj-3-tuple(v_570))))) then (if not-caught-fail(v_572) then (v_572,2-proj-3-tuple(v_570),3-proj-3-tuple(v_570)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {93}let v_574: key = catch-fail(dhexp(key_s(them),g)) in
        {94}let v_575: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_573),2-proj-7-tuple(v_526),3-proj-7-tuple(v_526),v_556,v_529,6-proj-7-tuple(v_526),7-proj-7-tuple(v_526))) in
        {95}let (hs_576: handshakestate,re_577: key,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_526) && success?(is-true(success?(1-proj-7-tuple(v_526))))) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-3-tuple(v_527))))) then (if not-caught-fail(v_528) then (if not-caught-fail(v_529) then (if not-caught-fail(v_531) then (if not-caught-fail(v_538) then (if not-caught-fail(v_545) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-3-tuple(v_555))))) then (if not-caught-fail(v_556) then (if not-caught-fail(v_563) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-3-tuple(v_573))))) then (if ((3-proj-3-tuple(v_555) && 3-proj-3-tuple(v_573)) && (v_556 = getpublickey((if not-caught-fail(v_574) then keypairpack(v_574,key_s(them)) else fail-any)))) then (if not-caught-fail(v_575) then (v_575,getpublickey(3-proj-7-tuple(v_526)),2-proj-3-tuple(v_573),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {96}event RecvMsg(me,them,stage_b,plaintext_b,valid);
        {97}insert statestore(me,them,statepack_c(hs_576))
    ) | (
        {116}get statestore(=me,=them,statepack_c(hs_578: handshakestate)) in
        {99}let v_579: bitstring = catch-fail(handshakestateunpack(hs_578)) in
        {100}let v_580: bitstring = catch-fail((empty,empty,empty)) in
        {101}let v_581: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_579))) in
        {102}let v_582: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_581))) in
        {103}let v_583: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_582),2-proj-2-tuple(v_582),3-proj-3-tuple(v_581),msg_c(me,them))) in
        {104}let v_584: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_581))) in
        {105}let v_585: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_582))) && success?(1-proj-3-tuple(v_581))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-2-tuple(v_584))))) then cipherstatepack(1-proj-2-tuple(v_584),increment_nonce(2-proj-2-tuple(v_582))) else fail-any) else fail-any)) in
        {106}let v_586: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_581)) && success?(1-proj-3-tuple(v_581))) then (if (not-caught-fail(v_582) && success?(is-true(success?(1-proj-2-tuple(v_582))))) then (if not-caught-fail(v_583) then (if not-caught-fail(v_585) then (v_585,v_583) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let v_587: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_586),2-proj-3-tuple(v_581),3-proj-3-tuple(v_581)))) in
        {108}let v_588: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_586)) && success?(symmetricstatepack(1-proj-2-tuple(v_586),2-proj-3-tuple(v_581),3-proj-3-tuple(v_581)))) then (if (not-caught-fail(v_587) && success?(is-true(success?(1-proj-3-tuple(v_587))))) then symmetricstatepack(1-proj-3-tuple(v_587),2-proj-3-tuple(v_587),hash(3-proj-3-tuple(v_587),2-proj-2-tuple(v_586))) else fail-any) else fail-any)) in
        {109}let v_589: bitstring = catch-fail((if success?(1-proj-7-tuple(v_579)) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-3-tuple(v_581))))) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-2-tuple(v_586))))) then (if not-caught-fail(v_588) then (v_588,2-proj-2-tuple(v_586)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {110}let v_590: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_589),2-proj-7-tuple(v_579),3-proj-7-tuple(v_579),4-proj-7-tuple(v_579),5-proj-7-tuple(v_579),6-proj-7-tuple(v_579),7-proj-7-tuple(v_579))) in
        {111}let v_591: bitstring = catch-fail(concat3(1-proj-3-tuple(v_580),2-proj-3-tuple(v_580),2-proj-2-tuple(v_589))) in
        {112}let (hs_592: handshakestate,re_593: key,message_c: bitstring) = (if (not-caught-fail(v_579) && success?(is-true(success?(1-proj-7-tuple(v_579))))) then (if (not-caught-fail(v_580) && success?(is-true(success?(1-proj-3-tuple(v_580))))) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-2-tuple(v_589))))) then (if not-caught-fail(v_590) then (if not-caught-fail(v_591) then (v_590,5-proj-7-tuple(v_579),v_591) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {113}event SendMsg(me,them,stage_c,msg_c(me,them),true);
        {114}insert statestore(me,them,statepack_d(hs_592));
        {115}out(pub, message_c)
    ) | (
        {144}get statestore(=me,=them,statepack_d(hs_594: handshakestate)) in
        {117}in(pub, message_d: bitstring);
        {118}let v_595: bitstring = catch-fail(handshakestateunpack(hs_594)) in
        {119}let v_596: bitstring = catch-fail(deconcat3(message_d)) in
        {120}let v_597: bool = catch-fail(true) in
        {121}let v_598: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_595))) in
        {122}let v_599: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_598))) in
        {123}let v_600: aead = catch-fail(decrypt(1-proj-2-tuple(v_599),2-proj-2-tuple(v_599),3-proj-3-tuple(v_598),3-proj-3-tuple(v_596))) in
        {124}let v_601: bitstring = catch-fail(aeadunpack(v_600)) in
        {125}let v_602: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_598))) in
        {126}let v_603: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_599))) && success?(1-proj-3-tuple(v_598))) then (if (not-caught-fail(v_602) && success?(is-true(success?(1-proj-2-tuple(v_602))))) then cipherstatepack(1-proj-2-tuple(v_602),increment_nonce(2-proj-2-tuple(v_599))) else fail-any) else fail-any)) in
        {127}let v_604: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_596)) && (success?(3-proj-3-tuple(v_598)) && success?(1-proj-3-tuple(v_598)))) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then (if not-caught-fail(v_600) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-3-tuple(v_601))))) then (if not-caught-fail(v_603) then (v_603,3-proj-3-tuple(v_601),1-proj-3-tuple(v_601)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {128}let v_605: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_604),2-proj-3-tuple(v_598),3-proj-3-tuple(v_598)))) in
        {129}let v_606: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_596)) && success?(symmetricstatepack(1-proj-3-tuple(v_604),2-proj-3-tuple(v_598),3-proj-3-tuple(v_598)))) then (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-3-tuple(v_605))))) then symmetricstatepack(1-proj-3-tuple(v_605),2-proj-3-tuple(v_605),hash(3-proj-3-tuple(v_605),3-proj-3-tuple(v_596))) else fail-any) else fail-any)) in
        {130}let v_607: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_596)) && success?(1-proj-7-tuple(v_595))) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-3-tuple(v_598))))) then (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-3-tuple(v_604))))) then (if not-caught-fail(v_606) then (v_606,2-proj-3-tuple(v_604),3-proj-3-tuple(v_604)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {131}let v_608: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_607),2-proj-7-tuple(v_595),3-proj-7-tuple(v_595),4-proj-7-tuple(v_595),5-proj-7-tuple(v_595),6-proj-7-tuple(v_595),7-proj-7-tuple(v_595))) in
        {132}let v_609: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_607))) in
        {133}let v_610: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_609),zero)) in
        {134}let v_611: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_609),zero)) in
        {135}let v_612: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_609),zero)) in
        {136}let v_613: bitstring = catch-fail((if success?(2-proj-3-tuple(v_609)) then (if not-caught-fail(v_610) then (if not-caught-fail(v_611) then (if not-caught-fail(v_612) then (v_610,v_611,v_612) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {137}let v_614: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_613)) then cipherstatepack(1-proj-3-tuple(v_613),minnonce) else fail-any)) in
        {138}let v_615: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_613)) then cipherstatepack(2-proj-3-tuple(v_613),minnonce) else fail-any)) in
        {139}let v_616: bitstring = catch-fail((if success?(1-proj-3-tuple(v_607)) then (if (not-caught-fail(v_609) && success?(is-true(success?(1-proj-3-tuple(v_609))))) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-3-tuple(v_613))))) then (if not-caught-fail(v_614) then (if not-caught-fail(v_615) then (1-proj-3-tuple(v_607),v_614,v_615) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {140}let (hs_617: handshakestate,re_618: key,plaintext_d: bitstring,valid_619: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-7-tuple(v_595))))) then (if (not-caught-fail(v_596) && success?(is-true(success?(1-proj-3-tuple(v_596))))) then (if not-caught-fail(v_597) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-3-tuple(v_607))))) then (if (v_597 && 3-proj-3-tuple(v_607)) then (if not-caught-fail(v_608) then (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-3-tuple(v_616))))) then (v_608,getpublickey(3-proj-7-tuple(v_595)),2-proj-3-tuple(v_607),true,2-proj-3-tuple(v_616),3-proj-3-tuple(v_616)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {141}event RecvMsg(me,them,stage_d,plaintext_d,valid_619);
        {142}insert statestore(me,them,statepack_e(hs_617));
        {143}event RecvEnd(valid_619)
    ) | (
        {145}event LeakS(phase0,me);
        {146}out(pub, key_s(me))
    ) | (
        {147}phase 1;
        {148}event LeakS(phase1,me);
        {149}out(pub, key_s(me))
    )
) | (
    {150}let them_620: principal = charlie in
    {151}let me_621: principal = alice in
    {152}let v_622: key = catch-fail(dhexp(key_s(me_621),g)) in
    {153}let s_623: keypair = (if not-caught-fail(v_622) then keypairpack(v_622,key_s(me_621)) else fail-any) in
    {154}out(pub, getpublickey(s_623));
    (
        {155}let e_624: keypair = keypairpack(empty,empty) in
        {156}let rs_625: key = empty in
        {157}let re_626: key = empty in
        {158}let v_627: bitstring = catch-fail(hash(somename,empty)) in
        {159}let v_628: key = catch-fail(v_627) in
        {160}let v_629: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {161}let v_630: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_627) then (if not-caught-fail(v_628) then (if not-caught-fail(v_629) then symmetricstatepack(v_629,v_628,v_627) else fail-any) else fail-any) else fail-any))) in
        {162}let v_631: symmetricstate = catch-fail((if success?((if not-caught-fail(v_627) then (if not-caught-fail(v_628) then (if not-caught-fail(v_629) then symmetricstatepack(v_629,v_628,v_627) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_630) && success?(is-true(success?(1-proj-3-tuple(v_630))))) then symmetricstatepack(1-proj-3-tuple(v_630),2-proj-3-tuple(v_630),hash(3-proj-3-tuple(v_630),empty)) else fail-any) else fail-any)) in
        {163}let v_632: bitstring = catch-fail(symmetricstateunpack(v_631)) in
        {164}let v_633: symmetricstate = catch-fail((if success?(getpublickey(s_623)) then (if (not-caught-fail(v_632) && success?(is-true(success?(1-proj-3-tuple(v_632))))) then symmetricstatepack(1-proj-3-tuple(v_632),2-proj-3-tuple(v_632),hash(3-proj-3-tuple(v_632),getpublickey(s_623))) else fail-any) else fail-any)) in
        {165}let hs_634: handshakestate = (if not-caught-fail(v_631) then (if not-caught-fail(v_633) then handshakestatepack(v_633,s_623,e_624,rs_625,re_626,empty,true) else fail-any) else fail-any) in
        {166}insert statestore(me_621,them_620,statepack_a(hs_634))
    ) | (
        {190}get statestore(=me_621,=them_620,statepack_a(hs_635: handshakestate)) in
        {167}let v_636: bitstring = catch-fail(handshakestateunpack(hs_635)) in
        {168}let v_637: bitstring = catch-fail((empty,empty,empty)) in
        {169}new key_e_638[me_621,them_620]: key;
        {170}let v_639: key = catch-fail(dhexp(key_e_638,g)) in
        {171}let v_640: keypair = catch-fail((if not-caught-fail(v_639) then keypairpack(v_639,key_e_638) else fail-any)) in
        {172}let v_641: bitstring = catch-fail(getpublickey(v_640)) in
        {173}let v_642: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_636))) in
        {174}let v_643: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_636)) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then symmetricstatepack(1-proj-3-tuple(v_642),2-proj-3-tuple(v_642),hash(3-proj-3-tuple(v_642),v_641)) else fail-any) else fail-any)) in
        {175}let v_644: bitstring = catch-fail(symmetricstateunpack(v_643)) in
        {176}let v_645: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_644))) in
        {177}let v_646: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_645),2-proj-2-tuple(v_645),3-proj-3-tuple(v_644),msg_a(me_621,them_620))) in
        {178}let v_647: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_644))) in
        {179}let v_648: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_645))) && success?(1-proj-3-tuple(v_644))) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-2-tuple(v_647))))) then cipherstatepack(1-proj-2-tuple(v_647),increment_nonce(2-proj-2-tuple(v_645))) else fail-any) else fail-any)) in
        {180}let v_649: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_644)) && success?(1-proj-3-tuple(v_644))) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-2-tuple(v_645))))) then (if not-caught-fail(v_646) then (if not-caught-fail(v_648) then (v_648,v_646) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {181}let v_650: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_649),2-proj-3-tuple(v_644),3-proj-3-tuple(v_644)))) in
        {182}let v_651: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_649)) && success?(symmetricstatepack(1-proj-2-tuple(v_649),2-proj-3-tuple(v_644),3-proj-3-tuple(v_644)))) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-3-tuple(v_650))))) then symmetricstatepack(1-proj-3-tuple(v_650),2-proj-3-tuple(v_650),hash(3-proj-3-tuple(v_650),2-proj-2-tuple(v_649))) else fail-any) else fail-any)) in
        {183}let v_652: bitstring = catch-fail((if (not-caught-fail(v_644) && success?(is-true(success?(1-proj-3-tuple(v_644))))) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-2-tuple(v_649))))) then (if not-caught-fail(v_651) then (v_651,2-proj-2-tuple(v_649)) else fail-any) else fail-any) else fail-any)) in
        {184}let v_653: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_652),2-proj-7-tuple(v_636),v_640,4-proj-7-tuple(v_636),5-proj-7-tuple(v_636),6-proj-7-tuple(v_636),7-proj-7-tuple(v_636))) in
        {185}let v_654: bitstring = catch-fail(concat3(v_641,2-proj-3-tuple(v_637),2-proj-2-tuple(v_652))) in
        {186}let (hs_655: handshakestate,re_656: key,message_a_657: bitstring) = (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-7-tuple(v_636))))) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-3-tuple(v_637))))) then (if not-caught-fail(v_640) then (if not-caught-fail(v_641) then (if not-caught-fail(v_643) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-2-tuple(v_652))))) then (if not-caught-fail(v_653) then (if not-caught-fail(v_654) then (v_653,5-proj-7-tuple(v_636),v_654) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {187}event SendMsg(me_621,them_620,stage_a,msg_a(me_621,them_620),true);
        {188}insert statestore(me_621,them_620,statepack_b(hs_655));
        {189}out(pub, message_a_657)
    ) | (
        {245}get statestore(=me_621,=them_620,statepack_b(hs_658: handshakestate)) in
        {191}in(pub, message_b_659: bitstring);
        {192}let v_660: bitstring = catch-fail(handshakestateunpack(hs_658)) in
        {193}let v_661: bitstring = catch-fail(deconcat3(message_b_659)) in
        {194}let v_662: bool = catch-fail(true) in
        {195}let v_663: key = catch-fail(1-proj-3-tuple(v_661)) in
        {196}let v_664: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_660))) in
        {197}let v_665: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_660)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-3-tuple(v_664))))) then symmetricstatepack(1-proj-3-tuple(v_664),2-proj-3-tuple(v_664),hash(3-proj-3-tuple(v_664),v_663)) else fail-any) else fail-any)) in
        {198}let v_666: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_660))) in
        {199}let v_667: bitstring = catch-fail(symmetricstateunpack(v_665)) in
        {200}let v_668: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_667),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then dhexp(2-proj-2-tuple(v_666),v_663) else fail-any) else fail-any))) in
        {201}let v_669: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_667),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then dhexp(2-proj-2-tuple(v_666),v_663) else fail-any) else fail-any))) in
        {202}let v_670: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_667),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then dhexp(2-proj-2-tuple(v_666),v_663) else fail-any) else fail-any))) in
        {203}let v_671: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then dhexp(2-proj-2-tuple(v_666),v_663) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_667))) then (if not-caught-fail(v_668) then (if not-caught-fail(v_669) then (if not-caught-fail(v_670) then (v_668,v_669,v_670) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {204}let v_672: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then dhexp(2-proj-2-tuple(v_666),v_663) else fail-any) else fail-any)) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-3-tuple(v_667))))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-3-tuple(v_671))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_671)) then cipherstatepack(2-proj-3-tuple(v_671),minnonce) else fail-any),1-proj-3-tuple(v_671),3-proj-3-tuple(v_667)) else fail-any) else fail-any) else fail-any)) in
        {205}let v_673: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_660))) in
        {206}let v_674: bitstring = catch-fail(symmetricstateunpack(v_672)) in
        {207}let v_675: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_674),(if success?(2-proj-7-tuple(v_660)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then dhexp(2-proj-2-tuple(v_673),v_663) else fail-any) else fail-any))) in
        {208}let v_676: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_674),(if success?(2-proj-7-tuple(v_660)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then dhexp(2-proj-2-tuple(v_673),v_663) else fail-any) else fail-any))) in
        {209}let v_677: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_674),(if success?(2-proj-7-tuple(v_660)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then dhexp(2-proj-2-tuple(v_673),v_663) else fail-any) else fail-any))) in
        {210}let v_678: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_660)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then dhexp(2-proj-2-tuple(v_673),v_663) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_674))) then (if not-caught-fail(v_675) then (if not-caught-fail(v_676) then (if not-caught-fail(v_677) then (v_675,v_676,v_677) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {211}let v_679: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_660)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then dhexp(2-proj-2-tuple(v_673),v_663) else fail-any) else fail-any)) then (if (not-caught-fail(v_674) && success?(is-true(success?(1-proj-3-tuple(v_674))))) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-3-tuple(v_678))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_678)) then cipherstatepack(2-proj-3-tuple(v_678),minnonce) else fail-any),1-proj-3-tuple(v_678),3-proj-3-tuple(v_674)) else fail-any) else fail-any) else fail-any)) in
        {212}let v_680: bitstring = catch-fail(symmetricstateunpack(v_679)) in
        {213}let v_681: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_680))) in
        {214}let v_682: aead = catch-fail(decrypt(1-proj-2-tuple(v_681),2-proj-2-tuple(v_681),3-proj-3-tuple(v_680),2-proj-3-tuple(v_661))) in
        {215}let v_683: bitstring = catch-fail(aeadunpack(v_682)) in
        {216}let v_684: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_680))) in
        {217}let v_685: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_681))) && success?(1-proj-3-tuple(v_680))) then (if (not-caught-fail(v_684) && success?(is-true(success?(1-proj-2-tuple(v_684))))) then cipherstatepack(1-proj-2-tuple(v_684),increment_nonce(2-proj-2-tuple(v_681))) else fail-any) else fail-any)) in
        {218}let v_686: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_661)) && (success?(3-proj-3-tuple(v_680)) && success?(1-proj-3-tuple(v_680)))) then (if (not-caught-fail(v_681) && success?(is-true(success?(1-proj-2-tuple(v_681))))) then (if not-caught-fail(v_682) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-3-tuple(v_683))))) then (if not-caught-fail(v_685) then (v_685,3-proj-3-tuple(v_683),1-proj-3-tuple(v_683)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {219}let v_687: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_686),2-proj-3-tuple(v_680),3-proj-3-tuple(v_680)))) in
        {220}let v_688: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_661)) && success?(symmetricstatepack(1-proj-3-tuple(v_686),2-proj-3-tuple(v_680),3-proj-3-tuple(v_680)))) then (if (not-caught-fail(v_687) && success?(is-true(success?(1-proj-3-tuple(v_687))))) then symmetricstatepack(1-proj-3-tuple(v_687),2-proj-3-tuple(v_687),hash(3-proj-3-tuple(v_687),2-proj-3-tuple(v_661))) else fail-any) else fail-any)) in
        {221}let v_689: bitstring = catch-fail((if success?(2-proj-3-tuple(v_661)) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-3-tuple(v_680))))) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then (if not-caught-fail(v_688) then (v_688,2-proj-3-tuple(v_686),3-proj-3-tuple(v_686)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {222}let v_690: key = catch-fail(2-proj-3-tuple(v_689)) in
        {223}let v_691: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_660))) in
        {224}let v_692: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_689))) in
        {225}let v_693: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_690) else fail-any) else fail-any))) in
        {226}let v_694: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_690) else fail-any) else fail-any))) in
        {227}let v_695: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_690) else fail-any) else fail-any))) in
        {228}let v_696: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_690) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_692))) then (if not-caught-fail(v_693) then (if not-caught-fail(v_694) then (if not-caught-fail(v_695) then (v_693,v_694,v_695) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {229}let v_697: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_660)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_690) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_689))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-3-tuple(v_692))))) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-3-tuple(v_696))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_696)) then cipherstatepack(2-proj-3-tuple(v_696),minnonce) else fail-any),1-proj-3-tuple(v_696),3-proj-3-tuple(v_692)) else fail-any) else fail-any) else fail-any)) in
        {230}let v_698: bitstring = catch-fail(symmetricstateunpack(v_697)) in
        {231}let v_699: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_698))) in
        {232}let v_700: aead = catch-fail(decrypt(1-proj-2-tuple(v_699),2-proj-2-tuple(v_699),3-proj-3-tuple(v_698),3-proj-3-tuple(v_661))) in
        {233}let v_701: bitstring = catch-fail(aeadunpack(v_700)) in
        {234}let v_702: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_698))) in
        {235}let v_703: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_699))) && success?(1-proj-3-tuple(v_698))) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-2-tuple(v_702))))) then cipherstatepack(1-proj-2-tuple(v_702),increment_nonce(2-proj-2-tuple(v_699))) else fail-any) else fail-any)) in
        {236}let v_704: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_661)) && (success?(3-proj-3-tuple(v_698)) && success?(1-proj-3-tuple(v_698)))) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-2-tuple(v_699))))) then (if not-caught-fail(v_700) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if not-caught-fail(v_703) then (v_703,3-proj-3-tuple(v_701),1-proj-3-tuple(v_701)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {237}let v_705: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_704),2-proj-3-tuple(v_698),3-proj-3-tuple(v_698)))) in
        {238}let v_706: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_661)) && success?(symmetricstatepack(1-proj-3-tuple(v_704),2-proj-3-tuple(v_698),3-proj-3-tuple(v_698)))) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then symmetricstatepack(1-proj-3-tuple(v_705),2-proj-3-tuple(v_705),hash(3-proj-3-tuple(v_705),3-proj-3-tuple(v_661))) else fail-any) else fail-any)) in
        {239}let v_707: bitstring = catch-fail((if success?(3-proj-3-tuple(v_661)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-3-tuple(v_698))))) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then (if not-caught-fail(v_706) then (v_706,2-proj-3-tuple(v_704),3-proj-3-tuple(v_704)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {240}let v_708: key = catch-fail(dhexp(key_s(them_620),g)) in
        {241}let v_709: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_707),2-proj-7-tuple(v_660),3-proj-7-tuple(v_660),v_690,v_663,6-proj-7-tuple(v_660),7-proj-7-tuple(v_660))) in
        {242}let (hs_710: handshakestate,re_711: key,plaintext_b_712: bitstring,valid_713: bool) = (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-7-tuple(v_660))))) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-3-tuple(v_661))))) then (if not-caught-fail(v_662) then (if not-caught-fail(v_663) then (if not-caught-fail(v_665) then (if not-caught-fail(v_672) then (if not-caught-fail(v_679) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-3-tuple(v_689))))) then (if not-caught-fail(v_690) then (if not-caught-fail(v_697) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-3-tuple(v_707))))) then (if ((3-proj-3-tuple(v_689) && 3-proj-3-tuple(v_707)) && (v_690 = getpublickey((if not-caught-fail(v_708) then keypairpack(v_708,key_s(them_620)) else fail-any)))) then (if not-caught-fail(v_709) then (v_709,getpublickey(3-proj-7-tuple(v_660)),2-proj-3-tuple(v_707),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {243}event RecvMsg(me_621,them_620,stage_b,plaintext_b_712,valid_713);
        {244}insert statestore(me_621,them_620,statepack_c(hs_710))
    ) | (
        {263}get statestore(=me_621,=them_620,statepack_c(hs_714: handshakestate)) in
        {246}let v_715: bitstring = catch-fail(handshakestateunpack(hs_714)) in
        {247}let v_716: bitstring = catch-fail((empty,empty,empty)) in
        {248}let v_717: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_715))) in
        {249}let v_718: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_717))) in
        {250}let v_719: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_718),2-proj-2-tuple(v_718),3-proj-3-tuple(v_717),msg_c(me_621,them_620))) in
        {251}let v_720: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_717))) in
        {252}let v_721: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_718))) && success?(1-proj-3-tuple(v_717))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-2-tuple(v_720))))) then cipherstatepack(1-proj-2-tuple(v_720),increment_nonce(2-proj-2-tuple(v_718))) else fail-any) else fail-any)) in
        {253}let v_722: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_717)) && success?(1-proj-3-tuple(v_717))) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then (if not-caught-fail(v_719) then (if not-caught-fail(v_721) then (v_721,v_719) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {254}let v_723: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_722),2-proj-3-tuple(v_717),3-proj-3-tuple(v_717)))) in
        {255}let v_724: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_722)) && success?(symmetricstatepack(1-proj-2-tuple(v_722),2-proj-3-tuple(v_717),3-proj-3-tuple(v_717)))) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then symmetricstatepack(1-proj-3-tuple(v_723),2-proj-3-tuple(v_723),hash(3-proj-3-tuple(v_723),2-proj-2-tuple(v_722))) else fail-any) else fail-any)) in
        {256}let v_725: bitstring = catch-fail((if success?(1-proj-7-tuple(v_715)) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-2-tuple(v_722))))) then (if not-caught-fail(v_724) then (v_724,2-proj-2-tuple(v_722)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {257}let v_726: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_725),2-proj-7-tuple(v_715),3-proj-7-tuple(v_715),4-proj-7-tuple(v_715),5-proj-7-tuple(v_715),6-proj-7-tuple(v_715),7-proj-7-tuple(v_715))) in
        {258}let v_727: bitstring = catch-fail(concat3(1-proj-3-tuple(v_716),2-proj-3-tuple(v_716),2-proj-2-tuple(v_725))) in
        {259}let (hs_728: handshakestate,re_729: key,message_c_730: bitstring) = (if (not-caught-fail(v_715) && success?(is-true(success?(1-proj-7-tuple(v_715))))) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-3-tuple(v_716))))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then (if not-caught-fail(v_726) then (if not-caught-fail(v_727) then (v_726,5-proj-7-tuple(v_715),v_727) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {260}event SendMsg(me_621,them_620,stage_c,msg_c(me_621,them_620),true);
        {261}insert statestore(me_621,them_620,statepack_d(hs_728));
        {262}out(pub, message_c_730)
    ) | (
        {291}get statestore(=me_621,=them_620,statepack_d(hs_731: handshakestate)) in
        {264}in(pub, message_d_732: bitstring);
        {265}let v_733: bitstring = catch-fail(handshakestateunpack(hs_731)) in
        {266}let v_734: bitstring = catch-fail(deconcat3(message_d_732)) in
        {267}let v_735: bool = catch-fail(true) in
        {268}let v_736: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_733))) in
        {269}let v_737: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_736))) in
        {270}let v_738: aead = catch-fail(decrypt(1-proj-2-tuple(v_737),2-proj-2-tuple(v_737),3-proj-3-tuple(v_736),3-proj-3-tuple(v_734))) in
        {271}let v_739: bitstring = catch-fail(aeadunpack(v_738)) in
        {272}let v_740: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_736))) in
        {273}let v_741: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_737))) && success?(1-proj-3-tuple(v_736))) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-2-tuple(v_740))))) then cipherstatepack(1-proj-2-tuple(v_740),increment_nonce(2-proj-2-tuple(v_737))) else fail-any) else fail-any)) in
        {274}let v_742: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_734)) && (success?(3-proj-3-tuple(v_736)) && success?(1-proj-3-tuple(v_736)))) then (if (not-caught-fail(v_737) && success?(is-true(success?(1-proj-2-tuple(v_737))))) then (if not-caught-fail(v_738) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then (if not-caught-fail(v_741) then (v_741,3-proj-3-tuple(v_739),1-proj-3-tuple(v_739)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {275}let v_743: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_742),2-proj-3-tuple(v_736),3-proj-3-tuple(v_736)))) in
        {276}let v_744: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_734)) && success?(symmetricstatepack(1-proj-3-tuple(v_742),2-proj-3-tuple(v_736),3-proj-3-tuple(v_736)))) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then symmetricstatepack(1-proj-3-tuple(v_743),2-proj-3-tuple(v_743),hash(3-proj-3-tuple(v_743),3-proj-3-tuple(v_734))) else fail-any) else fail-any)) in
        {277}let v_745: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_734)) && success?(1-proj-7-tuple(v_733))) then (if (not-caught-fail(v_736) && success?(is-true(success?(1-proj-3-tuple(v_736))))) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-3-tuple(v_742))))) then (if not-caught-fail(v_744) then (v_744,2-proj-3-tuple(v_742),3-proj-3-tuple(v_742)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {278}let v_746: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_745),2-proj-7-tuple(v_733),3-proj-7-tuple(v_733),4-proj-7-tuple(v_733),5-proj-7-tuple(v_733),6-proj-7-tuple(v_733),7-proj-7-tuple(v_733))) in
        {279}let v_747: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_745))) in
        {280}let v_748: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_747),zero)) in
        {281}let v_749: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_747),zero)) in
        {282}let v_750: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_747),zero)) in
        {283}let v_751: bitstring = catch-fail((if success?(2-proj-3-tuple(v_747)) then (if not-caught-fail(v_748) then (if not-caught-fail(v_749) then (if not-caught-fail(v_750) then (v_748,v_749,v_750) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {284}let v_752: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_751)) then cipherstatepack(1-proj-3-tuple(v_751),minnonce) else fail-any)) in
        {285}let v_753: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_751)) then cipherstatepack(2-proj-3-tuple(v_751),minnonce) else fail-any)) in
        {286}let v_754: bitstring = catch-fail((if success?(1-proj-3-tuple(v_745)) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-3-tuple(v_747))))) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-3-tuple(v_751))))) then (if not-caught-fail(v_752) then (if not-caught-fail(v_753) then (1-proj-3-tuple(v_745),v_752,v_753) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {287}let (hs_755: handshakestate,re_756: key,plaintext_d_757: bitstring,valid_758: bool,cs1_759: cipherstate,cs2_760: cipherstate) = (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-7-tuple(v_733))))) then (if (not-caught-fail(v_734) && success?(is-true(success?(1-proj-3-tuple(v_734))))) then (if not-caught-fail(v_735) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-3-tuple(v_745))))) then (if (v_735 && 3-proj-3-tuple(v_745)) then (if not-caught-fail(v_746) then (if (not-caught-fail(v_754) && success?(is-true(success?(1-proj-3-tuple(v_754))))) then (v_746,getpublickey(3-proj-7-tuple(v_733)),2-proj-3-tuple(v_745),true,2-proj-3-tuple(v_754),3-proj-3-tuple(v_754)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {288}event RecvMsg(me_621,them_620,stage_d,plaintext_d_757,valid_758);
        {289}insert statestore(me_621,them_620,statepack_e(hs_755));
        {290}event RecvEnd(valid_758)
    ) | (
        {292}event LeakS(phase0,me_621);
        {293}out(pub, key_s(me_621))
    ) | (
        {294}phase 1;
        {295}event LeakS(phase1,me_621);
        {296}out(pub, key_s(me_621))
    )
) | (
    {297}let them_761: principal = alice in
    {298}let me_762: principal = bob in
    {299}let s_763: keypair = keypairpack(empty,empty) in
    {300}out(pub, getpublickey(s_763));
    (
        {301}let e_764: keypair = keypairpack(empty,empty) in
        {302}let v_765: key = catch-fail(dhexp(key_s(them_761),g)) in
        {303}let rs_766: key = getpublickey((if not-caught-fail(v_765) then keypairpack(v_765,key_s(them_761)) else fail-any)) in
        {304}let re_767: key = empty in
        {305}let v_768: bitstring = catch-fail(hash(somename,empty)) in
        {306}let v_769: key = catch-fail(v_768) in
        {307}let v_770: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {308}let v_771: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_768) then (if not-caught-fail(v_769) then (if not-caught-fail(v_770) then symmetricstatepack(v_770,v_769,v_768) else fail-any) else fail-any) else fail-any))) in
        {309}let v_772: symmetricstate = catch-fail((if success?((if not-caught-fail(v_768) then (if not-caught-fail(v_769) then (if not-caught-fail(v_770) then symmetricstatepack(v_770,v_769,v_768) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-3-tuple(v_771))))) then symmetricstatepack(1-proj-3-tuple(v_771),2-proj-3-tuple(v_771),hash(3-proj-3-tuple(v_771),empty)) else fail-any) else fail-any)) in
        {310}let v_773: bitstring = catch-fail(symmetricstateunpack(v_772)) in
        {311}let v_774: symmetricstate = catch-fail((if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then symmetricstatepack(1-proj-3-tuple(v_773),2-proj-3-tuple(v_773),hash(3-proj-3-tuple(v_773),rs_766)) else fail-any)) in
        {312}let hs_775: handshakestate = (if not-caught-fail(v_772) then (if not-caught-fail(v_774) then handshakestatepack(v_774,s_763,e_764,rs_766,re_767,empty,false) else fail-any) else fail-any) in
        {313}insert statestore(me_762,them_761,statepack_a(hs_775))
    ) | (
        {335}get statestore(=me_762,=them_761,statepack_a(hs_776: handshakestate)) in
        {314}in(pub, message_a_777: bitstring);
        {315}let v_778: bitstring = catch-fail(handshakestateunpack(hs_776)) in
        {316}let v_779: bitstring = catch-fail(deconcat3(message_a_777)) in
        {317}let v_780: bool = catch-fail(true) in
        {318}let v_781: key = catch-fail(1-proj-3-tuple(v_779)) in
        {319}let v_782: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_778))) in
        {320}let v_783: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_778)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then symmetricstatepack(1-proj-3-tuple(v_782),2-proj-3-tuple(v_782),hash(3-proj-3-tuple(v_782),v_781)) else fail-any) else fail-any)) in
        {321}let v_784: bitstring = catch-fail(symmetricstateunpack(v_783)) in
        {322}let v_785: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_784))) in
        {323}let v_786: aead = catch-fail(decrypt(1-proj-2-tuple(v_785),2-proj-2-tuple(v_785),3-proj-3-tuple(v_784),3-proj-3-tuple(v_779))) in
        {324}let v_787: bitstring = catch-fail(aeadunpack(v_786)) in
        {325}let v_788: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_784))) in
        {326}let v_789: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_785))) && success?(1-proj-3-tuple(v_784))) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-2-tuple(v_788))))) then cipherstatepack(1-proj-2-tuple(v_788),increment_nonce(2-proj-2-tuple(v_785))) else fail-any) else fail-any)) in
        {327}let v_790: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_779)) && (success?(3-proj-3-tuple(v_784)) && success?(1-proj-3-tuple(v_784)))) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then (if not-caught-fail(v_786) then (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-3-tuple(v_787))))) then (if not-caught-fail(v_789) then (v_789,3-proj-3-tuple(v_787),1-proj-3-tuple(v_787)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {328}let v_791: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_790),2-proj-3-tuple(v_784),3-proj-3-tuple(v_784)))) in
        {329}let v_792: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_779)) && success?(symmetricstatepack(1-proj-3-tuple(v_790),2-proj-3-tuple(v_784),3-proj-3-tuple(v_784)))) then (if (not-caught-fail(v_791) && success?(is-true(success?(1-proj-3-tuple(v_791))))) then symmetricstatepack(1-proj-3-tuple(v_791),2-proj-3-tuple(v_791),hash(3-proj-3-tuple(v_791),3-proj-3-tuple(v_779))) else fail-any) else fail-any)) in
        {330}let v_793: bitstring = catch-fail((if success?(3-proj-3-tuple(v_779)) then (if (not-caught-fail(v_784) && success?(is-true(success?(1-proj-3-tuple(v_784))))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then (if not-caught-fail(v_792) then (v_792,2-proj-3-tuple(v_790),3-proj-3-tuple(v_790)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {331}let v_794: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_793),2-proj-7-tuple(v_778),3-proj-7-tuple(v_778),4-proj-7-tuple(v_778),v_781,6-proj-7-tuple(v_778),7-proj-7-tuple(v_778))) in
        {332}let (hs_795: handshakestate,re_796: key,plaintext_a: bitstring,valid_797: bool) = (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-7-tuple(v_778))))) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-3-tuple(v_779))))) then (if not-caught-fail(v_780) then (if not-caught-fail(v_781) then (if not-caught-fail(v_783) then (if (not-caught-fail(v_793) && success?(is-true(success?(1-proj-3-tuple(v_793))))) then (if (v_780 && 3-proj-3-tuple(v_793)) then (if not-caught-fail(v_794) then (v_794,getpublickey(3-proj-7-tuple(v_778)),2-proj-3-tuple(v_793),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {333}event RecvMsg(me_762,them_761,stage_a,plaintext_a,valid_797);
        {334}insert statestore(me_762,them_761,statepack_b(hs_795))
    ) | (
        {391}get statestore(=me_762,=them_761,statepack_b(hs_798: handshakestate)) in
        {336}let v_799: bitstring = catch-fail(handshakestateunpack(hs_798)) in
        {337}let v_800: bitstring = catch-fail((empty,empty,empty)) in
        {338}new key_e_801[me_762,them_761]: key;
        {339}let v_802: key = catch-fail(dhexp(key_e_801,g)) in
        {340}let v_803: keypair = catch-fail((if not-caught-fail(v_802) then keypairpack(v_802,key_e_801) else fail-any)) in
        {341}let v_804: bitstring = catch-fail(getpublickey(v_803)) in
        {342}let v_805: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_799))) in
        {343}let v_806: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_799)) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then symmetricstatepack(1-proj-3-tuple(v_805),2-proj-3-tuple(v_805),hash(3-proj-3-tuple(v_805),v_804)) else fail-any) else fail-any)) in
        {344}let v_807: bitstring = catch-fail(keypairunpack(v_803)) in
        {345}let v_808: bitstring = catch-fail(symmetricstateunpack(v_806)) in
        {346}let v_809: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_808),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then dhexp(2-proj-2-tuple(v_807),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {347}let v_810: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_808),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then dhexp(2-proj-2-tuple(v_807),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {348}let v_811: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_808),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then dhexp(2-proj-2-tuple(v_807),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {349}let v_812: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then dhexp(2-proj-2-tuple(v_807),5-proj-7-tuple(v_799)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_808))) then (if not-caught-fail(v_809) then (if not-caught-fail(v_810) then (if not-caught-fail(v_811) then (v_809,v_810,v_811) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {350}let v_813: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then dhexp(2-proj-2-tuple(v_807),5-proj-7-tuple(v_799)) else fail-any) else fail-any)) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then (if (not-caught-fail(v_812) && success?(is-true(success?(1-proj-3-tuple(v_812))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_812)) then cipherstatepack(2-proj-3-tuple(v_812),minnonce) else fail-any),1-proj-3-tuple(v_812),3-proj-3-tuple(v_808)) else fail-any) else fail-any) else fail-any)) in
        {351}let v_814: bitstring = catch-fail(keypairunpack(v_803)) in
        {352}let v_815: bitstring = catch-fail(symmetricstateunpack(v_813)) in
        {353}let v_816: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_815),(if success?(4-proj-7-tuple(v_799)) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then dhexp(2-proj-2-tuple(v_814),4-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {354}let v_817: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_815),(if success?(4-proj-7-tuple(v_799)) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then dhexp(2-proj-2-tuple(v_814),4-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {355}let v_818: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_815),(if success?(4-proj-7-tuple(v_799)) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then dhexp(2-proj-2-tuple(v_814),4-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {356}let v_819: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_799)) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then dhexp(2-proj-2-tuple(v_814),4-proj-7-tuple(v_799)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_815))) then (if not-caught-fail(v_816) then (if not-caught-fail(v_817) then (if not-caught-fail(v_818) then (v_816,v_817,v_818) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {357}let v_820: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_799)) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then dhexp(2-proj-2-tuple(v_814),4-proj-7-tuple(v_799)) else fail-any) else fail-any)) then (if (not-caught-fail(v_815) && success?(is-true(success?(1-proj-3-tuple(v_815))))) then (if (not-caught-fail(v_819) && success?(is-true(success?(1-proj-3-tuple(v_819))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_819)) then cipherstatepack(2-proj-3-tuple(v_819),minnonce) else fail-any),1-proj-3-tuple(v_819),3-proj-3-tuple(v_815)) else fail-any) else fail-any) else fail-any)) in
        {358}let v_821: key = catch-fail(dhexp(key_s(me_762),g)) in
        {359}let v_822: keypair = catch-fail((if not-caught-fail(v_821) then keypairpack(v_821,key_s(me_762)) else fail-any)) in
        {360}let v_823: bitstring = catch-fail(symmetricstateunpack(v_820)) in
        {361}let v_824: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_823))) in
        {362}let v_825: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_824),2-proj-2-tuple(v_824),3-proj-3-tuple(v_823),getpublickey(v_822))) in
        {363}let v_826: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_823))) in
        {364}let v_827: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_824))) && success?(1-proj-3-tuple(v_823))) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-2-tuple(v_826))))) then cipherstatepack(1-proj-2-tuple(v_826),increment_nonce(2-proj-2-tuple(v_824))) else fail-any) else fail-any)) in
        {365}let v_828: bitstring = catch-fail((if (success?(getpublickey(v_822)) && (success?(3-proj-3-tuple(v_823)) && success?(1-proj-3-tuple(v_823)))) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-2-tuple(v_824))))) then (if not-caught-fail(v_825) then (if not-caught-fail(v_827) then (v_827,v_825) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {366}let v_829: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_828),2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)))) in
        {367}let v_830: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_828)) && success?(symmetricstatepack(1-proj-2-tuple(v_828),2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)))) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then symmetricstatepack(1-proj-3-tuple(v_829),2-proj-3-tuple(v_829),hash(3-proj-3-tuple(v_829),2-proj-2-tuple(v_828))) else fail-any) else fail-any)) in
        {368}let v_831: bitstring = catch-fail((if success?(getpublickey(v_822)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (if (not-caught-fail(v_828) && success?(is-true(success?(1-proj-2-tuple(v_828))))) then (if not-caught-fail(v_830) then (v_830,2-proj-2-tuple(v_828)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {369}let v_832: bitstring = catch-fail(keypairunpack(v_822)) in
        {370}let v_833: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_831))) in
        {371}let v_834: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_833),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then dhexp(2-proj-2-tuple(v_832),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {372}let v_835: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_833),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then dhexp(2-proj-2-tuple(v_832),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {373}let v_836: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_833),(if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then dhexp(2-proj-2-tuple(v_832),5-proj-7-tuple(v_799)) else fail-any) else fail-any))) in
        {374}let v_837: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then dhexp(2-proj-2-tuple(v_832),5-proj-7-tuple(v_799)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_833))) then (if not-caught-fail(v_834) then (if not-caught-fail(v_835) then (if not-caught-fail(v_836) then (v_834,v_835,v_836) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {375}let v_838: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_799)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then dhexp(2-proj-2-tuple(v_832),5-proj-7-tuple(v_799)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_831))) then (if (not-caught-fail(v_833) && success?(is-true(success?(1-proj-3-tuple(v_833))))) then (if (not-caught-fail(v_837) && success?(is-true(success?(1-proj-3-tuple(v_837))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_837)) then cipherstatepack(2-proj-3-tuple(v_837),minnonce) else fail-any),1-proj-3-tuple(v_837),3-proj-3-tuple(v_833)) else fail-any) else fail-any) else fail-any)) in
        {376}let v_839: bitstring = catch-fail(symmetricstateunpack(v_838)) in
        {377}let v_840: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_839))) in
        {378}let v_841: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_840),2-proj-2-tuple(v_840),3-proj-3-tuple(v_839),msg_b(me_762,them_761))) in
        {379}let v_842: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_839))) in
        {380}let v_843: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_840))) && success?(1-proj-3-tuple(v_839))) then (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-2-tuple(v_842))))) then cipherstatepack(1-proj-2-tuple(v_842),increment_nonce(2-proj-2-tuple(v_840))) else fail-any) else fail-any)) in
        {381}let v_844: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_839)) && success?(1-proj-3-tuple(v_839))) then (if (not-caught-fail(v_840) && success?(is-true(success?(1-proj-2-tuple(v_840))))) then (if not-caught-fail(v_841) then (if not-caught-fail(v_843) then (v_843,v_841) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {382}let v_845: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_844),2-proj-3-tuple(v_839),3-proj-3-tuple(v_839)))) in
        {383}let v_846: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_844)) && success?(symmetricstatepack(1-proj-2-tuple(v_844),2-proj-3-tuple(v_839),3-proj-3-tuple(v_839)))) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-3-tuple(v_845))))) then symmetricstatepack(1-proj-3-tuple(v_845),2-proj-3-tuple(v_845),hash(3-proj-3-tuple(v_845),2-proj-2-tuple(v_844))) else fail-any) else fail-any)) in
        {384}let v_847: bitstring = catch-fail((if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-2-tuple(v_844))))) then (if not-caught-fail(v_846) then (v_846,2-proj-2-tuple(v_844)) else fail-any) else fail-any) else fail-any)) in
        {385}let v_848: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_847),v_822,v_803,4-proj-7-tuple(v_799),5-proj-7-tuple(v_799),6-proj-7-tuple(v_799),7-proj-7-tuple(v_799))) in
        {386}let v_849: bitstring = catch-fail(concat3(v_804,2-proj-2-tuple(v_831),2-proj-2-tuple(v_847))) in
        {387}let (hs_850: handshakestate,re_851: key,message_b_852: bitstring) = (if (not-caught-fail(v_799) && success?(is-true(success?(1-proj-7-tuple(v_799))))) then (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-3-tuple(v_800))))) then (if not-caught-fail(v_803) then (if not-caught-fail(v_804) then (if not-caught-fail(v_806) then (if not-caught-fail(v_813) then (if not-caught-fail(v_820) then (if not-caught-fail(v_822) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then (if not-caught-fail(v_838) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-2-tuple(v_847))))) then (if not-caught-fail(v_848) then (if not-caught-fail(v_849) then (v_848,5-proj-7-tuple(v_799),v_849) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {388}event SendMsg(me_762,them_761,stage_b,msg_b(me_762,them_761),true);
        {389}insert statestore(me_762,them_761,statepack_c(hs_850));
        {390}out(pub, message_b_852)
    ) | (
        {410}get statestore(=me_762,=them_761,statepack_c(hs_853: handshakestate)) in
        {392}in(pub, message_c_854: bitstring);
        {393}let v_855: bitstring = catch-fail(handshakestateunpack(hs_853)) in
        {394}let v_856: bitstring = catch-fail(deconcat3(message_c_854)) in
        {395}let v_857: bool = catch-fail(true) in
        {396}let v_858: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_855))) in
        {397}let v_859: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_858))) in
        {398}let v_860: aead = catch-fail(decrypt(1-proj-2-tuple(v_859),2-proj-2-tuple(v_859),3-proj-3-tuple(v_858),3-proj-3-tuple(v_856))) in
        {399}let v_861: bitstring = catch-fail(aeadunpack(v_860)) in
        {400}let v_862: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_858))) in
        {401}let v_863: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_859))) && success?(1-proj-3-tuple(v_858))) then (if (not-caught-fail(v_862) && success?(is-true(success?(1-proj-2-tuple(v_862))))) then cipherstatepack(1-proj-2-tuple(v_862),increment_nonce(2-proj-2-tuple(v_859))) else fail-any) else fail-any)) in
        {402}let v_864: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_856)) && (success?(3-proj-3-tuple(v_858)) && success?(1-proj-3-tuple(v_858)))) then (if (not-caught-fail(v_859) && success?(is-true(success?(1-proj-2-tuple(v_859))))) then (if not-caught-fail(v_860) then (if (not-caught-fail(v_861) && success?(is-true(success?(1-proj-3-tuple(v_861))))) then (if not-caught-fail(v_863) then (v_863,3-proj-3-tuple(v_861),1-proj-3-tuple(v_861)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {403}let v_865: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_864),2-proj-3-tuple(v_858),3-proj-3-tuple(v_858)))) in
        {404}let v_866: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_856)) && success?(symmetricstatepack(1-proj-3-tuple(v_864),2-proj-3-tuple(v_858),3-proj-3-tuple(v_858)))) then (if (not-caught-fail(v_865) && success?(is-true(success?(1-proj-3-tuple(v_865))))) then symmetricstatepack(1-proj-3-tuple(v_865),2-proj-3-tuple(v_865),hash(3-proj-3-tuple(v_865),3-proj-3-tuple(v_856))) else fail-any) else fail-any)) in
        {405}let v_867: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_856)) && success?(1-proj-7-tuple(v_855))) then (if (not-caught-fail(v_858) && success?(is-true(success?(1-proj-3-tuple(v_858))))) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-3-tuple(v_864))))) then (if not-caught-fail(v_866) then (v_866,2-proj-3-tuple(v_864),3-proj-3-tuple(v_864)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {406}let v_868: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_867),2-proj-7-tuple(v_855),3-proj-7-tuple(v_855),4-proj-7-tuple(v_855),5-proj-7-tuple(v_855),6-proj-7-tuple(v_855),7-proj-7-tuple(v_855))) in
        {407}let (hs_869: handshakestate,re_870: key,plaintext_c: bitstring,valid_871: bool) = (if (not-caught-fail(v_855) && success?(is-true(success?(1-proj-7-tuple(v_855))))) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-3-tuple(v_856))))) then (if not-caught-fail(v_857) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-3-tuple(v_867))))) then (if (v_857 && 3-proj-3-tuple(v_867)) then (if not-caught-fail(v_868) then (v_868,getpublickey(3-proj-7-tuple(v_855)),2-proj-3-tuple(v_867),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {408}event RecvMsg(me_762,them_761,stage_c,plaintext_c,valid_871);
        {409}insert statestore(me_762,them_761,statepack_d(hs_869))
    ) | (
        {436}get statestore(=me_762,=them_761,statepack_d(hs_872: handshakestate)) in
        {411}let v_873: bitstring = catch-fail(handshakestateunpack(hs_872)) in
        {412}let v_874: bitstring = catch-fail((empty,empty,empty)) in
        {413}let v_875: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_873))) in
        {414}let v_876: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_875))) in
        {415}let v_877: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_876),2-proj-2-tuple(v_876),3-proj-3-tuple(v_875),msg_d(me_762,them_761))) in
        {416}let v_878: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_875))) in
        {417}let v_879: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_876))) && success?(1-proj-3-tuple(v_875))) then (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-2-tuple(v_878))))) then cipherstatepack(1-proj-2-tuple(v_878),increment_nonce(2-proj-2-tuple(v_876))) else fail-any) else fail-any)) in
        {418}let v_880: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_875)) && success?(1-proj-3-tuple(v_875))) then (if (not-caught-fail(v_876) && success?(is-true(success?(1-proj-2-tuple(v_876))))) then (if not-caught-fail(v_877) then (if not-caught-fail(v_879) then (v_879,v_877) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {419}let v_881: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_880),2-proj-3-tuple(v_875),3-proj-3-tuple(v_875)))) in
        {420}let v_882: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_880)) && success?(symmetricstatepack(1-proj-2-tuple(v_880),2-proj-3-tuple(v_875),3-proj-3-tuple(v_875)))) then (if (not-caught-fail(v_881) && success?(is-true(success?(1-proj-3-tuple(v_881))))) then symmetricstatepack(1-proj-3-tuple(v_881),2-proj-3-tuple(v_881),hash(3-proj-3-tuple(v_881),2-proj-2-tuple(v_880))) else fail-any) else fail-any)) in
        {421}let v_883: bitstring = catch-fail((if success?(1-proj-7-tuple(v_873)) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-3-tuple(v_875))))) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-2-tuple(v_880))))) then (if not-caught-fail(v_882) then (v_882,2-proj-2-tuple(v_880)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {422}let v_884: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_883),2-proj-7-tuple(v_873),3-proj-7-tuple(v_873),4-proj-7-tuple(v_873),5-proj-7-tuple(v_873),6-proj-7-tuple(v_873),7-proj-7-tuple(v_873))) in
        {423}let v_885: bitstring = catch-fail(concat3(1-proj-3-tuple(v_874),2-proj-3-tuple(v_874),2-proj-2-tuple(v_883))) in
        {424}let v_886: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_883))) in
        {425}let v_887: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_886),zero)) in
        {426}let v_888: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_886),zero)) in
        {427}let v_889: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_886),zero)) in
        {428}let v_890: bitstring = catch-fail((if success?(2-proj-3-tuple(v_886)) then (if not-caught-fail(v_887) then (if not-caught-fail(v_888) then (if not-caught-fail(v_889) then (v_887,v_888,v_889) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {429}let v_891: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_890)) then cipherstatepack(1-proj-3-tuple(v_890),minnonce) else fail-any)) in
        {430}let v_892: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_890)) then cipherstatepack(2-proj-3-tuple(v_890),minnonce) else fail-any)) in
        {431}let v_893: bitstring = catch-fail((if success?(1-proj-2-tuple(v_883)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-3-tuple(v_886))))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-3-tuple(v_890))))) then (if not-caught-fail(v_891) then (if not-caught-fail(v_892) then (1-proj-2-tuple(v_883),v_891,v_892) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {432}let (hs_894: handshakestate,re_895: key,message_d_896: bitstring,cs1_897: cipherstate,cs2_898: cipherstate) = (if (not-caught-fail(v_873) && success?(is-true(success?(1-proj-7-tuple(v_873))))) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-2-tuple(v_883))))) then (if not-caught-fail(v_884) then (if not-caught-fail(v_885) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-3-tuple(v_893))))) then (v_884,5-proj-7-tuple(v_873),v_885,2-proj-3-tuple(v_893),3-proj-3-tuple(v_893)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {433}event SendMsg(me_762,them_761,stage_d,msg_d(me_762,them_761),true);
        {434}insert statestore(me_762,them_761,statepack_e(hs_894));
        {435}out(pub, message_d_896)
    ) | (
        {437}event LeakS(phase0,me_762);
        {438}out(pub, key_s(me_762))
    ) | (
        {439}phase 1;
        {440}event LeakS(phase1,me_762);
        {441}out(pub, key_s(me_762))
    )
) | (
    {442}let them_899: principal = charlie in
    {443}let me_900: principal = bob in
    {444}let s_901: keypair = keypairpack(empty,empty) in
    {445}out(pub, getpublickey(s_901));
    (
        {446}let e_902: keypair = keypairpack(empty,empty) in
        {447}let v_903: key = catch-fail(dhexp(key_s(them_899),g)) in
        {448}let rs_904: key = getpublickey((if not-caught-fail(v_903) then keypairpack(v_903,key_s(them_899)) else fail-any)) in
        {449}let re_905: key = empty in
        {450}let v_906: bitstring = catch-fail(hash(somename,empty)) in
        {451}let v_907: key = catch-fail(v_906) in
        {452}let v_908: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {453}let v_909: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_906) then (if not-caught-fail(v_907) then (if not-caught-fail(v_908) then symmetricstatepack(v_908,v_907,v_906) else fail-any) else fail-any) else fail-any))) in
        {454}let v_910: symmetricstate = catch-fail((if success?((if not-caught-fail(v_906) then (if not-caught-fail(v_907) then (if not-caught-fail(v_908) then symmetricstatepack(v_908,v_907,v_906) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_909) && success?(is-true(success?(1-proj-3-tuple(v_909))))) then symmetricstatepack(1-proj-3-tuple(v_909),2-proj-3-tuple(v_909),hash(3-proj-3-tuple(v_909),empty)) else fail-any) else fail-any)) in
        {455}let v_911: bitstring = catch-fail(symmetricstateunpack(v_910)) in
        {456}let v_912: symmetricstate = catch-fail((if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then symmetricstatepack(1-proj-3-tuple(v_911),2-proj-3-tuple(v_911),hash(3-proj-3-tuple(v_911),rs_904)) else fail-any)) in
        {457}let hs_913: handshakestate = (if not-caught-fail(v_910) then (if not-caught-fail(v_912) then handshakestatepack(v_912,s_901,e_902,rs_904,re_905,empty,false) else fail-any) else fail-any) in
        {458}insert statestore(me_900,them_899,statepack_a(hs_913))
    ) | (
        {480}get statestore(=me_900,=them_899,statepack_a(hs_914: handshakestate)) in
        {459}in(pub, message_a_915: bitstring);
        {460}let v_916: bitstring = catch-fail(handshakestateunpack(hs_914)) in
        {461}let v_917: bitstring = catch-fail(deconcat3(message_a_915)) in
        {462}let v_918: bool = catch-fail(true) in
        {463}let v_919: key = catch-fail(1-proj-3-tuple(v_917)) in
        {464}let v_920: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_916))) in
        {465}let v_921: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_916)) then (if (not-caught-fail(v_920) && success?(is-true(success?(1-proj-3-tuple(v_920))))) then symmetricstatepack(1-proj-3-tuple(v_920),2-proj-3-tuple(v_920),hash(3-proj-3-tuple(v_920),v_919)) else fail-any) else fail-any)) in
        {466}let v_922: bitstring = catch-fail(symmetricstateunpack(v_921)) in
        {467}let v_923: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_922))) in
        {468}let v_924: aead = catch-fail(decrypt(1-proj-2-tuple(v_923),2-proj-2-tuple(v_923),3-proj-3-tuple(v_922),3-proj-3-tuple(v_917))) in
        {469}let v_925: bitstring = catch-fail(aeadunpack(v_924)) in
        {470}let v_926: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_922))) in
        {471}let v_927: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_923))) && success?(1-proj-3-tuple(v_922))) then (if (not-caught-fail(v_926) && success?(is-true(success?(1-proj-2-tuple(v_926))))) then cipherstatepack(1-proj-2-tuple(v_926),increment_nonce(2-proj-2-tuple(v_923))) else fail-any) else fail-any)) in
        {472}let v_928: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_917)) && (success?(3-proj-3-tuple(v_922)) && success?(1-proj-3-tuple(v_922)))) then (if (not-caught-fail(v_923) && success?(is-true(success?(1-proj-2-tuple(v_923))))) then (if not-caught-fail(v_924) then (if (not-caught-fail(v_925) && success?(is-true(success?(1-proj-3-tuple(v_925))))) then (if not-caught-fail(v_927) then (v_927,3-proj-3-tuple(v_925),1-proj-3-tuple(v_925)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {473}let v_929: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_928),2-proj-3-tuple(v_922),3-proj-3-tuple(v_922)))) in
        {474}let v_930: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_917)) && success?(symmetricstatepack(1-proj-3-tuple(v_928),2-proj-3-tuple(v_922),3-proj-3-tuple(v_922)))) then (if (not-caught-fail(v_929) && success?(is-true(success?(1-proj-3-tuple(v_929))))) then symmetricstatepack(1-proj-3-tuple(v_929),2-proj-3-tuple(v_929),hash(3-proj-3-tuple(v_929),3-proj-3-tuple(v_917))) else fail-any) else fail-any)) in
        {475}let v_931: bitstring = catch-fail((if success?(3-proj-3-tuple(v_917)) then (if (not-caught-fail(v_922) && success?(is-true(success?(1-proj-3-tuple(v_922))))) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then (if not-caught-fail(v_930) then (v_930,2-proj-3-tuple(v_928),3-proj-3-tuple(v_928)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {476}let v_932: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_931),2-proj-7-tuple(v_916),3-proj-7-tuple(v_916),4-proj-7-tuple(v_916),v_919,6-proj-7-tuple(v_916),7-proj-7-tuple(v_916))) in
        {477}let (hs_933: handshakestate,re_934: key,plaintext_a_935: bitstring,valid_936: bool) = (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-7-tuple(v_916))))) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then (if not-caught-fail(v_918) then (if not-caught-fail(v_919) then (if not-caught-fail(v_921) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-3-tuple(v_931))))) then (if (v_918 && 3-proj-3-tuple(v_931)) then (if not-caught-fail(v_932) then (v_932,getpublickey(3-proj-7-tuple(v_916)),2-proj-3-tuple(v_931),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {478}event RecvMsg(me_900,them_899,stage_a,plaintext_a_935,valid_936);
        {479}insert statestore(me_900,them_899,statepack_b(hs_933))
    ) | (
        {536}get statestore(=me_900,=them_899,statepack_b(hs_937: handshakestate)) in
        {481}let v_938: bitstring = catch-fail(handshakestateunpack(hs_937)) in
        {482}let v_939: bitstring = catch-fail((empty,empty,empty)) in
        {483}new key_e_940[me_900,them_899]: key;
        {484}let v_941: key = catch-fail(dhexp(key_e_940,g)) in
        {485}let v_942: keypair = catch-fail((if not-caught-fail(v_941) then keypairpack(v_941,key_e_940) else fail-any)) in
        {486}let v_943: bitstring = catch-fail(getpublickey(v_942)) in
        {487}let v_944: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_938))) in
        {488}let v_945: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_938)) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then symmetricstatepack(1-proj-3-tuple(v_944),2-proj-3-tuple(v_944),hash(3-proj-3-tuple(v_944),v_943)) else fail-any) else fail-any)) in
        {489}let v_946: bitstring = catch-fail(keypairunpack(v_942)) in
        {490}let v_947: bitstring = catch-fail(symmetricstateunpack(v_945)) in
        {491}let v_948: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_947),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {492}let v_949: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_947),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {493}let v_950: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_947),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {494}let v_951: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),5-proj-7-tuple(v_938)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_947))) then (if not-caught-fail(v_948) then (if not-caught-fail(v_949) then (if not-caught-fail(v_950) then (v_948,v_949,v_950) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {495}let v_952: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),5-proj-7-tuple(v_938)) else fail-any) else fail-any)) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then (if (not-caught-fail(v_951) && success?(is-true(success?(1-proj-3-tuple(v_951))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_951)) then cipherstatepack(2-proj-3-tuple(v_951),minnonce) else fail-any),1-proj-3-tuple(v_951),3-proj-3-tuple(v_947)) else fail-any) else fail-any) else fail-any)) in
        {496}let v_953: bitstring = catch-fail(keypairunpack(v_942)) in
        {497}let v_954: bitstring = catch-fail(symmetricstateunpack(v_952)) in
        {498}let v_955: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_954),(if success?(4-proj-7-tuple(v_938)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-2-tuple(v_953))))) then dhexp(2-proj-2-tuple(v_953),4-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {499}let v_956: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_954),(if success?(4-proj-7-tuple(v_938)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-2-tuple(v_953))))) then dhexp(2-proj-2-tuple(v_953),4-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {500}let v_957: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_954),(if success?(4-proj-7-tuple(v_938)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-2-tuple(v_953))))) then dhexp(2-proj-2-tuple(v_953),4-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {501}let v_958: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_938)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-2-tuple(v_953))))) then dhexp(2-proj-2-tuple(v_953),4-proj-7-tuple(v_938)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_954))) then (if not-caught-fail(v_955) then (if not-caught-fail(v_956) then (if not-caught-fail(v_957) then (v_955,v_956,v_957) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {502}let v_959: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_938)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-2-tuple(v_953))))) then dhexp(2-proj-2-tuple(v_953),4-proj-7-tuple(v_938)) else fail-any) else fail-any)) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-3-tuple(v_954))))) then (if (not-caught-fail(v_958) && success?(is-true(success?(1-proj-3-tuple(v_958))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_958)) then cipherstatepack(2-proj-3-tuple(v_958),minnonce) else fail-any),1-proj-3-tuple(v_958),3-proj-3-tuple(v_954)) else fail-any) else fail-any) else fail-any)) in
        {503}let v_960: key = catch-fail(dhexp(key_s(me_900),g)) in
        {504}let v_961: keypair = catch-fail((if not-caught-fail(v_960) then keypairpack(v_960,key_s(me_900)) else fail-any)) in
        {505}let v_962: bitstring = catch-fail(symmetricstateunpack(v_959)) in
        {506}let v_963: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_962))) in
        {507}let v_964: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_963),2-proj-2-tuple(v_963),3-proj-3-tuple(v_962),getpublickey(v_961))) in
        {508}let v_965: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_962))) in
        {509}let v_966: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_963))) && success?(1-proj-3-tuple(v_962))) then (if (not-caught-fail(v_965) && success?(is-true(success?(1-proj-2-tuple(v_965))))) then cipherstatepack(1-proj-2-tuple(v_965),increment_nonce(2-proj-2-tuple(v_963))) else fail-any) else fail-any)) in
        {510}let v_967: bitstring = catch-fail((if (success?(getpublickey(v_961)) && (success?(3-proj-3-tuple(v_962)) && success?(1-proj-3-tuple(v_962)))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-2-tuple(v_963))))) then (if not-caught-fail(v_964) then (if not-caught-fail(v_966) then (v_966,v_964) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {511}let v_968: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_967),2-proj-3-tuple(v_962),3-proj-3-tuple(v_962)))) in
        {512}let v_969: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_967)) && success?(symmetricstatepack(1-proj-2-tuple(v_967),2-proj-3-tuple(v_962),3-proj-3-tuple(v_962)))) then (if (not-caught-fail(v_968) && success?(is-true(success?(1-proj-3-tuple(v_968))))) then symmetricstatepack(1-proj-3-tuple(v_968),2-proj-3-tuple(v_968),hash(3-proj-3-tuple(v_968),2-proj-2-tuple(v_967))) else fail-any) else fail-any)) in
        {513}let v_970: bitstring = catch-fail((if success?(getpublickey(v_961)) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then (if (not-caught-fail(v_967) && success?(is-true(success?(1-proj-2-tuple(v_967))))) then (if not-caught-fail(v_969) then (v_969,2-proj-2-tuple(v_967)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {514}let v_971: bitstring = catch-fail(keypairunpack(v_961)) in
        {515}let v_972: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_970))) in
        {516}let v_973: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_972),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then dhexp(2-proj-2-tuple(v_971),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {517}let v_974: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_972),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then dhexp(2-proj-2-tuple(v_971),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {518}let v_975: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_972),(if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then dhexp(2-proj-2-tuple(v_971),5-proj-7-tuple(v_938)) else fail-any) else fail-any))) in
        {519}let v_976: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then dhexp(2-proj-2-tuple(v_971),5-proj-7-tuple(v_938)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_972))) then (if not-caught-fail(v_973) then (if not-caught-fail(v_974) then (if not-caught-fail(v_975) then (v_973,v_974,v_975) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {520}let v_977: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_938)) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then dhexp(2-proj-2-tuple(v_971),5-proj-7-tuple(v_938)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_970))) then (if (not-caught-fail(v_972) && success?(is-true(success?(1-proj-3-tuple(v_972))))) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-3-tuple(v_976))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_976)) then cipherstatepack(2-proj-3-tuple(v_976),minnonce) else fail-any),1-proj-3-tuple(v_976),3-proj-3-tuple(v_972)) else fail-any) else fail-any) else fail-any)) in
        {521}let v_978: bitstring = catch-fail(symmetricstateunpack(v_977)) in
        {522}let v_979: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_978))) in
        {523}let v_980: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_979),2-proj-2-tuple(v_979),3-proj-3-tuple(v_978),msg_b(me_900,them_899))) in
        {524}let v_981: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_978))) in
        {525}let v_982: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_979))) && success?(1-proj-3-tuple(v_978))) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-2-tuple(v_981))))) then cipherstatepack(1-proj-2-tuple(v_981),increment_nonce(2-proj-2-tuple(v_979))) else fail-any) else fail-any)) in
        {526}let v_983: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_978)) && success?(1-proj-3-tuple(v_978))) then (if (not-caught-fail(v_979) && success?(is-true(success?(1-proj-2-tuple(v_979))))) then (if not-caught-fail(v_980) then (if not-caught-fail(v_982) then (v_982,v_980) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {527}let v_984: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_983),2-proj-3-tuple(v_978),3-proj-3-tuple(v_978)))) in
        {528}let v_985: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_983)) && success?(symmetricstatepack(1-proj-2-tuple(v_983),2-proj-3-tuple(v_978),3-proj-3-tuple(v_978)))) then (if (not-caught-fail(v_984) && success?(is-true(success?(1-proj-3-tuple(v_984))))) then symmetricstatepack(1-proj-3-tuple(v_984),2-proj-3-tuple(v_984),hash(3-proj-3-tuple(v_984),2-proj-2-tuple(v_983))) else fail-any) else fail-any)) in
        {529}let v_986: bitstring = catch-fail((if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-3-tuple(v_978))))) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then (if not-caught-fail(v_985) then (v_985,2-proj-2-tuple(v_983)) else fail-any) else fail-any) else fail-any)) in
        {530}let v_987: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_986),v_961,v_942,4-proj-7-tuple(v_938),5-proj-7-tuple(v_938),6-proj-7-tuple(v_938),7-proj-7-tuple(v_938))) in
        {531}let v_988: bitstring = catch-fail(concat3(v_943,2-proj-2-tuple(v_970),2-proj-2-tuple(v_986))) in
        {532}let (hs_989: handshakestate,re_990: key,message_b_991: bitstring) = (if (not-caught-fail(v_938) && success?(is-true(success?(1-proj-7-tuple(v_938))))) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-3-tuple(v_939))))) then (if not-caught-fail(v_942) then (if not-caught-fail(v_943) then (if not-caught-fail(v_945) then (if not-caught-fail(v_952) then (if not-caught-fail(v_959) then (if not-caught-fail(v_961) then (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-2-tuple(v_970))))) then (if not-caught-fail(v_977) then (if (not-caught-fail(v_986) && success?(is-true(success?(1-proj-2-tuple(v_986))))) then (if not-caught-fail(v_987) then (if not-caught-fail(v_988) then (v_987,5-proj-7-tuple(v_938),v_988) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {533}event SendMsg(me_900,them_899,stage_b,msg_b(me_900,them_899),true);
        {534}insert statestore(me_900,them_899,statepack_c(hs_989));
        {535}out(pub, message_b_991)
    ) | (
        {555}get statestore(=me_900,=them_899,statepack_c(hs_992: handshakestate)) in
        {537}in(pub, message_c_993: bitstring);
        {538}let v_994: bitstring = catch-fail(handshakestateunpack(hs_992)) in
        {539}let v_995: bitstring = catch-fail(deconcat3(message_c_993)) in
        {540}let v_996: bool = catch-fail(true) in
        {541}let v_997: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_994))) in
        {542}let v_998: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_997))) in
        {543}let v_999: aead = catch-fail(decrypt(1-proj-2-tuple(v_998),2-proj-2-tuple(v_998),3-proj-3-tuple(v_997),3-proj-3-tuple(v_995))) in
        {544}let v_1000: bitstring = catch-fail(aeadunpack(v_999)) in
        {545}let v_1001: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_997))) in
        {546}let v_1002: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_998))) && success?(1-proj-3-tuple(v_997))) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then cipherstatepack(1-proj-2-tuple(v_1001),increment_nonce(2-proj-2-tuple(v_998))) else fail-any) else fail-any)) in
        {547}let v_1003: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_995)) && (success?(3-proj-3-tuple(v_997)) && success?(1-proj-3-tuple(v_997)))) then (if (not-caught-fail(v_998) && success?(is-true(success?(1-proj-2-tuple(v_998))))) then (if not-caught-fail(v_999) then (if (not-caught-fail(v_1000) && success?(is-true(success?(1-proj-3-tuple(v_1000))))) then (if not-caught-fail(v_1002) then (v_1002,3-proj-3-tuple(v_1000),1-proj-3-tuple(v_1000)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {548}let v_1004: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1003),2-proj-3-tuple(v_997),3-proj-3-tuple(v_997)))) in
        {549}let v_1005: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_995)) && success?(symmetricstatepack(1-proj-3-tuple(v_1003),2-proj-3-tuple(v_997),3-proj-3-tuple(v_997)))) then (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-3-tuple(v_1004))))) then symmetricstatepack(1-proj-3-tuple(v_1004),2-proj-3-tuple(v_1004),hash(3-proj-3-tuple(v_1004),3-proj-3-tuple(v_995))) else fail-any) else fail-any)) in
        {550}let v_1006: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_995)) && success?(1-proj-7-tuple(v_994))) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then (if (not-caught-fail(v_1003) && success?(is-true(success?(1-proj-3-tuple(v_1003))))) then (if not-caught-fail(v_1005) then (v_1005,2-proj-3-tuple(v_1003),3-proj-3-tuple(v_1003)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {551}let v_1007: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1006),2-proj-7-tuple(v_994),3-proj-7-tuple(v_994),4-proj-7-tuple(v_994),5-proj-7-tuple(v_994),6-proj-7-tuple(v_994),7-proj-7-tuple(v_994))) in
        {552}let (hs_1008: handshakestate,re_1009: key,plaintext_c_1010: bitstring,valid_1011: bool) = (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-7-tuple(v_994))))) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then (if not-caught-fail(v_996) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-3-tuple(v_1006))))) then (if (v_996 && 3-proj-3-tuple(v_1006)) then (if not-caught-fail(v_1007) then (v_1007,getpublickey(3-proj-7-tuple(v_994)),2-proj-3-tuple(v_1006),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {553}event RecvMsg(me_900,them_899,stage_c,plaintext_c_1010,valid_1011);
        {554}insert statestore(me_900,them_899,statepack_d(hs_1008))
    ) | (
        {581}get statestore(=me_900,=them_899,statepack_d(hs_1012: handshakestate)) in
        {556}let v_1013: bitstring = catch-fail(handshakestateunpack(hs_1012)) in
        {557}let v_1014: bitstring = catch-fail((empty,empty,empty)) in
        {558}let v_1015: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1013))) in
        {559}let v_1016: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1015))) in
        {560}let v_1017: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1016),2-proj-2-tuple(v_1016),3-proj-3-tuple(v_1015),msg_d(me_900,them_899))) in
        {561}let v_1018: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1015))) in
        {562}let v_1019: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1016))) && success?(1-proj-3-tuple(v_1015))) then (if (not-caught-fail(v_1018) && success?(is-true(success?(1-proj-2-tuple(v_1018))))) then cipherstatepack(1-proj-2-tuple(v_1018),increment_nonce(2-proj-2-tuple(v_1016))) else fail-any) else fail-any)) in
        {563}let v_1020: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1015)) && success?(1-proj-3-tuple(v_1015))) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-2-tuple(v_1016))))) then (if not-caught-fail(v_1017) then (if not-caught-fail(v_1019) then (v_1019,v_1017) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {564}let v_1021: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1020),2-proj-3-tuple(v_1015),3-proj-3-tuple(v_1015)))) in
        {565}let v_1022: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1020)) && success?(symmetricstatepack(1-proj-2-tuple(v_1020),2-proj-3-tuple(v_1015),3-proj-3-tuple(v_1015)))) then (if (not-caught-fail(v_1021) && success?(is-true(success?(1-proj-3-tuple(v_1021))))) then symmetricstatepack(1-proj-3-tuple(v_1021),2-proj-3-tuple(v_1021),hash(3-proj-3-tuple(v_1021),2-proj-2-tuple(v_1020))) else fail-any) else fail-any)) in
        {566}let v_1023: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1013)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-3-tuple(v_1015))))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-2-tuple(v_1020))))) then (if not-caught-fail(v_1022) then (v_1022,2-proj-2-tuple(v_1020)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {567}let v_1024: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1023),2-proj-7-tuple(v_1013),3-proj-7-tuple(v_1013),4-proj-7-tuple(v_1013),5-proj-7-tuple(v_1013),6-proj-7-tuple(v_1013),7-proj-7-tuple(v_1013))) in
        {568}let v_1025: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1014),2-proj-3-tuple(v_1014),2-proj-2-tuple(v_1023))) in
        {569}let v_1026: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1023))) in
        {570}let v_1027: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1026),zero)) in
        {571}let v_1028: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1026),zero)) in
        {572}let v_1029: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1026),zero)) in
        {573}let v_1030: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1026)) then (if not-caught-fail(v_1027) then (if not-caught-fail(v_1028) then (if not-caught-fail(v_1029) then (v_1027,v_1028,v_1029) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {574}let v_1031: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1030)) then cipherstatepack(1-proj-3-tuple(v_1030),minnonce) else fail-any)) in
        {575}let v_1032: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1030)) then cipherstatepack(2-proj-3-tuple(v_1030),minnonce) else fail-any)) in
        {576}let v_1033: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1023)) then (if (not-caught-fail(v_1026) && success?(is-true(success?(1-proj-3-tuple(v_1026))))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-3-tuple(v_1030))))) then (if not-caught-fail(v_1031) then (if not-caught-fail(v_1032) then (1-proj-2-tuple(v_1023),v_1031,v_1032) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {577}let (hs_1034: handshakestate,re_1035: key,message_d_1036: bitstring,cs1_1037: cipherstate,cs2_1038: cipherstate) = (if (not-caught-fail(v_1013) && success?(is-true(success?(1-proj-7-tuple(v_1013))))) then (if (not-caught-fail(v_1014) && success?(is-true(success?(1-proj-3-tuple(v_1014))))) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-2-tuple(v_1023))))) then (if not-caught-fail(v_1024) then (if not-caught-fail(v_1025) then (if (not-caught-fail(v_1033) && success?(is-true(success?(1-proj-3-tuple(v_1033))))) then (v_1024,5-proj-7-tuple(v_1013),v_1025,2-proj-3-tuple(v_1033),3-proj-3-tuple(v_1033)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {578}event SendMsg(me_900,them_899,stage_d,msg_d(me_900,them_899),true);
        {579}insert statestore(me_900,them_899,statepack_e(hs_1034));
        {580}out(pub, message_d_1036)
    ) | (
        {582}event LeakS(phase0,me_900);
        {583}out(pub, key_s(me_900))
    ) | (
        {584}phase 1;
        {585}event LeakS(phase1,me_900);
        {586}out(pub, key_s(me_900))
    )
)

