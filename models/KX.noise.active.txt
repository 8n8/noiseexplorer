File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 277, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 277, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 278, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 285, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 286, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "KX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 304, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 320, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 323, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 325, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 333, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 334, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 336, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 337, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 338, characters 48-53:
Warning: identifier valid1 rebound.
File "KX.noise.active.pv", line 339, characters 6-7:
Warning: identifier rs rebound.
File "KX.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 341, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 343, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 362, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 364, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 511, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 513, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 362, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 364, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 503, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 504, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 304, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 496, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 333, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 334, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 336, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 337, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 338, characters 48-53:
Warning: identifier valid1 rebound.
File "KX.noise.active.pv", line 339, characters 6-7:
Warning: identifier rs rebound.
File "KX.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 341, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 343, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 488, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 277, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 277, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 278, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 564, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 565, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 555, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 557, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 548, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 285, character 6:
Warning: identifier e rebound.
File "KX.noise.active.pv", line 286, characters 6-7:
Warning: identifier ne rebound.
File "KX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "KX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KX.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 541, characters 8-9:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 320, characters 6-7:
Warning: identifier re rebound.
File "KX.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 323, characters 7-8:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 325, characters 7-8:
Warning: identifier hs rebound.
File "KX.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KX.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KX.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let v_519: key = catch-fail(dhexp(key_s(alice),g)) in
    {5}let s_520: keypair = (if not-caught-fail(v_519) then keypairpack(v_519,key_s(alice)) else fail-any) in
    {6}out(pub, getpublickey(s_520));
    (
        {7}let e_521: keypair = keypairpack(empty,empty) in
        {8}let rs_522: key = empty in
        {9}let re_523: key = empty in
        {10}let v_524: bitstring = catch-fail(hash(somename,empty)) in
        {11}let v_525: key = catch-fail(v_524) in
        {12}let v_526: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {13}let v_527: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_524) then (if not-caught-fail(v_525) then (if not-caught-fail(v_526) then symmetricstatepack(v_526,v_525,v_524) else fail-any) else fail-any) else fail-any))) in
        {14}let v_528: symmetricstate = catch-fail((if success?((if not-caught-fail(v_524) then (if not-caught-fail(v_525) then (if not-caught-fail(v_526) then symmetricstatepack(v_526,v_525,v_524) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-3-tuple(v_527))))) then symmetricstatepack(1-proj-3-tuple(v_527),2-proj-3-tuple(v_527),hash(3-proj-3-tuple(v_527),empty)) else fail-any) else fail-any)) in
        {15}let v_529: bitstring = catch-fail(symmetricstateunpack(v_528)) in
        {16}let v_530: symmetricstate = catch-fail((if success?(getpublickey(s_520)) then (if (not-caught-fail(v_529) && success?(is-true(success?(1-proj-3-tuple(v_529))))) then symmetricstatepack(1-proj-3-tuple(v_529),2-proj-3-tuple(v_529),hash(3-proj-3-tuple(v_529),getpublickey(s_520))) else fail-any) else fail-any)) in
        {17}let hs: handshakestate = (if not-caught-fail(v_528) then (if not-caught-fail(v_530) then handshakestatepack(v_530,s_520,e_521,rs_522,re_523,empty,true) else fail-any) else fail-any) in
        {18}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {41}get statestore(=alice,=bob,=sid,statepack_a(hs_531: handshakestate)) in
        {19}let v_532: bitstring = catch-fail(handshakestateunpack(hs_531)) in
        {20}let v_533: bitstring = catch-fail((empty,empty,empty)) in
        {21}let v_534: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {22}let v_535: keypair = catch-fail((if not-caught-fail(v_534) then keypairpack(v_534,key_e(alice,bob,sid)) else fail-any)) in
        {23}let v_536: bitstring = catch-fail(getpublickey(v_535)) in
        {24}let v_537: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_532))) in
        {25}let v_538: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_532)) then (if (not-caught-fail(v_537) && success?(is-true(success?(1-proj-3-tuple(v_537))))) then symmetricstatepack(1-proj-3-tuple(v_537),2-proj-3-tuple(v_537),hash(3-proj-3-tuple(v_537),v_536)) else fail-any) else fail-any)) in
        {26}let v_539: bitstring = catch-fail(symmetricstateunpack(v_538)) in
        {27}let v_540: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_539))) in
        {28}let v_541: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_540),2-proj-2-tuple(v_540),3-proj-3-tuple(v_539),msg_a(alice,bob))) in
        {29}let v_542: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_539))) in
        {30}let v_543: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_540))) && success?(1-proj-3-tuple(v_539))) then (if (not-caught-fail(v_542) && success?(is-true(success?(1-proj-2-tuple(v_542))))) then cipherstatepack(1-proj-2-tuple(v_542),increment_nonce(2-proj-2-tuple(v_540))) else fail-any) else fail-any)) in
        {31}let v_544: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_539)) && success?(1-proj-3-tuple(v_539))) then (if (not-caught-fail(v_540) && success?(is-true(success?(1-proj-2-tuple(v_540))))) then (if not-caught-fail(v_541) then (if not-caught-fail(v_543) then (v_543,v_541) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {32}let v_545: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_544),2-proj-3-tuple(v_539),3-proj-3-tuple(v_539)))) in
        {33}let v_546: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_544)) && success?(symmetricstatepack(1-proj-2-tuple(v_544),2-proj-3-tuple(v_539),3-proj-3-tuple(v_539)))) then (if (not-caught-fail(v_545) && success?(is-true(success?(1-proj-3-tuple(v_545))))) then symmetricstatepack(1-proj-3-tuple(v_545),2-proj-3-tuple(v_545),hash(3-proj-3-tuple(v_545),2-proj-2-tuple(v_544))) else fail-any) else fail-any)) in
        {34}let v_547: bitstring = catch-fail((if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-3-tuple(v_539))))) then (if (not-caught-fail(v_544) && success?(is-true(success?(1-proj-2-tuple(v_544))))) then (if not-caught-fail(v_546) then (v_546,2-proj-2-tuple(v_544)) else fail-any) else fail-any) else fail-any)) in
        {35}let v_548: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_547),2-proj-7-tuple(v_532),v_535,4-proj-7-tuple(v_532),5-proj-7-tuple(v_532),6-proj-7-tuple(v_532),7-proj-7-tuple(v_532))) in
        {36}let v_549: bitstring = catch-fail(concat3(v_536,2-proj-3-tuple(v_533),2-proj-2-tuple(v_547))) in
        {37}let (hs_550: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-7-tuple(v_532))))) then (if (not-caught-fail(v_533) && success?(is-true(success?(1-proj-3-tuple(v_533))))) then (if not-caught-fail(v_535) then (if not-caught-fail(v_536) then (if not-caught-fail(v_538) then (if (not-caught-fail(v_547) && success?(is-true(success?(1-proj-2-tuple(v_547))))) then (if not-caught-fail(v_548) then (if not-caught-fail(v_549) then (v_548,v_549) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {38}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob));
        {39}insert statestore(alice,bob,sid,statepack_b(hs_550));
        {40}out(pub, message_a)
    ) | (
        {104}get statestore(=alice,=bob,=sid,statepack_b(hs_551: handshakestate)) in
        {42}in(pub, message_b: bitstring);
        {43}let v_552: bitstring = catch-fail(handshakestateunpack(hs_551)) in
        {44}let v_553: bitstring = catch-fail(deconcat3(message_b)) in
        {45}let v_554: bool = catch-fail(true) in
        {46}let v_555: key = catch-fail(1-proj-3-tuple(v_553)) in
        {47}let v_556: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_552))) in
        {48}let v_557: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_552)) then (if (not-caught-fail(v_556) && success?(is-true(success?(1-proj-3-tuple(v_556))))) then symmetricstatepack(1-proj-3-tuple(v_556),2-proj-3-tuple(v_556),hash(3-proj-3-tuple(v_556),v_555)) else fail-any) else fail-any)) in
        {49}let v_558: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_552))) in
        {50}let v_559: bitstring = catch-fail(symmetricstateunpack(v_557)) in
        {51}let v_560: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_559),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then dhexp(2-proj-2-tuple(v_558),v_555) else fail-any) else fail-any))) in
        {52}let v_561: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_559),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then dhexp(2-proj-2-tuple(v_558),v_555) else fail-any) else fail-any))) in
        {53}let v_562: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_559),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then dhexp(2-proj-2-tuple(v_558),v_555) else fail-any) else fail-any))) in
        {54}let v_563: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then dhexp(2-proj-2-tuple(v_558),v_555) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_559))) then (if not-caught-fail(v_560) then (if not-caught-fail(v_561) then (if not-caught-fail(v_562) then (v_560,v_561,v_562) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {55}let v_564: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then dhexp(2-proj-2-tuple(v_558),v_555) else fail-any) else fail-any)) then (if (not-caught-fail(v_559) && success?(is-true(success?(1-proj-3-tuple(v_559))))) then (if (not-caught-fail(v_563) && success?(is-true(success?(1-proj-3-tuple(v_563))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_563)) then cipherstatepack(2-proj-3-tuple(v_563),minnonce) else fail-any),1-proj-3-tuple(v_563),3-proj-3-tuple(v_559)) else fail-any) else fail-any) else fail-any)) in
        {56}let v_565: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_552))) in
        {57}let v_566: bitstring = catch-fail(symmetricstateunpack(v_564)) in
        {58}let v_567: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_566),(if success?(2-proj-7-tuple(v_552)) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then dhexp(2-proj-2-tuple(v_565),v_555) else fail-any) else fail-any))) in
        {59}let v_568: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_566),(if success?(2-proj-7-tuple(v_552)) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then dhexp(2-proj-2-tuple(v_565),v_555) else fail-any) else fail-any))) in
        {60}let v_569: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_566),(if success?(2-proj-7-tuple(v_552)) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then dhexp(2-proj-2-tuple(v_565),v_555) else fail-any) else fail-any))) in
        {61}let v_570: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_552)) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then dhexp(2-proj-2-tuple(v_565),v_555) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_566))) then (if not-caught-fail(v_567) then (if not-caught-fail(v_568) then (if not-caught-fail(v_569) then (v_567,v_568,v_569) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {62}let v_571: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_552)) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then dhexp(2-proj-2-tuple(v_565),v_555) else fail-any) else fail-any)) then (if (not-caught-fail(v_566) && success?(is-true(success?(1-proj-3-tuple(v_566))))) then (if (not-caught-fail(v_570) && success?(is-true(success?(1-proj-3-tuple(v_570))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_570)) then cipherstatepack(2-proj-3-tuple(v_570),minnonce) else fail-any),1-proj-3-tuple(v_570),3-proj-3-tuple(v_566)) else fail-any) else fail-any) else fail-any)) in
        {63}let v_572: bitstring = catch-fail(symmetricstateunpack(v_571)) in
        {64}let v_573: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_572))) in
        {65}let v_574: aead = catch-fail(decrypt(1-proj-2-tuple(v_573),2-proj-2-tuple(v_573),3-proj-3-tuple(v_572),2-proj-3-tuple(v_553))) in
        {66}let v_575: bitstring = catch-fail(aeadunpack(v_574)) in
        {67}let v_576: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_572))) in
        {68}let v_577: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_573))) && success?(1-proj-3-tuple(v_572))) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then cipherstatepack(1-proj-2-tuple(v_576),increment_nonce(2-proj-2-tuple(v_573))) else fail-any) else fail-any)) in
        {69}let v_578: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_553)) && (success?(3-proj-3-tuple(v_572)) && success?(1-proj-3-tuple(v_572)))) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then (if not-caught-fail(v_574) then (if (not-caught-fail(v_575) && success?(is-true(success?(1-proj-3-tuple(v_575))))) then (if not-caught-fail(v_577) then (v_577,3-proj-3-tuple(v_575),1-proj-3-tuple(v_575)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {70}let v_579: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_578),2-proj-3-tuple(v_572),3-proj-3-tuple(v_572)))) in
        {71}let v_580: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_553)) && success?(symmetricstatepack(1-proj-3-tuple(v_578),2-proj-3-tuple(v_572),3-proj-3-tuple(v_572)))) then (if (not-caught-fail(v_579) && success?(is-true(success?(1-proj-3-tuple(v_579))))) then symmetricstatepack(1-proj-3-tuple(v_579),2-proj-3-tuple(v_579),hash(3-proj-3-tuple(v_579),2-proj-3-tuple(v_553))) else fail-any) else fail-any)) in
        {72}let v_581: bitstring = catch-fail((if success?(2-proj-3-tuple(v_553)) then (if (not-caught-fail(v_572) && success?(is-true(success?(1-proj-3-tuple(v_572))))) then (if (not-caught-fail(v_578) && success?(is-true(success?(1-proj-3-tuple(v_578))))) then (if not-caught-fail(v_580) then (v_580,2-proj-3-tuple(v_578),3-proj-3-tuple(v_578)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {73}let v_582: key = catch-fail(2-proj-3-tuple(v_581)) in
        {74}let v_583: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_552))) in
        {75}let v_584: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_581))) in
        {76}let v_585: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_584),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then dhexp(2-proj-2-tuple(v_583),v_582) else fail-any) else fail-any))) in
        {77}let v_586: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_584),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then dhexp(2-proj-2-tuple(v_583),v_582) else fail-any) else fail-any))) in
        {78}let v_587: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_584),(if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then dhexp(2-proj-2-tuple(v_583),v_582) else fail-any) else fail-any))) in
        {79}let v_588: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then dhexp(2-proj-2-tuple(v_583),v_582) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_584))) then (if not-caught-fail(v_585) then (if not-caught-fail(v_586) then (if not-caught-fail(v_587) then (v_585,v_586,v_587) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {80}let v_589: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_552)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then dhexp(2-proj-2-tuple(v_583),v_582) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_581))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-3-tuple(v_584))))) then (if (not-caught-fail(v_588) && success?(is-true(success?(1-proj-3-tuple(v_588))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_588)) then cipherstatepack(2-proj-3-tuple(v_588),minnonce) else fail-any),1-proj-3-tuple(v_588),3-proj-3-tuple(v_584)) else fail-any) else fail-any) else fail-any)) in
        {81}let v_590: bitstring = catch-fail(symmetricstateunpack(v_589)) in
        {82}let v_591: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_590))) in
        {83}let v_592: aead = catch-fail(decrypt(1-proj-2-tuple(v_591),2-proj-2-tuple(v_591),3-proj-3-tuple(v_590),3-proj-3-tuple(v_553))) in
        {84}let v_593: bitstring = catch-fail(aeadunpack(v_592)) in
        {85}let v_594: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_590))) in
        {86}let v_595: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_591))) && success?(1-proj-3-tuple(v_590))) then (if (not-caught-fail(v_594) && success?(is-true(success?(1-proj-2-tuple(v_594))))) then cipherstatepack(1-proj-2-tuple(v_594),increment_nonce(2-proj-2-tuple(v_591))) else fail-any) else fail-any)) in
        {87}let v_596: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_553)) && (success?(3-proj-3-tuple(v_590)) && success?(1-proj-3-tuple(v_590)))) then (if (not-caught-fail(v_591) && success?(is-true(success?(1-proj-2-tuple(v_591))))) then (if not-caught-fail(v_592) then (if (not-caught-fail(v_593) && success?(is-true(success?(1-proj-3-tuple(v_593))))) then (if not-caught-fail(v_595) then (v_595,3-proj-3-tuple(v_593),1-proj-3-tuple(v_593)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {88}let v_597: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_596),2-proj-3-tuple(v_590),3-proj-3-tuple(v_590)))) in
        {89}let v_598: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_553)) && success?(symmetricstatepack(1-proj-3-tuple(v_596),2-proj-3-tuple(v_590),3-proj-3-tuple(v_590)))) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then symmetricstatepack(1-proj-3-tuple(v_597),2-proj-3-tuple(v_597),hash(3-proj-3-tuple(v_597),3-proj-3-tuple(v_553))) else fail-any) else fail-any)) in
        {90}let v_599: bitstring = catch-fail((if success?(3-proj-3-tuple(v_553)) then (if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then (if (not-caught-fail(v_596) && success?(is-true(success?(1-proj-3-tuple(v_596))))) then (if not-caught-fail(v_598) then (v_598,2-proj-3-tuple(v_596),3-proj-3-tuple(v_596)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {91}let v_600: key = catch-fail(dhexp(key_s(bob),g)) in
        {92}let v_601: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_599),2-proj-7-tuple(v_552),3-proj-7-tuple(v_552),v_582,v_555,6-proj-7-tuple(v_552),7-proj-7-tuple(v_552))) in
        {93}let v_602: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_599))) in
        {94}let v_603: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_602),zero)) in
        {95}let v_604: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_602),zero)) in
        {96}let v_605: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_602),zero)) in
        {97}let v_606: bitstring = catch-fail((if success?(2-proj-3-tuple(v_602)) then (if not-caught-fail(v_603) then (if not-caught-fail(v_604) then (if not-caught-fail(v_605) then (v_603,v_604,v_605) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {98}let v_607: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_606)) then cipherstatepack(1-proj-3-tuple(v_606),minnonce) else fail-any)) in
        {99}let v_608: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_606)) then cipherstatepack(2-proj-3-tuple(v_606),minnonce) else fail-any)) in
        {100}let v_609: bitstring = catch-fail((if success?(1-proj-3-tuple(v_599)) then (if (not-caught-fail(v_602) && success?(is-true(success?(1-proj-3-tuple(v_602))))) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-3-tuple(v_606))))) then (if not-caught-fail(v_607) then (if not-caught-fail(v_608) then (1-proj-3-tuple(v_599),v_607,v_608) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {101}let (hs_610: handshakestate,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_552) && success?(is-true(success?(1-proj-7-tuple(v_552))))) then (if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-3-tuple(v_553))))) then (if not-caught-fail(v_554) then (if not-caught-fail(v_555) then (if not-caught-fail(v_557) then (if not-caught-fail(v_564) then (if not-caught-fail(v_571) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-3-tuple(v_581))))) then (if not-caught-fail(v_582) then (if not-caught-fail(v_589) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-3-tuple(v_599))))) then (if ((3-proj-3-tuple(v_581) && 3-proj-3-tuple(v_599)) && (v_582 = getpublickey((if not-caught-fail(v_600) then keypairpack(v_600,key_s(bob)) else fail-any)))) then (if not-caught-fail(v_601) then (if (not-caught-fail(v_609) && success?(is-true(success?(1-proj-3-tuple(v_609))))) then (v_601,2-proj-3-tuple(v_599),true,2-proj-3-tuple(v_609),3-proj-3-tuple(v_609)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {102}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {103}insert statestore(alice,bob,sid,statepack_c(hs_610,cs1,cs2))
    ) | (
        {105}!
        {124}get statestore(=alice,=bob,=sid,statepack_c(hs_611: handshakestate,cs1_612: cipherstate,cs2_613: cipherstate)) in
        {106}let hs_614: handshakestate = handshakestatesetcs(hs_611,cs1_612) in
        {107}let v_615: bitstring = catch-fail(handshakestateunpack(hs_614)) in
        {108}let v_616: bitstring = catch-fail((empty,empty,empty)) in
        {109}let v_617: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_615))) in
        {110}let v_618: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {111}let v_619: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_618),2-proj-2-tuple(v_618),3-proj-3-tuple(v_617),msg_c(alice,bob))) in
        {112}let v_620: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {113}let v_621: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_618))) && success?(1-proj-3-tuple(v_617))) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-2-tuple(v_620))))) then cipherstatepack(1-proj-2-tuple(v_620),increment_nonce(2-proj-2-tuple(v_618))) else fail-any) else fail-any)) in
        {114}let v_622: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_617)) && success?(1-proj-3-tuple(v_617))) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-2-tuple(v_618))))) then (if not-caught-fail(v_619) then (if not-caught-fail(v_621) then (v_621,v_619) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {115}let v_623: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_622),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) in
        {116}let v_624: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_622)) && success?(symmetricstatepack(1-proj-2-tuple(v_622),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-3-tuple(v_623))))) then symmetricstatepack(1-proj-3-tuple(v_623),2-proj-3-tuple(v_623),hash(3-proj-3-tuple(v_623),2-proj-2-tuple(v_622))) else fail-any) else fail-any)) in
        {117}let v_625: bitstring = catch-fail((if success?(1-proj-7-tuple(v_615)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-3-tuple(v_617))))) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then (if not-caught-fail(v_624) then (v_624,2-proj-2-tuple(v_622)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {118}let v_626: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_625),2-proj-7-tuple(v_615),3-proj-7-tuple(v_615),4-proj-7-tuple(v_615),5-proj-7-tuple(v_615),6-proj-7-tuple(v_615),7-proj-7-tuple(v_615))) in
        {119}let v_627: bitstring = catch-fail(concat3(1-proj-3-tuple(v_616),2-proj-3-tuple(v_616),2-proj-2-tuple(v_625))) in
        {120}let (hs_628: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_615) && success?(is-true(success?(1-proj-7-tuple(v_615))))) then (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-3-tuple(v_616))))) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then (if not-caught-fail(v_626) then (if not-caught-fail(v_627) then (v_626,v_627) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {121}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob));
        {122}insert statestore(alice,bob,sid,statepack_d(hs_628,handshakestategetcs(hs_628),cs2_613));
        {123}out(pub, message_c)
    ) | (
        {125}!
        {145}get statestore(=alice,=bob,=sid,statepack_d(hs_629: handshakestate,cs1_630: cipherstate,cs2_631: cipherstate)) in
        {126}let hs_632: handshakestate = handshakestatesetcs(hs_629,cs2_631) in
        {127}in(pub, message_d: bitstring);
        {128}let v_633: bitstring = catch-fail(handshakestateunpack(hs_632)) in
        {129}let v_634: bitstring = catch-fail(deconcat3(message_d)) in
        {130}let v_635: bool = catch-fail(true) in
        {131}let v_636: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_633))) in
        {132}let v_637: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_636))) in
        {133}let v_638: aead = catch-fail(decrypt(1-proj-2-tuple(v_637),2-proj-2-tuple(v_637),3-proj-3-tuple(v_636),3-proj-3-tuple(v_634))) in
        {134}let v_639: bitstring = catch-fail(aeadunpack(v_638)) in
        {135}let v_640: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_636))) in
        {136}let v_641: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_637))) && success?(1-proj-3-tuple(v_636))) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then cipherstatepack(1-proj-2-tuple(v_640),increment_nonce(2-proj-2-tuple(v_637))) else fail-any) else fail-any)) in
        {137}let v_642: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_634)) && (success?(3-proj-3-tuple(v_636)) && success?(1-proj-3-tuple(v_636)))) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then (if not-caught-fail(v_638) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-3-tuple(v_639))))) then (if not-caught-fail(v_641) then (v_641,3-proj-3-tuple(v_639),1-proj-3-tuple(v_639)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {138}let v_643: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_642),2-proj-3-tuple(v_636),3-proj-3-tuple(v_636)))) in
        {139}let v_644: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_634)) && success?(symmetricstatepack(1-proj-3-tuple(v_642),2-proj-3-tuple(v_636),3-proj-3-tuple(v_636)))) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-3-tuple(v_643))))) then symmetricstatepack(1-proj-3-tuple(v_643),2-proj-3-tuple(v_643),hash(3-proj-3-tuple(v_643),3-proj-3-tuple(v_634))) else fail-any) else fail-any)) in
        {140}let v_645: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_634)) && success?(1-proj-7-tuple(v_633))) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then (if not-caught-fail(v_644) then (v_644,2-proj-3-tuple(v_642),3-proj-3-tuple(v_642)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {141}let v_646: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_645),2-proj-7-tuple(v_633),3-proj-7-tuple(v_633),4-proj-7-tuple(v_633),5-proj-7-tuple(v_633),6-proj-7-tuple(v_633),7-proj-7-tuple(v_633))) in
        {142}let (hs_647: handshakestate,plaintext_d: bitstring,valid_648: bool) = (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-7-tuple(v_633))))) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then (if not-caught-fail(v_635) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then (if (v_635 && 3-proj-3-tuple(v_645)) then (if not-caught-fail(v_646) then (v_646,2-proj-3-tuple(v_645),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {143}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {144}event RecvEnd(valid_648)
    ) | (
        {146}event LeakS(phase0,alice);
        {147}out(pub, key_s(alice))
    ) | (
        {148}phase 1;
        {149}event LeakS(phase1,alice);
        {150}out(pub, key_s(alice))
    )
) | (
    {151}let v_649: key = catch-fail(dhexp(key_s(alice),g)) in
    {152}let s_650: keypair = (if not-caught-fail(v_649) then keypairpack(v_649,key_s(alice)) else fail-any) in
    {153}out(pub, getpublickey(s_650));
    (
        {154}let e_651: keypair = keypairpack(empty,empty) in
        {155}let rs_652: key = empty in
        {156}let re_653: key = empty in
        {157}let v_654: bitstring = catch-fail(hash(somename,empty)) in
        {158}let v_655: key = catch-fail(v_654) in
        {159}let v_656: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {160}let v_657: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_654) then (if not-caught-fail(v_655) then (if not-caught-fail(v_656) then symmetricstatepack(v_656,v_655,v_654) else fail-any) else fail-any) else fail-any))) in
        {161}let v_658: symmetricstate = catch-fail((if success?((if not-caught-fail(v_654) then (if not-caught-fail(v_655) then (if not-caught-fail(v_656) then symmetricstatepack(v_656,v_655,v_654) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-3-tuple(v_657))))) then symmetricstatepack(1-proj-3-tuple(v_657),2-proj-3-tuple(v_657),hash(3-proj-3-tuple(v_657),empty)) else fail-any) else fail-any)) in
        {162}let v_659: bitstring = catch-fail(symmetricstateunpack(v_658)) in
        {163}let v_660: symmetricstate = catch-fail((if success?(getpublickey(s_650)) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-3-tuple(v_659))))) then symmetricstatepack(1-proj-3-tuple(v_659),2-proj-3-tuple(v_659),hash(3-proj-3-tuple(v_659),getpublickey(s_650))) else fail-any) else fail-any)) in
        {164}let hs_661: handshakestate = (if not-caught-fail(v_658) then (if not-caught-fail(v_660) then handshakestatepack(v_660,s_650,e_651,rs_652,re_653,empty,true) else fail-any) else fail-any) in
        {165}insert statestore(alice,charlie,sid,statepack_a(hs_661))
    ) | (
        {188}get statestore(=alice,=charlie,=sid,statepack_a(hs_662: handshakestate)) in
        {166}let v_663: bitstring = catch-fail(handshakestateunpack(hs_662)) in
        {167}let v_664: bitstring = catch-fail((empty,empty,empty)) in
        {168}let v_665: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {169}let v_666: keypair = catch-fail((if not-caught-fail(v_665) then keypairpack(v_665,key_e(alice,charlie,sid)) else fail-any)) in
        {170}let v_667: bitstring = catch-fail(getpublickey(v_666)) in
        {171}let v_668: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_663))) in
        {172}let v_669: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_663)) then (if (not-caught-fail(v_668) && success?(is-true(success?(1-proj-3-tuple(v_668))))) then symmetricstatepack(1-proj-3-tuple(v_668),2-proj-3-tuple(v_668),hash(3-proj-3-tuple(v_668),v_667)) else fail-any) else fail-any)) in
        {173}let v_670: bitstring = catch-fail(symmetricstateunpack(v_669)) in
        {174}let v_671: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {175}let v_672: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_671),2-proj-2-tuple(v_671),3-proj-3-tuple(v_670),msg_a(alice,charlie))) in
        {176}let v_673: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {177}let v_674: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_671))) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then cipherstatepack(1-proj-2-tuple(v_673),increment_nonce(2-proj-2-tuple(v_671))) else fail-any) else fail-any)) in
        {178}let v_675: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_670)) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if not-caught-fail(v_672) then (if not-caught-fail(v_674) then (v_674,v_672) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {179}let v_676: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) in
        {180}let v_677: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_675)) && success?(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then symmetricstatepack(1-proj-3-tuple(v_676),2-proj-3-tuple(v_676),hash(3-proj-3-tuple(v_676),2-proj-2-tuple(v_675))) else fail-any) else fail-any)) in
        {181}let v_678: bitstring = catch-fail((if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-2-tuple(v_675))))) then (if not-caught-fail(v_677) then (v_677,2-proj-2-tuple(v_675)) else fail-any) else fail-any) else fail-any)) in
        {182}let v_679: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_678),2-proj-7-tuple(v_663),v_666,4-proj-7-tuple(v_663),5-proj-7-tuple(v_663),6-proj-7-tuple(v_663),7-proj-7-tuple(v_663))) in
        {183}let v_680: bitstring = catch-fail(concat3(v_667,2-proj-3-tuple(v_664),2-proj-2-tuple(v_678))) in
        {184}let (hs_681: handshakestate,message_a_682: bitstring) = (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-7-tuple(v_663))))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-3-tuple(v_664))))) then (if not-caught-fail(v_666) then (if not-caught-fail(v_667) then (if not-caught-fail(v_669) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-2-tuple(v_678))))) then (if not-caught-fail(v_679) then (if not-caught-fail(v_680) then (v_679,v_680) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {185}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie));
        {186}insert statestore(alice,charlie,sid,statepack_b(hs_681));
        {187}out(pub, message_a_682)
    ) | (
        {251}get statestore(=alice,=charlie,=sid,statepack_b(hs_683: handshakestate)) in
        {189}in(pub, message_b_684: bitstring);
        {190}let v_685: bitstring = catch-fail(handshakestateunpack(hs_683)) in
        {191}let v_686: bitstring = catch-fail(deconcat3(message_b_684)) in
        {192}let v_687: bool = catch-fail(true) in
        {193}let v_688: key = catch-fail(1-proj-3-tuple(v_686)) in
        {194}let v_689: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_685))) in
        {195}let v_690: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_685)) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-3-tuple(v_689))))) then symmetricstatepack(1-proj-3-tuple(v_689),2-proj-3-tuple(v_689),hash(3-proj-3-tuple(v_689),v_688)) else fail-any) else fail-any)) in
        {196}let v_691: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_685))) in
        {197}let v_692: bitstring = catch-fail(symmetricstateunpack(v_690)) in
        {198}let v_693: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_688) else fail-any) else fail-any))) in
        {199}let v_694: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_688) else fail-any) else fail-any))) in
        {200}let v_695: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_692),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_688) else fail-any) else fail-any))) in
        {201}let v_696: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_688) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_692))) then (if not-caught-fail(v_693) then (if not-caught-fail(v_694) then (if not-caught-fail(v_695) then (v_693,v_694,v_695) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {202}let v_697: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then dhexp(2-proj-2-tuple(v_691),v_688) else fail-any) else fail-any)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-3-tuple(v_692))))) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-3-tuple(v_696))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_696)) then cipherstatepack(2-proj-3-tuple(v_696),minnonce) else fail-any),1-proj-3-tuple(v_696),3-proj-3-tuple(v_692)) else fail-any) else fail-any) else fail-any)) in
        {203}let v_698: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_685))) in
        {204}let v_699: bitstring = catch-fail(symmetricstateunpack(v_697)) in
        {205}let v_700: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_699),(if success?(2-proj-7-tuple(v_685)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then dhexp(2-proj-2-tuple(v_698),v_688) else fail-any) else fail-any))) in
        {206}let v_701: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_699),(if success?(2-proj-7-tuple(v_685)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then dhexp(2-proj-2-tuple(v_698),v_688) else fail-any) else fail-any))) in
        {207}let v_702: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_699),(if success?(2-proj-7-tuple(v_685)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then dhexp(2-proj-2-tuple(v_698),v_688) else fail-any) else fail-any))) in
        {208}let v_703: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_685)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then dhexp(2-proj-2-tuple(v_698),v_688) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_699))) then (if not-caught-fail(v_700) then (if not-caught-fail(v_701) then (if not-caught-fail(v_702) then (v_700,v_701,v_702) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {209}let v_704: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_685)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then dhexp(2-proj-2-tuple(v_698),v_688) else fail-any) else fail-any)) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-3-tuple(v_699))))) then (if (not-caught-fail(v_703) && success?(is-true(success?(1-proj-3-tuple(v_703))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_703)) then cipherstatepack(2-proj-3-tuple(v_703),minnonce) else fail-any),1-proj-3-tuple(v_703),3-proj-3-tuple(v_699)) else fail-any) else fail-any) else fail-any)) in
        {210}let v_705: bitstring = catch-fail(symmetricstateunpack(v_704)) in
        {211}let v_706: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {212}let v_707: aead = catch-fail(decrypt(1-proj-2-tuple(v_706),2-proj-2-tuple(v_706),3-proj-3-tuple(v_705),2-proj-3-tuple(v_686))) in
        {213}let v_708: bitstring = catch-fail(aeadunpack(v_707)) in
        {214}let v_709: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {215}let v_710: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_706))) && success?(1-proj-3-tuple(v_705))) then (if (not-caught-fail(v_709) && success?(is-true(success?(1-proj-2-tuple(v_709))))) then cipherstatepack(1-proj-2-tuple(v_709),increment_nonce(2-proj-2-tuple(v_706))) else fail-any) else fail-any)) in
        {216}let v_711: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_686)) && (success?(3-proj-3-tuple(v_705)) && success?(1-proj-3-tuple(v_705)))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-2-tuple(v_706))))) then (if not-caught-fail(v_707) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-3-tuple(v_708))))) then (if not-caught-fail(v_710) then (v_710,3-proj-3-tuple(v_708),1-proj-3-tuple(v_708)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {217}let v_712: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_711),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) in
        {218}let v_713: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_686)) && success?(symmetricstatepack(1-proj-3-tuple(v_711),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-3-tuple(v_712))))) then symmetricstatepack(1-proj-3-tuple(v_712),2-proj-3-tuple(v_712),hash(3-proj-3-tuple(v_712),2-proj-3-tuple(v_686))) else fail-any) else fail-any)) in
        {219}let v_714: bitstring = catch-fail((if success?(2-proj-3-tuple(v_686)) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-3-tuple(v_711))))) then (if not-caught-fail(v_713) then (v_713,2-proj-3-tuple(v_711),3-proj-3-tuple(v_711)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {220}let v_715: key = catch-fail(2-proj-3-tuple(v_714)) in
        {221}let v_716: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_685))) in
        {222}let v_717: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_714))) in
        {223}let v_718: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_717),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-2-tuple(v_716))))) then dhexp(2-proj-2-tuple(v_716),v_715) else fail-any) else fail-any))) in
        {224}let v_719: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_717),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-2-tuple(v_716))))) then dhexp(2-proj-2-tuple(v_716),v_715) else fail-any) else fail-any))) in
        {225}let v_720: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_717),(if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-2-tuple(v_716))))) then dhexp(2-proj-2-tuple(v_716),v_715) else fail-any) else fail-any))) in
        {226}let v_721: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-2-tuple(v_716))))) then dhexp(2-proj-2-tuple(v_716),v_715) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_717))) then (if not-caught-fail(v_718) then (if not-caught-fail(v_719) then (if not-caught-fail(v_720) then (v_718,v_719,v_720) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {227}let v_722: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_685)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-2-tuple(v_716))))) then dhexp(2-proj-2-tuple(v_716),v_715) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_714))) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-3-tuple(v_721))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_721)) then cipherstatepack(2-proj-3-tuple(v_721),minnonce) else fail-any),1-proj-3-tuple(v_721),3-proj-3-tuple(v_717)) else fail-any) else fail-any) else fail-any)) in
        {228}let v_723: bitstring = catch-fail(symmetricstateunpack(v_722)) in
        {229}let v_724: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_723))) in
        {230}let v_725: aead = catch-fail(decrypt(1-proj-2-tuple(v_724),2-proj-2-tuple(v_724),3-proj-3-tuple(v_723),3-proj-3-tuple(v_686))) in
        {231}let v_726: bitstring = catch-fail(aeadunpack(v_725)) in
        {232}let v_727: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_723))) in
        {233}let v_728: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_724))) && success?(1-proj-3-tuple(v_723))) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-2-tuple(v_727))))) then cipherstatepack(1-proj-2-tuple(v_727),increment_nonce(2-proj-2-tuple(v_724))) else fail-any) else fail-any)) in
        {234}let v_729: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_686)) && (success?(3-proj-3-tuple(v_723)) && success?(1-proj-3-tuple(v_723)))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-2-tuple(v_724))))) then (if not-caught-fail(v_725) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-3-tuple(v_726))))) then (if not-caught-fail(v_728) then (v_728,3-proj-3-tuple(v_726),1-proj-3-tuple(v_726)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {235}let v_730: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_729),2-proj-3-tuple(v_723),3-proj-3-tuple(v_723)))) in
        {236}let v_731: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_686)) && success?(symmetricstatepack(1-proj-3-tuple(v_729),2-proj-3-tuple(v_723),3-proj-3-tuple(v_723)))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-3-tuple(v_730))))) then symmetricstatepack(1-proj-3-tuple(v_730),2-proj-3-tuple(v_730),hash(3-proj-3-tuple(v_730),3-proj-3-tuple(v_686))) else fail-any) else fail-any)) in
        {237}let v_732: bitstring = catch-fail((if success?(3-proj-3-tuple(v_686)) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then (if (not-caught-fail(v_729) && success?(is-true(success?(1-proj-3-tuple(v_729))))) then (if not-caught-fail(v_731) then (v_731,2-proj-3-tuple(v_729),3-proj-3-tuple(v_729)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {238}let v_733: key = catch-fail(dhexp(key_s(charlie),g)) in
        {239}let v_734: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_732),2-proj-7-tuple(v_685),3-proj-7-tuple(v_685),v_715,v_688,6-proj-7-tuple(v_685),7-proj-7-tuple(v_685))) in
        {240}let v_735: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_732))) in
        {241}let v_736: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_735),zero)) in
        {242}let v_737: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_735),zero)) in
        {243}let v_738: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_735),zero)) in
        {244}let v_739: bitstring = catch-fail((if success?(2-proj-3-tuple(v_735)) then (if not-caught-fail(v_736) then (if not-caught-fail(v_737) then (if not-caught-fail(v_738) then (v_736,v_737,v_738) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {245}let v_740: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_739)) then cipherstatepack(1-proj-3-tuple(v_739),minnonce) else fail-any)) in
        {246}let v_741: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_739)) then cipherstatepack(2-proj-3-tuple(v_739),minnonce) else fail-any)) in
        {247}let v_742: bitstring = catch-fail((if success?(1-proj-3-tuple(v_732)) then (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-3-tuple(v_735))))) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then (if not-caught-fail(v_740) then (if not-caught-fail(v_741) then (1-proj-3-tuple(v_732),v_740,v_741) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {248}let (hs_743: handshakestate,plaintext_b_744: bitstring,valid_745: bool,cs1_746: cipherstate,cs2_747: cipherstate) = (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-7-tuple(v_685))))) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then (if not-caught-fail(v_687) then (if not-caught-fail(v_688) then (if not-caught-fail(v_690) then (if not-caught-fail(v_697) then (if not-caught-fail(v_704) then (if (not-caught-fail(v_714) && success?(is-true(success?(1-proj-3-tuple(v_714))))) then (if not-caught-fail(v_715) then (if not-caught-fail(v_722) then (if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-3-tuple(v_732))))) then (if ((3-proj-3-tuple(v_714) && 3-proj-3-tuple(v_732)) && (v_715 = getpublickey((if not-caught-fail(v_733) then keypairpack(v_733,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_734) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-3-tuple(v_742))))) then (v_734,2-proj-3-tuple(v_732),true,2-proj-3-tuple(v_742),3-proj-3-tuple(v_742)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {249}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_744);
        {250}insert statestore(alice,charlie,sid,statepack_c(hs_743,cs1_746,cs2_747))
    ) | (
        {252}!
        {271}get statestore(=alice,=charlie,=sid,statepack_c(hs_748: handshakestate,cs1_749: cipherstate,cs2_750: cipherstate)) in
        {253}let hs_751: handshakestate = handshakestatesetcs(hs_748,cs1_749) in
        {254}let v_752: bitstring = catch-fail(handshakestateunpack(hs_751)) in
        {255}let v_753: bitstring = catch-fail((empty,empty,empty)) in
        {256}let v_754: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_752))) in
        {257}let v_755: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_754))) in
        {258}let v_756: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_755),2-proj-2-tuple(v_755),3-proj-3-tuple(v_754),msg_c(alice,charlie))) in
        {259}let v_757: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_754))) in
        {260}let v_758: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_755))) && success?(1-proj-3-tuple(v_754))) then (if (not-caught-fail(v_757) && success?(is-true(success?(1-proj-2-tuple(v_757))))) then cipherstatepack(1-proj-2-tuple(v_757),increment_nonce(2-proj-2-tuple(v_755))) else fail-any) else fail-any)) in
        {261}let v_759: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_754)) && success?(1-proj-3-tuple(v_754))) then (if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-2-tuple(v_755))))) then (if not-caught-fail(v_756) then (if not-caught-fail(v_758) then (v_758,v_756) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {262}let v_760: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_759),2-proj-3-tuple(v_754),3-proj-3-tuple(v_754)))) in
        {263}let v_761: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_759)) && success?(symmetricstatepack(1-proj-2-tuple(v_759),2-proj-3-tuple(v_754),3-proj-3-tuple(v_754)))) then (if (not-caught-fail(v_760) && success?(is-true(success?(1-proj-3-tuple(v_760))))) then symmetricstatepack(1-proj-3-tuple(v_760),2-proj-3-tuple(v_760),hash(3-proj-3-tuple(v_760),2-proj-2-tuple(v_759))) else fail-any) else fail-any)) in
        {264}let v_762: bitstring = catch-fail((if success?(1-proj-7-tuple(v_752)) then (if (not-caught-fail(v_754) && success?(is-true(success?(1-proj-3-tuple(v_754))))) then (if (not-caught-fail(v_759) && success?(is-true(success?(1-proj-2-tuple(v_759))))) then (if not-caught-fail(v_761) then (v_761,2-proj-2-tuple(v_759)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {265}let v_763: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_762),2-proj-7-tuple(v_752),3-proj-7-tuple(v_752),4-proj-7-tuple(v_752),5-proj-7-tuple(v_752),6-proj-7-tuple(v_752),7-proj-7-tuple(v_752))) in
        {266}let v_764: bitstring = catch-fail(concat3(1-proj-3-tuple(v_753),2-proj-3-tuple(v_753),2-proj-2-tuple(v_762))) in
        {267}let (hs_765: handshakestate,message_c_766: bitstring) = (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-7-tuple(v_752))))) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-3-tuple(v_753))))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-2-tuple(v_762))))) then (if not-caught-fail(v_763) then (if not-caught-fail(v_764) then (v_763,v_764) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {268}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie));
        {269}insert statestore(alice,charlie,sid,statepack_d(hs_765,handshakestategetcs(hs_765),cs2_750));
        {270}out(pub, message_c_766)
    ) | (
        {272}!
        {292}get statestore(=alice,=charlie,=sid,statepack_d(hs_767: handshakestate,cs1_768: cipherstate,cs2_769: cipherstate)) in
        {273}let hs_770: handshakestate = handshakestatesetcs(hs_767,cs2_769) in
        {274}in(pub, message_d_771: bitstring);
        {275}let v_772: bitstring = catch-fail(handshakestateunpack(hs_770)) in
        {276}let v_773: bitstring = catch-fail(deconcat3(message_d_771)) in
        {277}let v_774: bool = catch-fail(true) in
        {278}let v_775: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_772))) in
        {279}let v_776: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_775))) in
        {280}let v_777: aead = catch-fail(decrypt(1-proj-2-tuple(v_776),2-proj-2-tuple(v_776),3-proj-3-tuple(v_775),3-proj-3-tuple(v_773))) in
        {281}let v_778: bitstring = catch-fail(aeadunpack(v_777)) in
        {282}let v_779: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_775))) in
        {283}let v_780: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_776))) && success?(1-proj-3-tuple(v_775))) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then cipherstatepack(1-proj-2-tuple(v_779),increment_nonce(2-proj-2-tuple(v_776))) else fail-any) else fail-any)) in
        {284}let v_781: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_773)) && (success?(3-proj-3-tuple(v_775)) && success?(1-proj-3-tuple(v_775)))) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-2-tuple(v_776))))) then (if not-caught-fail(v_777) then (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-3-tuple(v_778))))) then (if not-caught-fail(v_780) then (v_780,3-proj-3-tuple(v_778),1-proj-3-tuple(v_778)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {285}let v_782: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_781),2-proj-3-tuple(v_775),3-proj-3-tuple(v_775)))) in
        {286}let v_783: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_773)) && success?(symmetricstatepack(1-proj-3-tuple(v_781),2-proj-3-tuple(v_775),3-proj-3-tuple(v_775)))) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then symmetricstatepack(1-proj-3-tuple(v_782),2-proj-3-tuple(v_782),hash(3-proj-3-tuple(v_782),3-proj-3-tuple(v_773))) else fail-any) else fail-any)) in
        {287}let v_784: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_773)) && success?(1-proj-7-tuple(v_772))) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-3-tuple(v_775))))) then (if (not-caught-fail(v_781) && success?(is-true(success?(1-proj-3-tuple(v_781))))) then (if not-caught-fail(v_783) then (v_783,2-proj-3-tuple(v_781),3-proj-3-tuple(v_781)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {288}let v_785: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_784),2-proj-7-tuple(v_772),3-proj-7-tuple(v_772),4-proj-7-tuple(v_772),5-proj-7-tuple(v_772),6-proj-7-tuple(v_772),7-proj-7-tuple(v_772))) in
        {289}let (hs_786: handshakestate,plaintext_d_787: bitstring,valid_788: bool) = (if (not-caught-fail(v_772) && success?(is-true(success?(1-proj-7-tuple(v_772))))) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then (if not-caught-fail(v_774) then (if (not-caught-fail(v_784) && success?(is-true(success?(1-proj-3-tuple(v_784))))) then (if (v_774 && 3-proj-3-tuple(v_784)) then (if not-caught-fail(v_785) then (v_785,2-proj-3-tuple(v_784),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {290}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_787);
        {291}event RecvEnd(valid_788)
    ) | (
        {293}event LeakS(phase0,alice);
        {294}out(pub, key_s(alice))
    ) | (
        {295}phase 1;
        {296}event LeakS(phase1,alice);
        {297}out(pub, key_s(alice))
    )
) | (
    {298}let s_789: keypair = keypairpack(empty,empty) in
    {299}out(pub, getpublickey(s_789));
    (
        {300}let e_790: keypair = keypairpack(empty,empty) in
        {301}let v_791: key = catch-fail(dhexp(key_s(alice),g)) in
        {302}let rs_792: key = getpublickey((if not-caught-fail(v_791) then keypairpack(v_791,key_s(alice)) else fail-any)) in
        {303}let re_793: key = empty in
        {304}let v_794: bitstring = catch-fail(hash(somename,empty)) in
        {305}let v_795: key = catch-fail(v_794) in
        {306}let v_796: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {307}let v_797: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_794) then (if not-caught-fail(v_795) then (if not-caught-fail(v_796) then symmetricstatepack(v_796,v_795,v_794) else fail-any) else fail-any) else fail-any))) in
        {308}let v_798: symmetricstate = catch-fail((if success?((if not-caught-fail(v_794) then (if not-caught-fail(v_795) then (if not-caught-fail(v_796) then symmetricstatepack(v_796,v_795,v_794) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-3-tuple(v_797))))) then symmetricstatepack(1-proj-3-tuple(v_797),2-proj-3-tuple(v_797),hash(3-proj-3-tuple(v_797),empty)) else fail-any) else fail-any)) in
        {309}let v_799: bitstring = catch-fail(symmetricstateunpack(v_798)) in
        {310}let v_800: symmetricstate = catch-fail((if (not-caught-fail(v_799) && success?(is-true(success?(1-proj-3-tuple(v_799))))) then symmetricstatepack(1-proj-3-tuple(v_799),2-proj-3-tuple(v_799),hash(3-proj-3-tuple(v_799),rs_792)) else fail-any)) in
        {311}let hs_801: handshakestate = (if not-caught-fail(v_798) then (if not-caught-fail(v_800) then handshakestatepack(v_800,s_789,e_790,rs_792,re_793,empty,false) else fail-any) else fail-any) in
        {312}insert statestore(bob,alice,sid,statepack_a(hs_801))
    ) | (
        {334}get statestore(=bob,=alice,=sid,statepack_a(hs_802: handshakestate)) in
        {313}in(pub, message_a_803: bitstring);
        {314}let v_804: bitstring = catch-fail(handshakestateunpack(hs_802)) in
        {315}let v_805: bitstring = catch-fail(deconcat3(message_a_803)) in
        {316}let v_806: bool = catch-fail(true) in
        {317}let v_807: key = catch-fail(1-proj-3-tuple(v_805)) in
        {318}let v_808: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_804))) in
        {319}let v_809: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_804)) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then symmetricstatepack(1-proj-3-tuple(v_808),2-proj-3-tuple(v_808),hash(3-proj-3-tuple(v_808),v_807)) else fail-any) else fail-any)) in
        {320}let v_810: bitstring = catch-fail(symmetricstateunpack(v_809)) in
        {321}let v_811: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {322}let v_812: aead = catch-fail(decrypt(1-proj-2-tuple(v_811),2-proj-2-tuple(v_811),3-proj-3-tuple(v_810),3-proj-3-tuple(v_805))) in
        {323}let v_813: bitstring = catch-fail(aeadunpack(v_812)) in
        {324}let v_814: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_810))) in
        {325}let v_815: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_811))) && success?(1-proj-3-tuple(v_810))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-2-tuple(v_814))))) then cipherstatepack(1-proj-2-tuple(v_814),increment_nonce(2-proj-2-tuple(v_811))) else fail-any) else fail-any)) in
        {326}let v_816: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_805)) && (success?(3-proj-3-tuple(v_810)) && success?(1-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-2-tuple(v_811))))) then (if not-caught-fail(v_812) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-3-tuple(v_813))))) then (if not-caught-fail(v_815) then (v_815,3-proj-3-tuple(v_813),1-proj-3-tuple(v_813)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {327}let v_817: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) in
        {328}let v_818: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_805)) && success?(symmetricstatepack(1-proj-3-tuple(v_816),2-proj-3-tuple(v_810),3-proj-3-tuple(v_810)))) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then symmetricstatepack(1-proj-3-tuple(v_817),2-proj-3-tuple(v_817),hash(3-proj-3-tuple(v_817),3-proj-3-tuple(v_805))) else fail-any) else fail-any)) in
        {329}let v_819: bitstring = catch-fail((if success?(3-proj-3-tuple(v_805)) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-3-tuple(v_816))))) then (if not-caught-fail(v_818) then (v_818,2-proj-3-tuple(v_816),3-proj-3-tuple(v_816)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {330}let v_820: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_819),2-proj-7-tuple(v_804),3-proj-7-tuple(v_804),4-proj-7-tuple(v_804),v_807,6-proj-7-tuple(v_804),7-proj-7-tuple(v_804))) in
        {331}let (hs_821: handshakestate,plaintext_a: bitstring,valid_822: bool) = (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-7-tuple(v_804))))) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then (if not-caught-fail(v_806) then (if not-caught-fail(v_807) then (if not-caught-fail(v_809) then (if (not-caught-fail(v_819) && success?(is-true(success?(1-proj-3-tuple(v_819))))) then (if (v_806 && 3-proj-3-tuple(v_819)) then (if not-caught-fail(v_820) then (v_820,2-proj-3-tuple(v_819),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {332}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {333}insert statestore(bob,alice,sid,statepack_b(hs_821))
    ) | (
        {397}get statestore(=bob,=alice,=sid,statepack_b(hs_823: handshakestate)) in
        {335}let v_824: bitstring = catch-fail(handshakestateunpack(hs_823)) in
        {336}let v_825: bitstring = catch-fail((empty,empty,empty)) in
        {337}let v_826: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {338}let v_827: keypair = catch-fail((if not-caught-fail(v_826) then keypairpack(v_826,key_e(bob,alice,sid)) else fail-any)) in
        {339}let v_828: bitstring = catch-fail(getpublickey(v_827)) in
        {340}let v_829: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_824))) in
        {341}let v_830: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_824)) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then symmetricstatepack(1-proj-3-tuple(v_829),2-proj-3-tuple(v_829),hash(3-proj-3-tuple(v_829),v_828)) else fail-any) else fail-any)) in
        {342}let v_831: bitstring = catch-fail(keypairunpack(v_827)) in
        {343}let v_832: bitstring = catch-fail(symmetricstateunpack(v_830)) in
        {344}let v_833: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_832),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then dhexp(2-proj-2-tuple(v_831),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {345}let v_834: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_832),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then dhexp(2-proj-2-tuple(v_831),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {346}let v_835: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_832),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then dhexp(2-proj-2-tuple(v_831),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {347}let v_836: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then dhexp(2-proj-2-tuple(v_831),5-proj-7-tuple(v_824)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_832))) then (if not-caught-fail(v_833) then (if not-caught-fail(v_834) then (if not-caught-fail(v_835) then (v_833,v_834,v_835) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {348}let v_837: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then dhexp(2-proj-2-tuple(v_831),5-proj-7-tuple(v_824)) else fail-any) else fail-any)) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-3-tuple(v_832))))) then (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-3-tuple(v_836))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_836)) then cipherstatepack(2-proj-3-tuple(v_836),minnonce) else fail-any),1-proj-3-tuple(v_836),3-proj-3-tuple(v_832)) else fail-any) else fail-any) else fail-any)) in
        {349}let v_838: bitstring = catch-fail(keypairunpack(v_827)) in
        {350}let v_839: bitstring = catch-fail(symmetricstateunpack(v_837)) in
        {351}let v_840: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_839),(if success?(4-proj-7-tuple(v_824)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),4-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {352}let v_841: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_839),(if success?(4-proj-7-tuple(v_824)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),4-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {353}let v_842: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_839),(if success?(4-proj-7-tuple(v_824)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),4-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {354}let v_843: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_824)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),4-proj-7-tuple(v_824)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_839))) then (if not-caught-fail(v_840) then (if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (v_840,v_841,v_842) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {355}let v_844: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_824)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),4-proj-7-tuple(v_824)) else fail-any) else fail-any)) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-3-tuple(v_843))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_843)) then cipherstatepack(2-proj-3-tuple(v_843),minnonce) else fail-any),1-proj-3-tuple(v_843),3-proj-3-tuple(v_839)) else fail-any) else fail-any) else fail-any)) in
        {356}let v_845: key = catch-fail(dhexp(key_s(bob),g)) in
        {357}let v_846: keypair = catch-fail((if not-caught-fail(v_845) then keypairpack(v_845,key_s(bob)) else fail-any)) in
        {358}let v_847: bitstring = catch-fail(symmetricstateunpack(v_844)) in
        {359}let v_848: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_847))) in
        {360}let v_849: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_848),2-proj-2-tuple(v_848),3-proj-3-tuple(v_847),getpublickey(v_846))) in
        {361}let v_850: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_847))) in
        {362}let v_851: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_848))) && success?(1-proj-3-tuple(v_847))) then (if (not-caught-fail(v_850) && success?(is-true(success?(1-proj-2-tuple(v_850))))) then cipherstatepack(1-proj-2-tuple(v_850),increment_nonce(2-proj-2-tuple(v_848))) else fail-any) else fail-any)) in
        {363}let v_852: bitstring = catch-fail((if (success?(getpublickey(v_846)) && (success?(3-proj-3-tuple(v_847)) && success?(1-proj-3-tuple(v_847)))) then (if (not-caught-fail(v_848) && success?(is-true(success?(1-proj-2-tuple(v_848))))) then (if not-caught-fail(v_849) then (if not-caught-fail(v_851) then (v_851,v_849) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {364}let v_853: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_852),2-proj-3-tuple(v_847),3-proj-3-tuple(v_847)))) in
        {365}let v_854: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_852)) && success?(symmetricstatepack(1-proj-2-tuple(v_852),2-proj-3-tuple(v_847),3-proj-3-tuple(v_847)))) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-3-tuple(v_853))))) then symmetricstatepack(1-proj-3-tuple(v_853),2-proj-3-tuple(v_853),hash(3-proj-3-tuple(v_853),2-proj-2-tuple(v_852))) else fail-any) else fail-any)) in
        {366}let v_855: bitstring = catch-fail((if success?(getpublickey(v_846)) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-3-tuple(v_847))))) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then (if not-caught-fail(v_854) then (v_854,2-proj-2-tuple(v_852)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {367}let v_856: bitstring = catch-fail(keypairunpack(v_846)) in
        {368}let v_857: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_855))) in
        {369}let v_858: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_857),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {370}let v_859: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_857),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {371}let v_860: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_857),(if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_824)) else fail-any) else fail-any))) in
        {372}let v_861: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_824)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_857))) then (if not-caught-fail(v_858) then (if not-caught-fail(v_859) then (if not-caught-fail(v_860) then (v_858,v_859,v_860) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {373}let v_862: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_824)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),5-proj-7-tuple(v_824)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_855))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then (if (not-caught-fail(v_861) && success?(is-true(success?(1-proj-3-tuple(v_861))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_861)) then cipherstatepack(2-proj-3-tuple(v_861),minnonce) else fail-any),1-proj-3-tuple(v_861),3-proj-3-tuple(v_857)) else fail-any) else fail-any) else fail-any)) in
        {374}let v_863: bitstring = catch-fail(symmetricstateunpack(v_862)) in
        {375}let v_864: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {376}let v_865: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_864),2-proj-2-tuple(v_864),3-proj-3-tuple(v_863),msg_b(bob,alice))) in
        {377}let v_866: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {378}let v_867: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_864))) && success?(1-proj-3-tuple(v_863))) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-2-tuple(v_866))))) then cipherstatepack(1-proj-2-tuple(v_866),increment_nonce(2-proj-2-tuple(v_864))) else fail-any) else fail-any)) in
        {379}let v_868: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_863)) && success?(1-proj-3-tuple(v_863))) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-2-tuple(v_864))))) then (if not-caught-fail(v_865) then (if not-caught-fail(v_867) then (v_867,v_865) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {380}let v_869: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_868),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) in
        {381}let v_870: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_868)) && success?(symmetricstatepack(1-proj-2-tuple(v_868),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-3-tuple(v_869))))) then symmetricstatepack(1-proj-3-tuple(v_869),2-proj-3-tuple(v_869),hash(3-proj-3-tuple(v_869),2-proj-2-tuple(v_868))) else fail-any) else fail-any)) in
        {382}let v_871: bitstring = catch-fail((if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-3-tuple(v_863))))) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-2-tuple(v_868))))) then (if not-caught-fail(v_870) then (v_870,2-proj-2-tuple(v_868)) else fail-any) else fail-any) else fail-any)) in
        {383}let v_872: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_871),v_846,v_827,4-proj-7-tuple(v_824),5-proj-7-tuple(v_824),6-proj-7-tuple(v_824),7-proj-7-tuple(v_824))) in
        {384}let v_873: bitstring = catch-fail(concat3(v_828,2-proj-2-tuple(v_855),2-proj-2-tuple(v_871))) in
        {385}let v_874: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_871))) in
        {386}let v_875: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_874),zero)) in
        {387}let v_876: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_874),zero)) in
        {388}let v_877: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_874),zero)) in
        {389}let v_878: bitstring = catch-fail((if success?(2-proj-3-tuple(v_874)) then (if not-caught-fail(v_875) then (if not-caught-fail(v_876) then (if not-caught-fail(v_877) then (v_875,v_876,v_877) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {390}let v_879: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_878)) then cipherstatepack(1-proj-3-tuple(v_878),minnonce) else fail-any)) in
        {391}let v_880: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_878)) then cipherstatepack(2-proj-3-tuple(v_878),minnonce) else fail-any)) in
        {392}let v_881: bitstring = catch-fail((if success?(1-proj-2-tuple(v_871)) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-3-tuple(v_878))))) then (if not-caught-fail(v_879) then (if not-caught-fail(v_880) then (1-proj-2-tuple(v_871),v_879,v_880) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {393}let (hs_882: handshakestate,message_b_883: bitstring,cs1_884: cipherstate,cs2_885: cipherstate) = (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-7-tuple(v_824))))) then (if (not-caught-fail(v_825) && success?(is-true(success?(1-proj-3-tuple(v_825))))) then (if not-caught-fail(v_827) then (if not-caught-fail(v_828) then (if not-caught-fail(v_830) then (if not-caught-fail(v_837) then (if not-caught-fail(v_844) then (if not-caught-fail(v_846) then (if (not-caught-fail(v_855) && success?(is-true(success?(1-proj-2-tuple(v_855))))) then (if not-caught-fail(v_862) then (if (not-caught-fail(v_871) && success?(is-true(success?(1-proj-2-tuple(v_871))))) then (if not-caught-fail(v_872) then (if not-caught-fail(v_873) then (if (not-caught-fail(v_881) && success?(is-true(success?(1-proj-3-tuple(v_881))))) then (v_872,v_873,2-proj-3-tuple(v_881),3-proj-3-tuple(v_881)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {394}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice));
        {395}insert statestore(bob,alice,sid,statepack_c(hs_882,cs1_884,cs2_885));
        {396}out(pub, message_b_883)
    ) | (
        {398}!
        {418}get statestore(=bob,=alice,=sid,statepack_c(hs_886: handshakestate,cs1_887: cipherstate,cs2_888: cipherstate)) in
        {399}let hs_889: handshakestate = handshakestatesetcs(hs_886,cs1_887) in
        {400}in(pub, message_c_890: bitstring);
        {401}let v_891: bitstring = catch-fail(handshakestateunpack(hs_889)) in
        {402}let v_892: bitstring = catch-fail(deconcat3(message_c_890)) in
        {403}let v_893: bool = catch-fail(true) in
        {404}let v_894: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_891))) in
        {405}let v_895: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_894))) in
        {406}let v_896: aead = catch-fail(decrypt(1-proj-2-tuple(v_895),2-proj-2-tuple(v_895),3-proj-3-tuple(v_894),3-proj-3-tuple(v_892))) in
        {407}let v_897: bitstring = catch-fail(aeadunpack(v_896)) in
        {408}let v_898: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_894))) in
        {409}let v_899: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_895))) && success?(1-proj-3-tuple(v_894))) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-2-tuple(v_898))))) then cipherstatepack(1-proj-2-tuple(v_898),increment_nonce(2-proj-2-tuple(v_895))) else fail-any) else fail-any)) in
        {410}let v_900: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_892)) && (success?(3-proj-3-tuple(v_894)) && success?(1-proj-3-tuple(v_894)))) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-2-tuple(v_895))))) then (if not-caught-fail(v_896) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-3-tuple(v_897))))) then (if not-caught-fail(v_899) then (v_899,3-proj-3-tuple(v_897),1-proj-3-tuple(v_897)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {411}let v_901: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_900),2-proj-3-tuple(v_894),3-proj-3-tuple(v_894)))) in
        {412}let v_902: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_892)) && success?(symmetricstatepack(1-proj-3-tuple(v_900),2-proj-3-tuple(v_894),3-proj-3-tuple(v_894)))) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-3-tuple(v_901))))) then symmetricstatepack(1-proj-3-tuple(v_901),2-proj-3-tuple(v_901),hash(3-proj-3-tuple(v_901),3-proj-3-tuple(v_892))) else fail-any) else fail-any)) in
        {413}let v_903: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_892)) && success?(1-proj-7-tuple(v_891))) then (if (not-caught-fail(v_894) && success?(is-true(success?(1-proj-3-tuple(v_894))))) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-3-tuple(v_900))))) then (if not-caught-fail(v_902) then (v_902,2-proj-3-tuple(v_900),3-proj-3-tuple(v_900)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {414}let v_904: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_903),2-proj-7-tuple(v_891),3-proj-7-tuple(v_891),4-proj-7-tuple(v_891),5-proj-7-tuple(v_891),6-proj-7-tuple(v_891),7-proj-7-tuple(v_891))) in
        {415}let (hs_905: handshakestate,plaintext_c: bitstring,valid_906: bool) = (if (not-caught-fail(v_891) && success?(is-true(success?(1-proj-7-tuple(v_891))))) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if not-caught-fail(v_893) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-3-tuple(v_903))))) then (if (v_893 && 3-proj-3-tuple(v_903)) then (if not-caught-fail(v_904) then (v_904,2-proj-3-tuple(v_903),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {416}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {417}insert statestore(bob,alice,sid,statepack_d(hs_905,handshakestategetcs(hs_905),cs2_888))
    ) | (
        {419}!
        {437}get statestore(=bob,=alice,=sid,statepack_d(hs_907: handshakestate,cs1_908: cipherstate,cs2_909: cipherstate)) in
        {420}let hs_910: handshakestate = handshakestatesetcs(hs_907,cs2_909) in
        {421}let v_911: bitstring = catch-fail(handshakestateunpack(hs_910)) in
        {422}let v_912: bitstring = catch-fail((empty,empty,empty)) in
        {423}let v_913: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_911))) in
        {424}let v_914: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_913))) in
        {425}let v_915: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_914),2-proj-2-tuple(v_914),3-proj-3-tuple(v_913),msg_d(bob,alice))) in
        {426}let v_916: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_913))) in
        {427}let v_917: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_914))) && success?(1-proj-3-tuple(v_913))) then (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-2-tuple(v_916))))) then cipherstatepack(1-proj-2-tuple(v_916),increment_nonce(2-proj-2-tuple(v_914))) else fail-any) else fail-any)) in
        {428}let v_918: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_913)) && success?(1-proj-3-tuple(v_913))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-2-tuple(v_914))))) then (if not-caught-fail(v_915) then (if not-caught-fail(v_917) then (v_917,v_915) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {429}let v_919: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_918),2-proj-3-tuple(v_913),3-proj-3-tuple(v_913)))) in
        {430}let v_920: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_918)) && success?(symmetricstatepack(1-proj-2-tuple(v_918),2-proj-3-tuple(v_913),3-proj-3-tuple(v_913)))) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-3-tuple(v_919))))) then symmetricstatepack(1-proj-3-tuple(v_919),2-proj-3-tuple(v_919),hash(3-proj-3-tuple(v_919),2-proj-2-tuple(v_918))) else fail-any) else fail-any)) in
        {431}let v_921: bitstring = catch-fail((if success?(1-proj-7-tuple(v_911)) then (if (not-caught-fail(v_913) && success?(is-true(success?(1-proj-3-tuple(v_913))))) then (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-2-tuple(v_918))))) then (if not-caught-fail(v_920) then (v_920,2-proj-2-tuple(v_918)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {432}let v_922: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_921),2-proj-7-tuple(v_911),3-proj-7-tuple(v_911),4-proj-7-tuple(v_911),5-proj-7-tuple(v_911),6-proj-7-tuple(v_911),7-proj-7-tuple(v_911))) in
        {433}let v_923: bitstring = catch-fail(concat3(1-proj-3-tuple(v_912),2-proj-3-tuple(v_912),2-proj-2-tuple(v_921))) in
        {434}let (hs_924: handshakestate,message_d_925: bitstring) = (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-7-tuple(v_911))))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-3-tuple(v_912))))) then (if (not-caught-fail(v_921) && success?(is-true(success?(1-proj-2-tuple(v_921))))) then (if not-caught-fail(v_922) then (if not-caught-fail(v_923) then (v_922,v_923) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {435}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice));
        {436}out(pub, message_d_925)
    ) | (
        {438}event LeakS(phase0,bob);
        {439}out(pub, key_s(bob))
    ) | (
        {440}phase 1;
        {441}event LeakS(phase1,bob);
        {442}out(pub, key_s(bob))
    )
) | (
    {443}let s_926: keypair = keypairpack(empty,empty) in
    {444}out(pub, getpublickey(s_926));
    (
        {445}let e_927: keypair = keypairpack(empty,empty) in
        {446}let v_928: key = catch-fail(dhexp(key_s(charlie),g)) in
        {447}let rs_929: key = getpublickey((if not-caught-fail(v_928) then keypairpack(v_928,key_s(charlie)) else fail-any)) in
        {448}let re_930: key = empty in
        {449}let v_931: bitstring = catch-fail(hash(somename,empty)) in
        {450}let v_932: key = catch-fail(v_931) in
        {451}let v_933: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {452}let v_934: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_931) then (if not-caught-fail(v_932) then (if not-caught-fail(v_933) then symmetricstatepack(v_933,v_932,v_931) else fail-any) else fail-any) else fail-any))) in
        {453}let v_935: symmetricstate = catch-fail((if success?((if not-caught-fail(v_931) then (if not-caught-fail(v_932) then (if not-caught-fail(v_933) then symmetricstatepack(v_933,v_932,v_931) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-3-tuple(v_934))))) then symmetricstatepack(1-proj-3-tuple(v_934),2-proj-3-tuple(v_934),hash(3-proj-3-tuple(v_934),empty)) else fail-any) else fail-any)) in
        {454}let v_936: bitstring = catch-fail(symmetricstateunpack(v_935)) in
        {455}let v_937: symmetricstate = catch-fail((if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_936),hash(3-proj-3-tuple(v_936),rs_929)) else fail-any)) in
        {456}let hs_938: handshakestate = (if not-caught-fail(v_935) then (if not-caught-fail(v_937) then handshakestatepack(v_937,s_926,e_927,rs_929,re_930,empty,false) else fail-any) else fail-any) in
        {457}insert statestore(bob,charlie,sid,statepack_a(hs_938))
    ) | (
        {479}get statestore(=bob,=charlie,=sid,statepack_a(hs_939: handshakestate)) in
        {458}in(pub, message_a_940: bitstring);
        {459}let v_941: bitstring = catch-fail(handshakestateunpack(hs_939)) in
        {460}let v_942: bitstring = catch-fail(deconcat3(message_a_940)) in
        {461}let v_943: bool = catch-fail(true) in
        {462}let v_944: key = catch-fail(1-proj-3-tuple(v_942)) in
        {463}let v_945: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_941))) in
        {464}let v_946: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_941)) then (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-3-tuple(v_945))))) then symmetricstatepack(1-proj-3-tuple(v_945),2-proj-3-tuple(v_945),hash(3-proj-3-tuple(v_945),v_944)) else fail-any) else fail-any)) in
        {465}let v_947: bitstring = catch-fail(symmetricstateunpack(v_946)) in
        {466}let v_948: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_947))) in
        {467}let v_949: aead = catch-fail(decrypt(1-proj-2-tuple(v_948),2-proj-2-tuple(v_948),3-proj-3-tuple(v_947),3-proj-3-tuple(v_942))) in
        {468}let v_950: bitstring = catch-fail(aeadunpack(v_949)) in
        {469}let v_951: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_947))) in
        {470}let v_952: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_948))) && success?(1-proj-3-tuple(v_947))) then (if (not-caught-fail(v_951) && success?(is-true(success?(1-proj-2-tuple(v_951))))) then cipherstatepack(1-proj-2-tuple(v_951),increment_nonce(2-proj-2-tuple(v_948))) else fail-any) else fail-any)) in
        {471}let v_953: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_942)) && (success?(3-proj-3-tuple(v_947)) && success?(1-proj-3-tuple(v_947)))) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then (if not-caught-fail(v_949) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-3-tuple(v_950))))) then (if not-caught-fail(v_952) then (v_952,3-proj-3-tuple(v_950),1-proj-3-tuple(v_950)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {472}let v_954: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_953),2-proj-3-tuple(v_947),3-proj-3-tuple(v_947)))) in
        {473}let v_955: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_942)) && success?(symmetricstatepack(1-proj-3-tuple(v_953),2-proj-3-tuple(v_947),3-proj-3-tuple(v_947)))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-3-tuple(v_954))))) then symmetricstatepack(1-proj-3-tuple(v_954),2-proj-3-tuple(v_954),hash(3-proj-3-tuple(v_954),3-proj-3-tuple(v_942))) else fail-any) else fail-any)) in
        {474}let v_956: bitstring = catch-fail((if success?(3-proj-3-tuple(v_942)) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-3-tuple(v_953))))) then (if not-caught-fail(v_955) then (v_955,2-proj-3-tuple(v_953),3-proj-3-tuple(v_953)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {475}let v_957: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_956),2-proj-7-tuple(v_941),3-proj-7-tuple(v_941),4-proj-7-tuple(v_941),v_944,6-proj-7-tuple(v_941),7-proj-7-tuple(v_941))) in
        {476}let (hs_958: handshakestate,plaintext_a_959: bitstring,valid_960: bool) = (if (not-caught-fail(v_941) && success?(is-true(success?(1-proj-7-tuple(v_941))))) then (if (not-caught-fail(v_942) && success?(is-true(success?(1-proj-3-tuple(v_942))))) then (if not-caught-fail(v_943) then (if not-caught-fail(v_944) then (if not-caught-fail(v_946) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if (v_943 && 3-proj-3-tuple(v_956)) then (if not-caught-fail(v_957) then (v_957,2-proj-3-tuple(v_956),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {477}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_959);
        {478}insert statestore(bob,charlie,sid,statepack_b(hs_958))
    ) | (
        {542}get statestore(=bob,=charlie,=sid,statepack_b(hs_961: handshakestate)) in
        {480}let v_962: bitstring = catch-fail(handshakestateunpack(hs_961)) in
        {481}let v_963: bitstring = catch-fail((empty,empty,empty)) in
        {482}let v_964: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {483}let v_965: keypair = catch-fail((if not-caught-fail(v_964) then keypairpack(v_964,key_e(bob,charlie,sid)) else fail-any)) in
        {484}let v_966: bitstring = catch-fail(getpublickey(v_965)) in
        {485}let v_967: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_962))) in
        {486}let v_968: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_962)) then (if (not-caught-fail(v_967) && success?(is-true(success?(1-proj-3-tuple(v_967))))) then symmetricstatepack(1-proj-3-tuple(v_967),2-proj-3-tuple(v_967),hash(3-proj-3-tuple(v_967),v_966)) else fail-any) else fail-any)) in
        {487}let v_969: bitstring = catch-fail(keypairunpack(v_965)) in
        {488}let v_970: bitstring = catch-fail(symmetricstateunpack(v_968)) in
        {489}let v_971: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_970),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-2-tuple(v_969))))) then dhexp(2-proj-2-tuple(v_969),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {490}let v_972: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_970),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-2-tuple(v_969))))) then dhexp(2-proj-2-tuple(v_969),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {491}let v_973: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_970),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-2-tuple(v_969))))) then dhexp(2-proj-2-tuple(v_969),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {492}let v_974: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-2-tuple(v_969))))) then dhexp(2-proj-2-tuple(v_969),5-proj-7-tuple(v_962)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_970))) then (if not-caught-fail(v_971) then (if not-caught-fail(v_972) then (if not-caught-fail(v_973) then (v_971,v_972,v_973) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {493}let v_975: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-2-tuple(v_969))))) then dhexp(2-proj-2-tuple(v_969),5-proj-7-tuple(v_962)) else fail-any) else fail-any)) then (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-3-tuple(v_970))))) then (if (not-caught-fail(v_974) && success?(is-true(success?(1-proj-3-tuple(v_974))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_974)) then cipherstatepack(2-proj-3-tuple(v_974),minnonce) else fail-any),1-proj-3-tuple(v_974),3-proj-3-tuple(v_970)) else fail-any) else fail-any) else fail-any)) in
        {494}let v_976: bitstring = catch-fail(keypairunpack(v_965)) in
        {495}let v_977: bitstring = catch-fail(symmetricstateunpack(v_975)) in
        {496}let v_978: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_977),(if success?(4-proj-7-tuple(v_962)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-2-tuple(v_976))))) then dhexp(2-proj-2-tuple(v_976),4-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {497}let v_979: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_977),(if success?(4-proj-7-tuple(v_962)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-2-tuple(v_976))))) then dhexp(2-proj-2-tuple(v_976),4-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {498}let v_980: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_977),(if success?(4-proj-7-tuple(v_962)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-2-tuple(v_976))))) then dhexp(2-proj-2-tuple(v_976),4-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {499}let v_981: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_962)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-2-tuple(v_976))))) then dhexp(2-proj-2-tuple(v_976),4-proj-7-tuple(v_962)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_977))) then (if not-caught-fail(v_978) then (if not-caught-fail(v_979) then (if not-caught-fail(v_980) then (v_978,v_979,v_980) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {500}let v_982: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_962)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-2-tuple(v_976))))) then dhexp(2-proj-2-tuple(v_976),4-proj-7-tuple(v_962)) else fail-any) else fail-any)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-3-tuple(v_977))))) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_981)) then cipherstatepack(2-proj-3-tuple(v_981),minnonce) else fail-any),1-proj-3-tuple(v_981),3-proj-3-tuple(v_977)) else fail-any) else fail-any) else fail-any)) in
        {501}let v_983: key = catch-fail(dhexp(key_s(bob),g)) in
        {502}let v_984: keypair = catch-fail((if not-caught-fail(v_983) then keypairpack(v_983,key_s(bob)) else fail-any)) in
        {503}let v_985: bitstring = catch-fail(symmetricstateunpack(v_982)) in
        {504}let v_986: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_985))) in
        {505}let v_987: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_986),2-proj-2-tuple(v_986),3-proj-3-tuple(v_985),getpublickey(v_984))) in
        {506}let v_988: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_985))) in
        {507}let v_989: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_986))) && success?(1-proj-3-tuple(v_985))) then (if (not-caught-fail(v_988) && success?(is-true(success?(1-proj-2-tuple(v_988))))) then cipherstatepack(1-proj-2-tuple(v_988),increment_nonce(2-proj-2-tuple(v_986))) else fail-any) else fail-any)) in
        {508}let v_990: bitstring = catch-fail((if (success?(getpublickey(v_984)) && (success?(3-proj-3-tuple(v_985)) && success?(1-proj-3-tuple(v_985)))) then (if (not-caught-fail(v_986) && success?(is-true(success?(1-proj-2-tuple(v_986))))) then (if not-caught-fail(v_987) then (if not-caught-fail(v_989) then (v_989,v_987) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {509}let v_991: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_990),2-proj-3-tuple(v_985),3-proj-3-tuple(v_985)))) in
        {510}let v_992: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_990)) && success?(symmetricstatepack(1-proj-2-tuple(v_990),2-proj-3-tuple(v_985),3-proj-3-tuple(v_985)))) then (if (not-caught-fail(v_991) && success?(is-true(success?(1-proj-3-tuple(v_991))))) then symmetricstatepack(1-proj-3-tuple(v_991),2-proj-3-tuple(v_991),hash(3-proj-3-tuple(v_991),2-proj-2-tuple(v_990))) else fail-any) else fail-any)) in
        {511}let v_993: bitstring = catch-fail((if success?(getpublickey(v_984)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-3-tuple(v_985))))) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then (if not-caught-fail(v_992) then (v_992,2-proj-2-tuple(v_990)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {512}let v_994: bitstring = catch-fail(keypairunpack(v_984)) in
        {513}let v_995: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_993))) in
        {514}let v_996: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_995),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then dhexp(2-proj-2-tuple(v_994),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {515}let v_997: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_995),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then dhexp(2-proj-2-tuple(v_994),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {516}let v_998: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_995),(if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then dhexp(2-proj-2-tuple(v_994),5-proj-7-tuple(v_962)) else fail-any) else fail-any))) in
        {517}let v_999: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then dhexp(2-proj-2-tuple(v_994),5-proj-7-tuple(v_962)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_995))) then (if not-caught-fail(v_996) then (if not-caught-fail(v_997) then (if not-caught-fail(v_998) then (v_996,v_997,v_998) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {518}let v_1000: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_962)) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then dhexp(2-proj-2-tuple(v_994),5-proj-7-tuple(v_962)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_993))) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_999)) then cipherstatepack(2-proj-3-tuple(v_999),minnonce) else fail-any),1-proj-3-tuple(v_999),3-proj-3-tuple(v_995)) else fail-any) else fail-any) else fail-any)) in
        {519}let v_1001: bitstring = catch-fail(symmetricstateunpack(v_1000)) in
        {520}let v_1002: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1001))) in
        {521}let v_1003: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1002),2-proj-2-tuple(v_1002),3-proj-3-tuple(v_1001),msg_b(bob,charlie))) in
        {522}let v_1004: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1001))) in
        {523}let v_1005: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1002))) && success?(1-proj-3-tuple(v_1001))) then (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-2-tuple(v_1004))))) then cipherstatepack(1-proj-2-tuple(v_1004),increment_nonce(2-proj-2-tuple(v_1002))) else fail-any) else fail-any)) in
        {524}let v_1006: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1001)) && success?(1-proj-3-tuple(v_1001))) then (if (not-caught-fail(v_1002) && success?(is-true(success?(1-proj-2-tuple(v_1002))))) then (if not-caught-fail(v_1003) then (if not-caught-fail(v_1005) then (v_1005,v_1003) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {525}let v_1007: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1006),2-proj-3-tuple(v_1001),3-proj-3-tuple(v_1001)))) in
        {526}let v_1008: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1006)) && success?(symmetricstatepack(1-proj-2-tuple(v_1006),2-proj-3-tuple(v_1001),3-proj-3-tuple(v_1001)))) then (if (not-caught-fail(v_1007) && success?(is-true(success?(1-proj-3-tuple(v_1007))))) then symmetricstatepack(1-proj-3-tuple(v_1007),2-proj-3-tuple(v_1007),hash(3-proj-3-tuple(v_1007),2-proj-2-tuple(v_1006))) else fail-any) else fail-any)) in
        {527}let v_1009: bitstring = catch-fail((if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-3-tuple(v_1001))))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-2-tuple(v_1006))))) then (if not-caught-fail(v_1008) then (v_1008,2-proj-2-tuple(v_1006)) else fail-any) else fail-any) else fail-any)) in
        {528}let v_1010: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1009),v_984,v_965,4-proj-7-tuple(v_962),5-proj-7-tuple(v_962),6-proj-7-tuple(v_962),7-proj-7-tuple(v_962))) in
        {529}let v_1011: bitstring = catch-fail(concat3(v_966,2-proj-2-tuple(v_993),2-proj-2-tuple(v_1009))) in
        {530}let v_1012: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1009))) in
        {531}let v_1013: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1012),zero)) in
        {532}let v_1014: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1012),zero)) in
        {533}let v_1015: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1012),zero)) in
        {534}let v_1016: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1012)) then (if not-caught-fail(v_1013) then (if not-caught-fail(v_1014) then (if not-caught-fail(v_1015) then (v_1013,v_1014,v_1015) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {535}let v_1017: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1016)) then cipherstatepack(1-proj-3-tuple(v_1016),minnonce) else fail-any)) in
        {536}let v_1018: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1016)) then cipherstatepack(2-proj-3-tuple(v_1016),minnonce) else fail-any)) in
        {537}let v_1019: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1009)) then (if (not-caught-fail(v_1012) && success?(is-true(success?(1-proj-3-tuple(v_1012))))) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-3-tuple(v_1016))))) then (if not-caught-fail(v_1017) then (if not-caught-fail(v_1018) then (1-proj-2-tuple(v_1009),v_1017,v_1018) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {538}let (hs_1020: handshakestate,message_b_1021: bitstring,cs1_1022: cipherstate,cs2_1023: cipherstate) = (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-7-tuple(v_962))))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-3-tuple(v_963))))) then (if not-caught-fail(v_965) then (if not-caught-fail(v_966) then (if not-caught-fail(v_968) then (if not-caught-fail(v_975) then (if not-caught-fail(v_982) then (if not-caught-fail(v_984) then (if (not-caught-fail(v_993) && success?(is-true(success?(1-proj-2-tuple(v_993))))) then (if not-caught-fail(v_1000) then (if (not-caught-fail(v_1009) && success?(is-true(success?(1-proj-2-tuple(v_1009))))) then (if not-caught-fail(v_1010) then (if not-caught-fail(v_1011) then (if (not-caught-fail(v_1019) && success?(is-true(success?(1-proj-3-tuple(v_1019))))) then (v_1010,v_1011,2-proj-3-tuple(v_1019),3-proj-3-tuple(v_1019)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {539}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie));
        {540}insert statestore(bob,charlie,sid,statepack_c(hs_1020,cs1_1022,cs2_1023));
        {541}out(pub, message_b_1021)
    ) | (
        {543}!
        {563}get statestore(=bob,=charlie,=sid,statepack_c(hs_1024: handshakestate,cs1_1025: cipherstate,cs2_1026: cipherstate)) in
        {544}let hs_1027: handshakestate = handshakestatesetcs(hs_1024,cs1_1025) in
        {545}in(pub, message_c_1028: bitstring);
        {546}let v_1029: bitstring = catch-fail(handshakestateunpack(hs_1027)) in
        {547}let v_1030: bitstring = catch-fail(deconcat3(message_c_1028)) in
        {548}let v_1031: bool = catch-fail(true) in
        {549}let v_1032: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1029))) in
        {550}let v_1033: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1032))) in
        {551}let v_1034: aead = catch-fail(decrypt(1-proj-2-tuple(v_1033),2-proj-2-tuple(v_1033),3-proj-3-tuple(v_1032),3-proj-3-tuple(v_1030))) in
        {552}let v_1035: bitstring = catch-fail(aeadunpack(v_1034)) in
        {553}let v_1036: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1032))) in
        {554}let v_1037: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1033))) && success?(1-proj-3-tuple(v_1032))) then (if (not-caught-fail(v_1036) && success?(is-true(success?(1-proj-2-tuple(v_1036))))) then cipherstatepack(1-proj-2-tuple(v_1036),increment_nonce(2-proj-2-tuple(v_1033))) else fail-any) else fail-any)) in
        {555}let v_1038: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1030)) && (success?(3-proj-3-tuple(v_1032)) && success?(1-proj-3-tuple(v_1032)))) then (if (not-caught-fail(v_1033) && success?(is-true(success?(1-proj-2-tuple(v_1033))))) then (if not-caught-fail(v_1034) then (if (not-caught-fail(v_1035) && success?(is-true(success?(1-proj-3-tuple(v_1035))))) then (if not-caught-fail(v_1037) then (v_1037,3-proj-3-tuple(v_1035),1-proj-3-tuple(v_1035)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {556}let v_1039: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1038),2-proj-3-tuple(v_1032),3-proj-3-tuple(v_1032)))) in
        {557}let v_1040: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1030)) && success?(symmetricstatepack(1-proj-3-tuple(v_1038),2-proj-3-tuple(v_1032),3-proj-3-tuple(v_1032)))) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then symmetricstatepack(1-proj-3-tuple(v_1039),2-proj-3-tuple(v_1039),hash(3-proj-3-tuple(v_1039),3-proj-3-tuple(v_1030))) else fail-any) else fail-any)) in
        {558}let v_1041: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1030)) && success?(1-proj-7-tuple(v_1029))) then (if (not-caught-fail(v_1032) && success?(is-true(success?(1-proj-3-tuple(v_1032))))) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-3-tuple(v_1038))))) then (if not-caught-fail(v_1040) then (v_1040,2-proj-3-tuple(v_1038),3-proj-3-tuple(v_1038)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {559}let v_1042: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1041),2-proj-7-tuple(v_1029),3-proj-7-tuple(v_1029),4-proj-7-tuple(v_1029),5-proj-7-tuple(v_1029),6-proj-7-tuple(v_1029),7-proj-7-tuple(v_1029))) in
        {560}let (hs_1043: handshakestate,plaintext_c_1044: bitstring,valid_1045: bool) = (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-7-tuple(v_1029))))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-3-tuple(v_1030))))) then (if not-caught-fail(v_1031) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-3-tuple(v_1041))))) then (if (v_1031 && 3-proj-3-tuple(v_1041)) then (if not-caught-fail(v_1042) then (v_1042,2-proj-3-tuple(v_1041),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {561}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1044);
        {562}insert statestore(bob,charlie,sid,statepack_d(hs_1043,handshakestategetcs(hs_1043),cs2_1026))
    ) | (
        {564}!
        {582}get statestore(=bob,=charlie,=sid,statepack_d(hs_1046: handshakestate,cs1_1047: cipherstate,cs2_1048: cipherstate)) in
        {565}let hs_1049: handshakestate = handshakestatesetcs(hs_1046,cs2_1048) in
        {566}let v_1050: bitstring = catch-fail(handshakestateunpack(hs_1049)) in
        {567}let v_1051: bitstring = catch-fail((empty,empty,empty)) in
        {568}let v_1052: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1050))) in
        {569}let v_1053: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1052))) in
        {570}let v_1054: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1053),2-proj-2-tuple(v_1053),3-proj-3-tuple(v_1052),msg_d(bob,charlie))) in
        {571}let v_1055: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1052))) in
        {572}let v_1056: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1053))) && success?(1-proj-3-tuple(v_1052))) then (if (not-caught-fail(v_1055) && success?(is-true(success?(1-proj-2-tuple(v_1055))))) then cipherstatepack(1-proj-2-tuple(v_1055),increment_nonce(2-proj-2-tuple(v_1053))) else fail-any) else fail-any)) in
        {573}let v_1057: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1052)) && success?(1-proj-3-tuple(v_1052))) then (if (not-caught-fail(v_1053) && success?(is-true(success?(1-proj-2-tuple(v_1053))))) then (if not-caught-fail(v_1054) then (if not-caught-fail(v_1056) then (v_1056,v_1054) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {574}let v_1058: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1057),2-proj-3-tuple(v_1052),3-proj-3-tuple(v_1052)))) in
        {575}let v_1059: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1057)) && success?(symmetricstatepack(1-proj-2-tuple(v_1057),2-proj-3-tuple(v_1052),3-proj-3-tuple(v_1052)))) then (if (not-caught-fail(v_1058) && success?(is-true(success?(1-proj-3-tuple(v_1058))))) then symmetricstatepack(1-proj-3-tuple(v_1058),2-proj-3-tuple(v_1058),hash(3-proj-3-tuple(v_1058),2-proj-2-tuple(v_1057))) else fail-any) else fail-any)) in
        {576}let v_1060: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1050)) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-3-tuple(v_1052))))) then (if (not-caught-fail(v_1057) && success?(is-true(success?(1-proj-2-tuple(v_1057))))) then (if not-caught-fail(v_1059) then (v_1059,2-proj-2-tuple(v_1057)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {577}let v_1061: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1060),2-proj-7-tuple(v_1050),3-proj-7-tuple(v_1050),4-proj-7-tuple(v_1050),5-proj-7-tuple(v_1050),6-proj-7-tuple(v_1050),7-proj-7-tuple(v_1050))) in
        {578}let v_1062: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1051),2-proj-3-tuple(v_1051),2-proj-2-tuple(v_1060))) in
        {579}let (hs_1063: handshakestate,message_d_1064: bitstring) = (if (not-caught-fail(v_1050) && success?(is-true(success?(1-proj-7-tuple(v_1050))))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-3-tuple(v_1051))))) then (if (not-caught-fail(v_1060) && success?(is-true(success?(1-proj-2-tuple(v_1060))))) then (if not-caught-fail(v_1061) then (if not-caught-fail(v_1062) then (v_1061,v_1062) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {580}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie));
        {581}out(pub, message_d_1064)
    ) | (
        {583}event LeakS(phase0,bob);
        {584}out(pub, key_s(bob))
    ) | (
        {585}phase 1;
        {586}event LeakS(phase1,bob);
        {587}out(pub, key_s(bob))
    )
)

