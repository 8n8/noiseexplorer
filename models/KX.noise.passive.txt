File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 274, character 7 - line 274, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 275, character 7 - line 275, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 275, character 36 - line 275, character 36:
Warning: identifier h rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 305, character 6 - line 305, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 310, character 6 - line 310, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 316, character 6 - line 316, character 6:
Warning: identifier e rebound.
File "KX.noise.passive.pv", line 317, character 6 - line 317, character 7:
Warning: identifier ne rebound.
File "KX.noise.passive.pv", line 318, character 6 - line 318, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 320, character 7 - line 320, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 320, character 26 - line 320, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 321, character 6 - line 321, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 328, character 6 - line 328, character 6:
Warning: identifier e rebound.
File "KX.noise.passive.pv", line 329, character 6 - line 329, character 7:
Warning: identifier ne rebound.
File "KX.noise.passive.pv", line 330, character 6 - line 330, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 332, character 6 - line 332, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 333, character 6 - line 333, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 334, character 6 - line 334, character 6:
Warning: identifier s rebound.
File "KX.noise.passive.pv", line 335, character 7 - line 335, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 335, character 26 - line 335, character 36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.passive.pv", line 336, character 6 - line 336, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 337, character 7 - line 337, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 337, character 26 - line 337, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 338, character 6 - line 338, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 345, character 7 - line 345, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 345, character 26 - line 345, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 346, character 6 - line 346, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 353, character 7 - line 353, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 353, character 26 - line 353, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 354, character 6 - line 354, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 363, character 6 - line 363, character 7:
Warning: identifier re rebound.
File "KX.noise.passive.pv", line 364, character 6 - line 364, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 366, character 7 - line 366, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 368, character 7 - line 368, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 376, character 6 - line 376, character 7:
Warning: identifier re rebound.
File "KX.noise.passive.pv", line 377, character 6 - line 377, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 379, character 6 - line 379, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 380, character 6 - line 380, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 381, character 7 - line 381, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 381, character 48 - line 381, character 53:
Warning: identifier valid1 rebound.
File "KX.noise.passive.pv", line 382, character 6 - line 382, character 7:
Warning: identifier rs rebound.
File "KX.noise.passive.pv", line 383, character 6 - line 383, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 384, character 7 - line 384, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 386, character 7 - line 386, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 394, character 7 - line 394, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 396, character 7 - line 396, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 404, character 7 - line 404, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 406, character 7 - line 406, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 554, character 8 - line 554, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 404, character 7 - line 404, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 406, character 7 - line 406, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 546, character 8 - line 546, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 345, character 7 - line 345, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 345, character 26 - line 345, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 346, character 6 - line 346, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 539, character 8 - line 539, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 376, character 6 - line 376, character 7:
Warning: identifier re rebound.
File "KX.noise.passive.pv", line 377, character 6 - line 377, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 379, character 6 - line 379, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 380, character 6 - line 380, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 381, character 7 - line 381, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 381, character 48 - line 381, character 53:
Warning: identifier valid1 rebound.
File "KX.noise.passive.pv", line 382, character 6 - line 382, character 7:
Warning: identifier rs rebound.
File "KX.noise.passive.pv", line 383, character 6 - line 383, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 384, character 7 - line 384, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 386, character 7 - line 386, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 531, character 8 - line 531, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 316, character 6 - line 316, character 6:
Warning: identifier e rebound.
File "KX.noise.passive.pv", line 317, character 6 - line 317, character 7:
Warning: identifier ne rebound.
File "KX.noise.passive.pv", line 318, character 6 - line 318, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 320, character 7 - line 320, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 320, character 26 - line 320, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 321, character 6 - line 321, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 305, character 6 - line 305, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 604, character 8 - line 604, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 353, character 7 - line 353, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 353, character 26 - line 353, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 354, character 6 - line 354, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 597, character 8 - line 597, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 394, character 7 - line 394, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 396, character 7 - line 396, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 589, character 8 - line 589, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 328, character 6 - line 328, character 6:
Warning: identifier e rebound.
File "KX.noise.passive.pv", line 329, character 6 - line 329, character 7:
Warning: identifier ne rebound.
File "KX.noise.passive.pv", line 330, character 6 - line 330, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 332, character 6 - line 332, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 333, character 6 - line 333, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 334, character 6 - line 334, character 6:
Warning: identifier s rebound.
File "KX.noise.passive.pv", line 335, character 7 - line 335, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 335, character 26 - line 335, character 36:
Warning: identifier ciphertext1 rebound.
File "KX.noise.passive.pv", line 336, character 6 - line 336, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 337, character 7 - line 337, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 337, character 26 - line 337, character 36:
Warning: identifier ciphertext2 rebound.
File "KX.noise.passive.pv", line 338, character 6 - line 338, character 7:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 265, character 7 - line 265, character 8:
Warning: identifier ck rebound.
File "KX.noise.passive.pv", line 284, character 7 - line 284, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 285, character 6 - line 285, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 582, character 8 - line 582, character 9:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 363, character 6 - line 363, character 7:
Warning: identifier re rebound.
File "KX.noise.passive.pv", line 364, character 6 - line 364, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 366, character 7 - line 366, character 8:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 368, character 7 - line 368, character 8:
Warning: identifier hs rebound.
File "KX.noise.passive.pv", line 290, character 7 - line 290, character 8:
Warning: identifier cs rebound.
File "KX.noise.passive.pv", line 291, character 6 - line 291, character 7:
Warning: identifier ss rebound.
File "KX.noise.passive.pv", line 310, character 6 - line 310, character 7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}!
(
    {2}let v_570: key = catch-fail(dhexp(key_s(alice),g)) in
    {3}let s_571: keypair = (if not-caught-fail(v_570) then keypairpack(v_570,key_s(alice)) else fail-any) in
    {4}out(pub, getpublickey(s_571));
    (
        {5}let e_572: keypair = keypairpack(empty,empty) in
        {6}let rs_573: key = empty in
        {7}let re_574: key = empty in
        {8}let v_575: bitstring = catch-fail(hash(somename,empty)) in
        {9}let v_576: key = catch-fail(v_575) in
        {10}let v_577: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {11}let v_578: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_575) then (if not-caught-fail(v_576) then (if not-caught-fail(v_577) then symmetricstatepack(v_577,v_576,v_575) else fail-any) else fail-any) else fail-any))) in
        {12}let v_579: symmetricstate = catch-fail((if success?((if not-caught-fail(v_575) then (if not-caught-fail(v_576) then (if not-caught-fail(v_577) then symmetricstatepack(v_577,v_576,v_575) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_578) && success?(is-true(success?(1-proj-3-tuple(v_578))))) then symmetricstatepack(1-proj-3-tuple(v_578),2-proj-3-tuple(v_578),hash(3-proj-3-tuple(v_578),empty)) else fail-any) else fail-any)) in
        {13}let v_580: bitstring = catch-fail(symmetricstateunpack(v_579)) in
        {14}let v_581: symmetricstate = catch-fail((if success?(getpublickey(s_571)) then (if (not-caught-fail(v_580) && success?(is-true(success?(1-proj-3-tuple(v_580))))) then symmetricstatepack(1-proj-3-tuple(v_580),2-proj-3-tuple(v_580),hash(3-proj-3-tuple(v_580),getpublickey(s_571))) else fail-any) else fail-any)) in
        {15}let hs: handshakestate = (if not-caught-fail(v_579) then (if not-caught-fail(v_581) then handshakestatepack(v_581,s_571,e_572,rs_573,re_574,empty,true) else fail-any) else fail-any) in
        {16}insert statestore(alice,bob,statepack_a(hs))
    ) | (
        {39}get statestore(=alice,=bob,statepack_a(hs_582: handshakestate)) in
        {17}let v_583: bitstring = catch-fail(handshakestateunpack(hs_582)) in
        {18}let v_584: bitstring = catch-fail((empty,empty,empty)) in
        {19}let v_585: key = catch-fail(dhexp(key_e(alice,bob),g)) in
        {20}let v_586: keypair = catch-fail((if not-caught-fail(v_585) then keypairpack(v_585,key_e(alice,bob)) else fail-any)) in
        {21}let v_587: bitstring = catch-fail(getpublickey(v_586)) in
        {22}let v_588: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_583))) in
        {23}let v_589: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_583)) then (if (not-caught-fail(v_588) && success?(is-true(success?(1-proj-3-tuple(v_588))))) then symmetricstatepack(1-proj-3-tuple(v_588),2-proj-3-tuple(v_588),hash(3-proj-3-tuple(v_588),v_587)) else fail-any) else fail-any)) in
        {24}let v_590: bitstring = catch-fail(symmetricstateunpack(v_589)) in
        {25}let v_591: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_590))) in
        {26}let v_592: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_591),2-proj-2-tuple(v_591),3-proj-3-tuple(v_590),msg_a(alice,bob))) in
        {27}let v_593: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_590))) in
        {28}let v_594: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_591))) && success?(1-proj-3-tuple(v_590))) then (if (not-caught-fail(v_593) && success?(is-true(success?(1-proj-2-tuple(v_593))))) then cipherstatepack(1-proj-2-tuple(v_593),increment_nonce(2-proj-2-tuple(v_591))) else fail-any) else fail-any)) in
        {29}let v_595: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_590)) && success?(1-proj-3-tuple(v_590))) then (if (not-caught-fail(v_591) && success?(is-true(success?(1-proj-2-tuple(v_591))))) then (if not-caught-fail(v_592) then (if not-caught-fail(v_594) then (v_594,v_592) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {30}let v_596: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_595),2-proj-3-tuple(v_590),3-proj-3-tuple(v_590)))) in
        {31}let v_597: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_595)) && success?(symmetricstatepack(1-proj-2-tuple(v_595),2-proj-3-tuple(v_590),3-proj-3-tuple(v_590)))) then (if (not-caught-fail(v_596) && success?(is-true(success?(1-proj-3-tuple(v_596))))) then symmetricstatepack(1-proj-3-tuple(v_596),2-proj-3-tuple(v_596),hash(3-proj-3-tuple(v_596),2-proj-2-tuple(v_595))) else fail-any) else fail-any)) in
        {32}let v_598: bitstring = catch-fail((if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-2-tuple(v_595))))) then (if not-caught-fail(v_597) then (v_597,2-proj-2-tuple(v_595)) else fail-any) else fail-any) else fail-any)) in
        {33}let v_599: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_598),2-proj-7-tuple(v_583),v_586,4-proj-7-tuple(v_583),5-proj-7-tuple(v_583),6-proj-7-tuple(v_583),7-proj-7-tuple(v_583))) in
        {34}let v_600: bitstring = catch-fail(concat3(v_587,2-proj-3-tuple(v_584),2-proj-2-tuple(v_598))) in
        {35}let (hs_601: handshakestate,re_602: key,message_a: bitstring) = (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-7-tuple(v_583))))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-3-tuple(v_584))))) then (if not-caught-fail(v_586) then (if not-caught-fail(v_587) then (if not-caught-fail(v_589) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-2-tuple(v_598))))) then (if not-caught-fail(v_599) then (if not-caught-fail(v_600) then (v_599,5-proj-7-tuple(v_583),v_600) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {36}event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true);
        {37}insert statestore(alice,bob,statepack_b(hs_601));
        {38}out(pub, message_a)
    ) | (
        {94}get statestore(=alice,=bob,statepack_b(hs_603: handshakestate)) in
        {40}in(pub, message_b: bitstring);
        {41}let v_604: bitstring = catch-fail(handshakestateunpack(hs_603)) in
        {42}let v_605: bitstring = catch-fail(deconcat3(message_b)) in
        {43}let v_606: bool = catch-fail(true) in
        {44}let v_607: key = catch-fail(1-proj-3-tuple(v_605)) in
        {45}let v_608: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_604))) in
        {46}let v_609: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_604)) then (if (not-caught-fail(v_608) && success?(is-true(success?(1-proj-3-tuple(v_608))))) then symmetricstatepack(1-proj-3-tuple(v_608),2-proj-3-tuple(v_608),hash(3-proj-3-tuple(v_608),v_607)) else fail-any) else fail-any)) in
        {47}let v_610: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_604))) in
        {48}let v_611: bitstring = catch-fail(symmetricstateunpack(v_609)) in
        {49}let v_612: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_607) else fail-any) else fail-any))) in
        {50}let v_613: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_607) else fail-any) else fail-any))) in
        {51}let v_614: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_611),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_607) else fail-any) else fail-any))) in
        {52}let v_615: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_607) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_611))) then (if not-caught-fail(v_612) then (if not-caught-fail(v_613) then (if not-caught-fail(v_614) then (v_612,v_613,v_614) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {53}let v_616: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),v_607) else fail-any) else fail-any)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-3-tuple(v_611))))) then (if (not-caught-fail(v_615) && success?(is-true(success?(1-proj-3-tuple(v_615))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_615)) then cipherstatepack(2-proj-3-tuple(v_615),minnonce) else fail-any),1-proj-3-tuple(v_615),3-proj-3-tuple(v_611)) else fail-any) else fail-any) else fail-any)) in
        {54}let v_617: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_604))) in
        {55}let v_618: bitstring = catch-fail(symmetricstateunpack(v_616)) in
        {56}let v_619: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_618),(if success?(2-proj-7-tuple(v_604)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then dhexp(2-proj-2-tuple(v_617),v_607) else fail-any) else fail-any))) in
        {57}let v_620: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_618),(if success?(2-proj-7-tuple(v_604)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then dhexp(2-proj-2-tuple(v_617),v_607) else fail-any) else fail-any))) in
        {58}let v_621: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_618),(if success?(2-proj-7-tuple(v_604)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then dhexp(2-proj-2-tuple(v_617),v_607) else fail-any) else fail-any))) in
        {59}let v_622: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_604)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then dhexp(2-proj-2-tuple(v_617),v_607) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_618))) then (if not-caught-fail(v_619) then (if not-caught-fail(v_620) then (if not-caught-fail(v_621) then (v_619,v_620,v_621) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {60}let v_623: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_604)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then dhexp(2-proj-2-tuple(v_617),v_607) else fail-any) else fail-any)) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-3-tuple(v_618))))) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-3-tuple(v_622))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_622)) then cipherstatepack(2-proj-3-tuple(v_622),minnonce) else fail-any),1-proj-3-tuple(v_622),3-proj-3-tuple(v_618)) else fail-any) else fail-any) else fail-any)) in
        {61}let v_624: bitstring = catch-fail(symmetricstateunpack(v_623)) in
        {62}let v_625: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_624))) in
        {63}let v_626: aead = catch-fail(decrypt(1-proj-2-tuple(v_625),2-proj-2-tuple(v_625),3-proj-3-tuple(v_624),2-proj-3-tuple(v_605))) in
        {64}let v_627: bitstring = catch-fail(aeadunpack(v_626)) in
        {65}let v_628: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_624))) in
        {66}let v_629: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_625))) && success?(1-proj-3-tuple(v_624))) then (if (not-caught-fail(v_628) && success?(is-true(success?(1-proj-2-tuple(v_628))))) then cipherstatepack(1-proj-2-tuple(v_628),increment_nonce(2-proj-2-tuple(v_625))) else fail-any) else fail-any)) in
        {67}let v_630: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_605)) && (success?(3-proj-3-tuple(v_624)) && success?(1-proj-3-tuple(v_624)))) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then (if not-caught-fail(v_626) then (if (not-caught-fail(v_627) && success?(is-true(success?(1-proj-3-tuple(v_627))))) then (if not-caught-fail(v_629) then (v_629,3-proj-3-tuple(v_627),1-proj-3-tuple(v_627)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {68}let v_631: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_630),2-proj-3-tuple(v_624),3-proj-3-tuple(v_624)))) in
        {69}let v_632: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_605)) && success?(symmetricstatepack(1-proj-3-tuple(v_630),2-proj-3-tuple(v_624),3-proj-3-tuple(v_624)))) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then symmetricstatepack(1-proj-3-tuple(v_631),2-proj-3-tuple(v_631),hash(3-proj-3-tuple(v_631),2-proj-3-tuple(v_605))) else fail-any) else fail-any)) in
        {70}let v_633: bitstring = catch-fail((if success?(2-proj-3-tuple(v_605)) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-3-tuple(v_624))))) then (if (not-caught-fail(v_630) && success?(is-true(success?(1-proj-3-tuple(v_630))))) then (if not-caught-fail(v_632) then (v_632,2-proj-3-tuple(v_630),3-proj-3-tuple(v_630)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {71}let v_634: key = catch-fail(2-proj-3-tuple(v_633)) in
        {72}let v_635: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_604))) in
        {73}let v_636: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_633))) in
        {74}let v_637: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_636),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then dhexp(2-proj-2-tuple(v_635),v_634) else fail-any) else fail-any))) in
        {75}let v_638: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_636),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then dhexp(2-proj-2-tuple(v_635),v_634) else fail-any) else fail-any))) in
        {76}let v_639: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_636),(if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then dhexp(2-proj-2-tuple(v_635),v_634) else fail-any) else fail-any))) in
        {77}let v_640: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then dhexp(2-proj-2-tuple(v_635),v_634) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_636))) then (if not-caught-fail(v_637) then (if not-caught-fail(v_638) then (if not-caught-fail(v_639) then (v_637,v_638,v_639) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {78}let v_641: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_604)) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then dhexp(2-proj-2-tuple(v_635),v_634) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_633))) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-3-tuple(v_640))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_640)) then cipherstatepack(2-proj-3-tuple(v_640),minnonce) else fail-any),1-proj-3-tuple(v_640),3-proj-3-tuple(v_636)) else fail-any) else fail-any) else fail-any)) in
        {79}let v_642: bitstring = catch-fail(symmetricstateunpack(v_641)) in
        {80}let v_643: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_642))) in
        {81}let v_644: aead = catch-fail(decrypt(1-proj-2-tuple(v_643),2-proj-2-tuple(v_643),3-proj-3-tuple(v_642),3-proj-3-tuple(v_605))) in
        {82}let v_645: bitstring = catch-fail(aeadunpack(v_644)) in
        {83}let v_646: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_642))) in
        {84}let v_647: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_643))) && success?(1-proj-3-tuple(v_642))) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-2-tuple(v_646))))) then cipherstatepack(1-proj-2-tuple(v_646),increment_nonce(2-proj-2-tuple(v_643))) else fail-any) else fail-any)) in
        {85}let v_648: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_605)) && (success?(3-proj-3-tuple(v_642)) && success?(1-proj-3-tuple(v_642)))) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-2-tuple(v_643))))) then (if not-caught-fail(v_644) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then (if not-caught-fail(v_647) then (v_647,3-proj-3-tuple(v_645),1-proj-3-tuple(v_645)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {86}let v_649: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_648),2-proj-3-tuple(v_642),3-proj-3-tuple(v_642)))) in
        {87}let v_650: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_605)) && success?(symmetricstatepack(1-proj-3-tuple(v_648),2-proj-3-tuple(v_642),3-proj-3-tuple(v_642)))) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-3-tuple(v_649))))) then symmetricstatepack(1-proj-3-tuple(v_649),2-proj-3-tuple(v_649),hash(3-proj-3-tuple(v_649),3-proj-3-tuple(v_605))) else fail-any) else fail-any)) in
        {88}let v_651: bitstring = catch-fail((if success?(3-proj-3-tuple(v_605)) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-3-tuple(v_648))))) then (if not-caught-fail(v_650) then (v_650,2-proj-3-tuple(v_648),3-proj-3-tuple(v_648)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {89}let v_652: key = catch-fail(dhexp(key_s(bob),g)) in
        {90}let v_653: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_651),2-proj-7-tuple(v_604),3-proj-7-tuple(v_604),v_634,v_607,6-proj-7-tuple(v_604),7-proj-7-tuple(v_604))) in
        {91}let (hs_654: handshakestate,re_655: key,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-7-tuple(v_604))))) then (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-3-tuple(v_605))))) then (if not-caught-fail(v_606) then (if not-caught-fail(v_607) then (if not-caught-fail(v_609) then (if not-caught-fail(v_616) then (if not-caught-fail(v_623) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-3-tuple(v_633))))) then (if not-caught-fail(v_634) then (if not-caught-fail(v_641) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-3-tuple(v_651))))) then (if ((3-proj-3-tuple(v_633) && 3-proj-3-tuple(v_651)) && (v_634 = getpublickey((if not-caught-fail(v_652) then keypairpack(v_652,key_s(bob)) else fail-any)))) then (if not-caught-fail(v_653) then (v_653,getpublickey(3-proj-7-tuple(v_604)),2-proj-3-tuple(v_651),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {92}event RecvMsg(alice,bob,stage_b,plaintext_b,valid);
        {93}insert statestore(alice,bob,statepack_c(hs_654))
    ) | (
        {112}get statestore(=alice,=bob,statepack_c(hs_656: handshakestate)) in
        {95}let v_657: bitstring = catch-fail(handshakestateunpack(hs_656)) in
        {96}let v_658: bitstring = catch-fail((empty,empty,empty)) in
        {97}let v_659: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_657))) in
        {98}let v_660: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_659))) in
        {99}let v_661: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_660),2-proj-2-tuple(v_660),3-proj-3-tuple(v_659),msg_c(alice,bob))) in
        {100}let v_662: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_659))) in
        {101}let v_663: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_660))) && success?(1-proj-3-tuple(v_659))) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-2-tuple(v_662))))) then cipherstatepack(1-proj-2-tuple(v_662),increment_nonce(2-proj-2-tuple(v_660))) else fail-any) else fail-any)) in
        {102}let v_664: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_659)) && success?(1-proj-3-tuple(v_659))) then (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-2-tuple(v_660))))) then (if not-caught-fail(v_661) then (if not-caught-fail(v_663) then (v_663,v_661) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {103}let v_665: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_664),2-proj-3-tuple(v_659),3-proj-3-tuple(v_659)))) in
        {104}let v_666: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_664)) && success?(symmetricstatepack(1-proj-2-tuple(v_664),2-proj-3-tuple(v_659),3-proj-3-tuple(v_659)))) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-3-tuple(v_665))))) then symmetricstatepack(1-proj-3-tuple(v_665),2-proj-3-tuple(v_665),hash(3-proj-3-tuple(v_665),2-proj-2-tuple(v_664))) else fail-any) else fail-any)) in
        {105}let v_667: bitstring = catch-fail((if success?(1-proj-7-tuple(v_657)) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-3-tuple(v_659))))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then (if not-caught-fail(v_666) then (v_666,2-proj-2-tuple(v_664)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {106}let v_668: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_667),2-proj-7-tuple(v_657),3-proj-7-tuple(v_657),4-proj-7-tuple(v_657),5-proj-7-tuple(v_657),6-proj-7-tuple(v_657),7-proj-7-tuple(v_657))) in
        {107}let v_669: bitstring = catch-fail(concat3(1-proj-3-tuple(v_658),2-proj-3-tuple(v_658),2-proj-2-tuple(v_667))) in
        {108}let (hs_670: handshakestate,re_671: key,message_c: bitstring) = (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-7-tuple(v_657))))) then (if (not-caught-fail(v_658) && success?(is-true(success?(1-proj-3-tuple(v_658))))) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-2-tuple(v_667))))) then (if not-caught-fail(v_668) then (if not-caught-fail(v_669) then (v_668,5-proj-7-tuple(v_657),v_669) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {109}event SendMsg(alice,bob,stage_c,msg_c(alice,bob),true);
        {110}insert statestore(alice,bob,statepack_d(hs_670));
        {111}out(pub, message_c)
    ) | (
        {140}get statestore(=alice,=bob,statepack_d(hs_672: handshakestate)) in
        {113}in(pub, message_d: bitstring);
        {114}let v_673: bitstring = catch-fail(handshakestateunpack(hs_672)) in
        {115}let v_674: bitstring = catch-fail(deconcat3(message_d)) in
        {116}let v_675: bool = catch-fail(true) in
        {117}let v_676: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_673))) in
        {118}let v_677: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_676))) in
        {119}let v_678: aead = catch-fail(decrypt(1-proj-2-tuple(v_677),2-proj-2-tuple(v_677),3-proj-3-tuple(v_676),3-proj-3-tuple(v_674))) in
        {120}let v_679: bitstring = catch-fail(aeadunpack(v_678)) in
        {121}let v_680: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_676))) in
        {122}let v_681: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_677))) && success?(1-proj-3-tuple(v_676))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-2-tuple(v_680))))) then cipherstatepack(1-proj-2-tuple(v_680),increment_nonce(2-proj-2-tuple(v_677))) else fail-any) else fail-any)) in
        {123}let v_682: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_674)) && (success?(3-proj-3-tuple(v_676)) && success?(1-proj-3-tuple(v_676)))) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-2-tuple(v_677))))) then (if not-caught-fail(v_678) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-3-tuple(v_679))))) then (if not-caught-fail(v_681) then (v_681,3-proj-3-tuple(v_679),1-proj-3-tuple(v_679)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {124}let v_683: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_682),2-proj-3-tuple(v_676),3-proj-3-tuple(v_676)))) in
        {125}let v_684: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_674)) && success?(symmetricstatepack(1-proj-3-tuple(v_682),2-proj-3-tuple(v_676),3-proj-3-tuple(v_676)))) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-3-tuple(v_683))))) then symmetricstatepack(1-proj-3-tuple(v_683),2-proj-3-tuple(v_683),hash(3-proj-3-tuple(v_683),3-proj-3-tuple(v_674))) else fail-any) else fail-any)) in
        {126}let v_685: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_674)) && success?(1-proj-7-tuple(v_673))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then (if (not-caught-fail(v_682) && success?(is-true(success?(1-proj-3-tuple(v_682))))) then (if not-caught-fail(v_684) then (v_684,2-proj-3-tuple(v_682),3-proj-3-tuple(v_682)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {127}let v_686: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_685),2-proj-7-tuple(v_673),3-proj-7-tuple(v_673),4-proj-7-tuple(v_673),5-proj-7-tuple(v_673),6-proj-7-tuple(v_673),7-proj-7-tuple(v_673))) in
        {128}let v_687: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_685))) in
        {129}let v_688: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_687),zero)) in
        {130}let v_689: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_687),zero)) in
        {131}let v_690: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_687),zero)) in
        {132}let v_691: bitstring = catch-fail((if success?(2-proj-3-tuple(v_687)) then (if not-caught-fail(v_688) then (if not-caught-fail(v_689) then (if not-caught-fail(v_690) then (v_688,v_689,v_690) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {133}let v_692: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_691)) then cipherstatepack(1-proj-3-tuple(v_691),minnonce) else fail-any)) in
        {134}let v_693: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_691)) then cipherstatepack(2-proj-3-tuple(v_691),minnonce) else fail-any)) in
        {135}let v_694: bitstring = catch-fail((if success?(1-proj-3-tuple(v_685)) then (if (not-caught-fail(v_687) && success?(is-true(success?(1-proj-3-tuple(v_687))))) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-3-tuple(v_691))))) then (if not-caught-fail(v_692) then (if not-caught-fail(v_693) then (1-proj-3-tuple(v_685),v_692,v_693) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {136}let (hs_695: handshakestate,re_696: key,plaintext_d: bitstring,valid_697: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-7-tuple(v_673))))) then (if (not-caught-fail(v_674) && success?(is-true(success?(1-proj-3-tuple(v_674))))) then (if not-caught-fail(v_675) then (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-3-tuple(v_685))))) then (if (v_675 && 3-proj-3-tuple(v_685)) then (if not-caught-fail(v_686) then (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-3-tuple(v_694))))) then (v_686,getpublickey(3-proj-7-tuple(v_673)),2-proj-3-tuple(v_685),true,2-proj-3-tuple(v_694),3-proj-3-tuple(v_694)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {137}event RecvMsg(alice,bob,stage_d,plaintext_d,valid_697);
        {138}insert statestore(alice,bob,statepack_e(hs_695));
        {139}event RecvEnd(valid_697)
    ) | (
        {141}event LeakS(phase0,alice);
        {142}out(pub, key_s(alice))
    ) | (
        {143}phase 1;
        {144}event LeakS(phase1,alice);
        {145}out(pub, key_s(alice))
    )
) | (
    {146}let v_698: key = catch-fail(dhexp(key_s(alice),g)) in
    {147}let s_699: keypair = (if not-caught-fail(v_698) then keypairpack(v_698,key_s(alice)) else fail-any) in
    {148}out(pub, getpublickey(s_699));
    (
        {149}let e_700: keypair = keypairpack(empty,empty) in
        {150}let rs_701: key = empty in
        {151}let re_702: key = empty in
        {152}let v_703: bitstring = catch-fail(hash(somename,empty)) in
        {153}let v_704: key = catch-fail(v_703) in
        {154}let v_705: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {155}let v_706: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_703) then (if not-caught-fail(v_704) then (if not-caught-fail(v_705) then symmetricstatepack(v_705,v_704,v_703) else fail-any) else fail-any) else fail-any))) in
        {156}let v_707: symmetricstate = catch-fail((if success?((if not-caught-fail(v_703) then (if not-caught-fail(v_704) then (if not-caught-fail(v_705) then symmetricstatepack(v_705,v_704,v_703) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-3-tuple(v_706))))) then symmetricstatepack(1-proj-3-tuple(v_706),2-proj-3-tuple(v_706),hash(3-proj-3-tuple(v_706),empty)) else fail-any) else fail-any)) in
        {157}let v_708: bitstring = catch-fail(symmetricstateunpack(v_707)) in
        {158}let v_709: symmetricstate = catch-fail((if success?(getpublickey(s_699)) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-3-tuple(v_708))))) then symmetricstatepack(1-proj-3-tuple(v_708),2-proj-3-tuple(v_708),hash(3-proj-3-tuple(v_708),getpublickey(s_699))) else fail-any) else fail-any)) in
        {159}let hs_710: handshakestate = (if not-caught-fail(v_707) then (if not-caught-fail(v_709) then handshakestatepack(v_709,s_699,e_700,rs_701,re_702,empty,true) else fail-any) else fail-any) in
        {160}insert statestore(alice,charlie,statepack_a(hs_710))
    ) | (
        {183}get statestore(=alice,=charlie,statepack_a(hs_711: handshakestate)) in
        {161}let v_712: bitstring = catch-fail(handshakestateunpack(hs_711)) in
        {162}let v_713: bitstring = catch-fail((empty,empty,empty)) in
        {163}let v_714: key = catch-fail(dhexp(key_e(alice,charlie),g)) in
        {164}let v_715: keypair = catch-fail((if not-caught-fail(v_714) then keypairpack(v_714,key_e(alice,charlie)) else fail-any)) in
        {165}let v_716: bitstring = catch-fail(getpublickey(v_715)) in
        {166}let v_717: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_712))) in
        {167}let v_718: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_712)) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then symmetricstatepack(1-proj-3-tuple(v_717),2-proj-3-tuple(v_717),hash(3-proj-3-tuple(v_717),v_716)) else fail-any) else fail-any)) in
        {168}let v_719: bitstring = catch-fail(symmetricstateunpack(v_718)) in
        {169}let v_720: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_719))) in
        {170}let v_721: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_720),2-proj-2-tuple(v_720),3-proj-3-tuple(v_719),msg_a(alice,charlie))) in
        {171}let v_722: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_719))) in
        {172}let v_723: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_720))) && success?(1-proj-3-tuple(v_719))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-2-tuple(v_722))))) then cipherstatepack(1-proj-2-tuple(v_722),increment_nonce(2-proj-2-tuple(v_720))) else fail-any) else fail-any)) in
        {173}let v_724: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_719)) && success?(1-proj-3-tuple(v_719))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-2-tuple(v_720))))) then (if not-caught-fail(v_721) then (if not-caught-fail(v_723) then (v_723,v_721) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {174}let v_725: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_724),2-proj-3-tuple(v_719),3-proj-3-tuple(v_719)))) in
        {175}let v_726: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_724)) && success?(symmetricstatepack(1-proj-2-tuple(v_724),2-proj-3-tuple(v_719),3-proj-3-tuple(v_719)))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-3-tuple(v_725))))) then symmetricstatepack(1-proj-3-tuple(v_725),2-proj-3-tuple(v_725),hash(3-proj-3-tuple(v_725),2-proj-2-tuple(v_724))) else fail-any) else fail-any)) in
        {176}let v_727: bitstring = catch-fail((if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-3-tuple(v_719))))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-2-tuple(v_724))))) then (if not-caught-fail(v_726) then (v_726,2-proj-2-tuple(v_724)) else fail-any) else fail-any) else fail-any)) in
        {177}let v_728: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_727),2-proj-7-tuple(v_712),v_715,4-proj-7-tuple(v_712),5-proj-7-tuple(v_712),6-proj-7-tuple(v_712),7-proj-7-tuple(v_712))) in
        {178}let v_729: bitstring = catch-fail(concat3(v_716,2-proj-3-tuple(v_713),2-proj-2-tuple(v_727))) in
        {179}let (hs_730: handshakestate,re_731: key,message_a_732: bitstring) = (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-7-tuple(v_712))))) then (if (not-caught-fail(v_713) && success?(is-true(success?(1-proj-3-tuple(v_713))))) then (if not-caught-fail(v_715) then (if not-caught-fail(v_716) then (if not-caught-fail(v_718) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-2-tuple(v_727))))) then (if not-caught-fail(v_728) then (if not-caught-fail(v_729) then (v_728,5-proj-7-tuple(v_712),v_729) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {180}event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true);
        {181}insert statestore(alice,charlie,statepack_b(hs_730));
        {182}out(pub, message_a_732)
    ) | (
        {238}get statestore(=alice,=charlie,statepack_b(hs_733: handshakestate)) in
        {184}in(pub, message_b_734: bitstring);
        {185}let v_735: bitstring = catch-fail(handshakestateunpack(hs_733)) in
        {186}let v_736: bitstring = catch-fail(deconcat3(message_b_734)) in
        {187}let v_737: bool = catch-fail(true) in
        {188}let v_738: key = catch-fail(1-proj-3-tuple(v_736)) in
        {189}let v_739: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_735))) in
        {190}let v_740: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_735)) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then symmetricstatepack(1-proj-3-tuple(v_739),2-proj-3-tuple(v_739),hash(3-proj-3-tuple(v_739),v_738)) else fail-any) else fail-any)) in
        {191}let v_741: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_735))) in
        {192}let v_742: bitstring = catch-fail(symmetricstateunpack(v_740)) in
        {193}let v_743: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_742),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then dhexp(2-proj-2-tuple(v_741),v_738) else fail-any) else fail-any))) in
        {194}let v_744: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_742),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then dhexp(2-proj-2-tuple(v_741),v_738) else fail-any) else fail-any))) in
        {195}let v_745: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_742),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then dhexp(2-proj-2-tuple(v_741),v_738) else fail-any) else fail-any))) in
        {196}let v_746: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then dhexp(2-proj-2-tuple(v_741),v_738) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_742))) then (if not-caught-fail(v_743) then (if not-caught-fail(v_744) then (if not-caught-fail(v_745) then (v_743,v_744,v_745) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {197}let v_747: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-2-tuple(v_741))))) then dhexp(2-proj-2-tuple(v_741),v_738) else fail-any) else fail-any)) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-3-tuple(v_742))))) then (if (not-caught-fail(v_746) && success?(is-true(success?(1-proj-3-tuple(v_746))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_746)) then cipherstatepack(2-proj-3-tuple(v_746),minnonce) else fail-any),1-proj-3-tuple(v_746),3-proj-3-tuple(v_742)) else fail-any) else fail-any) else fail-any)) in
        {198}let v_748: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_735))) in
        {199}let v_749: bitstring = catch-fail(symmetricstateunpack(v_747)) in
        {200}let v_750: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_749),(if success?(2-proj-7-tuple(v_735)) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-2-tuple(v_748))))) then dhexp(2-proj-2-tuple(v_748),v_738) else fail-any) else fail-any))) in
        {201}let v_751: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_749),(if success?(2-proj-7-tuple(v_735)) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-2-tuple(v_748))))) then dhexp(2-proj-2-tuple(v_748),v_738) else fail-any) else fail-any))) in
        {202}let v_752: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_749),(if success?(2-proj-7-tuple(v_735)) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-2-tuple(v_748))))) then dhexp(2-proj-2-tuple(v_748),v_738) else fail-any) else fail-any))) in
        {203}let v_753: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_735)) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-2-tuple(v_748))))) then dhexp(2-proj-2-tuple(v_748),v_738) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_749))) then (if not-caught-fail(v_750) then (if not-caught-fail(v_751) then (if not-caught-fail(v_752) then (v_750,v_751,v_752) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {204}let v_754: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_735)) then (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-2-tuple(v_748))))) then dhexp(2-proj-2-tuple(v_748),v_738) else fail-any) else fail-any)) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-3-tuple(v_749))))) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-3-tuple(v_753))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_753)) then cipherstatepack(2-proj-3-tuple(v_753),minnonce) else fail-any),1-proj-3-tuple(v_753),3-proj-3-tuple(v_749)) else fail-any) else fail-any) else fail-any)) in
        {205}let v_755: bitstring = catch-fail(symmetricstateunpack(v_754)) in
        {206}let v_756: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_755))) in
        {207}let v_757: aead = catch-fail(decrypt(1-proj-2-tuple(v_756),2-proj-2-tuple(v_756),3-proj-3-tuple(v_755),2-proj-3-tuple(v_736))) in
        {208}let v_758: bitstring = catch-fail(aeadunpack(v_757)) in
        {209}let v_759: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_755))) in
        {210}let v_760: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_756))) && success?(1-proj-3-tuple(v_755))) then (if (not-caught-fail(v_759) && success?(is-true(success?(1-proj-2-tuple(v_759))))) then cipherstatepack(1-proj-2-tuple(v_759),increment_nonce(2-proj-2-tuple(v_756))) else fail-any) else fail-any)) in
        {211}let v_761: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_736)) && (success?(3-proj-3-tuple(v_755)) && success?(1-proj-3-tuple(v_755)))) then (if (not-caught-fail(v_756) && success?(is-true(success?(1-proj-2-tuple(v_756))))) then (if not-caught-fail(v_757) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-3-tuple(v_758))))) then (if not-caught-fail(v_760) then (v_760,3-proj-3-tuple(v_758),1-proj-3-tuple(v_758)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {212}let v_762: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_761),2-proj-3-tuple(v_755),3-proj-3-tuple(v_755)))) in
        {213}let v_763: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_736)) && success?(symmetricstatepack(1-proj-3-tuple(v_761),2-proj-3-tuple(v_755),3-proj-3-tuple(v_755)))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then symmetricstatepack(1-proj-3-tuple(v_762),2-proj-3-tuple(v_762),hash(3-proj-3-tuple(v_762),2-proj-3-tuple(v_736))) else fail-any) else fail-any)) in
        {214}let v_764: bitstring = catch-fail((if success?(2-proj-3-tuple(v_736)) then (if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-3-tuple(v_755))))) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-3-tuple(v_761))))) then (if not-caught-fail(v_763) then (v_763,2-proj-3-tuple(v_761),3-proj-3-tuple(v_761)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {215}let v_765: key = catch-fail(2-proj-3-tuple(v_764)) in
        {216}let v_766: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_735))) in
        {217}let v_767: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_764))) in
        {218}let v_768: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_767),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then dhexp(2-proj-2-tuple(v_766),v_765) else fail-any) else fail-any))) in
        {219}let v_769: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_767),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then dhexp(2-proj-2-tuple(v_766),v_765) else fail-any) else fail-any))) in
        {220}let v_770: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_767),(if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then dhexp(2-proj-2-tuple(v_766),v_765) else fail-any) else fail-any))) in
        {221}let v_771: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then dhexp(2-proj-2-tuple(v_766),v_765) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_767))) then (if not-caught-fail(v_768) then (if not-caught-fail(v_769) then (if not-caught-fail(v_770) then (v_768,v_769,v_770) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {222}let v_772: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_735)) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then dhexp(2-proj-2-tuple(v_766),v_765) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_764))) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-3-tuple(v_767))))) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-3-tuple(v_771))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_771)) then cipherstatepack(2-proj-3-tuple(v_771),minnonce) else fail-any),1-proj-3-tuple(v_771),3-proj-3-tuple(v_767)) else fail-any) else fail-any) else fail-any)) in
        {223}let v_773: bitstring = catch-fail(symmetricstateunpack(v_772)) in
        {224}let v_774: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {225}let v_775: aead = catch-fail(decrypt(1-proj-2-tuple(v_774),2-proj-2-tuple(v_774),3-proj-3-tuple(v_773),3-proj-3-tuple(v_736))) in
        {226}let v_776: bitstring = catch-fail(aeadunpack(v_775)) in
        {227}let v_777: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {228}let v_778: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_774))) && success?(1-proj-3-tuple(v_773))) then (if (not-caught-fail(v_777) && success?(is-true(success?(1-proj-2-tuple(v_777))))) then cipherstatepack(1-proj-2-tuple(v_777),increment_nonce(2-proj-2-tuple(v_774))) else fail-any) else fail-any)) in
        {229}let v_779: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_736)) && (success?(3-proj-3-tuple(v_773)) && success?(1-proj-3-tuple(v_773)))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-2-tuple(v_774))))) then (if not-caught-fail(v_775) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-3-tuple(v_776))))) then (if not-caught-fail(v_778) then (v_778,3-proj-3-tuple(v_776),1-proj-3-tuple(v_776)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {230}let v_780: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_779),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) in
        {231}let v_781: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_736)) && success?(symmetricstatepack(1-proj-3-tuple(v_779),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) then (if (not-caught-fail(v_780) && success?(is-true(success?(1-proj-3-tuple(v_780))))) then symmetricstatepack(1-proj-3-tuple(v_780),2-proj-3-tuple(v_780),hash(3-proj-3-tuple(v_780),3-proj-3-tuple(v_736))) else fail-any) else fail-any)) in
        {232}let v_782: bitstring = catch-fail((if success?(3-proj-3-tuple(v_736)) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-3-tuple(v_779))))) then (if not-caught-fail(v_781) then (v_781,2-proj-3-tuple(v_779),3-proj-3-tuple(v_779)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {233}let v_783: key = catch-fail(dhexp(key_s(charlie),g)) in
        {234}let v_784: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_782),2-proj-7-tuple(v_735),3-proj-7-tuple(v_735),v_765,v_738,6-proj-7-tuple(v_735),7-proj-7-tuple(v_735))) in
        {235}let (hs_785: handshakestate,re_786: key,plaintext_b_787: bitstring,valid_788: bool) = (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-7-tuple(v_735))))) then (if (not-caught-fail(v_736) && success?(is-true(success?(1-proj-3-tuple(v_736))))) then (if not-caught-fail(v_737) then (if not-caught-fail(v_738) then (if not-caught-fail(v_740) then (if not-caught-fail(v_747) then (if not-caught-fail(v_754) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-3-tuple(v_764))))) then (if not-caught-fail(v_765) then (if not-caught-fail(v_772) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then (if ((3-proj-3-tuple(v_764) && 3-proj-3-tuple(v_782)) && (v_765 = getpublickey((if not-caught-fail(v_783) then keypairpack(v_783,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_784) then (v_784,getpublickey(3-proj-7-tuple(v_735)),2-proj-3-tuple(v_782),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {236}event RecvMsg(alice,charlie,stage_b,plaintext_b_787,valid_788);
        {237}insert statestore(alice,charlie,statepack_c(hs_785))
    ) | (
        {256}get statestore(=alice,=charlie,statepack_c(hs_789: handshakestate)) in
        {239}let v_790: bitstring = catch-fail(handshakestateunpack(hs_789)) in
        {240}let v_791: bitstring = catch-fail((empty,empty,empty)) in
        {241}let v_792: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_790))) in
        {242}let v_793: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_792))) in
        {243}let v_794: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_793),2-proj-2-tuple(v_793),3-proj-3-tuple(v_792),msg_c(alice,charlie))) in
        {244}let v_795: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_792))) in
        {245}let v_796: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_793))) && success?(1-proj-3-tuple(v_792))) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then cipherstatepack(1-proj-2-tuple(v_795),increment_nonce(2-proj-2-tuple(v_793))) else fail-any) else fail-any)) in
        {246}let v_797: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_792)) && success?(1-proj-3-tuple(v_792))) then (if (not-caught-fail(v_793) && success?(is-true(success?(1-proj-2-tuple(v_793))))) then (if not-caught-fail(v_794) then (if not-caught-fail(v_796) then (v_796,v_794) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {247}let v_798: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_797),2-proj-3-tuple(v_792),3-proj-3-tuple(v_792)))) in
        {248}let v_799: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_797)) && success?(symmetricstatepack(1-proj-2-tuple(v_797),2-proj-3-tuple(v_792),3-proj-3-tuple(v_792)))) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-3-tuple(v_798))))) then symmetricstatepack(1-proj-3-tuple(v_798),2-proj-3-tuple(v_798),hash(3-proj-3-tuple(v_798),2-proj-2-tuple(v_797))) else fail-any) else fail-any)) in
        {249}let v_800: bitstring = catch-fail((if success?(1-proj-7-tuple(v_790)) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-3-tuple(v_792))))) then (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-2-tuple(v_797))))) then (if not-caught-fail(v_799) then (v_799,2-proj-2-tuple(v_797)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {250}let v_801: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_800),2-proj-7-tuple(v_790),3-proj-7-tuple(v_790),4-proj-7-tuple(v_790),5-proj-7-tuple(v_790),6-proj-7-tuple(v_790),7-proj-7-tuple(v_790))) in
        {251}let v_802: bitstring = catch-fail(concat3(1-proj-3-tuple(v_791),2-proj-3-tuple(v_791),2-proj-2-tuple(v_800))) in
        {252}let (hs_803: handshakestate,re_804: key,message_c_805: bitstring) = (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-7-tuple(v_790))))) then (if (not-caught-fail(v_791) && success?(is-true(success?(1-proj-3-tuple(v_791))))) then (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-2-tuple(v_800))))) then (if not-caught-fail(v_801) then (if not-caught-fail(v_802) then (v_801,5-proj-7-tuple(v_790),v_802) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {253}event SendMsg(alice,charlie,stage_c,msg_c(alice,charlie),true);
        {254}insert statestore(alice,charlie,statepack_d(hs_803));
        {255}out(pub, message_c_805)
    ) | (
        {284}get statestore(=alice,=charlie,statepack_d(hs_806: handshakestate)) in
        {257}in(pub, message_d_807: bitstring);
        {258}let v_808: bitstring = catch-fail(handshakestateunpack(hs_806)) in
        {259}let v_809: bitstring = catch-fail(deconcat3(message_d_807)) in
        {260}let v_810: bool = catch-fail(true) in
        {261}let v_811: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_808))) in
        {262}let v_812: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_811))) in
        {263}let v_813: aead = catch-fail(decrypt(1-proj-2-tuple(v_812),2-proj-2-tuple(v_812),3-proj-3-tuple(v_811),3-proj-3-tuple(v_809))) in
        {264}let v_814: bitstring = catch-fail(aeadunpack(v_813)) in
        {265}let v_815: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_811))) in
        {266}let v_816: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_812))) && success?(1-proj-3-tuple(v_811))) then (if (not-caught-fail(v_815) && success?(is-true(success?(1-proj-2-tuple(v_815))))) then cipherstatepack(1-proj-2-tuple(v_815),increment_nonce(2-proj-2-tuple(v_812))) else fail-any) else fail-any)) in
        {267}let v_817: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_809)) && (success?(3-proj-3-tuple(v_811)) && success?(1-proj-3-tuple(v_811)))) then (if (not-caught-fail(v_812) && success?(is-true(success?(1-proj-2-tuple(v_812))))) then (if not-caught-fail(v_813) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-3-tuple(v_814))))) then (if not-caught-fail(v_816) then (v_816,3-proj-3-tuple(v_814),1-proj-3-tuple(v_814)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {268}let v_818: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_817),2-proj-3-tuple(v_811),3-proj-3-tuple(v_811)))) in
        {269}let v_819: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_809)) && success?(symmetricstatepack(1-proj-3-tuple(v_817),2-proj-3-tuple(v_811),3-proj-3-tuple(v_811)))) then (if (not-caught-fail(v_818) && success?(is-true(success?(1-proj-3-tuple(v_818))))) then symmetricstatepack(1-proj-3-tuple(v_818),2-proj-3-tuple(v_818),hash(3-proj-3-tuple(v_818),3-proj-3-tuple(v_809))) else fail-any) else fail-any)) in
        {270}let v_820: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_809)) && success?(1-proj-7-tuple(v_808))) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-3-tuple(v_811))))) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then (if not-caught-fail(v_819) then (v_819,2-proj-3-tuple(v_817),3-proj-3-tuple(v_817)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {271}let v_821: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_820),2-proj-7-tuple(v_808),3-proj-7-tuple(v_808),4-proj-7-tuple(v_808),5-proj-7-tuple(v_808),6-proj-7-tuple(v_808),7-proj-7-tuple(v_808))) in
        {272}let v_822: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_820))) in
        {273}let v_823: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_822),zero)) in
        {274}let v_824: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_822),zero)) in
        {275}let v_825: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_822),zero)) in
        {276}let v_826: bitstring = catch-fail((if success?(2-proj-3-tuple(v_822)) then (if not-caught-fail(v_823) then (if not-caught-fail(v_824) then (if not-caught-fail(v_825) then (v_823,v_824,v_825) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {277}let v_827: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_826)) then cipherstatepack(1-proj-3-tuple(v_826),minnonce) else fail-any)) in
        {278}let v_828: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_826)) then cipherstatepack(2-proj-3-tuple(v_826),minnonce) else fail-any)) in
        {279}let v_829: bitstring = catch-fail((if success?(1-proj-3-tuple(v_820)) then (if (not-caught-fail(v_822) && success?(is-true(success?(1-proj-3-tuple(v_822))))) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then (if not-caught-fail(v_827) then (if not-caught-fail(v_828) then (1-proj-3-tuple(v_820),v_827,v_828) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {280}let (hs_830: handshakestate,re_831: key,plaintext_d_832: bitstring,valid_833: bool,cs1_834: cipherstate,cs2_835: cipherstate) = (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-7-tuple(v_808))))) then (if (not-caught-fail(v_809) && success?(is-true(success?(1-proj-3-tuple(v_809))))) then (if not-caught-fail(v_810) then (if (not-caught-fail(v_820) && success?(is-true(success?(1-proj-3-tuple(v_820))))) then (if (v_810 && 3-proj-3-tuple(v_820)) then (if not-caught-fail(v_821) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then (v_821,getpublickey(3-proj-7-tuple(v_808)),2-proj-3-tuple(v_820),true,2-proj-3-tuple(v_829),3-proj-3-tuple(v_829)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {281}event RecvMsg(alice,charlie,stage_d,plaintext_d_832,valid_833);
        {282}insert statestore(alice,charlie,statepack_e(hs_830));
        {283}event RecvEnd(valid_833)
    ) | (
        {285}event LeakS(phase0,alice);
        {286}out(pub, key_s(alice))
    ) | (
        {287}phase 1;
        {288}event LeakS(phase1,alice);
        {289}out(pub, key_s(alice))
    )
) | (
    {290}let s_836: keypair = keypairpack(empty,empty) in
    {291}out(pub, getpublickey(s_836));
    (
        {292}let e_837: keypair = keypairpack(empty,empty) in
        {293}let v_838: key = catch-fail(dhexp(key_s(alice),g)) in
        {294}let rs_839: key = getpublickey((if not-caught-fail(v_838) then keypairpack(v_838,key_s(alice)) else fail-any)) in
        {295}let re_840: key = empty in
        {296}let v_841: bitstring = catch-fail(hash(somename,empty)) in
        {297}let v_842: key = catch-fail(v_841) in
        {298}let v_843: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {299}let v_844: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (if not-caught-fail(v_843) then symmetricstatepack(v_843,v_842,v_841) else fail-any) else fail-any) else fail-any))) in
        {300}let v_845: symmetricstate = catch-fail((if success?((if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (if not-caught-fail(v_843) then symmetricstatepack(v_843,v_842,v_841) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-3-tuple(v_844))))) then symmetricstatepack(1-proj-3-tuple(v_844),2-proj-3-tuple(v_844),hash(3-proj-3-tuple(v_844),empty)) else fail-any) else fail-any)) in
        {301}let v_846: bitstring = catch-fail(symmetricstateunpack(v_845)) in
        {302}let v_847: symmetricstate = catch-fail((if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-3-tuple(v_846))))) then symmetricstatepack(1-proj-3-tuple(v_846),2-proj-3-tuple(v_846),hash(3-proj-3-tuple(v_846),rs_839)) else fail-any)) in
        {303}let hs_848: handshakestate = (if not-caught-fail(v_845) then (if not-caught-fail(v_847) then handshakestatepack(v_847,s_836,e_837,rs_839,re_840,empty,false) else fail-any) else fail-any) in
        {304}insert statestore(bob,alice,statepack_a(hs_848))
    ) | (
        {326}get statestore(=bob,=alice,statepack_a(hs_849: handshakestate)) in
        {305}in(pub, message_a_850: bitstring);
        {306}let v_851: bitstring = catch-fail(handshakestateunpack(hs_849)) in
        {307}let v_852: bitstring = catch-fail(deconcat3(message_a_850)) in
        {308}let v_853: bool = catch-fail(true) in
        {309}let v_854: key = catch-fail(1-proj-3-tuple(v_852)) in
        {310}let v_855: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_851))) in
        {311}let v_856: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_851)) then (if (not-caught-fail(v_855) && success?(is-true(success?(1-proj-3-tuple(v_855))))) then symmetricstatepack(1-proj-3-tuple(v_855),2-proj-3-tuple(v_855),hash(3-proj-3-tuple(v_855),v_854)) else fail-any) else fail-any)) in
        {312}let v_857: bitstring = catch-fail(symmetricstateunpack(v_856)) in
        {313}let v_858: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_857))) in
        {314}let v_859: aead = catch-fail(decrypt(1-proj-2-tuple(v_858),2-proj-2-tuple(v_858),3-proj-3-tuple(v_857),3-proj-3-tuple(v_852))) in
        {315}let v_860: bitstring = catch-fail(aeadunpack(v_859)) in
        {316}let v_861: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_857))) in
        {317}let v_862: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_858))) && success?(1-proj-3-tuple(v_857))) then (if (not-caught-fail(v_861) && success?(is-true(success?(1-proj-2-tuple(v_861))))) then cipherstatepack(1-proj-2-tuple(v_861),increment_nonce(2-proj-2-tuple(v_858))) else fail-any) else fail-any)) in
        {318}let v_863: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_852)) && (success?(3-proj-3-tuple(v_857)) && success?(1-proj-3-tuple(v_857)))) then (if (not-caught-fail(v_858) && success?(is-true(success?(1-proj-2-tuple(v_858))))) then (if not-caught-fail(v_859) then (if (not-caught-fail(v_860) && success?(is-true(success?(1-proj-3-tuple(v_860))))) then (if not-caught-fail(v_862) then (v_862,3-proj-3-tuple(v_860),1-proj-3-tuple(v_860)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {319}let v_864: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_863),2-proj-3-tuple(v_857),3-proj-3-tuple(v_857)))) in
        {320}let v_865: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_852)) && success?(symmetricstatepack(1-proj-3-tuple(v_863),2-proj-3-tuple(v_857),3-proj-3-tuple(v_857)))) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-3-tuple(v_864))))) then symmetricstatepack(1-proj-3-tuple(v_864),2-proj-3-tuple(v_864),hash(3-proj-3-tuple(v_864),3-proj-3-tuple(v_852))) else fail-any) else fail-any)) in
        {321}let v_866: bitstring = catch-fail((if success?(3-proj-3-tuple(v_852)) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-3-tuple(v_863))))) then (if not-caught-fail(v_865) then (v_865,2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {322}let v_867: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_866),2-proj-7-tuple(v_851),3-proj-7-tuple(v_851),4-proj-7-tuple(v_851),v_854,6-proj-7-tuple(v_851),7-proj-7-tuple(v_851))) in
        {323}let (hs_868: handshakestate,re_869: key,plaintext_a: bitstring,valid_870: bool) = (if (not-caught-fail(v_851) && success?(is-true(success?(1-proj-7-tuple(v_851))))) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-3-tuple(v_852))))) then (if not-caught-fail(v_853) then (if not-caught-fail(v_854) then (if not-caught-fail(v_856) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then (if (v_853 && 3-proj-3-tuple(v_866)) then (if not-caught-fail(v_867) then (v_867,getpublickey(3-proj-7-tuple(v_851)),2-proj-3-tuple(v_866),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {324}event RecvMsg(bob,alice,stage_a,plaintext_a,valid_870);
        {325}insert statestore(bob,alice,statepack_b(hs_868))
    ) | (
        {381}get statestore(=bob,=alice,statepack_b(hs_871: handshakestate)) in
        {327}let v_872: bitstring = catch-fail(handshakestateunpack(hs_871)) in
        {328}let v_873: bitstring = catch-fail((empty,empty,empty)) in
        {329}let v_874: key = catch-fail(dhexp(key_e(bob,alice),g)) in
        {330}let v_875: keypair = catch-fail((if not-caught-fail(v_874) then keypairpack(v_874,key_e(bob,alice)) else fail-any)) in
        {331}let v_876: bitstring = catch-fail(getpublickey(v_875)) in
        {332}let v_877: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_872))) in
        {333}let v_878: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_872)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-3-tuple(v_877))))) then symmetricstatepack(1-proj-3-tuple(v_877),2-proj-3-tuple(v_877),hash(3-proj-3-tuple(v_877),v_876)) else fail-any) else fail-any)) in
        {334}let v_879: bitstring = catch-fail(keypairunpack(v_875)) in
        {335}let v_880: bitstring = catch-fail(symmetricstateunpack(v_878)) in
        {336}let v_881: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_880),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-2-tuple(v_879))))) then dhexp(2-proj-2-tuple(v_879),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {337}let v_882: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_880),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-2-tuple(v_879))))) then dhexp(2-proj-2-tuple(v_879),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {338}let v_883: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_880),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-2-tuple(v_879))))) then dhexp(2-proj-2-tuple(v_879),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {339}let v_884: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-2-tuple(v_879))))) then dhexp(2-proj-2-tuple(v_879),5-proj-7-tuple(v_872)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_880))) then (if not-caught-fail(v_881) then (if not-caught-fail(v_882) then (if not-caught-fail(v_883) then (v_881,v_882,v_883) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {340}let v_885: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-2-tuple(v_879))))) then dhexp(2-proj-2-tuple(v_879),5-proj-7-tuple(v_872)) else fail-any) else fail-any)) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-3-tuple(v_880))))) then (if (not-caught-fail(v_884) && success?(is-true(success?(1-proj-3-tuple(v_884))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_884)) then cipherstatepack(2-proj-3-tuple(v_884),minnonce) else fail-any),1-proj-3-tuple(v_884),3-proj-3-tuple(v_880)) else fail-any) else fail-any) else fail-any)) in
        {341}let v_886: bitstring = catch-fail(keypairunpack(v_875)) in
        {342}let v_887: bitstring = catch-fail(symmetricstateunpack(v_885)) in
        {343}let v_888: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_887),(if success?(4-proj-7-tuple(v_872)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-2-tuple(v_886))))) then dhexp(2-proj-2-tuple(v_886),4-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {344}let v_889: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_887),(if success?(4-proj-7-tuple(v_872)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-2-tuple(v_886))))) then dhexp(2-proj-2-tuple(v_886),4-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {345}let v_890: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_887),(if success?(4-proj-7-tuple(v_872)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-2-tuple(v_886))))) then dhexp(2-proj-2-tuple(v_886),4-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {346}let v_891: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_872)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-2-tuple(v_886))))) then dhexp(2-proj-2-tuple(v_886),4-proj-7-tuple(v_872)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_887))) then (if not-caught-fail(v_888) then (if not-caught-fail(v_889) then (if not-caught-fail(v_890) then (v_888,v_889,v_890) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {347}let v_892: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_872)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-2-tuple(v_886))))) then dhexp(2-proj-2-tuple(v_886),4-proj-7-tuple(v_872)) else fail-any) else fail-any)) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-3-tuple(v_887))))) then (if (not-caught-fail(v_891) && success?(is-true(success?(1-proj-3-tuple(v_891))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_891)) then cipherstatepack(2-proj-3-tuple(v_891),minnonce) else fail-any),1-proj-3-tuple(v_891),3-proj-3-tuple(v_887)) else fail-any) else fail-any) else fail-any)) in
        {348}let v_893: key = catch-fail(dhexp(key_s(bob),g)) in
        {349}let v_894: keypair = catch-fail((if not-caught-fail(v_893) then keypairpack(v_893,key_s(bob)) else fail-any)) in
        {350}let v_895: bitstring = catch-fail(symmetricstateunpack(v_892)) in
        {351}let v_896: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_895))) in
        {352}let v_897: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_896),2-proj-2-tuple(v_896),3-proj-3-tuple(v_895),getpublickey(v_894))) in
        {353}let v_898: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_895))) in
        {354}let v_899: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_896))) && success?(1-proj-3-tuple(v_895))) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-2-tuple(v_898))))) then cipherstatepack(1-proj-2-tuple(v_898),increment_nonce(2-proj-2-tuple(v_896))) else fail-any) else fail-any)) in
        {355}let v_900: bitstring = catch-fail((if (success?(getpublickey(v_894)) && (success?(3-proj-3-tuple(v_895)) && success?(1-proj-3-tuple(v_895)))) then (if (not-caught-fail(v_896) && success?(is-true(success?(1-proj-2-tuple(v_896))))) then (if not-caught-fail(v_897) then (if not-caught-fail(v_899) then (v_899,v_897) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {356}let v_901: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_900),2-proj-3-tuple(v_895),3-proj-3-tuple(v_895)))) in
        {357}let v_902: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_900)) && success?(symmetricstatepack(1-proj-2-tuple(v_900),2-proj-3-tuple(v_895),3-proj-3-tuple(v_895)))) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-3-tuple(v_901))))) then symmetricstatepack(1-proj-3-tuple(v_901),2-proj-3-tuple(v_901),hash(3-proj-3-tuple(v_901),2-proj-2-tuple(v_900))) else fail-any) else fail-any)) in
        {358}let v_903: bitstring = catch-fail((if success?(getpublickey(v_894)) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-3-tuple(v_895))))) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then (if not-caught-fail(v_902) then (v_902,2-proj-2-tuple(v_900)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {359}let v_904: bitstring = catch-fail(keypairunpack(v_894)) in
        {360}let v_905: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_903))) in
        {361}let v_906: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_905),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then dhexp(2-proj-2-tuple(v_904),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {362}let v_907: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_905),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then dhexp(2-proj-2-tuple(v_904),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {363}let v_908: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_905),(if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then dhexp(2-proj-2-tuple(v_904),5-proj-7-tuple(v_872)) else fail-any) else fail-any))) in
        {364}let v_909: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then dhexp(2-proj-2-tuple(v_904),5-proj-7-tuple(v_872)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_905))) then (if not-caught-fail(v_906) then (if not-caught-fail(v_907) then (if not-caught-fail(v_908) then (v_906,v_907,v_908) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {365}let v_910: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_872)) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then dhexp(2-proj-2-tuple(v_904),5-proj-7-tuple(v_872)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_903))) then (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-3-tuple(v_905))))) then (if (not-caught-fail(v_909) && success?(is-true(success?(1-proj-3-tuple(v_909))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_909)) then cipherstatepack(2-proj-3-tuple(v_909),minnonce) else fail-any),1-proj-3-tuple(v_909),3-proj-3-tuple(v_905)) else fail-any) else fail-any) else fail-any)) in
        {366}let v_911: bitstring = catch-fail(symmetricstateunpack(v_910)) in
        {367}let v_912: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_911))) in
        {368}let v_913: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_912),2-proj-2-tuple(v_912),3-proj-3-tuple(v_911),msg_b(bob,alice))) in
        {369}let v_914: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_911))) in
        {370}let v_915: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_912))) && success?(1-proj-3-tuple(v_911))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-2-tuple(v_914))))) then cipherstatepack(1-proj-2-tuple(v_914),increment_nonce(2-proj-2-tuple(v_912))) else fail-any) else fail-any)) in
        {371}let v_916: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_911)) && success?(1-proj-3-tuple(v_911))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-2-tuple(v_912))))) then (if not-caught-fail(v_913) then (if not-caught-fail(v_915) then (v_915,v_913) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {372}let v_917: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_916),2-proj-3-tuple(v_911),3-proj-3-tuple(v_911)))) in
        {373}let v_918: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_916)) && success?(symmetricstatepack(1-proj-2-tuple(v_916),2-proj-3-tuple(v_911),3-proj-3-tuple(v_911)))) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then symmetricstatepack(1-proj-3-tuple(v_917),2-proj-3-tuple(v_917),hash(3-proj-3-tuple(v_917),2-proj-2-tuple(v_916))) else fail-any) else fail-any)) in
        {374}let v_919: bitstring = catch-fail((if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-2-tuple(v_916))))) then (if not-caught-fail(v_918) then (v_918,2-proj-2-tuple(v_916)) else fail-any) else fail-any) else fail-any)) in
        {375}let v_920: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_919),v_894,v_875,4-proj-7-tuple(v_872),5-proj-7-tuple(v_872),6-proj-7-tuple(v_872),7-proj-7-tuple(v_872))) in
        {376}let v_921: bitstring = catch-fail(concat3(v_876,2-proj-2-tuple(v_903),2-proj-2-tuple(v_919))) in
        {377}let (hs_922: handshakestate,re_923: key,message_b_924: bitstring) = (if (not-caught-fail(v_872) && success?(is-true(success?(1-proj-7-tuple(v_872))))) then (if (not-caught-fail(v_873) && success?(is-true(success?(1-proj-3-tuple(v_873))))) then (if not-caught-fail(v_875) then (if not-caught-fail(v_876) then (if not-caught-fail(v_878) then (if not-caught-fail(v_885) then (if not-caught-fail(v_892) then (if not-caught-fail(v_894) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then (if not-caught-fail(v_910) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then (if not-caught-fail(v_920) then (if not-caught-fail(v_921) then (v_920,5-proj-7-tuple(v_872),v_921) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {378}event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true);
        {379}insert statestore(bob,alice,statepack_c(hs_922));
        {380}out(pub, message_b_924)
    ) | (
        {400}get statestore(=bob,=alice,statepack_c(hs_925: handshakestate)) in
        {382}in(pub, message_c_926: bitstring);
        {383}let v_927: bitstring = catch-fail(handshakestateunpack(hs_925)) in
        {384}let v_928: bitstring = catch-fail(deconcat3(message_c_926)) in
        {385}let v_929: bool = catch-fail(true) in
        {386}let v_930: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_927))) in
        {387}let v_931: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_930))) in
        {388}let v_932: aead = catch-fail(decrypt(1-proj-2-tuple(v_931),2-proj-2-tuple(v_931),3-proj-3-tuple(v_930),3-proj-3-tuple(v_928))) in
        {389}let v_933: bitstring = catch-fail(aeadunpack(v_932)) in
        {390}let v_934: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_930))) in
        {391}let v_935: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_931))) && success?(1-proj-3-tuple(v_930))) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-2-tuple(v_934))))) then cipherstatepack(1-proj-2-tuple(v_934),increment_nonce(2-proj-2-tuple(v_931))) else fail-any) else fail-any)) in
        {392}let v_936: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_928)) && (success?(3-proj-3-tuple(v_930)) && success?(1-proj-3-tuple(v_930)))) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then (if not-caught-fail(v_932) then (if (not-caught-fail(v_933) && success?(is-true(success?(1-proj-3-tuple(v_933))))) then (if not-caught-fail(v_935) then (v_935,3-proj-3-tuple(v_933),1-proj-3-tuple(v_933)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {393}let v_937: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_930),3-proj-3-tuple(v_930)))) in
        {394}let v_938: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_928)) && success?(symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_930),3-proj-3-tuple(v_930)))) then (if (not-caught-fail(v_937) && success?(is-true(success?(1-proj-3-tuple(v_937))))) then symmetricstatepack(1-proj-3-tuple(v_937),2-proj-3-tuple(v_937),hash(3-proj-3-tuple(v_937),3-proj-3-tuple(v_928))) else fail-any) else fail-any)) in
        {395}let v_939: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_928)) && success?(1-proj-7-tuple(v_927))) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-3-tuple(v_930))))) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then (if not-caught-fail(v_938) then (v_938,2-proj-3-tuple(v_936),3-proj-3-tuple(v_936)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {396}let v_940: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_939),2-proj-7-tuple(v_927),3-proj-7-tuple(v_927),4-proj-7-tuple(v_927),5-proj-7-tuple(v_927),6-proj-7-tuple(v_927),7-proj-7-tuple(v_927))) in
        {397}let (hs_941: handshakestate,re_942: key,plaintext_c: bitstring,valid_943: bool) = (if (not-caught-fail(v_927) && success?(is-true(success?(1-proj-7-tuple(v_927))))) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then (if not-caught-fail(v_929) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-3-tuple(v_939))))) then (if (v_929 && 3-proj-3-tuple(v_939)) then (if not-caught-fail(v_940) then (v_940,getpublickey(3-proj-7-tuple(v_927)),2-proj-3-tuple(v_939),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {398}event RecvMsg(bob,alice,stage_c,plaintext_c,valid_943);
        {399}insert statestore(bob,alice,statepack_d(hs_941))
    ) | (
        {426}get statestore(=bob,=alice,statepack_d(hs_944: handshakestate)) in
        {401}let v_945: bitstring = catch-fail(handshakestateunpack(hs_944)) in
        {402}let v_946: bitstring = catch-fail((empty,empty,empty)) in
        {403}let v_947: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_945))) in
        {404}let v_948: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_947))) in
        {405}let v_949: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_948),2-proj-2-tuple(v_948),3-proj-3-tuple(v_947),msg_d(bob,alice))) in
        {406}let v_950: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_947))) in
        {407}let v_951: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_948))) && success?(1-proj-3-tuple(v_947))) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-2-tuple(v_950))))) then cipherstatepack(1-proj-2-tuple(v_950),increment_nonce(2-proj-2-tuple(v_948))) else fail-any) else fail-any)) in
        {408}let v_952: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_947)) && success?(1-proj-3-tuple(v_947))) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then (if not-caught-fail(v_949) then (if not-caught-fail(v_951) then (v_951,v_949) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {409}let v_953: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_952),2-proj-3-tuple(v_947),3-proj-3-tuple(v_947)))) in
        {410}let v_954: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_952)) && success?(symmetricstatepack(1-proj-2-tuple(v_952),2-proj-3-tuple(v_947),3-proj-3-tuple(v_947)))) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-3-tuple(v_953))))) then symmetricstatepack(1-proj-3-tuple(v_953),2-proj-3-tuple(v_953),hash(3-proj-3-tuple(v_953),2-proj-2-tuple(v_952))) else fail-any) else fail-any)) in
        {411}let v_955: bitstring = catch-fail((if success?(1-proj-7-tuple(v_945)) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then (if (not-caught-fail(v_952) && success?(is-true(success?(1-proj-2-tuple(v_952))))) then (if not-caught-fail(v_954) then (v_954,2-proj-2-tuple(v_952)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {412}let v_956: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_955),2-proj-7-tuple(v_945),3-proj-7-tuple(v_945),4-proj-7-tuple(v_945),5-proj-7-tuple(v_945),6-proj-7-tuple(v_945),7-proj-7-tuple(v_945))) in
        {413}let v_957: bitstring = catch-fail(concat3(1-proj-3-tuple(v_946),2-proj-3-tuple(v_946),2-proj-2-tuple(v_955))) in
        {414}let v_958: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_955))) in
        {415}let v_959: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_958),zero)) in
        {416}let v_960: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_958),zero)) in
        {417}let v_961: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_958),zero)) in
        {418}let v_962: bitstring = catch-fail((if success?(2-proj-3-tuple(v_958)) then (if not-caught-fail(v_959) then (if not-caught-fail(v_960) then (if not-caught-fail(v_961) then (v_959,v_960,v_961) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {419}let v_963: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_962)) then cipherstatepack(1-proj-3-tuple(v_962),minnonce) else fail-any)) in
        {420}let v_964: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_962)) then cipherstatepack(2-proj-3-tuple(v_962),minnonce) else fail-any)) in
        {421}let v_965: bitstring = catch-fail((if success?(1-proj-2-tuple(v_955)) then (if (not-caught-fail(v_958) && success?(is-true(success?(1-proj-3-tuple(v_958))))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then (if not-caught-fail(v_963) then (if not-caught-fail(v_964) then (1-proj-2-tuple(v_955),v_963,v_964) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {422}let (hs_966: handshakestate,re_967: key,message_d_968: bitstring,cs1_969: cipherstate,cs2_970: cipherstate) = (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-7-tuple(v_945))))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-3-tuple(v_946))))) then (if (not-caught-fail(v_955) && success?(is-true(success?(1-proj-2-tuple(v_955))))) then (if not-caught-fail(v_956) then (if not-caught-fail(v_957) then (if (not-caught-fail(v_965) && success?(is-true(success?(1-proj-3-tuple(v_965))))) then (v_956,5-proj-7-tuple(v_945),v_957,2-proj-3-tuple(v_965),3-proj-3-tuple(v_965)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {423}event SendMsg(bob,alice,stage_d,msg_d(bob,alice),true);
        {424}insert statestore(bob,alice,statepack_e(hs_966));
        {425}out(pub, message_d_968)
    ) | (
        {427}event LeakS(phase0,bob);
        {428}out(pub, key_s(bob))
    ) | (
        {429}phase 1;
        {430}event LeakS(phase1,bob);
        {431}out(pub, key_s(bob))
    )
) | (
    {432}let s_971: keypair = keypairpack(empty,empty) in
    {433}out(pub, getpublickey(s_971));
    (
        {434}let e_972: keypair = keypairpack(empty,empty) in
        {435}let v_973: key = catch-fail(dhexp(key_s(charlie),g)) in
        {436}let rs_974: key = getpublickey((if not-caught-fail(v_973) then keypairpack(v_973,key_s(charlie)) else fail-any)) in
        {437}let re_975: key = empty in
        {438}let v_976: bitstring = catch-fail(hash(somename,empty)) in
        {439}let v_977: key = catch-fail(v_976) in
        {440}let v_978: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {441}let v_979: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_976) then (if not-caught-fail(v_977) then (if not-caught-fail(v_978) then symmetricstatepack(v_978,v_977,v_976) else fail-any) else fail-any) else fail-any))) in
        {442}let v_980: symmetricstate = catch-fail((if success?((if not-caught-fail(v_976) then (if not-caught-fail(v_977) then (if not-caught-fail(v_978) then symmetricstatepack(v_978,v_977,v_976) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_979) && success?(is-true(success?(1-proj-3-tuple(v_979))))) then symmetricstatepack(1-proj-3-tuple(v_979),2-proj-3-tuple(v_979),hash(3-proj-3-tuple(v_979),empty)) else fail-any) else fail-any)) in
        {443}let v_981: bitstring = catch-fail(symmetricstateunpack(v_980)) in
        {444}let v_982: symmetricstate = catch-fail((if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then symmetricstatepack(1-proj-3-tuple(v_981),2-proj-3-tuple(v_981),hash(3-proj-3-tuple(v_981),rs_974)) else fail-any)) in
        {445}let hs_983: handshakestate = (if not-caught-fail(v_980) then (if not-caught-fail(v_982) then handshakestatepack(v_982,s_971,e_972,rs_974,re_975,empty,false) else fail-any) else fail-any) in
        {446}insert statestore(bob,charlie,statepack_a(hs_983))
    ) | (
        {468}get statestore(=bob,=charlie,statepack_a(hs_984: handshakestate)) in
        {447}in(pub, message_a_985: bitstring);
        {448}let v_986: bitstring = catch-fail(handshakestateunpack(hs_984)) in
        {449}let v_987: bitstring = catch-fail(deconcat3(message_a_985)) in
        {450}let v_988: bool = catch-fail(true) in
        {451}let v_989: key = catch-fail(1-proj-3-tuple(v_987)) in
        {452}let v_990: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_986))) in
        {453}let v_991: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_986)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-3-tuple(v_990))))) then symmetricstatepack(1-proj-3-tuple(v_990),2-proj-3-tuple(v_990),hash(3-proj-3-tuple(v_990),v_989)) else fail-any) else fail-any)) in
        {454}let v_992: bitstring = catch-fail(symmetricstateunpack(v_991)) in
        {455}let v_993: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_992))) in
        {456}let v_994: aead = catch-fail(decrypt(1-proj-2-tuple(v_993),2-proj-2-tuple(v_993),3-proj-3-tuple(v_992),3-proj-3-tuple(v_987))) in
        {457}let v_995: bitstring = catch-fail(aeadunpack(v_994)) in
        {458}let v_996: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_992))) in
        {459}let v_997: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_993))) && success?(1-proj-3-tuple(v_992))) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then cipherstatepack(1-proj-2-tuple(v_996),increment_nonce(2-proj-2-tuple(v_993))) else fail-any) else fail-any)) in
        {460}let v_998: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_987)) && (success?(3-proj-3-tuple(v_992)) && success?(1-proj-3-tuple(v_992)))) then (if (not-caught-fail(v_993) && success?(is-true(success?(1-proj-2-tuple(v_993))))) then (if not-caught-fail(v_994) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then (if not-caught-fail(v_997) then (v_997,3-proj-3-tuple(v_995),1-proj-3-tuple(v_995)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {461}let v_999: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_998),2-proj-3-tuple(v_992),3-proj-3-tuple(v_992)))) in
        {462}let v_1000: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_987)) && success?(symmetricstatepack(1-proj-3-tuple(v_998),2-proj-3-tuple(v_992),3-proj-3-tuple(v_992)))) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then symmetricstatepack(1-proj-3-tuple(v_999),2-proj-3-tuple(v_999),hash(3-proj-3-tuple(v_999),3-proj-3-tuple(v_987))) else fail-any) else fail-any)) in
        {463}let v_1001: bitstring = catch-fail((if success?(3-proj-3-tuple(v_987)) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-3-tuple(v_992))))) then (if (not-caught-fail(v_998) && success?(is-true(success?(1-proj-3-tuple(v_998))))) then (if not-caught-fail(v_1000) then (v_1000,2-proj-3-tuple(v_998),3-proj-3-tuple(v_998)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {464}let v_1002: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1001),2-proj-7-tuple(v_986),3-proj-7-tuple(v_986),4-proj-7-tuple(v_986),v_989,6-proj-7-tuple(v_986),7-proj-7-tuple(v_986))) in
        {465}let (hs_1003: handshakestate,re_1004: key,plaintext_a_1005: bitstring,valid_1006: bool) = (if (not-caught-fail(v_986) && success?(is-true(success?(1-proj-7-tuple(v_986))))) then (if (not-caught-fail(v_987) && success?(is-true(success?(1-proj-3-tuple(v_987))))) then (if not-caught-fail(v_988) then (if not-caught-fail(v_989) then (if not-caught-fail(v_991) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-3-tuple(v_1001))))) then (if (v_988 && 3-proj-3-tuple(v_1001)) then (if not-caught-fail(v_1002) then (v_1002,getpublickey(3-proj-7-tuple(v_986)),2-proj-3-tuple(v_1001),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {466}event RecvMsg(bob,charlie,stage_a,plaintext_a_1005,valid_1006);
        {467}insert statestore(bob,charlie,statepack_b(hs_1003))
    ) | (
        {523}get statestore(=bob,=charlie,statepack_b(hs_1007: handshakestate)) in
        {469}let v_1008: bitstring = catch-fail(handshakestateunpack(hs_1007)) in
        {470}let v_1009: bitstring = catch-fail((empty,empty,empty)) in
        {471}let v_1010: key = catch-fail(dhexp(key_e(bob,charlie),g)) in
        {472}let v_1011: keypair = catch-fail((if not-caught-fail(v_1010) then keypairpack(v_1010,key_e(bob,charlie)) else fail-any)) in
        {473}let v_1012: bitstring = catch-fail(getpublickey(v_1011)) in
        {474}let v_1013: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1008))) in
        {475}let v_1014: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1013) && success?(is-true(success?(1-proj-3-tuple(v_1013))))) then symmetricstatepack(1-proj-3-tuple(v_1013),2-proj-3-tuple(v_1013),hash(3-proj-3-tuple(v_1013),v_1012)) else fail-any) else fail-any)) in
        {476}let v_1015: bitstring = catch-fail(keypairunpack(v_1011)) in
        {477}let v_1016: bitstring = catch-fail(symmetricstateunpack(v_1014)) in
        {478}let v_1017: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1016),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-2-tuple(v_1015))))) then dhexp(2-proj-2-tuple(v_1015),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {479}let v_1018: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1016),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-2-tuple(v_1015))))) then dhexp(2-proj-2-tuple(v_1015),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {480}let v_1019: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1016),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-2-tuple(v_1015))))) then dhexp(2-proj-2-tuple(v_1015),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {481}let v_1020: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-2-tuple(v_1015))))) then dhexp(2-proj-2-tuple(v_1015),5-proj-7-tuple(v_1008)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1016))) then (if not-caught-fail(v_1017) then (if not-caught-fail(v_1018) then (if not-caught-fail(v_1019) then (v_1017,v_1018,v_1019) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {482}let v_1021: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-2-tuple(v_1015))))) then dhexp(2-proj-2-tuple(v_1015),5-proj-7-tuple(v_1008)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-3-tuple(v_1016))))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1020)) then cipherstatepack(2-proj-3-tuple(v_1020),minnonce) else fail-any),1-proj-3-tuple(v_1020),3-proj-3-tuple(v_1016)) else fail-any) else fail-any) else fail-any)) in
        {483}let v_1022: bitstring = catch-fail(keypairunpack(v_1011)) in
        {484}let v_1023: bitstring = catch-fail(symmetricstateunpack(v_1021)) in
        {485}let v_1024: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1023),(if success?(4-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),4-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {486}let v_1025: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1023),(if success?(4-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),4-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {487}let v_1026: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1023),(if success?(4-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),4-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {488}let v_1027: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),4-proj-7-tuple(v_1008)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1023))) then (if not-caught-fail(v_1024) then (if not-caught-fail(v_1025) then (if not-caught-fail(v_1026) then (v_1024,v_1025,v_1026) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {489}let v_1028: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-2-tuple(v_1022))))) then dhexp(2-proj-2-tuple(v_1022),4-proj-7-tuple(v_1008)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-3-tuple(v_1023))))) then (if (not-caught-fail(v_1027) && success?(is-true(success?(1-proj-3-tuple(v_1027))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1027)) then cipherstatepack(2-proj-3-tuple(v_1027),minnonce) else fail-any),1-proj-3-tuple(v_1027),3-proj-3-tuple(v_1023)) else fail-any) else fail-any) else fail-any)) in
        {490}let v_1029: key = catch-fail(dhexp(key_s(bob),g)) in
        {491}let v_1030: keypair = catch-fail((if not-caught-fail(v_1029) then keypairpack(v_1029,key_s(bob)) else fail-any)) in
        {492}let v_1031: bitstring = catch-fail(symmetricstateunpack(v_1028)) in
        {493}let v_1032: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1031))) in
        {494}let v_1033: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1032),2-proj-2-tuple(v_1032),3-proj-3-tuple(v_1031),getpublickey(v_1030))) in
        {495}let v_1034: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1031))) in
        {496}let v_1035: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1032))) && success?(1-proj-3-tuple(v_1031))) then (if (not-caught-fail(v_1034) && success?(is-true(success?(1-proj-2-tuple(v_1034))))) then cipherstatepack(1-proj-2-tuple(v_1034),increment_nonce(2-proj-2-tuple(v_1032))) else fail-any) else fail-any)) in
        {497}let v_1036: bitstring = catch-fail((if (success?(getpublickey(v_1030)) && (success?(3-proj-3-tuple(v_1031)) && success?(1-proj-3-tuple(v_1031)))) then (if (not-caught-fail(v_1032) && success?(is-true(success?(1-proj-2-tuple(v_1032))))) then (if not-caught-fail(v_1033) then (if not-caught-fail(v_1035) then (v_1035,v_1033) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {498}let v_1037: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1036),2-proj-3-tuple(v_1031),3-proj-3-tuple(v_1031)))) in
        {499}let v_1038: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1036)) && success?(symmetricstatepack(1-proj-2-tuple(v_1036),2-proj-3-tuple(v_1031),3-proj-3-tuple(v_1031)))) then (if (not-caught-fail(v_1037) && success?(is-true(success?(1-proj-3-tuple(v_1037))))) then symmetricstatepack(1-proj-3-tuple(v_1037),2-proj-3-tuple(v_1037),hash(3-proj-3-tuple(v_1037),2-proj-2-tuple(v_1036))) else fail-any) else fail-any)) in
        {500}let v_1039: bitstring = catch-fail((if success?(getpublickey(v_1030)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-3-tuple(v_1031))))) then (if (not-caught-fail(v_1036) && success?(is-true(success?(1-proj-2-tuple(v_1036))))) then (if not-caught-fail(v_1038) then (v_1038,2-proj-2-tuple(v_1036)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {501}let v_1040: bitstring = catch-fail(keypairunpack(v_1030)) in
        {502}let v_1041: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1039))) in
        {503}let v_1042: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1041),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then dhexp(2-proj-2-tuple(v_1040),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {504}let v_1043: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1041),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then dhexp(2-proj-2-tuple(v_1040),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {505}let v_1044: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1041),(if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then dhexp(2-proj-2-tuple(v_1040),5-proj-7-tuple(v_1008)) else fail-any) else fail-any))) in
        {506}let v_1045: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then dhexp(2-proj-2-tuple(v_1040),5-proj-7-tuple(v_1008)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1041))) then (if not-caught-fail(v_1042) then (if not-caught-fail(v_1043) then (if not-caught-fail(v_1044) then (v_1042,v_1043,v_1044) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {507}let v_1046: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1008)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then dhexp(2-proj-2-tuple(v_1040),5-proj-7-tuple(v_1008)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_1039))) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-3-tuple(v_1041))))) then (if (not-caught-fail(v_1045) && success?(is-true(success?(1-proj-3-tuple(v_1045))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1045)) then cipherstatepack(2-proj-3-tuple(v_1045),minnonce) else fail-any),1-proj-3-tuple(v_1045),3-proj-3-tuple(v_1041)) else fail-any) else fail-any) else fail-any)) in
        {508}let v_1047: bitstring = catch-fail(symmetricstateunpack(v_1046)) in
        {509}let v_1048: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1047))) in
        {510}let v_1049: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1048),2-proj-2-tuple(v_1048),3-proj-3-tuple(v_1047),msg_b(bob,charlie))) in
        {511}let v_1050: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1047))) in
        {512}let v_1051: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1048))) && success?(1-proj-3-tuple(v_1047))) then (if (not-caught-fail(v_1050) && success?(is-true(success?(1-proj-2-tuple(v_1050))))) then cipherstatepack(1-proj-2-tuple(v_1050),increment_nonce(2-proj-2-tuple(v_1048))) else fail-any) else fail-any)) in
        {513}let v_1052: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1047)) && success?(1-proj-3-tuple(v_1047))) then (if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-2-tuple(v_1048))))) then (if not-caught-fail(v_1049) then (if not-caught-fail(v_1051) then (v_1051,v_1049) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {514}let v_1053: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1052),2-proj-3-tuple(v_1047),3-proj-3-tuple(v_1047)))) in
        {515}let v_1054: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1052)) && success?(symmetricstatepack(1-proj-2-tuple(v_1052),2-proj-3-tuple(v_1047),3-proj-3-tuple(v_1047)))) then (if (not-caught-fail(v_1053) && success?(is-true(success?(1-proj-3-tuple(v_1053))))) then symmetricstatepack(1-proj-3-tuple(v_1053),2-proj-3-tuple(v_1053),hash(3-proj-3-tuple(v_1053),2-proj-2-tuple(v_1052))) else fail-any) else fail-any)) in
        {516}let v_1055: bitstring = catch-fail((if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-3-tuple(v_1047))))) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-2-tuple(v_1052))))) then (if not-caught-fail(v_1054) then (v_1054,2-proj-2-tuple(v_1052)) else fail-any) else fail-any) else fail-any)) in
        {517}let v_1056: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1055),v_1030,v_1011,4-proj-7-tuple(v_1008),5-proj-7-tuple(v_1008),6-proj-7-tuple(v_1008),7-proj-7-tuple(v_1008))) in
        {518}let v_1057: bitstring = catch-fail(concat3(v_1012,2-proj-2-tuple(v_1039),2-proj-2-tuple(v_1055))) in
        {519}let (hs_1058: handshakestate,re_1059: key,message_b_1060: bitstring) = (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-7-tuple(v_1008))))) then (if (not-caught-fail(v_1009) && success?(is-true(success?(1-proj-3-tuple(v_1009))))) then (if not-caught-fail(v_1011) then (if not-caught-fail(v_1012) then (if not-caught-fail(v_1014) then (if not-caught-fail(v_1021) then (if not-caught-fail(v_1028) then (if not-caught-fail(v_1030) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-2-tuple(v_1039))))) then (if not-caught-fail(v_1046) then (if (not-caught-fail(v_1055) && success?(is-true(success?(1-proj-2-tuple(v_1055))))) then (if not-caught-fail(v_1056) then (if not-caught-fail(v_1057) then (v_1056,5-proj-7-tuple(v_1008),v_1057) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {520}event SendMsg(bob,charlie,stage_b,msg_b(bob,charlie),true);
        {521}insert statestore(bob,charlie,statepack_c(hs_1058));
        {522}out(pub, message_b_1060)
    ) | (
        {542}get statestore(=bob,=charlie,statepack_c(hs_1061: handshakestate)) in
        {524}in(pub, message_c_1062: bitstring);
        {525}let v_1063: bitstring = catch-fail(handshakestateunpack(hs_1061)) in
        {526}let v_1064: bitstring = catch-fail(deconcat3(message_c_1062)) in
        {527}let v_1065: bool = catch-fail(true) in
        {528}let v_1066: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1063))) in
        {529}let v_1067: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1066))) in
        {530}let v_1068: aead = catch-fail(decrypt(1-proj-2-tuple(v_1067),2-proj-2-tuple(v_1067),3-proj-3-tuple(v_1066),3-proj-3-tuple(v_1064))) in
        {531}let v_1069: bitstring = catch-fail(aeadunpack(v_1068)) in
        {532}let v_1070: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1066))) in
        {533}let v_1071: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1067))) && success?(1-proj-3-tuple(v_1066))) then (if (not-caught-fail(v_1070) && success?(is-true(success?(1-proj-2-tuple(v_1070))))) then cipherstatepack(1-proj-2-tuple(v_1070),increment_nonce(2-proj-2-tuple(v_1067))) else fail-any) else fail-any)) in
        {534}let v_1072: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1064)) && (success?(3-proj-3-tuple(v_1066)) && success?(1-proj-3-tuple(v_1066)))) then (if (not-caught-fail(v_1067) && success?(is-true(success?(1-proj-2-tuple(v_1067))))) then (if not-caught-fail(v_1068) then (if (not-caught-fail(v_1069) && success?(is-true(success?(1-proj-3-tuple(v_1069))))) then (if not-caught-fail(v_1071) then (v_1071,3-proj-3-tuple(v_1069),1-proj-3-tuple(v_1069)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {535}let v_1073: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1072),2-proj-3-tuple(v_1066),3-proj-3-tuple(v_1066)))) in
        {536}let v_1074: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1064)) && success?(symmetricstatepack(1-proj-3-tuple(v_1072),2-proj-3-tuple(v_1066),3-proj-3-tuple(v_1066)))) then (if (not-caught-fail(v_1073) && success?(is-true(success?(1-proj-3-tuple(v_1073))))) then symmetricstatepack(1-proj-3-tuple(v_1073),2-proj-3-tuple(v_1073),hash(3-proj-3-tuple(v_1073),3-proj-3-tuple(v_1064))) else fail-any) else fail-any)) in
        {537}let v_1075: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1064)) && success?(1-proj-7-tuple(v_1063))) then (if (not-caught-fail(v_1066) && success?(is-true(success?(1-proj-3-tuple(v_1066))))) then (if (not-caught-fail(v_1072) && success?(is-true(success?(1-proj-3-tuple(v_1072))))) then (if not-caught-fail(v_1074) then (v_1074,2-proj-3-tuple(v_1072),3-proj-3-tuple(v_1072)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {538}let v_1076: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1075),2-proj-7-tuple(v_1063),3-proj-7-tuple(v_1063),4-proj-7-tuple(v_1063),5-proj-7-tuple(v_1063),6-proj-7-tuple(v_1063),7-proj-7-tuple(v_1063))) in
        {539}let (hs_1077: handshakestate,re_1078: key,plaintext_c_1079: bitstring,valid_1080: bool) = (if (not-caught-fail(v_1063) && success?(is-true(success?(1-proj-7-tuple(v_1063))))) then (if (not-caught-fail(v_1064) && success?(is-true(success?(1-proj-3-tuple(v_1064))))) then (if not-caught-fail(v_1065) then (if (not-caught-fail(v_1075) && success?(is-true(success?(1-proj-3-tuple(v_1075))))) then (if (v_1065 && 3-proj-3-tuple(v_1075)) then (if not-caught-fail(v_1076) then (v_1076,getpublickey(3-proj-7-tuple(v_1063)),2-proj-3-tuple(v_1075),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {540}event RecvMsg(bob,charlie,stage_c,plaintext_c_1079,valid_1080);
        {541}insert statestore(bob,charlie,statepack_d(hs_1077))
    ) | (
        {568}get statestore(=bob,=charlie,statepack_d(hs_1081: handshakestate)) in
        {543}let v_1082: bitstring = catch-fail(handshakestateunpack(hs_1081)) in
        {544}let v_1083: bitstring = catch-fail((empty,empty,empty)) in
        {545}let v_1084: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1082))) in
        {546}let v_1085: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1084))) in
        {547}let v_1086: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1085),2-proj-2-tuple(v_1085),3-proj-3-tuple(v_1084),msg_d(bob,charlie))) in
        {548}let v_1087: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1084))) in
        {549}let v_1088: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1085))) && success?(1-proj-3-tuple(v_1084))) then (if (not-caught-fail(v_1087) && success?(is-true(success?(1-proj-2-tuple(v_1087))))) then cipherstatepack(1-proj-2-tuple(v_1087),increment_nonce(2-proj-2-tuple(v_1085))) else fail-any) else fail-any)) in
        {550}let v_1089: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1084)) && success?(1-proj-3-tuple(v_1084))) then (if (not-caught-fail(v_1085) && success?(is-true(success?(1-proj-2-tuple(v_1085))))) then (if not-caught-fail(v_1086) then (if not-caught-fail(v_1088) then (v_1088,v_1086) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {551}let v_1090: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1089),2-proj-3-tuple(v_1084),3-proj-3-tuple(v_1084)))) in
        {552}let v_1091: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1089)) && success?(symmetricstatepack(1-proj-2-tuple(v_1089),2-proj-3-tuple(v_1084),3-proj-3-tuple(v_1084)))) then (if (not-caught-fail(v_1090) && success?(is-true(success?(1-proj-3-tuple(v_1090))))) then symmetricstatepack(1-proj-3-tuple(v_1090),2-proj-3-tuple(v_1090),hash(3-proj-3-tuple(v_1090),2-proj-2-tuple(v_1089))) else fail-any) else fail-any)) in
        {553}let v_1092: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1082)) then (if (not-caught-fail(v_1084) && success?(is-true(success?(1-proj-3-tuple(v_1084))))) then (if (not-caught-fail(v_1089) && success?(is-true(success?(1-proj-2-tuple(v_1089))))) then (if not-caught-fail(v_1091) then (v_1091,2-proj-2-tuple(v_1089)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {554}let v_1093: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1092),2-proj-7-tuple(v_1082),3-proj-7-tuple(v_1082),4-proj-7-tuple(v_1082),5-proj-7-tuple(v_1082),6-proj-7-tuple(v_1082),7-proj-7-tuple(v_1082))) in
        {555}let v_1094: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1083),2-proj-3-tuple(v_1083),2-proj-2-tuple(v_1092))) in
        {556}let v_1095: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1092))) in
        {557}let v_1096: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1095),zero)) in
        {558}let v_1097: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1095),zero)) in
        {559}let v_1098: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1095),zero)) in
        {560}let v_1099: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1095)) then (if not-caught-fail(v_1096) then (if not-caught-fail(v_1097) then (if not-caught-fail(v_1098) then (v_1096,v_1097,v_1098) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {561}let v_1100: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1099)) then cipherstatepack(1-proj-3-tuple(v_1099),minnonce) else fail-any)) in
        {562}let v_1101: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1099)) then cipherstatepack(2-proj-3-tuple(v_1099),minnonce) else fail-any)) in
        {563}let v_1102: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1092)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-3-tuple(v_1095))))) then (if (not-caught-fail(v_1099) && success?(is-true(success?(1-proj-3-tuple(v_1099))))) then (if not-caught-fail(v_1100) then (if not-caught-fail(v_1101) then (1-proj-2-tuple(v_1092),v_1100,v_1101) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {564}let (hs_1103: handshakestate,re_1104: key,message_d_1105: bitstring,cs1_1106: cipherstate,cs2_1107: cipherstate) = (if (not-caught-fail(v_1082) && success?(is-true(success?(1-proj-7-tuple(v_1082))))) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then (if (not-caught-fail(v_1092) && success?(is-true(success?(1-proj-2-tuple(v_1092))))) then (if not-caught-fail(v_1093) then (if not-caught-fail(v_1094) then (if (not-caught-fail(v_1102) && success?(is-true(success?(1-proj-3-tuple(v_1102))))) then (v_1093,5-proj-7-tuple(v_1082),v_1094,2-proj-3-tuple(v_1102),3-proj-3-tuple(v_1102)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {565}event SendMsg(bob,charlie,stage_d,msg_d(bob,charlie),true);
        {566}insert statestore(bob,charlie,statepack_e(hs_1103));
        {567}out(pub, message_d_1105)
    ) | (
        {569}event LeakS(phase0,bob);
        {570}out(pub, key_s(bob))
    ) | (
        {571}phase 1;
        {572}event LeakS(phase1,bob);
        {573}out(pub, key_s(bob))
    )
) | (
    {574}out(pub, (key_s(charlie),key_e(charlie,alice),key_e(charlie,bob)))
)

-- Query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 313 rules in the queue.
400 rules inserted. The rule base contains 400 rules. 127 rules in the queue.
600 rules inserted. The rule base contains 588 rules. 178 rules in the queue.
800 rules inserted. The rule base contains 767 rules. 162 rules in the queue.
1000 rules inserted. The rule base contains 945 rules. 151 rules in the queue.
1200 rules inserted. The rule base contains 1143 rules. 278 rules in the queue.
1400 rules inserted. The rule base contains 1317 rules. 261 rules in the queue.
1600 rules inserted. The rule base contains 1447 rules. 215 rules in the queue.
1800 rules inserted. The rule base contains 1608 rules. 221 rules in the queue.
2000 rules inserted. The rule base contains 1742 rules. 224 rules in the queue.
2200 rules inserted. The rule base contains 1875 rules. 245 rules in the queue.
2400 rules inserted. The rule base contains 2030 rules. 306 rules in the queue.
2600 rules inserted. The rule base contains 2202 rules. 347 rules in the queue.
2800 rules inserted. The rule base contains 2336 rules. 361 rules in the queue.
3000 rules inserted. The rule base contains 2464 rules. 389 rules in the queue.
3200 rules inserted. The rule base contains 2584 rules. 394 rules in the queue.
3400 rules inserted. The rule base contains 2715 rules. 397 rules in the queue.
3600 rules inserted. The rule base contains 2889 rules. 407 rules in the queue.
3800 rules inserted. The rule base contains 3045 rules. 409 rules in the queue.
4000 rules inserted. The rule base contains 3191 rules. 398 rules in the queue.
4200 rules inserted. The rule base contains 3363 rules. 422 rules in the queue.
4400 rules inserted. The rule base contains 3513 rules. 449 rules in the queue.
4600 rules inserted. The rule base contains 3680 rules. 489 rules in the queue.
4800 rules inserted. The rule base contains 3841 rules. 485 rules in the queue.
5000 rules inserted. The rule base contains 4003 rules. 486 rules in the queue.
5200 rules inserted. The rule base contains 4129 rules. 473 rules in the queue.
5400 rules inserted. The rule base contains 4288 rules. 476 rules in the queue.
5600 rules inserted. The rule base contains 4407 rules. 471 rules in the queue.
5800 rules inserted. The rule base contains 4535 rules. 462 rules in the queue.
6000 rules inserted. The rule base contains 4640 rules. 451 rules in the queue.
6200 rules inserted. The rule base contains 4783 rules. 461 rules in the queue.
6400 rules inserted. The rule base contains 4869 rules. 385 rules in the queue.
6600 rules inserted. The rule base contains 5004 rules. 377 rules in the queue.
6800 rules inserted. The rule base contains 5119 rules. 343 rules in the queue.
7000 rules inserted. The rule base contains 5253 rules. 348 rules in the queue.
7200 rules inserted. The rule base contains 5390 rules. 360 rules in the queue.
7400 rules inserted. The rule base contains 5485 rules. 338 rules in the queue.
7600 rules inserted. The rule base contains 5589 rules. 304 rules in the queue.
7800 rules inserted. The rule base contains 5719 rules. 301 rules in the queue.
8000 rules inserted. The rule base contains 5835 rules. 249 rules in the queue.
8200 rules inserted. The rule base contains 5962 rules. 221 rules in the queue.
8400 rules inserted. The rule base contains 6098 rules. 225 rules in the queue.
8600 rules inserted. The rule base contains 6228 rules. 201 rules in the queue.
8800 rules inserted. The rule base contains 6334 rules. 157 rules in the queue.
9000 rules inserted. The rule base contains 6442 rules. 86 rules in the queue.
9200 rules inserted. The rule base contains 6477 rules. 25 rules in the queue.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true))
goal reachable: begin(SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true))

1. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

2. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {160}.
table(statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {183}.
The event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true) may be executed at {180}.
So the message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) may be sent on channel pub at output {182}.
mess(pub,concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie)))).

4. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 1 may be read at get {326}.
The message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) that may be sent on channel pub by 3 may be received at input {305}.
We have dhexp(key_e(alice,charlie),g) <> caught-fail.
So event RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true) may be executed at {324}.
end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true)).


Could not find a trace corresponding to this derivation.
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) cannot be proved.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,bob),true))
goal reachable: begin(SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,bob),true))
goal reachable: begin(SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1110,stage_a,m,true)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true))

1. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

2. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {160}.
table(statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {183}.
The event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true) may be executed at {180}.
So the message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) may be sent on channel pub at output {182}.
mess(pub,concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie)))).

4. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 1 may be read at get {326}.
The message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) that may be sent on channel pub by 3 may be received at input {305}.
We have dhexp(key_e(alice,charlie),g) <> caught-fail.
So event RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true) may be executed at {324}.
end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true)).


Could not find a trace corresponding to this derivation.
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true)) -> end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true))

1. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

2. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {160}.
table(statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {183}.
The event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true) may be executed at {180}.
So the message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) may be sent on channel pub at output {182}.
mess(pub,concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie)))).

4. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 1 may be read at get {326}.
The message concat3(dhexp(key_e(alice,charlie),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,charlie),g)),msg_a(alice,charlie))) that may be sent on channel pub by 3 may be received at input {305}.
We have dhexp(key_e(alice,charlie),g) <> caught-fail.
So event RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true) may be executed at {324}.
end(RecvMsg(bob,alice,stage_a,msg_a(alice,charlie),true)).


Could not find a trace corresponding to this derivation.
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) cannot be proved.
Starting query not attacker_p1(msg_a(alice,bob))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> attacker_p1(msg_a(alice,bob))

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) by listening on this channel.
attacker(concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

5. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
attacker(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

6. By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
So the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

7. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_e(alice,bob),g).
attacker(dhexp(key_e(alice,bob),g)).

8. The message dhexp(key_s(alice),g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_s(alice),g)).

9. By 1, the attacker may have the channel pub.
By 8, the message dhexp(key_s(alice),g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_s(alice),g) by listening on this channel.
attacker(dhexp(key_s(alice),g)).

10. Using the function empty the attacker may obtain empty.
attacker(empty).

11. Using the function somename the attacker may obtain somename.
attacker(somename).

12. By 11, the attacker may know somename.
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

13. By 12, the attacker may know hash(somename,empty).
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

14. By 13, the attacker may know hash(hash(somename,empty),empty).
By 9, the attacker may know dhexp(key_s(alice),g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))).

15. By 14, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
By 7, the attacker may know dhexp(key_e(alice,bob),g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

16. By 15, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

17. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

18. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

19. By 18, the attacker may know empty in phase 1.
By 17, the attacker may know minnonce in phase 1.
By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
By 6, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob) in phase 1.
attacker_p1(msg_a(alice,bob)).


Could not find a trace corresponding to this derivation.
RESULT not attacker_p1(msg_a(alice,bob)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> attacker_p1(msg_a(alice,bob))

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) by listening on this channel.
attacker(concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

5. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
attacker(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

6. By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
So the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

7. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_e(alice,bob),g).
attacker(dhexp(key_e(alice,bob),g)).

8. The message dhexp(key_s(alice),g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_s(alice),g)).

9. By 1, the attacker may have the channel pub.
By 8, the message dhexp(key_s(alice),g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_s(alice),g) by listening on this channel.
attacker(dhexp(key_s(alice),g)).

10. Using the function empty the attacker may obtain empty.
attacker(empty).

11. Using the function somename the attacker may obtain somename.
attacker(somename).

12. By 11, the attacker may know somename.
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

13. By 12, the attacker may know hash(somename,empty).
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

14. By 13, the attacker may know hash(hash(somename,empty),empty).
By 9, the attacker may know dhexp(key_s(alice),g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))).

15. By 14, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
By 7, the attacker may know dhexp(key_e(alice,bob),g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

16. By 15, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

17. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

18. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

19. By 18, the attacker may know empty in phase 1.
By 17, the attacker may know minnonce in phase 1.
By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
By 6, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob) in phase 1.
attacker_p1(msg_a(alice,bob)).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice)))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> attacker_p1(msg_a(alice,bob))

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) by listening on this channel.
attacker(concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

5. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
attacker(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

6. By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
So the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

7. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_e(alice,bob),g).
attacker(dhexp(key_e(alice,bob),g)).

8. The message dhexp(key_s(alice),g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_s(alice),g)).

9. By 1, the attacker may have the channel pub.
By 8, the message dhexp(key_s(alice),g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_s(alice),g) by listening on this channel.
attacker(dhexp(key_s(alice),g)).

10. Using the function empty the attacker may obtain empty.
attacker(empty).

11. Using the function somename the attacker may obtain somename.
attacker(somename).

12. By 11, the attacker may know somename.
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

13. By 12, the attacker may know hash(somename,empty).
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

14. By 13, the attacker may know hash(hash(somename,empty),empty).
By 9, the attacker may know dhexp(key_s(alice),g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))).

15. By 14, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
By 7, the attacker may know dhexp(key_e(alice,bob),g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

16. By 15, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

17. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

18. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

19. By 18, the attacker may know empty in phase 1.
By 17, the attacker may know minnonce in phase 1.
By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
By 6, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob) in phase 1.
attacker_p1(msg_a(alice,bob)).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> attacker_p1(msg_a(alice,bob))

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

3. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 2 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) by listening on this channel.
attacker(concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

5. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
attacker(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

6. By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)).
So the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

7. By 4, the attacker may know concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_e(alice,bob),g).
attacker(dhexp(key_e(alice,bob),g)).

8. The message dhexp(key_s(alice),g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_s(alice),g)).

9. By 1, the attacker may have the channel pub.
By 8, the message dhexp(key_s(alice),g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_s(alice),g) by listening on this channel.
attacker(dhexp(key_s(alice),g)).

10. Using the function empty the attacker may obtain empty.
attacker(empty).

11. Using the function somename the attacker may obtain somename.
attacker(somename).

12. By 11, the attacker may know somename.
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

13. By 12, the attacker may know hash(somename,empty).
By 10, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

14. By 13, the attacker may know hash(hash(somename,empty),empty).
By 9, the attacker may know dhexp(key_s(alice),g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))).

15. By 14, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)).
By 7, the attacker may know dhexp(key_e(alice,bob),g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

16. By 15, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g))).

17. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

18. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

19. By 18, the attacker may know empty in phase 1.
By 17, the attacker may know minnonce in phase 1.
By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)) in phase 1.
By 6, the attacker may know encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob) in phase 1.
attacker_p1(msg_a(alice,bob)).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_b,msg_b(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_b,msg_b(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_b,msg_b(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1110,stage_b,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_b,msg_b(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_b,msg_b(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query not attacker_p1(msg_b(bob,alice))
RESULT not attacker_p1(msg_b(bob,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice))
RESULT attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob)))
RESULT attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
Starting query attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice))
RESULT attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_c,msg_c(alice,bob),true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_c,msg_c(alice,bob),true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_c,msg_c(alice,bob),true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1110,stage_c,m,true)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_c,msg_c(alice,bob),true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(bob,alice,stage_c,msg_c(alice,bob),true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) is true.
Starting query not attacker_p1(msg_c(alice,bob))
RESULT not attacker_p1(msg_c(alice,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob))
RESULT attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice)))
RESULT attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
Starting query attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob))
RESULT attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_d,msg_d(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_d,msg_d(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_d,msg_d(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1110,stage_d,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_d,msg_d(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvMsg(alice,bob,stage_d,msg_d(bob,alice),true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query not attacker_p1(msg_d(bob,alice))
RESULT not attacker_p1(msg_d(bob,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice))
RESULT attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob)))
RESULT attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
Starting query attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice))
RESULT attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) is true.
Starting query not event(RecvEnd(true))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d(bob,alice),true)) && begin(SendMsg(alice,bob,stage_c,msg_c(alice,bob),true)) && begin(SendMsg(bob,alice,stage_b,msg_b(bob,alice),true)) && begin(SendMsg(alice,bob,stage_a,msg_a(alice,bob),true)) -> end(RecvEnd(true))

1. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

2. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 1 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the entry statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true))) may be inserted in a table at insert {37}.
table(statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true)))).

3. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

4. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

5. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 4 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

6. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 3 may be read at get {326}.
The message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) that may be sent on channel pub by 5 may be received at input {305}.
We have dhexp(key_e(alice,bob),g) <> caught-fail.
So the entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) may be inserted in a table at insert {325}.
table(statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false)))).

7. The entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) that may be in a table by 6 may be read at get {381}.
The event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true) may be executed at {378}.
So the message concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))) may be sent on channel pub at output {380}.
mess(pub,concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))).

8. The entry statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true))) that may be in a table by 2 may be read at get {94}.
The message concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))) that may be sent on channel pub by 7 may be received at input {40}.
We have dhexp(key_e(bob,alice),g) <> caught-fail.
So the entry statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) may be inserted in a table at insert {93}.
table(statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true)))).

9. The entry statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) that may be in a table by 8 may be read at get {112}.
The event SendMsg(alice,bob,stage_c,msg_c(alice,bob),true) may be executed at {109}.
So the entry statestore(alice,bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) may be inserted in a table at insert {110}.
table(statestore(alice,bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true)))).

10. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

11. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

12. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 11 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

13. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 10 may be read at get {326}.
The message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) that may be sent on channel pub by 12 may be received at input {305}.
We have dhexp(key_e(alice,bob),g) <> caught-fail.
So the entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) may be inserted in a table at insert {325}.
table(statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false)))).

14. The entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) that may be in a table by 13 may be read at get {381}.
The event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true) may be executed at {378}.
So the entry statestore(bob,alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) may be inserted in a table at insert {379}.
table(statestore(bob,alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false)))).

15. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

16. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 15 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the entry statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true))) may be inserted in a table at insert {37}.
table(statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true)))).

17. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) may be inserted in a table at insert {304}.
table(statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false)))).

18. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) may be inserted in a table at insert {16}.
table(statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true)))).

19. The entry statestore(alice,bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(empty,empty),empty,empty,empty,true))) that may be in a table by 18 may be read at get {39}.
The event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true) may be executed at {36}.
So the message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) may be sent on channel pub at output {38}.
mess(pub,concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))).

20. The entry statestore(bob,alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),empty,empty,false))) that may be in a table by 17 may be read at get {326}.
The message concat3(dhexp(key_e(alice,bob),g),empty,encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))) that may be sent on channel pub by 19 may be received at input {305}.
We have dhexp(key_e(alice,bob),g) <> caught-fail.
So the entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) may be inserted in a table at insert {325}.
table(statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false)))).

21. The entry statestore(bob,alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) that may be in a table by 20 may be read at get {381}.
The event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true) may be executed at {378}.
So the message concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))) may be sent on channel pub at output {380}.
mess(pub,concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))).

22. The entry statestore(alice,bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),empty,empty,empty,true))) that may be in a table by 16 may be read at get {94}.
The message concat3(dhexp(key_e(bob,alice),g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))) that may be sent on channel pub by 21 may be received at input {40}.
We have dhexp(key_e(bob,alice),g) <> caught-fail.
So the entry statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) may be inserted in a table at insert {93}.
table(statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true)))).

23. The entry statestore(alice,bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) that may be in a table by 22 may be read at get {112}.
The event SendMsg(alice,bob,stage_c,msg_c(alice,bob),true) may be executed at {109}.
So the message concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob))) may be sent on channel pub at output {111}.
mess(pub,concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))).

24. The entry statestore(bob,alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) that may be in a table by 14 may be read at get {400}.
The message concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob))) that may be sent on channel pub by 23 may be received at input {382}.
So the entry statestore(bob,alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) may be inserted in a table at insert {399}.
table(statestore(bob,alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false)))).

25. The entry statestore(bob,alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(bob),g),key_s(bob)),keypairpack(dhexp(key_e(bob,alice),g),key_e(bob,alice)),dhexp(key_s(alice),g),dhexp(key_e(alice,bob),g),empty,false))) that may be in a table by 24 may be read at get {426}.
The event SendMsg(bob,alice,stage_d,msg_d(bob,alice),true) may be executed at {423}.
So the message concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob))),msg_d(bob,alice))) may be sent on channel pub at output {425}.
mess(pub,concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob))),msg_d(bob,alice)))).

26. The entry statestore(alice,bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_s(bob),dhexp(key_e(alice,bob),g))),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob)))),keypairpack(dhexp(key_s(alice),g),key_s(alice)),keypairpack(dhexp(key_e(alice,bob),g),key_e(alice,bob)),dhexp(key_s(bob),g),dhexp(key_e(bob,alice),g),empty,true))) that may be in a table by 9 may be read at get {140}.
The message concat3(empty,empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),dhexp(key_e(alice,bob),dhexp(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_e(alice,bob),dhexp(key_e(bob,alice),g))),dhexp(key_s(alice),dhexp(key_e(bob,alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),encrypt(empty,minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_s(alice),g)),dhexp(key_e(alice,bob),g)),msg_a(alice,bob))),dhexp(key_e(bob,alice),g)),dhexp(key_s(bob),g))),msg_b(bob,alice))),msg_c(alice,bob))),msg_d(bob,alice))) that may be sent on channel pub by 25 may be received at input {113}.
So event RecvEnd(true) may be executed at {139}.
end(RecvEnd(true)).


Could not find a trace corresponding to this derivation.
RESULT not event(RecvEnd(true)) cannot be proved.
