File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "KK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 263, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 275, character 6:
Warning: identifier e rebound.
File "KK.noise.active.pv", line 276, characters 6-7:
Warning: identifier ne rebound.
File "KK.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 279, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "KK.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "KK.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 295, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 295, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 296, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 304, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 304, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 305, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 313, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 321, characters 6-7:
Warning: identifier re rebound.
File "KK.noise.active.pv", line 322, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 325, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 326, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 328, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 336, characters 6-7:
Warning: identifier re rebound.
File "KK.noise.active.pv", line 337, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 341, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 343, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 362, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 364, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 512, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 514, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 362, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 364, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 504, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 505, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 304, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 304, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 305, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 497, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 336, characters 6-7:
Warning: identifier re rebound.
File "KK.noise.active.pv", line 337, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 341, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 343, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 489, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 275, character 6:
Warning: identifier e rebound.
File "KK.noise.active.pv", line 276, characters 6-7:
Warning: identifier ne rebound.
File "KK.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 279, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 263, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 565, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 566, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 313, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 556, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 558, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 549, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "KK.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "KK.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 295, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 295, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK.noise.active.pv", line 296, characters 6-7:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 542, characters 8-9:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 321, characters 6-7:
Warning: identifier re rebound.
File "KK.noise.active.pv", line 322, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 325, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 326, characters 7-8:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 328, characters 7-8:
Warning: identifier hs rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "KK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "KK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "KK.noise.active.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let v_513: key = catch-fail(dhexp(key_s(alice),g)) in
    {5}let s_514: keypair = (if not-caught-fail(v_513) then keypairpack(v_513,key_s(alice)) else fail-any) in
    {6}out(pub, getpublickey(s_514));
    (
        {7}let e_515: keypair = keypairpack(empty,empty) in
        {8}let v_516: key = catch-fail(dhexp(key_s(bob),g)) in
        {9}let rs_517: key = getpublickey((if not-caught-fail(v_516) then keypairpack(v_516,key_s(bob)) else fail-any)) in
        {10}let re_518: key = empty in
        {11}let v_519: bitstring = catch-fail(hash(somename,empty)) in
        {12}let v_520: key = catch-fail(v_519) in
        {13}let v_521: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {14}let v_522: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_519) then (if not-caught-fail(v_520) then (if not-caught-fail(v_521) then symmetricstatepack(v_521,v_520,v_519) else fail-any) else fail-any) else fail-any))) in
        {15}let v_523: symmetricstate = catch-fail((if success?((if not-caught-fail(v_519) then (if not-caught-fail(v_520) then (if not-caught-fail(v_521) then symmetricstatepack(v_521,v_520,v_519) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_522) && success?(is-true(success?(1-proj-3-tuple(v_522))))) then symmetricstatepack(1-proj-3-tuple(v_522),2-proj-3-tuple(v_522),hash(3-proj-3-tuple(v_522),empty)) else fail-any) else fail-any)) in
        {16}let v_524: bitstring = catch-fail(symmetricstateunpack(v_523)) in
        {17}let v_525: symmetricstate = catch-fail((if success?(getpublickey(s_514)) then (if (not-caught-fail(v_524) && success?(is-true(success?(1-proj-3-tuple(v_524))))) then symmetricstatepack(1-proj-3-tuple(v_524),2-proj-3-tuple(v_524),hash(3-proj-3-tuple(v_524),getpublickey(s_514))) else fail-any) else fail-any)) in
        {18}let v_526: bitstring = catch-fail(symmetricstateunpack(v_525)) in
        {19}let v_527: symmetricstate = catch-fail((if (not-caught-fail(v_526) && success?(is-true(success?(1-proj-3-tuple(v_526))))) then symmetricstatepack(1-proj-3-tuple(v_526),2-proj-3-tuple(v_526),hash(3-proj-3-tuple(v_526),rs_517)) else fail-any)) in
        {20}let hs: handshakestate = (if not-caught-fail(v_523) then (if not-caught-fail(v_525) then (if not-caught-fail(v_527) then handshakestatepack(v_527,s_514,e_515,rs_517,re_518,empty,true) else fail-any) else fail-any) else fail-any) in
        {21}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {58}get statestore(=alice,=bob,=sid,statepack_a(hs_528: handshakestate)) in
        {22}let v_529: bitstring = catch-fail(handshakestateunpack(hs_528)) in
        {23}let v_530: bitstring = catch-fail((empty,empty,empty)) in
        {24}let v_531: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {25}let v_532: keypair = catch-fail((if not-caught-fail(v_531) then keypairpack(v_531,key_e(alice,bob,sid)) else fail-any)) in
        {26}let v_533: bitstring = catch-fail(getpublickey(v_532)) in
        {27}let v_534: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_529))) in
        {28}let v_535: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_529)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-3-tuple(v_534))))) then symmetricstatepack(1-proj-3-tuple(v_534),2-proj-3-tuple(v_534),hash(3-proj-3-tuple(v_534),v_533)) else fail-any) else fail-any)) in
        {29}let v_536: bitstring = catch-fail(keypairunpack(v_532)) in
        {30}let v_537: bitstring = catch-fail(symmetricstateunpack(v_535)) in
        {31}let v_538: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_537),(if success?(4-proj-7-tuple(v_529)) then (if (not-caught-fail(v_536) && success?(is-true(success?(1-proj-2-tuple(v_536))))) then dhexp(2-proj-2-tuple(v_536),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {32}let v_539: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_537),(if success?(4-proj-7-tuple(v_529)) then (if (not-caught-fail(v_536) && success?(is-true(success?(1-proj-2-tuple(v_536))))) then dhexp(2-proj-2-tuple(v_536),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {33}let v_540: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_537),(if success?(4-proj-7-tuple(v_529)) then (if (not-caught-fail(v_536) && success?(is-true(success?(1-proj-2-tuple(v_536))))) then dhexp(2-proj-2-tuple(v_536),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {34}let v_541: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_529)) then (if (not-caught-fail(v_536) && success?(is-true(success?(1-proj-2-tuple(v_536))))) then dhexp(2-proj-2-tuple(v_536),4-proj-7-tuple(v_529)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_537))) then (if not-caught-fail(v_538) then (if not-caught-fail(v_539) then (if not-caught-fail(v_540) then (v_538,v_539,v_540) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {35}let v_542: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_529)) then (if (not-caught-fail(v_536) && success?(is-true(success?(1-proj-2-tuple(v_536))))) then dhexp(2-proj-2-tuple(v_536),4-proj-7-tuple(v_529)) else fail-any) else fail-any)) then (if (not-caught-fail(v_537) && success?(is-true(success?(1-proj-3-tuple(v_537))))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-3-tuple(v_541))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_541)) then cipherstatepack(2-proj-3-tuple(v_541),minnonce) else fail-any),1-proj-3-tuple(v_541),3-proj-3-tuple(v_537)) else fail-any) else fail-any) else fail-any)) in
        {36}let v_543: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_529))) in
        {37}let v_544: bitstring = catch-fail(symmetricstateunpack(v_542)) in
        {38}let v_545: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_544),(if (success?(4-proj-7-tuple(v_529)) && success?(2-proj-7-tuple(v_529))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-2-tuple(v_543))))) then dhexp(2-proj-2-tuple(v_543),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {39}let v_546: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_544),(if (success?(4-proj-7-tuple(v_529)) && success?(2-proj-7-tuple(v_529))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-2-tuple(v_543))))) then dhexp(2-proj-2-tuple(v_543),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {40}let v_547: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_544),(if (success?(4-proj-7-tuple(v_529)) && success?(2-proj-7-tuple(v_529))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-2-tuple(v_543))))) then dhexp(2-proj-2-tuple(v_543),4-proj-7-tuple(v_529)) else fail-any) else fail-any))) in
        {41}let v_548: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_529)) && success?(2-proj-7-tuple(v_529))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-2-tuple(v_543))))) then dhexp(2-proj-2-tuple(v_543),4-proj-7-tuple(v_529)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_544))) then (if not-caught-fail(v_545) then (if not-caught-fail(v_546) then (if not-caught-fail(v_547) then (v_545,v_546,v_547) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {42}let v_549: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_529)) && success?(2-proj-7-tuple(v_529))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-2-tuple(v_543))))) then dhexp(2-proj-2-tuple(v_543),4-proj-7-tuple(v_529)) else fail-any) else fail-any)) then (if (not-caught-fail(v_544) && success?(is-true(success?(1-proj-3-tuple(v_544))))) then (if (not-caught-fail(v_548) && success?(is-true(success?(1-proj-3-tuple(v_548))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_548)) then cipherstatepack(2-proj-3-tuple(v_548),minnonce) else fail-any),1-proj-3-tuple(v_548),3-proj-3-tuple(v_544)) else fail-any) else fail-any) else fail-any)) in
        {43}let v_550: bitstring = catch-fail(symmetricstateunpack(v_549)) in
        {44}let v_551: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_550))) in
        {45}let v_552: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_551),2-proj-2-tuple(v_551),3-proj-3-tuple(v_550),msg_a(alice,bob,sid))) in
        {46}let v_553: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_550))) in
        {47}let v_554: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_551))) && success?(1-proj-3-tuple(v_550))) then (if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-2-tuple(v_553))))) then cipherstatepack(1-proj-2-tuple(v_553),increment_nonce(2-proj-2-tuple(v_551))) else fail-any) else fail-any)) in
        {48}let v_555: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_550)) && success?(1-proj-3-tuple(v_550))) then (if (not-caught-fail(v_551) && success?(is-true(success?(1-proj-2-tuple(v_551))))) then (if not-caught-fail(v_552) then (if not-caught-fail(v_554) then (v_554,v_552) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {49}let v_556: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_555),2-proj-3-tuple(v_550),3-proj-3-tuple(v_550)))) in
        {50}let v_557: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_555)) && success?(symmetricstatepack(1-proj-2-tuple(v_555),2-proj-3-tuple(v_550),3-proj-3-tuple(v_550)))) then (if (not-caught-fail(v_556) && success?(is-true(success?(1-proj-3-tuple(v_556))))) then symmetricstatepack(1-proj-3-tuple(v_556),2-proj-3-tuple(v_556),hash(3-proj-3-tuple(v_556),2-proj-2-tuple(v_555))) else fail-any) else fail-any)) in
        {51}let v_558: bitstring = catch-fail((if (not-caught-fail(v_550) && success?(is-true(success?(1-proj-3-tuple(v_550))))) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then (if not-caught-fail(v_557) then (v_557,2-proj-2-tuple(v_555)) else fail-any) else fail-any) else fail-any)) in
        {52}let v_559: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_558),2-proj-7-tuple(v_529),v_532,4-proj-7-tuple(v_529),5-proj-7-tuple(v_529),6-proj-7-tuple(v_529),7-proj-7-tuple(v_529))) in
        {53}let v_560: bitstring = catch-fail(concat3(v_533,2-proj-3-tuple(v_530),2-proj-2-tuple(v_558))) in
        {54}let (hs_561: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_529) && success?(is-true(success?(1-proj-7-tuple(v_529))))) then (if (not-caught-fail(v_530) && success?(is-true(success?(1-proj-3-tuple(v_530))))) then (if not-caught-fail(v_532) then (if not-caught-fail(v_533) then (if not-caught-fail(v_535) then (if not-caught-fail(v_542) then (if not-caught-fail(v_549) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then (if not-caught-fail(v_559) then (if not-caught-fail(v_560) then (v_559,v_560) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {55}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {56}insert statestore(alice,bob,sid,statepack_b(hs_561));
        {57}out(pub, message_a)
    ) | (
        {102}get statestore(=alice,=bob,=sid,statepack_b(hs_562: handshakestate)) in
        {59}in(pub, message_b: bitstring);
        {60}let v_563: bitstring = catch-fail(handshakestateunpack(hs_562)) in
        {61}let v_564: bitstring = catch-fail(deconcat3(message_b)) in
        {62}let v_565: bool = catch-fail(true) in
        {63}let v_566: key = catch-fail(1-proj-3-tuple(v_564)) in
        {64}let v_567: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_563))) in
        {65}let v_568: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_563)) then (if (not-caught-fail(v_567) && success?(is-true(success?(1-proj-3-tuple(v_567))))) then symmetricstatepack(1-proj-3-tuple(v_567),2-proj-3-tuple(v_567),hash(3-proj-3-tuple(v_567),v_566)) else fail-any) else fail-any)) in
        {66}let v_569: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_563))) in
        {67}let v_570: bitstring = catch-fail(symmetricstateunpack(v_568)) in
        {68}let v_571: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_570),(if success?(3-proj-7-tuple(v_563)) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then dhexp(2-proj-2-tuple(v_569),v_566) else fail-any) else fail-any))) in
        {69}let v_572: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_570),(if success?(3-proj-7-tuple(v_563)) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then dhexp(2-proj-2-tuple(v_569),v_566) else fail-any) else fail-any))) in
        {70}let v_573: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_570),(if success?(3-proj-7-tuple(v_563)) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then dhexp(2-proj-2-tuple(v_569),v_566) else fail-any) else fail-any))) in
        {71}let v_574: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_563)) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then dhexp(2-proj-2-tuple(v_569),v_566) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_570))) then (if not-caught-fail(v_571) then (if not-caught-fail(v_572) then (if not-caught-fail(v_573) then (v_571,v_572,v_573) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {72}let v_575: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_563)) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then dhexp(2-proj-2-tuple(v_569),v_566) else fail-any) else fail-any)) then (if (not-caught-fail(v_570) && success?(is-true(success?(1-proj-3-tuple(v_570))))) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-3-tuple(v_574))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_574)) then cipherstatepack(2-proj-3-tuple(v_574),minnonce) else fail-any),1-proj-3-tuple(v_574),3-proj-3-tuple(v_570)) else fail-any) else fail-any) else fail-any)) in
        {73}let v_576: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_563))) in
        {74}let v_577: bitstring = catch-fail(symmetricstateunpack(v_575)) in
        {75}let v_578: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_577),(if success?(2-proj-7-tuple(v_563)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_566) else fail-any) else fail-any))) in
        {76}let v_579: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_577),(if success?(2-proj-7-tuple(v_563)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_566) else fail-any) else fail-any))) in
        {77}let v_580: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_577),(if success?(2-proj-7-tuple(v_563)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_566) else fail-any) else fail-any))) in
        {78}let v_581: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_563)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_566) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_577))) then (if not-caught-fail(v_578) then (if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (v_578,v_579,v_580) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {79}let v_582: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_563)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_566) else fail-any) else fail-any)) then (if (not-caught-fail(v_577) && success?(is-true(success?(1-proj-3-tuple(v_577))))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-3-tuple(v_581))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_581)) then cipherstatepack(2-proj-3-tuple(v_581),minnonce) else fail-any),1-proj-3-tuple(v_581),3-proj-3-tuple(v_577)) else fail-any) else fail-any) else fail-any)) in
        {80}let v_583: bitstring = catch-fail(symmetricstateunpack(v_582)) in
        {81}let v_584: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_583))) in
        {82}let v_585: aead = catch-fail(decrypt(1-proj-2-tuple(v_584),2-proj-2-tuple(v_584),3-proj-3-tuple(v_583),3-proj-3-tuple(v_564))) in
        {83}let v_586: bitstring = catch-fail(aeadunpack(v_585)) in
        {84}let v_587: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_583))) in
        {85}let v_588: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_584))) && success?(1-proj-3-tuple(v_583))) then (if (not-caught-fail(v_587) && success?(is-true(success?(1-proj-2-tuple(v_587))))) then cipherstatepack(1-proj-2-tuple(v_587),increment_nonce(2-proj-2-tuple(v_584))) else fail-any) else fail-any)) in
        {86}let v_589: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_564)) && (success?(3-proj-3-tuple(v_583)) && success?(1-proj-3-tuple(v_583)))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-2-tuple(v_584))))) then (if not-caught-fail(v_585) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then (if not-caught-fail(v_588) then (v_588,3-proj-3-tuple(v_586),1-proj-3-tuple(v_586)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {87}let v_590: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_589),2-proj-3-tuple(v_583),3-proj-3-tuple(v_583)))) in
        {88}let v_591: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_564)) && success?(symmetricstatepack(1-proj-3-tuple(v_589),2-proj-3-tuple(v_583),3-proj-3-tuple(v_583)))) then (if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then symmetricstatepack(1-proj-3-tuple(v_590),2-proj-3-tuple(v_590),hash(3-proj-3-tuple(v_590),3-proj-3-tuple(v_564))) else fail-any) else fail-any)) in
        {89}let v_592: bitstring = catch-fail((if success?(3-proj-3-tuple(v_564)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-3-tuple(v_583))))) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-3-tuple(v_589))))) then (if not-caught-fail(v_591) then (v_591,2-proj-3-tuple(v_589),3-proj-3-tuple(v_589)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {90}let v_593: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_592),2-proj-7-tuple(v_563),3-proj-7-tuple(v_563),4-proj-7-tuple(v_563),v_566,6-proj-7-tuple(v_563),7-proj-7-tuple(v_563))) in
        {91}let v_594: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_592))) in
        {92}let v_595: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_594),zero)) in
        {93}let v_596: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_594),zero)) in
        {94}let v_597: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_594),zero)) in
        {95}let v_598: bitstring = catch-fail((if success?(2-proj-3-tuple(v_594)) then (if not-caught-fail(v_595) then (if not-caught-fail(v_596) then (if not-caught-fail(v_597) then (v_595,v_596,v_597) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {96}let v_599: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_598)) then cipherstatepack(1-proj-3-tuple(v_598),minnonce) else fail-any)) in
        {97}let v_600: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_598)) then cipherstatepack(2-proj-3-tuple(v_598),minnonce) else fail-any)) in
        {98}let v_601: bitstring = catch-fail((if success?(1-proj-3-tuple(v_592)) then (if (not-caught-fail(v_594) && success?(is-true(success?(1-proj-3-tuple(v_594))))) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-3-tuple(v_598))))) then (if not-caught-fail(v_599) then (if not-caught-fail(v_600) then (1-proj-3-tuple(v_592),v_599,v_600) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {99}let (hs_602: handshakestate,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_563) && success?(is-true(success?(1-proj-7-tuple(v_563))))) then (if (not-caught-fail(v_564) && success?(is-true(success?(1-proj-3-tuple(v_564))))) then (if not-caught-fail(v_565) then (if not-caught-fail(v_566) then (if not-caught-fail(v_568) then (if not-caught-fail(v_575) then (if not-caught-fail(v_582) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-3-tuple(v_592))))) then (if (v_565 && 3-proj-3-tuple(v_592)) then (if not-caught-fail(v_593) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-3-tuple(v_601))))) then (v_593,2-proj-3-tuple(v_592),true,2-proj-3-tuple(v_601),3-proj-3-tuple(v_601)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {100}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {101}insert statestore(alice,bob,sid,statepack_c(hs_602,cs1,cs2))
    ) | (
        {103}!
        {122}get statestore(=alice,=bob,=sid,statepack_c(hs_603: handshakestate,cs1_604: cipherstate,cs2_605: cipherstate)) in
        {104}let hs_606: handshakestate = handshakestatesetcs(hs_603,cs1_604) in
        {105}let v_607: bitstring = catch-fail(handshakestateunpack(hs_606)) in
        {106}let v_608: bitstring = catch-fail((empty,empty,empty)) in
        {107}let v_609: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_607))) in
        {108}let v_610: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_609))) in
        {109}let v_611: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_610),2-proj-2-tuple(v_610),3-proj-3-tuple(v_609),msg_c(alice,bob,sid))) in
        {110}let v_612: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_609))) in
        {111}let v_613: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_610))) && success?(1-proj-3-tuple(v_609))) then (if (not-caught-fail(v_612) && success?(is-true(success?(1-proj-2-tuple(v_612))))) then cipherstatepack(1-proj-2-tuple(v_612),increment_nonce(2-proj-2-tuple(v_610))) else fail-any) else fail-any)) in
        {112}let v_614: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_609)) && success?(1-proj-3-tuple(v_609))) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then (if not-caught-fail(v_611) then (if not-caught-fail(v_613) then (v_613,v_611) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {113}let v_615: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_614),2-proj-3-tuple(v_609),3-proj-3-tuple(v_609)))) in
        {114}let v_616: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_614)) && success?(symmetricstatepack(1-proj-2-tuple(v_614),2-proj-3-tuple(v_609),3-proj-3-tuple(v_609)))) then (if (not-caught-fail(v_615) && success?(is-true(success?(1-proj-3-tuple(v_615))))) then symmetricstatepack(1-proj-3-tuple(v_615),2-proj-3-tuple(v_615),hash(3-proj-3-tuple(v_615),2-proj-2-tuple(v_614))) else fail-any) else fail-any)) in
        {115}let v_617: bitstring = catch-fail((if success?(1-proj-7-tuple(v_607)) then (if (not-caught-fail(v_609) && success?(is-true(success?(1-proj-3-tuple(v_609))))) then (if (not-caught-fail(v_614) && success?(is-true(success?(1-proj-2-tuple(v_614))))) then (if not-caught-fail(v_616) then (v_616,2-proj-2-tuple(v_614)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {116}let v_618: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_617),2-proj-7-tuple(v_607),3-proj-7-tuple(v_607),4-proj-7-tuple(v_607),5-proj-7-tuple(v_607),6-proj-7-tuple(v_607),7-proj-7-tuple(v_607))) in
        {117}let v_619: bitstring = catch-fail(concat3(1-proj-3-tuple(v_608),2-proj-3-tuple(v_608),2-proj-2-tuple(v_617))) in
        {118}let (hs_620: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-7-tuple(v_607))))) then (if (not-caught-fail(v_608) && success?(is-true(success?(1-proj-3-tuple(v_608))))) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then (if not-caught-fail(v_618) then (if not-caught-fail(v_619) then (v_618,v_619) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {119}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {120}insert statestore(alice,bob,sid,statepack_d(hs_620,handshakestategetcs(hs_620),cs2_605));
        {121}out(pub, message_c)
    ) | (
        {123}!
        {143}get statestore(=alice,=bob,=sid,statepack_d(hs_621: handshakestate,cs1_622: cipherstate,cs2_623: cipherstate)) in
        {124}let hs_624: handshakestate = handshakestatesetcs(hs_621,cs2_623) in
        {125}in(pub, message_d: bitstring);
        {126}let v_625: bitstring = catch-fail(handshakestateunpack(hs_624)) in
        {127}let v_626: bitstring = catch-fail(deconcat3(message_d)) in
        {128}let v_627: bool = catch-fail(true) in
        {129}let v_628: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_625))) in
        {130}let v_629: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_628))) in
        {131}let v_630: aead = catch-fail(decrypt(1-proj-2-tuple(v_629),2-proj-2-tuple(v_629),3-proj-3-tuple(v_628),3-proj-3-tuple(v_626))) in
        {132}let v_631: bitstring = catch-fail(aeadunpack(v_630)) in
        {133}let v_632: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_628))) in
        {134}let v_633: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_629))) && success?(1-proj-3-tuple(v_628))) then (if (not-caught-fail(v_632) && success?(is-true(success?(1-proj-2-tuple(v_632))))) then cipherstatepack(1-proj-2-tuple(v_632),increment_nonce(2-proj-2-tuple(v_629))) else fail-any) else fail-any)) in
        {135}let v_634: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_626)) && (success?(3-proj-3-tuple(v_628)) && success?(1-proj-3-tuple(v_628)))) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then (if not-caught-fail(v_630) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then (if not-caught-fail(v_633) then (v_633,3-proj-3-tuple(v_631),1-proj-3-tuple(v_631)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {136}let v_635: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_634),2-proj-3-tuple(v_628),3-proj-3-tuple(v_628)))) in
        {137}let v_636: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_626)) && success?(symmetricstatepack(1-proj-3-tuple(v_634),2-proj-3-tuple(v_628),3-proj-3-tuple(v_628)))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-3-tuple(v_635))))) then symmetricstatepack(1-proj-3-tuple(v_635),2-proj-3-tuple(v_635),hash(3-proj-3-tuple(v_635),3-proj-3-tuple(v_626))) else fail-any) else fail-any)) in
        {138}let v_637: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_626)) && success?(1-proj-7-tuple(v_625))) then (if (not-caught-fail(v_628) && success?(is-true(success?(1-proj-3-tuple(v_628))))) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then (if not-caught-fail(v_636) then (v_636,2-proj-3-tuple(v_634),3-proj-3-tuple(v_634)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {139}let v_638: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_637),2-proj-7-tuple(v_625),3-proj-7-tuple(v_625),4-proj-7-tuple(v_625),5-proj-7-tuple(v_625),6-proj-7-tuple(v_625),7-proj-7-tuple(v_625))) in
        {140}let (hs_639: handshakestate,plaintext_d: bitstring,valid_640: bool) = (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-7-tuple(v_625))))) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-3-tuple(v_626))))) then (if not-caught-fail(v_627) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-3-tuple(v_637))))) then (if (v_627 && 3-proj-3-tuple(v_637)) then (if not-caught-fail(v_638) then (v_638,2-proj-3-tuple(v_637),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {141}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {142}event RecvEnd(valid_640)
    ) | (
        {144}event LeakS(phase0,alice);
        {145}out(pub, key_s(alice))
    ) | (
        {146}phase 1;
        {147}event LeakS(phase1,alice);
        {148}out(pub, key_s(alice))
    )
) | (
    {149}let v_641: key = catch-fail(dhexp(key_s(alice),g)) in
    {150}let s_642: keypair = (if not-caught-fail(v_641) then keypairpack(v_641,key_s(alice)) else fail-any) in
    {151}out(pub, getpublickey(s_642));
    (
        {152}let e_643: keypair = keypairpack(empty,empty) in
        {153}let v_644: key = catch-fail(dhexp(key_s(charlie),g)) in
        {154}let rs_645: key = getpublickey((if not-caught-fail(v_644) then keypairpack(v_644,key_s(charlie)) else fail-any)) in
        {155}let re_646: key = empty in
        {156}let v_647: bitstring = catch-fail(hash(somename,empty)) in
        {157}let v_648: key = catch-fail(v_647) in
        {158}let v_649: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {159}let v_650: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_647) then (if not-caught-fail(v_648) then (if not-caught-fail(v_649) then symmetricstatepack(v_649,v_648,v_647) else fail-any) else fail-any) else fail-any))) in
        {160}let v_651: symmetricstate = catch-fail((if success?((if not-caught-fail(v_647) then (if not-caught-fail(v_648) then (if not-caught-fail(v_649) then symmetricstatepack(v_649,v_648,v_647) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-3-tuple(v_650))))) then symmetricstatepack(1-proj-3-tuple(v_650),2-proj-3-tuple(v_650),hash(3-proj-3-tuple(v_650),empty)) else fail-any) else fail-any)) in
        {161}let v_652: bitstring = catch-fail(symmetricstateunpack(v_651)) in
        {162}let v_653: symmetricstate = catch-fail((if success?(getpublickey(s_642)) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-3-tuple(v_652))))) then symmetricstatepack(1-proj-3-tuple(v_652),2-proj-3-tuple(v_652),hash(3-proj-3-tuple(v_652),getpublickey(s_642))) else fail-any) else fail-any)) in
        {163}let v_654: bitstring = catch-fail(symmetricstateunpack(v_653)) in
        {164}let v_655: symmetricstate = catch-fail((if (not-caught-fail(v_654) && success?(is-true(success?(1-proj-3-tuple(v_654))))) then symmetricstatepack(1-proj-3-tuple(v_654),2-proj-3-tuple(v_654),hash(3-proj-3-tuple(v_654),rs_645)) else fail-any)) in
        {165}let hs_656: handshakestate = (if not-caught-fail(v_651) then (if not-caught-fail(v_653) then (if not-caught-fail(v_655) then handshakestatepack(v_655,s_642,e_643,rs_645,re_646,empty,true) else fail-any) else fail-any) else fail-any) in
        {166}insert statestore(alice,charlie,sid,statepack_a(hs_656))
    ) | (
        {203}get statestore(=alice,=charlie,=sid,statepack_a(hs_657: handshakestate)) in
        {167}let v_658: bitstring = catch-fail(handshakestateunpack(hs_657)) in
        {168}let v_659: bitstring = catch-fail((empty,empty,empty)) in
        {169}let v_660: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {170}let v_661: keypair = catch-fail((if not-caught-fail(v_660) then keypairpack(v_660,key_e(alice,charlie,sid)) else fail-any)) in
        {171}let v_662: bitstring = catch-fail(getpublickey(v_661)) in
        {172}let v_663: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_658))) in
        {173}let v_664: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_658)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-3-tuple(v_663))))) then symmetricstatepack(1-proj-3-tuple(v_663),2-proj-3-tuple(v_663),hash(3-proj-3-tuple(v_663),v_662)) else fail-any) else fail-any)) in
        {174}let v_665: bitstring = catch-fail(keypairunpack(v_661)) in
        {175}let v_666: bitstring = catch-fail(symmetricstateunpack(v_664)) in
        {176}let v_667: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_666),(if success?(4-proj-7-tuple(v_658)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-2-tuple(v_665))))) then dhexp(2-proj-2-tuple(v_665),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {177}let v_668: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_666),(if success?(4-proj-7-tuple(v_658)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-2-tuple(v_665))))) then dhexp(2-proj-2-tuple(v_665),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {178}let v_669: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_666),(if success?(4-proj-7-tuple(v_658)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-2-tuple(v_665))))) then dhexp(2-proj-2-tuple(v_665),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {179}let v_670: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_658)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-2-tuple(v_665))))) then dhexp(2-proj-2-tuple(v_665),4-proj-7-tuple(v_658)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_666))) then (if not-caught-fail(v_667) then (if not-caught-fail(v_668) then (if not-caught-fail(v_669) then (v_667,v_668,v_669) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {180}let v_671: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_658)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-2-tuple(v_665))))) then dhexp(2-proj-2-tuple(v_665),4-proj-7-tuple(v_658)) else fail-any) else fail-any)) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then (if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_670)) then cipherstatepack(2-proj-3-tuple(v_670),minnonce) else fail-any),1-proj-3-tuple(v_670),3-proj-3-tuple(v_666)) else fail-any) else fail-any) else fail-any)) in
        {181}let v_672: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_658))) in
        {182}let v_673: bitstring = catch-fail(symmetricstateunpack(v_671)) in
        {183}let v_674: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_673),(if (success?(4-proj-7-tuple(v_658)) && success?(2-proj-7-tuple(v_658))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-2-tuple(v_672))))) then dhexp(2-proj-2-tuple(v_672),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {184}let v_675: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_673),(if (success?(4-proj-7-tuple(v_658)) && success?(2-proj-7-tuple(v_658))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-2-tuple(v_672))))) then dhexp(2-proj-2-tuple(v_672),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {185}let v_676: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_673),(if (success?(4-proj-7-tuple(v_658)) && success?(2-proj-7-tuple(v_658))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-2-tuple(v_672))))) then dhexp(2-proj-2-tuple(v_672),4-proj-7-tuple(v_658)) else fail-any) else fail-any))) in
        {186}let v_677: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_658)) && success?(2-proj-7-tuple(v_658))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-2-tuple(v_672))))) then dhexp(2-proj-2-tuple(v_672),4-proj-7-tuple(v_658)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_673))) then (if not-caught-fail(v_674) then (if not-caught-fail(v_675) then (if not-caught-fail(v_676) then (v_674,v_675,v_676) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {187}let v_678: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_658)) && success?(2-proj-7-tuple(v_658))) then (if (not-caught-fail(v_672) && success?(is-true(success?(1-proj-2-tuple(v_672))))) then dhexp(2-proj-2-tuple(v_672),4-proj-7-tuple(v_658)) else fail-any) else fail-any)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-3-tuple(v_673))))) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-3-tuple(v_677))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_677)) then cipherstatepack(2-proj-3-tuple(v_677),minnonce) else fail-any),1-proj-3-tuple(v_677),3-proj-3-tuple(v_673)) else fail-any) else fail-any) else fail-any)) in
        {188}let v_679: bitstring = catch-fail(symmetricstateunpack(v_678)) in
        {189}let v_680: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_679))) in
        {190}let v_681: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_680),2-proj-2-tuple(v_680),3-proj-3-tuple(v_679),msg_a(alice,charlie,sid))) in
        {191}let v_682: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_679))) in
        {192}let v_683: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_680))) && success?(1-proj-3-tuple(v_679))) then (if (not-caught-fail(v_682) && success?(is-true(success?(1-proj-2-tuple(v_682))))) then cipherstatepack(1-proj-2-tuple(v_682),increment_nonce(2-proj-2-tuple(v_680))) else fail-any) else fail-any)) in
        {193}let v_684: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_679)) && success?(1-proj-3-tuple(v_679))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-2-tuple(v_680))))) then (if not-caught-fail(v_681) then (if not-caught-fail(v_683) then (v_683,v_681) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {194}let v_685: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_684),2-proj-3-tuple(v_679),3-proj-3-tuple(v_679)))) in
        {195}let v_686: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_684)) && success?(symmetricstatepack(1-proj-2-tuple(v_684),2-proj-3-tuple(v_679),3-proj-3-tuple(v_679)))) then (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-3-tuple(v_685))))) then symmetricstatepack(1-proj-3-tuple(v_685),2-proj-3-tuple(v_685),hash(3-proj-3-tuple(v_685),2-proj-2-tuple(v_684))) else fail-any) else fail-any)) in
        {196}let v_687: bitstring = catch-fail((if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-3-tuple(v_679))))) then (if (not-caught-fail(v_684) && success?(is-true(success?(1-proj-2-tuple(v_684))))) then (if not-caught-fail(v_686) then (v_686,2-proj-2-tuple(v_684)) else fail-any) else fail-any) else fail-any)) in
        {197}let v_688: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_687),2-proj-7-tuple(v_658),v_661,4-proj-7-tuple(v_658),5-proj-7-tuple(v_658),6-proj-7-tuple(v_658),7-proj-7-tuple(v_658))) in
        {198}let v_689: bitstring = catch-fail(concat3(v_662,2-proj-3-tuple(v_659),2-proj-2-tuple(v_687))) in
        {199}let (hs_690: handshakestate,message_a_691: bitstring) = (if (not-caught-fail(v_658) && success?(is-true(success?(1-proj-7-tuple(v_658))))) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-3-tuple(v_659))))) then (if not-caught-fail(v_661) then (if not-caught-fail(v_662) then (if not-caught-fail(v_664) then (if not-caught-fail(v_671) then (if not-caught-fail(v_678) then (if (not-caught-fail(v_687) && success?(is-true(success?(1-proj-2-tuple(v_687))))) then (if not-caught-fail(v_688) then (if not-caught-fail(v_689) then (v_688,v_689) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {200}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {201}insert statestore(alice,charlie,sid,statepack_b(hs_690));
        {202}out(pub, message_a_691)
    ) | (
        {247}get statestore(=alice,=charlie,=sid,statepack_b(hs_692: handshakestate)) in
        {204}in(pub, message_b_693: bitstring);
        {205}let v_694: bitstring = catch-fail(handshakestateunpack(hs_692)) in
        {206}let v_695: bitstring = catch-fail(deconcat3(message_b_693)) in
        {207}let v_696: bool = catch-fail(true) in
        {208}let v_697: key = catch-fail(1-proj-3-tuple(v_695)) in
        {209}let v_698: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_694))) in
        {210}let v_699: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_694)) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-3-tuple(v_698))))) then symmetricstatepack(1-proj-3-tuple(v_698),2-proj-3-tuple(v_698),hash(3-proj-3-tuple(v_698),v_697)) else fail-any) else fail-any)) in
        {211}let v_700: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_694))) in
        {212}let v_701: bitstring = catch-fail(symmetricstateunpack(v_699)) in
        {213}let v_702: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_701),(if success?(3-proj-7-tuple(v_694)) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then dhexp(2-proj-2-tuple(v_700),v_697) else fail-any) else fail-any))) in
        {214}let v_703: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_701),(if success?(3-proj-7-tuple(v_694)) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then dhexp(2-proj-2-tuple(v_700),v_697) else fail-any) else fail-any))) in
        {215}let v_704: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_701),(if success?(3-proj-7-tuple(v_694)) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then dhexp(2-proj-2-tuple(v_700),v_697) else fail-any) else fail-any))) in
        {216}let v_705: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_694)) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then dhexp(2-proj-2-tuple(v_700),v_697) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_701))) then (if not-caught-fail(v_702) then (if not-caught-fail(v_703) then (if not-caught-fail(v_704) then (v_702,v_703,v_704) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {217}let v_706: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_694)) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-2-tuple(v_700))))) then dhexp(2-proj-2-tuple(v_700),v_697) else fail-any) else fail-any)) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_705)) then cipherstatepack(2-proj-3-tuple(v_705),minnonce) else fail-any),1-proj-3-tuple(v_705),3-proj-3-tuple(v_701)) else fail-any) else fail-any) else fail-any)) in
        {218}let v_707: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_694))) in
        {219}let v_708: bitstring = catch-fail(symmetricstateunpack(v_706)) in
        {220}let v_709: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_708),(if success?(2-proj-7-tuple(v_694)) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-2-tuple(v_707))))) then dhexp(2-proj-2-tuple(v_707),v_697) else fail-any) else fail-any))) in
        {221}let v_710: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_708),(if success?(2-proj-7-tuple(v_694)) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-2-tuple(v_707))))) then dhexp(2-proj-2-tuple(v_707),v_697) else fail-any) else fail-any))) in
        {222}let v_711: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_708),(if success?(2-proj-7-tuple(v_694)) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-2-tuple(v_707))))) then dhexp(2-proj-2-tuple(v_707),v_697) else fail-any) else fail-any))) in
        {223}let v_712: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_694)) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-2-tuple(v_707))))) then dhexp(2-proj-2-tuple(v_707),v_697) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_708))) then (if not-caught-fail(v_709) then (if not-caught-fail(v_710) then (if not-caught-fail(v_711) then (v_709,v_710,v_711) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {224}let v_713: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_694)) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-2-tuple(v_707))))) then dhexp(2-proj-2-tuple(v_707),v_697) else fail-any) else fail-any)) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-3-tuple(v_708))))) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-3-tuple(v_712))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_712)) then cipherstatepack(2-proj-3-tuple(v_712),minnonce) else fail-any),1-proj-3-tuple(v_712),3-proj-3-tuple(v_708)) else fail-any) else fail-any) else fail-any)) in
        {225}let v_714: bitstring = catch-fail(symmetricstateunpack(v_713)) in
        {226}let v_715: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_714))) in
        {227}let v_716: aead = catch-fail(decrypt(1-proj-2-tuple(v_715),2-proj-2-tuple(v_715),3-proj-3-tuple(v_714),3-proj-3-tuple(v_695))) in
        {228}let v_717: bitstring = catch-fail(aeadunpack(v_716)) in
        {229}let v_718: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_714))) in
        {230}let v_719: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_715))) && success?(1-proj-3-tuple(v_714))) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then cipherstatepack(1-proj-2-tuple(v_718),increment_nonce(2-proj-2-tuple(v_715))) else fail-any) else fail-any)) in
        {231}let v_720: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_695)) && (success?(3-proj-3-tuple(v_714)) && success?(1-proj-3-tuple(v_714)))) then (if (not-caught-fail(v_715) && success?(is-true(success?(1-proj-2-tuple(v_715))))) then (if not-caught-fail(v_716) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then (if not-caught-fail(v_719) then (v_719,3-proj-3-tuple(v_717),1-proj-3-tuple(v_717)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {232}let v_721: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_720),2-proj-3-tuple(v_714),3-proj-3-tuple(v_714)))) in
        {233}let v_722: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_695)) && success?(symmetricstatepack(1-proj-3-tuple(v_720),2-proj-3-tuple(v_714),3-proj-3-tuple(v_714)))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-3-tuple(v_721))))) then symmetricstatepack(1-proj-3-tuple(v_721),2-proj-3-tuple(v_721),hash(3-proj-3-tuple(v_721),3-proj-3-tuple(v_695))) else fail-any) else fail-any)) in
        {234}let v_723: bitstring = catch-fail((if success?(3-proj-3-tuple(v_695)) then (if (not-caught-fail(v_714) && success?(is-true(success?(1-proj-3-tuple(v_714))))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-3-tuple(v_720))))) then (if not-caught-fail(v_722) then (v_722,2-proj-3-tuple(v_720),3-proj-3-tuple(v_720)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {235}let v_724: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_723),2-proj-7-tuple(v_694),3-proj-7-tuple(v_694),4-proj-7-tuple(v_694),v_697,6-proj-7-tuple(v_694),7-proj-7-tuple(v_694))) in
        {236}let v_725: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_723))) in
        {237}let v_726: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_725),zero)) in
        {238}let v_727: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_725),zero)) in
        {239}let v_728: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_725),zero)) in
        {240}let v_729: bitstring = catch-fail((if success?(2-proj-3-tuple(v_725)) then (if not-caught-fail(v_726) then (if not-caught-fail(v_727) then (if not-caught-fail(v_728) then (v_726,v_727,v_728) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {241}let v_730: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_729)) then cipherstatepack(1-proj-3-tuple(v_729),minnonce) else fail-any)) in
        {242}let v_731: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_729)) then cipherstatepack(2-proj-3-tuple(v_729),minnonce) else fail-any)) in
        {243}let v_732: bitstring = catch-fail((if success?(1-proj-3-tuple(v_723)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-3-tuple(v_725))))) then (if (not-caught-fail(v_729) && success?(is-true(success?(1-proj-3-tuple(v_729))))) then (if not-caught-fail(v_730) then (if not-caught-fail(v_731) then (1-proj-3-tuple(v_723),v_730,v_731) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {244}let (hs_733: handshakestate,plaintext_b_734: bitstring,valid_735: bool,cs1_736: cipherstate,cs2_737: cipherstate) = (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-7-tuple(v_694))))) then (if (not-caught-fail(v_695) && success?(is-true(success?(1-proj-3-tuple(v_695))))) then (if not-caught-fail(v_696) then (if not-caught-fail(v_697) then (if not-caught-fail(v_699) then (if not-caught-fail(v_706) then (if not-caught-fail(v_713) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then (if (v_696 && 3-proj-3-tuple(v_723)) then (if not-caught-fail(v_724) then (if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-3-tuple(v_732))))) then (v_724,2-proj-3-tuple(v_723),true,2-proj-3-tuple(v_732),3-proj-3-tuple(v_732)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {245}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_734);
        {246}insert statestore(alice,charlie,sid,statepack_c(hs_733,cs1_736,cs2_737))
    ) | (
        {248}!
        {267}get statestore(=alice,=charlie,=sid,statepack_c(hs_738: handshakestate,cs1_739: cipherstate,cs2_740: cipherstate)) in
        {249}let hs_741: handshakestate = handshakestatesetcs(hs_738,cs1_739) in
        {250}let v_742: bitstring = catch-fail(handshakestateunpack(hs_741)) in
        {251}let v_743: bitstring = catch-fail((empty,empty,empty)) in
        {252}let v_744: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_742))) in
        {253}let v_745: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_744))) in
        {254}let v_746: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_745),2-proj-2-tuple(v_745),3-proj-3-tuple(v_744),msg_c(alice,charlie,sid))) in
        {255}let v_747: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_744))) in
        {256}let v_748: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_745))) && success?(1-proj-3-tuple(v_744))) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-2-tuple(v_747))))) then cipherstatepack(1-proj-2-tuple(v_747),increment_nonce(2-proj-2-tuple(v_745))) else fail-any) else fail-any)) in
        {257}let v_749: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_744)) && success?(1-proj-3-tuple(v_744))) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then (if not-caught-fail(v_746) then (if not-caught-fail(v_748) then (v_748,v_746) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {258}let v_750: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_749),2-proj-3-tuple(v_744),3-proj-3-tuple(v_744)))) in
        {259}let v_751: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_749)) && success?(symmetricstatepack(1-proj-2-tuple(v_749),2-proj-3-tuple(v_744),3-proj-3-tuple(v_744)))) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then symmetricstatepack(1-proj-3-tuple(v_750),2-proj-3-tuple(v_750),hash(3-proj-3-tuple(v_750),2-proj-2-tuple(v_749))) else fail-any) else fail-any)) in
        {260}let v_752: bitstring = catch-fail((if success?(1-proj-7-tuple(v_742)) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-3-tuple(v_744))))) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-2-tuple(v_749))))) then (if not-caught-fail(v_751) then (v_751,2-proj-2-tuple(v_749)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {261}let v_753: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_752),2-proj-7-tuple(v_742),3-proj-7-tuple(v_742),4-proj-7-tuple(v_742),5-proj-7-tuple(v_742),6-proj-7-tuple(v_742),7-proj-7-tuple(v_742))) in
        {262}let v_754: bitstring = catch-fail(concat3(1-proj-3-tuple(v_743),2-proj-3-tuple(v_743),2-proj-2-tuple(v_752))) in
        {263}let (hs_755: handshakestate,message_c_756: bitstring) = (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-7-tuple(v_742))))) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-2-tuple(v_752))))) then (if not-caught-fail(v_753) then (if not-caught-fail(v_754) then (v_753,v_754) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {264}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {265}insert statestore(alice,charlie,sid,statepack_d(hs_755,handshakestategetcs(hs_755),cs2_740));
        {266}out(pub, message_c_756)
    ) | (
        {268}!
        {288}get statestore(=alice,=charlie,=sid,statepack_d(hs_757: handshakestate,cs1_758: cipherstate,cs2_759: cipherstate)) in
        {269}let hs_760: handshakestate = handshakestatesetcs(hs_757,cs2_759) in
        {270}in(pub, message_d_761: bitstring);
        {271}let v_762: bitstring = catch-fail(handshakestateunpack(hs_760)) in
        {272}let v_763: bitstring = catch-fail(deconcat3(message_d_761)) in
        {273}let v_764: bool = catch-fail(true) in
        {274}let v_765: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_762))) in
        {275}let v_766: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_765))) in
        {276}let v_767: aead = catch-fail(decrypt(1-proj-2-tuple(v_766),2-proj-2-tuple(v_766),3-proj-3-tuple(v_765),3-proj-3-tuple(v_763))) in
        {277}let v_768: bitstring = catch-fail(aeadunpack(v_767)) in
        {278}let v_769: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_765))) in
        {279}let v_770: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_766))) && success?(1-proj-3-tuple(v_765))) then (if (not-caught-fail(v_769) && success?(is-true(success?(1-proj-2-tuple(v_769))))) then cipherstatepack(1-proj-2-tuple(v_769),increment_nonce(2-proj-2-tuple(v_766))) else fail-any) else fail-any)) in
        {280}let v_771: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_763)) && (success?(3-proj-3-tuple(v_765)) && success?(1-proj-3-tuple(v_765)))) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-2-tuple(v_766))))) then (if not-caught-fail(v_767) then (if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-3-tuple(v_768))))) then (if not-caught-fail(v_770) then (v_770,3-proj-3-tuple(v_768),1-proj-3-tuple(v_768)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {281}let v_772: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_771),2-proj-3-tuple(v_765),3-proj-3-tuple(v_765)))) in
        {282}let v_773: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_763)) && success?(symmetricstatepack(1-proj-3-tuple(v_771),2-proj-3-tuple(v_765),3-proj-3-tuple(v_765)))) then (if (not-caught-fail(v_772) && success?(is-true(success?(1-proj-3-tuple(v_772))))) then symmetricstatepack(1-proj-3-tuple(v_772),2-proj-3-tuple(v_772),hash(3-proj-3-tuple(v_772),3-proj-3-tuple(v_763))) else fail-any) else fail-any)) in
        {283}let v_774: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_763)) && success?(1-proj-7-tuple(v_762))) then (if (not-caught-fail(v_765) && success?(is-true(success?(1-proj-3-tuple(v_765))))) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-3-tuple(v_771))))) then (if not-caught-fail(v_773) then (v_773,2-proj-3-tuple(v_771),3-proj-3-tuple(v_771)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {284}let v_775: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_774),2-proj-7-tuple(v_762),3-proj-7-tuple(v_762),4-proj-7-tuple(v_762),5-proj-7-tuple(v_762),6-proj-7-tuple(v_762),7-proj-7-tuple(v_762))) in
        {285}let (hs_776: handshakestate,plaintext_d_777: bitstring,valid_778: bool) = (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-7-tuple(v_762))))) then (if (not-caught-fail(v_763) && success?(is-true(success?(1-proj-3-tuple(v_763))))) then (if not-caught-fail(v_764) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then (if (v_764 && 3-proj-3-tuple(v_774)) then (if not-caught-fail(v_775) then (v_775,2-proj-3-tuple(v_774),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {286}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_777);
        {287}event RecvEnd(valid_778)
    ) | (
        {289}event LeakS(phase0,alice);
        {290}out(pub, key_s(alice))
    ) | (
        {291}phase 1;
        {292}event LeakS(phase1,alice);
        {293}out(pub, key_s(alice))
    )
) | (
    {294}let v_779: key = catch-fail(dhexp(key_s(bob),g)) in
    {295}let s_780: keypair = (if not-caught-fail(v_779) then keypairpack(v_779,key_s(bob)) else fail-any) in
    {296}out(pub, getpublickey(s_780));
    (
        {297}let e_781: keypair = keypairpack(empty,empty) in
        {298}let v_782: key = catch-fail(dhexp(key_s(alice),g)) in
        {299}let rs_783: key = getpublickey((if not-caught-fail(v_782) then keypairpack(v_782,key_s(alice)) else fail-any)) in
        {300}let re_784: key = empty in
        {301}let v_785: bitstring = catch-fail(hash(somename,empty)) in
        {302}let v_786: key = catch-fail(v_785) in
        {303}let v_787: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {304}let v_788: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_785) then (if not-caught-fail(v_786) then (if not-caught-fail(v_787) then symmetricstatepack(v_787,v_786,v_785) else fail-any) else fail-any) else fail-any))) in
        {305}let v_789: symmetricstate = catch-fail((if success?((if not-caught-fail(v_785) then (if not-caught-fail(v_786) then (if not-caught-fail(v_787) then symmetricstatepack(v_787,v_786,v_785) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-3-tuple(v_788))))) then symmetricstatepack(1-proj-3-tuple(v_788),2-proj-3-tuple(v_788),hash(3-proj-3-tuple(v_788),empty)) else fail-any) else fail-any)) in
        {306}let v_790: bitstring = catch-fail(symmetricstateunpack(v_789)) in
        {307}let v_791: symmetricstate = catch-fail((if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then symmetricstatepack(1-proj-3-tuple(v_790),2-proj-3-tuple(v_790),hash(3-proj-3-tuple(v_790),rs_783)) else fail-any)) in
        {308}let v_792: bitstring = catch-fail(symmetricstateunpack(v_791)) in
        {309}let v_793: symmetricstate = catch-fail((if success?(getpublickey(s_780)) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-3-tuple(v_792))))) then symmetricstatepack(1-proj-3-tuple(v_792),2-proj-3-tuple(v_792),hash(3-proj-3-tuple(v_792),getpublickey(s_780))) else fail-any) else fail-any)) in
        {310}let hs_794: handshakestate = (if not-caught-fail(v_789) then (if not-caught-fail(v_791) then (if not-caught-fail(v_793) then handshakestatepack(v_793,s_780,e_781,rs_783,re_784,empty,false) else fail-any) else fail-any) else fail-any) in
        {311}insert statestore(bob,alice,sid,statepack_a(hs_794))
    ) | (
        {347}get statestore(=bob,=alice,=sid,statepack_a(hs_795: handshakestate)) in
        {312}in(pub, message_a_796: bitstring);
        {313}let v_797: bitstring = catch-fail(handshakestateunpack(hs_795)) in
        {314}let v_798: bitstring = catch-fail(deconcat3(message_a_796)) in
        {315}let v_799: bool = catch-fail(true) in
        {316}let v_800: key = catch-fail(1-proj-3-tuple(v_798)) in
        {317}let v_801: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_797))) in
        {318}let v_802: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_797)) then (if (not-caught-fail(v_801) && success?(is-true(success?(1-proj-3-tuple(v_801))))) then symmetricstatepack(1-proj-3-tuple(v_801),2-proj-3-tuple(v_801),hash(3-proj-3-tuple(v_801),v_800)) else fail-any) else fail-any)) in
        {319}let v_803: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_797))) in
        {320}let v_804: bitstring = catch-fail(symmetricstateunpack(v_802)) in
        {321}let v_805: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_804),(if success?(2-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {322}let v_806: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_804),(if success?(2-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {323}let v_807: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_804),(if success?(2-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any))) in
        {324}let v_808: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_804))) then (if not-caught-fail(v_805) then (if not-caught-fail(v_806) then (if not-caught-fail(v_807) then (v_805,v_806,v_807) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {325}let v_809: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_797)) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-2-tuple(v_803))))) then dhexp(2-proj-2-tuple(v_803),v_800) else fail-any) else fail-any)) then (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-3-tuple(v_804))))) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_808)) then cipherstatepack(2-proj-3-tuple(v_808),minnonce) else fail-any),1-proj-3-tuple(v_808),3-proj-3-tuple(v_804)) else fail-any) else fail-any) else fail-any)) in
        {326}let v_810: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_797))) in
        {327}let v_811: bitstring = catch-fail(symmetricstateunpack(v_809)) in
        {328}let v_812: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_811),(if (success?(4-proj-7-tuple(v_797)) && success?(2-proj-7-tuple(v_797))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then dhexp(2-proj-2-tuple(v_810),4-proj-7-tuple(v_797)) else fail-any) else fail-any))) in
        {329}let v_813: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_811),(if (success?(4-proj-7-tuple(v_797)) && success?(2-proj-7-tuple(v_797))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then dhexp(2-proj-2-tuple(v_810),4-proj-7-tuple(v_797)) else fail-any) else fail-any))) in
        {330}let v_814: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_811),(if (success?(4-proj-7-tuple(v_797)) && success?(2-proj-7-tuple(v_797))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then dhexp(2-proj-2-tuple(v_810),4-proj-7-tuple(v_797)) else fail-any) else fail-any))) in
        {331}let v_815: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_797)) && success?(2-proj-7-tuple(v_797))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then dhexp(2-proj-2-tuple(v_810),4-proj-7-tuple(v_797)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_811))) then (if not-caught-fail(v_812) then (if not-caught-fail(v_813) then (if not-caught-fail(v_814) then (v_812,v_813,v_814) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {332}let v_816: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_797)) && success?(2-proj-7-tuple(v_797))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then dhexp(2-proj-2-tuple(v_810),4-proj-7-tuple(v_797)) else fail-any) else fail-any)) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-3-tuple(v_811))))) then (if (not-caught-fail(v_815) && success?(is-true(success?(1-proj-3-tuple(v_815))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_815)) then cipherstatepack(2-proj-3-tuple(v_815),minnonce) else fail-any),1-proj-3-tuple(v_815),3-proj-3-tuple(v_811)) else fail-any) else fail-any) else fail-any)) in
        {333}let v_817: bitstring = catch-fail(symmetricstateunpack(v_816)) in
        {334}let v_818: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_817))) in
        {335}let v_819: aead = catch-fail(decrypt(1-proj-2-tuple(v_818),2-proj-2-tuple(v_818),3-proj-3-tuple(v_817),3-proj-3-tuple(v_798))) in
        {336}let v_820: bitstring = catch-fail(aeadunpack(v_819)) in
        {337}let v_821: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_817))) in
        {338}let v_822: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_818))) && success?(1-proj-3-tuple(v_817))) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then cipherstatepack(1-proj-2-tuple(v_821),increment_nonce(2-proj-2-tuple(v_818))) else fail-any) else fail-any)) in
        {339}let v_823: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_798)) && (success?(3-proj-3-tuple(v_817)) && success?(1-proj-3-tuple(v_817)))) then (if (not-caught-fail(v_818) && success?(is-true(success?(1-proj-2-tuple(v_818))))) then (if not-caught-fail(v_819) then (if (not-caught-fail(v_820) && success?(is-true(success?(1-proj-3-tuple(v_820))))) then (if not-caught-fail(v_822) then (v_822,3-proj-3-tuple(v_820),1-proj-3-tuple(v_820)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {340}let v_824: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_823),2-proj-3-tuple(v_817),3-proj-3-tuple(v_817)))) in
        {341}let v_825: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_798)) && success?(symmetricstatepack(1-proj-3-tuple(v_823),2-proj-3-tuple(v_817),3-proj-3-tuple(v_817)))) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-3-tuple(v_824))))) then symmetricstatepack(1-proj-3-tuple(v_824),2-proj-3-tuple(v_824),hash(3-proj-3-tuple(v_824),3-proj-3-tuple(v_798))) else fail-any) else fail-any)) in
        {342}let v_826: bitstring = catch-fail((if success?(3-proj-3-tuple(v_798)) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (if not-caught-fail(v_825) then (v_825,2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {343}let v_827: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_826),2-proj-7-tuple(v_797),3-proj-7-tuple(v_797),4-proj-7-tuple(v_797),v_800,6-proj-7-tuple(v_797),7-proj-7-tuple(v_797))) in
        {344}let (hs_828: handshakestate,plaintext_a: bitstring,valid_829: bool) = (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-7-tuple(v_797))))) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-3-tuple(v_798))))) then (if not-caught-fail(v_799) then (if not-caught-fail(v_800) then (if not-caught-fail(v_802) then (if not-caught-fail(v_809) then (if not-caught-fail(v_816) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then (if (v_799 && 3-proj-3-tuple(v_826)) then (if not-caught-fail(v_827) then (v_827,2-proj-3-tuple(v_826),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {345}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {346}insert statestore(bob,alice,sid,statepack_b(hs_828))
    ) | (
        {392}get statestore(=bob,=alice,=sid,statepack_b(hs_830: handshakestate)) in
        {348}let v_831: bitstring = catch-fail(handshakestateunpack(hs_830)) in
        {349}let v_832: bitstring = catch-fail((empty,empty,empty)) in
        {350}let v_833: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {351}let v_834: keypair = catch-fail((if not-caught-fail(v_833) then keypairpack(v_833,key_e(bob,alice,sid)) else fail-any)) in
        {352}let v_835: bitstring = catch-fail(getpublickey(v_834)) in
        {353}let v_836: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_831))) in
        {354}let v_837: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_831)) then (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-3-tuple(v_836))))) then symmetricstatepack(1-proj-3-tuple(v_836),2-proj-3-tuple(v_836),hash(3-proj-3-tuple(v_836),v_835)) else fail-any) else fail-any)) in
        {355}let v_838: bitstring = catch-fail(keypairunpack(v_834)) in
        {356}let v_839: bitstring = catch-fail(symmetricstateunpack(v_837)) in
        {357}let v_840: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_839),(if success?(5-proj-7-tuple(v_831)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),5-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {358}let v_841: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_839),(if success?(5-proj-7-tuple(v_831)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),5-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {359}let v_842: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_839),(if success?(5-proj-7-tuple(v_831)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),5-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {360}let v_843: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_831)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),5-proj-7-tuple(v_831)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_839))) then (if not-caught-fail(v_840) then (if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (v_840,v_841,v_842) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {361}let v_844: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_831)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),5-proj-7-tuple(v_831)) else fail-any) else fail-any)) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-3-tuple(v_843))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_843)) then cipherstatepack(2-proj-3-tuple(v_843),minnonce) else fail-any),1-proj-3-tuple(v_843),3-proj-3-tuple(v_839)) else fail-any) else fail-any) else fail-any)) in
        {362}let v_845: bitstring = catch-fail(keypairunpack(v_834)) in
        {363}let v_846: bitstring = catch-fail(symmetricstateunpack(v_844)) in
        {364}let v_847: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_846),(if success?(4-proj-7-tuple(v_831)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then dhexp(2-proj-2-tuple(v_845),4-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {365}let v_848: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_846),(if success?(4-proj-7-tuple(v_831)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then dhexp(2-proj-2-tuple(v_845),4-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {366}let v_849: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_846),(if success?(4-proj-7-tuple(v_831)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then dhexp(2-proj-2-tuple(v_845),4-proj-7-tuple(v_831)) else fail-any) else fail-any))) in
        {367}let v_850: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_831)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then dhexp(2-proj-2-tuple(v_845),4-proj-7-tuple(v_831)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_846))) then (if not-caught-fail(v_847) then (if not-caught-fail(v_848) then (if not-caught-fail(v_849) then (v_847,v_848,v_849) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {368}let v_851: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_831)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then dhexp(2-proj-2-tuple(v_845),4-proj-7-tuple(v_831)) else fail-any) else fail-any)) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-3-tuple(v_846))))) then (if (not-caught-fail(v_850) && success?(is-true(success?(1-proj-3-tuple(v_850))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_850)) then cipherstatepack(2-proj-3-tuple(v_850),minnonce) else fail-any),1-proj-3-tuple(v_850),3-proj-3-tuple(v_846)) else fail-any) else fail-any) else fail-any)) in
        {369}let v_852: bitstring = catch-fail(symmetricstateunpack(v_851)) in
        {370}let v_853: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_852))) in
        {371}let v_854: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_853),2-proj-2-tuple(v_853),3-proj-3-tuple(v_852),msg_b(bob,alice,sid))) in
        {372}let v_855: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_852))) in
        {373}let v_856: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_853))) && success?(1-proj-3-tuple(v_852))) then (if (not-caught-fail(v_855) && success?(is-true(success?(1-proj-2-tuple(v_855))))) then cipherstatepack(1-proj-2-tuple(v_855),increment_nonce(2-proj-2-tuple(v_853))) else fail-any) else fail-any)) in
        {374}let v_857: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_852)) && success?(1-proj-3-tuple(v_852))) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-2-tuple(v_853))))) then (if not-caught-fail(v_854) then (if not-caught-fail(v_856) then (v_856,v_854) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {375}let v_858: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_857),2-proj-3-tuple(v_852),3-proj-3-tuple(v_852)))) in
        {376}let v_859: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_857)) && success?(symmetricstatepack(1-proj-2-tuple(v_857),2-proj-3-tuple(v_852),3-proj-3-tuple(v_852)))) then (if (not-caught-fail(v_858) && success?(is-true(success?(1-proj-3-tuple(v_858))))) then symmetricstatepack(1-proj-3-tuple(v_858),2-proj-3-tuple(v_858),hash(3-proj-3-tuple(v_858),2-proj-2-tuple(v_857))) else fail-any) else fail-any)) in
        {377}let v_860: bitstring = catch-fail((if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-3-tuple(v_852))))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-2-tuple(v_857))))) then (if not-caught-fail(v_859) then (v_859,2-proj-2-tuple(v_857)) else fail-any) else fail-any) else fail-any)) in
        {378}let v_861: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_860),2-proj-7-tuple(v_831),v_834,4-proj-7-tuple(v_831),5-proj-7-tuple(v_831),6-proj-7-tuple(v_831),7-proj-7-tuple(v_831))) in
        {379}let v_862: bitstring = catch-fail(concat3(v_835,2-proj-3-tuple(v_832),2-proj-2-tuple(v_860))) in
        {380}let v_863: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_860))) in
        {381}let v_864: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_863),zero)) in
        {382}let v_865: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_863),zero)) in
        {383}let v_866: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_863),zero)) in
        {384}let v_867: bitstring = catch-fail((if success?(2-proj-3-tuple(v_863)) then (if not-caught-fail(v_864) then (if not-caught-fail(v_865) then (if not-caught-fail(v_866) then (v_864,v_865,v_866) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {385}let v_868: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_867)) then cipherstatepack(1-proj-3-tuple(v_867),minnonce) else fail-any)) in
        {386}let v_869: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_867)) then cipherstatepack(2-proj-3-tuple(v_867),minnonce) else fail-any)) in
        {387}let v_870: bitstring = catch-fail((if success?(1-proj-2-tuple(v_860)) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-3-tuple(v_863))))) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-3-tuple(v_867))))) then (if not-caught-fail(v_868) then (if not-caught-fail(v_869) then (1-proj-2-tuple(v_860),v_868,v_869) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {388}let (hs_871: handshakestate,message_b_872: bitstring,cs1_873: cipherstate,cs2_874: cipherstate) = (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-7-tuple(v_831))))) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-3-tuple(v_832))))) then (if not-caught-fail(v_834) then (if not-caught-fail(v_835) then (if not-caught-fail(v_837) then (if not-caught-fail(v_844) then (if not-caught-fail(v_851) then (if (not-caught-fail(v_860) && success?(is-true(success?(1-proj-2-tuple(v_860))))) then (if not-caught-fail(v_861) then (if not-caught-fail(v_862) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-3-tuple(v_870))))) then (v_861,v_862,2-proj-3-tuple(v_870),3-proj-3-tuple(v_870)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {389}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {390}insert statestore(bob,alice,sid,statepack_c(hs_871,cs1_873,cs2_874));
        {391}out(pub, message_b_872)
    ) | (
        {393}!
        {413}get statestore(=bob,=alice,=sid,statepack_c(hs_875: handshakestate,cs1_876: cipherstate,cs2_877: cipherstate)) in
        {394}let hs_878: handshakestate = handshakestatesetcs(hs_875,cs1_876) in
        {395}in(pub, message_c_879: bitstring);
        {396}let v_880: bitstring = catch-fail(handshakestateunpack(hs_878)) in
        {397}let v_881: bitstring = catch-fail(deconcat3(message_c_879)) in
        {398}let v_882: bool = catch-fail(true) in
        {399}let v_883: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_880))) in
        {400}let v_884: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_883))) in
        {401}let v_885: aead = catch-fail(decrypt(1-proj-2-tuple(v_884),2-proj-2-tuple(v_884),3-proj-3-tuple(v_883),3-proj-3-tuple(v_881))) in
        {402}let v_886: bitstring = catch-fail(aeadunpack(v_885)) in
        {403}let v_887: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_883))) in
        {404}let v_888: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_884))) && success?(1-proj-3-tuple(v_883))) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-2-tuple(v_887))))) then cipherstatepack(1-proj-2-tuple(v_887),increment_nonce(2-proj-2-tuple(v_884))) else fail-any) else fail-any)) in
        {405}let v_889: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_881)) && (success?(3-proj-3-tuple(v_883)) && success?(1-proj-3-tuple(v_883)))) then (if (not-caught-fail(v_884) && success?(is-true(success?(1-proj-2-tuple(v_884))))) then (if not-caught-fail(v_885) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-3-tuple(v_886))))) then (if not-caught-fail(v_888) then (v_888,3-proj-3-tuple(v_886),1-proj-3-tuple(v_886)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {406}let v_890: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_889),2-proj-3-tuple(v_883),3-proj-3-tuple(v_883)))) in
        {407}let v_891: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_881)) && success?(symmetricstatepack(1-proj-3-tuple(v_889),2-proj-3-tuple(v_883),3-proj-3-tuple(v_883)))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-3-tuple(v_890))))) then symmetricstatepack(1-proj-3-tuple(v_890),2-proj-3-tuple(v_890),hash(3-proj-3-tuple(v_890),3-proj-3-tuple(v_881))) else fail-any) else fail-any)) in
        {408}let v_892: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_881)) && success?(1-proj-7-tuple(v_880))) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then (if (not-caught-fail(v_889) && success?(is-true(success?(1-proj-3-tuple(v_889))))) then (if not-caught-fail(v_891) then (v_891,2-proj-3-tuple(v_889),3-proj-3-tuple(v_889)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {409}let v_893: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_892),2-proj-7-tuple(v_880),3-proj-7-tuple(v_880),4-proj-7-tuple(v_880),5-proj-7-tuple(v_880),6-proj-7-tuple(v_880),7-proj-7-tuple(v_880))) in
        {410}let (hs_894: handshakestate,plaintext_c: bitstring,valid_895: bool) = (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-7-tuple(v_880))))) then (if (not-caught-fail(v_881) && success?(is-true(success?(1-proj-3-tuple(v_881))))) then (if not-caught-fail(v_882) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if (v_882 && 3-proj-3-tuple(v_892)) then (if not-caught-fail(v_893) then (v_893,2-proj-3-tuple(v_892),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {411}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {412}insert statestore(bob,alice,sid,statepack_d(hs_894,handshakestategetcs(hs_894),cs2_877))
    ) | (
        {414}!
        {432}get statestore(=bob,=alice,=sid,statepack_d(hs_896: handshakestate,cs1_897: cipherstate,cs2_898: cipherstate)) in
        {415}let hs_899: handshakestate = handshakestatesetcs(hs_896,cs2_898) in
        {416}let v_900: bitstring = catch-fail(handshakestateunpack(hs_899)) in
        {417}let v_901: bitstring = catch-fail((empty,empty,empty)) in
        {418}let v_902: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_900))) in
        {419}let v_903: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_902))) in
        {420}let v_904: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_903),2-proj-2-tuple(v_903),3-proj-3-tuple(v_902),msg_d(bob,alice,sid))) in
        {421}let v_905: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_902))) in
        {422}let v_906: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_903))) && success?(1-proj-3-tuple(v_902))) then (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-2-tuple(v_905))))) then cipherstatepack(1-proj-2-tuple(v_905),increment_nonce(2-proj-2-tuple(v_903))) else fail-any) else fail-any)) in
        {423}let v_907: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_902)) && success?(1-proj-3-tuple(v_902))) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then (if not-caught-fail(v_904) then (if not-caught-fail(v_906) then (v_906,v_904) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {424}let v_908: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_907),2-proj-3-tuple(v_902),3-proj-3-tuple(v_902)))) in
        {425}let v_909: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_907)) && success?(symmetricstatepack(1-proj-2-tuple(v_907),2-proj-3-tuple(v_902),3-proj-3-tuple(v_902)))) then (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-3-tuple(v_908))))) then symmetricstatepack(1-proj-3-tuple(v_908),2-proj-3-tuple(v_908),hash(3-proj-3-tuple(v_908),2-proj-2-tuple(v_907))) else fail-any) else fail-any)) in
        {426}let v_910: bitstring = catch-fail((if success?(1-proj-7-tuple(v_900)) then (if (not-caught-fail(v_902) && success?(is-true(success?(1-proj-3-tuple(v_902))))) then (if (not-caught-fail(v_907) && success?(is-true(success?(1-proj-2-tuple(v_907))))) then (if not-caught-fail(v_909) then (v_909,2-proj-2-tuple(v_907)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {427}let v_911: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_910),2-proj-7-tuple(v_900),3-proj-7-tuple(v_900),4-proj-7-tuple(v_900),5-proj-7-tuple(v_900),6-proj-7-tuple(v_900),7-proj-7-tuple(v_900))) in
        {428}let v_912: bitstring = catch-fail(concat3(1-proj-3-tuple(v_901),2-proj-3-tuple(v_901),2-proj-2-tuple(v_910))) in
        {429}let (hs_913: handshakestate,message_d_914: bitstring) = (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-7-tuple(v_900))))) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-3-tuple(v_901))))) then (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-2-tuple(v_910))))) then (if not-caught-fail(v_911) then (if not-caught-fail(v_912) then (v_911,v_912) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {430}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice,sid));
        {431}out(pub, message_d_914)
    ) | (
        {433}event LeakS(phase0,bob);
        {434}out(pub, key_s(bob))
    ) | (
        {435}phase 1;
        {436}event LeakS(phase1,bob);
        {437}out(pub, key_s(bob))
    )
) | (
    {438}let v_915: key = catch-fail(dhexp(key_s(bob),g)) in
    {439}let s_916: keypair = (if not-caught-fail(v_915) then keypairpack(v_915,key_s(bob)) else fail-any) in
    {440}out(pub, getpublickey(s_916));
    (
        {441}let e_917: keypair = keypairpack(empty,empty) in
        {442}let v_918: key = catch-fail(dhexp(key_s(charlie),g)) in
        {443}let rs_919: key = getpublickey((if not-caught-fail(v_918) then keypairpack(v_918,key_s(charlie)) else fail-any)) in
        {444}let re_920: key = empty in
        {445}let v_921: bitstring = catch-fail(hash(somename,empty)) in
        {446}let v_922: key = catch-fail(v_921) in
        {447}let v_923: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {448}let v_924: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_921) then (if not-caught-fail(v_922) then (if not-caught-fail(v_923) then symmetricstatepack(v_923,v_922,v_921) else fail-any) else fail-any) else fail-any))) in
        {449}let v_925: symmetricstate = catch-fail((if success?((if not-caught-fail(v_921) then (if not-caught-fail(v_922) then (if not-caught-fail(v_923) then symmetricstatepack(v_923,v_922,v_921) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-3-tuple(v_924))))) then symmetricstatepack(1-proj-3-tuple(v_924),2-proj-3-tuple(v_924),hash(3-proj-3-tuple(v_924),empty)) else fail-any) else fail-any)) in
        {450}let v_926: bitstring = catch-fail(symmetricstateunpack(v_925)) in
        {451}let v_927: symmetricstate = catch-fail((if (not-caught-fail(v_926) && success?(is-true(success?(1-proj-3-tuple(v_926))))) then symmetricstatepack(1-proj-3-tuple(v_926),2-proj-3-tuple(v_926),hash(3-proj-3-tuple(v_926),rs_919)) else fail-any)) in
        {452}let v_928: bitstring = catch-fail(symmetricstateunpack(v_927)) in
        {453}let v_929: symmetricstate = catch-fail((if success?(getpublickey(s_916)) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then symmetricstatepack(1-proj-3-tuple(v_928),2-proj-3-tuple(v_928),hash(3-proj-3-tuple(v_928),getpublickey(s_916))) else fail-any) else fail-any)) in
        {454}let hs_930: handshakestate = (if not-caught-fail(v_925) then (if not-caught-fail(v_927) then (if not-caught-fail(v_929) then handshakestatepack(v_929,s_916,e_917,rs_919,re_920,empty,false) else fail-any) else fail-any) else fail-any) in
        {455}insert statestore(bob,charlie,sid,statepack_a(hs_930))
    ) | (
        {491}get statestore(=bob,=charlie,=sid,statepack_a(hs_931: handshakestate)) in
        {456}in(pub, message_a_932: bitstring);
        {457}let v_933: bitstring = catch-fail(handshakestateunpack(hs_931)) in
        {458}let v_934: bitstring = catch-fail(deconcat3(message_a_932)) in
        {459}let v_935: bool = catch-fail(true) in
        {460}let v_936: key = catch-fail(1-proj-3-tuple(v_934)) in
        {461}let v_937: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_933))) in
        {462}let v_938: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_933)) then (if (not-caught-fail(v_937) && success?(is-true(success?(1-proj-3-tuple(v_937))))) then symmetricstatepack(1-proj-3-tuple(v_937),2-proj-3-tuple(v_937),hash(3-proj-3-tuple(v_937),v_936)) else fail-any) else fail-any)) in
        {463}let v_939: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_933))) in
        {464}let v_940: bitstring = catch-fail(symmetricstateunpack(v_938)) in
        {465}let v_941: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_940),(if success?(2-proj-7-tuple(v_933)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then dhexp(2-proj-2-tuple(v_939),v_936) else fail-any) else fail-any))) in
        {466}let v_942: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_940),(if success?(2-proj-7-tuple(v_933)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then dhexp(2-proj-2-tuple(v_939),v_936) else fail-any) else fail-any))) in
        {467}let v_943: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_940),(if success?(2-proj-7-tuple(v_933)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then dhexp(2-proj-2-tuple(v_939),v_936) else fail-any) else fail-any))) in
        {468}let v_944: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_933)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then dhexp(2-proj-2-tuple(v_939),v_936) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_940))) then (if not-caught-fail(v_941) then (if not-caught-fail(v_942) then (if not-caught-fail(v_943) then (v_941,v_942,v_943) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {469}let v_945: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_933)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-2-tuple(v_939))))) then dhexp(2-proj-2-tuple(v_939),v_936) else fail-any) else fail-any)) then (if (not-caught-fail(v_940) && success?(is-true(success?(1-proj-3-tuple(v_940))))) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_944)) then cipherstatepack(2-proj-3-tuple(v_944),minnonce) else fail-any),1-proj-3-tuple(v_944),3-proj-3-tuple(v_940)) else fail-any) else fail-any) else fail-any)) in
        {470}let v_946: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_933))) in
        {471}let v_947: bitstring = catch-fail(symmetricstateunpack(v_945)) in
        {472}let v_948: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_947),(if (success?(4-proj-7-tuple(v_933)) && success?(2-proj-7-tuple(v_933))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),4-proj-7-tuple(v_933)) else fail-any) else fail-any))) in
        {473}let v_949: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_947),(if (success?(4-proj-7-tuple(v_933)) && success?(2-proj-7-tuple(v_933))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),4-proj-7-tuple(v_933)) else fail-any) else fail-any))) in
        {474}let v_950: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_947),(if (success?(4-proj-7-tuple(v_933)) && success?(2-proj-7-tuple(v_933))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),4-proj-7-tuple(v_933)) else fail-any) else fail-any))) in
        {475}let v_951: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_933)) && success?(2-proj-7-tuple(v_933))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),4-proj-7-tuple(v_933)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_947))) then (if not-caught-fail(v_948) then (if not-caught-fail(v_949) then (if not-caught-fail(v_950) then (v_948,v_949,v_950) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {476}let v_952: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_933)) && success?(2-proj-7-tuple(v_933))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-2-tuple(v_946))))) then dhexp(2-proj-2-tuple(v_946),4-proj-7-tuple(v_933)) else fail-any) else fail-any)) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-3-tuple(v_947))))) then (if (not-caught-fail(v_951) && success?(is-true(success?(1-proj-3-tuple(v_951))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_951)) then cipherstatepack(2-proj-3-tuple(v_951),minnonce) else fail-any),1-proj-3-tuple(v_951),3-proj-3-tuple(v_947)) else fail-any) else fail-any) else fail-any)) in
        {477}let v_953: bitstring = catch-fail(symmetricstateunpack(v_952)) in
        {478}let v_954: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_953))) in
        {479}let v_955: aead = catch-fail(decrypt(1-proj-2-tuple(v_954),2-proj-2-tuple(v_954),3-proj-3-tuple(v_953),3-proj-3-tuple(v_934))) in
        {480}let v_956: bitstring = catch-fail(aeadunpack(v_955)) in
        {481}let v_957: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_953))) in
        {482}let v_958: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_954))) && success?(1-proj-3-tuple(v_953))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then cipherstatepack(1-proj-2-tuple(v_957),increment_nonce(2-proj-2-tuple(v_954))) else fail-any) else fail-any)) in
        {483}let v_959: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_934)) && (success?(3-proj-3-tuple(v_953)) && success?(1-proj-3-tuple(v_953)))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-2-tuple(v_954))))) then (if not-caught-fail(v_955) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if not-caught-fail(v_958) then (v_958,3-proj-3-tuple(v_956),1-proj-3-tuple(v_956)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {484}let v_960: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_959),2-proj-3-tuple(v_953),3-proj-3-tuple(v_953)))) in
        {485}let v_961: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_934)) && success?(symmetricstatepack(1-proj-3-tuple(v_959),2-proj-3-tuple(v_953),3-proj-3-tuple(v_953)))) then (if (not-caught-fail(v_960) && success?(is-true(success?(1-proj-3-tuple(v_960))))) then symmetricstatepack(1-proj-3-tuple(v_960),2-proj-3-tuple(v_960),hash(3-proj-3-tuple(v_960),3-proj-3-tuple(v_934))) else fail-any) else fail-any)) in
        {486}let v_962: bitstring = catch-fail((if success?(3-proj-3-tuple(v_934)) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-3-tuple(v_953))))) then (if (not-caught-fail(v_959) && success?(is-true(success?(1-proj-3-tuple(v_959))))) then (if not-caught-fail(v_961) then (v_961,2-proj-3-tuple(v_959),3-proj-3-tuple(v_959)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {487}let v_963: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_962),2-proj-7-tuple(v_933),3-proj-7-tuple(v_933),4-proj-7-tuple(v_933),v_936,6-proj-7-tuple(v_933),7-proj-7-tuple(v_933))) in
        {488}let (hs_964: handshakestate,plaintext_a_965: bitstring,valid_966: bool) = (if (not-caught-fail(v_933) && success?(is-true(success?(1-proj-7-tuple(v_933))))) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-3-tuple(v_934))))) then (if not-caught-fail(v_935) then (if not-caught-fail(v_936) then (if not-caught-fail(v_938) then (if not-caught-fail(v_945) then (if not-caught-fail(v_952) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then (if (v_935 && 3-proj-3-tuple(v_962)) then (if not-caught-fail(v_963) then (v_963,2-proj-3-tuple(v_962),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {489}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_965);
        {490}insert statestore(bob,charlie,sid,statepack_b(hs_964))
    ) | (
        {536}get statestore(=bob,=charlie,=sid,statepack_b(hs_967: handshakestate)) in
        {492}let v_968: bitstring = catch-fail(handshakestateunpack(hs_967)) in
        {493}let v_969: bitstring = catch-fail((empty,empty,empty)) in
        {494}let v_970: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {495}let v_971: keypair = catch-fail((if not-caught-fail(v_970) then keypairpack(v_970,key_e(bob,charlie,sid)) else fail-any)) in
        {496}let v_972: bitstring = catch-fail(getpublickey(v_971)) in
        {497}let v_973: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_968))) in
        {498}let v_974: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_968)) then (if (not-caught-fail(v_973) && success?(is-true(success?(1-proj-3-tuple(v_973))))) then symmetricstatepack(1-proj-3-tuple(v_973),2-proj-3-tuple(v_973),hash(3-proj-3-tuple(v_973),v_972)) else fail-any) else fail-any)) in
        {499}let v_975: bitstring = catch-fail(keypairunpack(v_971)) in
        {500}let v_976: bitstring = catch-fail(symmetricstateunpack(v_974)) in
        {501}let v_977: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_976),(if success?(5-proj-7-tuple(v_968)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then dhexp(2-proj-2-tuple(v_975),5-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {502}let v_978: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_976),(if success?(5-proj-7-tuple(v_968)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then dhexp(2-proj-2-tuple(v_975),5-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {503}let v_979: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_976),(if success?(5-proj-7-tuple(v_968)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then dhexp(2-proj-2-tuple(v_975),5-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {504}let v_980: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_968)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then dhexp(2-proj-2-tuple(v_975),5-proj-7-tuple(v_968)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_976))) then (if not-caught-fail(v_977) then (if not-caught-fail(v_978) then (if not-caught-fail(v_979) then (v_977,v_978,v_979) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {505}let v_981: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_968)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then dhexp(2-proj-2-tuple(v_975),5-proj-7-tuple(v_968)) else fail-any) else fail-any)) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-3-tuple(v_976))))) then (if (not-caught-fail(v_980) && success?(is-true(success?(1-proj-3-tuple(v_980))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_980)) then cipherstatepack(2-proj-3-tuple(v_980),minnonce) else fail-any),1-proj-3-tuple(v_980),3-proj-3-tuple(v_976)) else fail-any) else fail-any) else fail-any)) in
        {506}let v_982: bitstring = catch-fail(keypairunpack(v_971)) in
        {507}let v_983: bitstring = catch-fail(symmetricstateunpack(v_981)) in
        {508}let v_984: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_983),(if success?(4-proj-7-tuple(v_968)) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-2-tuple(v_982))))) then dhexp(2-proj-2-tuple(v_982),4-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {509}let v_985: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_983),(if success?(4-proj-7-tuple(v_968)) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-2-tuple(v_982))))) then dhexp(2-proj-2-tuple(v_982),4-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {510}let v_986: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_983),(if success?(4-proj-7-tuple(v_968)) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-2-tuple(v_982))))) then dhexp(2-proj-2-tuple(v_982),4-proj-7-tuple(v_968)) else fail-any) else fail-any))) in
        {511}let v_987: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_968)) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-2-tuple(v_982))))) then dhexp(2-proj-2-tuple(v_982),4-proj-7-tuple(v_968)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_983))) then (if not-caught-fail(v_984) then (if not-caught-fail(v_985) then (if not-caught-fail(v_986) then (v_984,v_985,v_986) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {512}let v_988: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_968)) then (if (not-caught-fail(v_982) && success?(is-true(success?(1-proj-2-tuple(v_982))))) then dhexp(2-proj-2-tuple(v_982),4-proj-7-tuple(v_968)) else fail-any) else fail-any)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-3-tuple(v_983))))) then (if (not-caught-fail(v_987) && success?(is-true(success?(1-proj-3-tuple(v_987))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_987)) then cipherstatepack(2-proj-3-tuple(v_987),minnonce) else fail-any),1-proj-3-tuple(v_987),3-proj-3-tuple(v_983)) else fail-any) else fail-any) else fail-any)) in
        {513}let v_989: bitstring = catch-fail(symmetricstateunpack(v_988)) in
        {514}let v_990: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_989))) in
        {515}let v_991: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_990),2-proj-2-tuple(v_990),3-proj-3-tuple(v_989),msg_b(bob,charlie,sid))) in
        {516}let v_992: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_989))) in
        {517}let v_993: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_990))) && success?(1-proj-3-tuple(v_989))) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-2-tuple(v_992))))) then cipherstatepack(1-proj-2-tuple(v_992),increment_nonce(2-proj-2-tuple(v_990))) else fail-any) else fail-any)) in
        {518}let v_994: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_989)) && success?(1-proj-3-tuple(v_989))) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then (if not-caught-fail(v_991) then (if not-caught-fail(v_993) then (v_993,v_991) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {519}let v_995: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_994),2-proj-3-tuple(v_989),3-proj-3-tuple(v_989)))) in
        {520}let v_996: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_994)) && success?(symmetricstatepack(1-proj-2-tuple(v_994),2-proj-3-tuple(v_989),3-proj-3-tuple(v_989)))) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then symmetricstatepack(1-proj-3-tuple(v_995),2-proj-3-tuple(v_995),hash(3-proj-3-tuple(v_995),2-proj-2-tuple(v_994))) else fail-any) else fail-any)) in
        {521}let v_997: bitstring = catch-fail((if (not-caught-fail(v_989) && success?(is-true(success?(1-proj-3-tuple(v_989))))) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then (if not-caught-fail(v_996) then (v_996,2-proj-2-tuple(v_994)) else fail-any) else fail-any) else fail-any)) in
        {522}let v_998: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_997),2-proj-7-tuple(v_968),v_971,4-proj-7-tuple(v_968),5-proj-7-tuple(v_968),6-proj-7-tuple(v_968),7-proj-7-tuple(v_968))) in
        {523}let v_999: bitstring = catch-fail(concat3(v_972,2-proj-3-tuple(v_969),2-proj-2-tuple(v_997))) in
        {524}let v_1000: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_997))) in
        {525}let v_1001: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1000),zero)) in
        {526}let v_1002: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1000),zero)) in
        {527}let v_1003: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1000),zero)) in
        {528}let v_1004: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1000)) then (if not-caught-fail(v_1001) then (if not-caught-fail(v_1002) then (if not-caught-fail(v_1003) then (v_1001,v_1002,v_1003) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {529}let v_1005: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1004)) then cipherstatepack(1-proj-3-tuple(v_1004),minnonce) else fail-any)) in
        {530}let v_1006: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1004)) then cipherstatepack(2-proj-3-tuple(v_1004),minnonce) else fail-any)) in
        {531}let v_1007: bitstring = catch-fail((if success?(1-proj-2-tuple(v_997)) then (if (not-caught-fail(v_1000) && success?(is-true(success?(1-proj-3-tuple(v_1000))))) then (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-3-tuple(v_1004))))) then (if not-caught-fail(v_1005) then (if not-caught-fail(v_1006) then (1-proj-2-tuple(v_997),v_1005,v_1006) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {532}let (hs_1008: handshakestate,message_b_1009: bitstring,cs1_1010: cipherstate,cs2_1011: cipherstate) = (if (not-caught-fail(v_968) && success?(is-true(success?(1-proj-7-tuple(v_968))))) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-3-tuple(v_969))))) then (if not-caught-fail(v_971) then (if not-caught-fail(v_972) then (if not-caught-fail(v_974) then (if not-caught-fail(v_981) then (if not-caught-fail(v_988) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-2-tuple(v_997))))) then (if not-caught-fail(v_998) then (if not-caught-fail(v_999) then (if (not-caught-fail(v_1007) && success?(is-true(success?(1-proj-3-tuple(v_1007))))) then (v_998,v_999,2-proj-3-tuple(v_1007),3-proj-3-tuple(v_1007)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {533}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {534}insert statestore(bob,charlie,sid,statepack_c(hs_1008,cs1_1010,cs2_1011));
        {535}out(pub, message_b_1009)
    ) | (
        {537}!
        {557}get statestore(=bob,=charlie,=sid,statepack_c(hs_1012: handshakestate,cs1_1013: cipherstate,cs2_1014: cipherstate)) in
        {538}let hs_1015: handshakestate = handshakestatesetcs(hs_1012,cs1_1013) in
        {539}in(pub, message_c_1016: bitstring);
        {540}let v_1017: bitstring = catch-fail(handshakestateunpack(hs_1015)) in
        {541}let v_1018: bitstring = catch-fail(deconcat3(message_c_1016)) in
        {542}let v_1019: bool = catch-fail(true) in
        {543}let v_1020: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1017))) in
        {544}let v_1021: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1020))) in
        {545}let v_1022: aead = catch-fail(decrypt(1-proj-2-tuple(v_1021),2-proj-2-tuple(v_1021),3-proj-3-tuple(v_1020),3-proj-3-tuple(v_1018))) in
        {546}let v_1023: bitstring = catch-fail(aeadunpack(v_1022)) in
        {547}let v_1024: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1020))) in
        {548}let v_1025: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1021))) && success?(1-proj-3-tuple(v_1020))) then (if (not-caught-fail(v_1024) && success?(is-true(success?(1-proj-2-tuple(v_1024))))) then cipherstatepack(1-proj-2-tuple(v_1024),increment_nonce(2-proj-2-tuple(v_1021))) else fail-any) else fail-any)) in
        {549}let v_1026: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1018)) && (success?(3-proj-3-tuple(v_1020)) && success?(1-proj-3-tuple(v_1020)))) then (if (not-caught-fail(v_1021) && success?(is-true(success?(1-proj-2-tuple(v_1021))))) then (if not-caught-fail(v_1022) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-3-tuple(v_1023))))) then (if not-caught-fail(v_1025) then (v_1025,3-proj-3-tuple(v_1023),1-proj-3-tuple(v_1023)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {550}let v_1027: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1026),2-proj-3-tuple(v_1020),3-proj-3-tuple(v_1020)))) in
        {551}let v_1028: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1018)) && success?(symmetricstatepack(1-proj-3-tuple(v_1026),2-proj-3-tuple(v_1020),3-proj-3-tuple(v_1020)))) then (if (not-caught-fail(v_1027) && success?(is-true(success?(1-proj-3-tuple(v_1027))))) then symmetricstatepack(1-proj-3-tuple(v_1027),2-proj-3-tuple(v_1027),hash(3-proj-3-tuple(v_1027),3-proj-3-tuple(v_1018))) else fail-any) else fail-any)) in
        {552}let v_1029: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1018)) && success?(1-proj-7-tuple(v_1017))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then (if (not-caught-fail(v_1026) && success?(is-true(success?(1-proj-3-tuple(v_1026))))) then (if not-caught-fail(v_1028) then (v_1028,2-proj-3-tuple(v_1026),3-proj-3-tuple(v_1026)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {553}let v_1030: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1029),2-proj-7-tuple(v_1017),3-proj-7-tuple(v_1017),4-proj-7-tuple(v_1017),5-proj-7-tuple(v_1017),6-proj-7-tuple(v_1017),7-proj-7-tuple(v_1017))) in
        {554}let (hs_1031: handshakestate,plaintext_c_1032: bitstring,valid_1033: bool) = (if (not-caught-fail(v_1017) && success?(is-true(success?(1-proj-7-tuple(v_1017))))) then (if (not-caught-fail(v_1018) && success?(is-true(success?(1-proj-3-tuple(v_1018))))) then (if not-caught-fail(v_1019) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-3-tuple(v_1029))))) then (if (v_1019 && 3-proj-3-tuple(v_1029)) then (if not-caught-fail(v_1030) then (v_1030,2-proj-3-tuple(v_1029),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {555}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1032);
        {556}insert statestore(bob,charlie,sid,statepack_d(hs_1031,handshakestategetcs(hs_1031),cs2_1014))
    ) | (
        {558}!
        {576}get statestore(=bob,=charlie,=sid,statepack_d(hs_1034: handshakestate,cs1_1035: cipherstate,cs2_1036: cipherstate)) in
        {559}let hs_1037: handshakestate = handshakestatesetcs(hs_1034,cs2_1036) in
        {560}let v_1038: bitstring = catch-fail(handshakestateunpack(hs_1037)) in
        {561}let v_1039: bitstring = catch-fail((empty,empty,empty)) in
        {562}let v_1040: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1038))) in
        {563}let v_1041: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1040))) in
        {564}let v_1042: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1041),2-proj-2-tuple(v_1041),3-proj-3-tuple(v_1040),msg_d(bob,charlie,sid))) in
        {565}let v_1043: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1040))) in
        {566}let v_1044: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1041))) && success?(1-proj-3-tuple(v_1040))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-2-tuple(v_1043))))) then cipherstatepack(1-proj-2-tuple(v_1043),increment_nonce(2-proj-2-tuple(v_1041))) else fail-any) else fail-any)) in
        {567}let v_1045: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1040)) && success?(1-proj-3-tuple(v_1040))) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then (if not-caught-fail(v_1042) then (if not-caught-fail(v_1044) then (v_1044,v_1042) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {568}let v_1046: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1045),2-proj-3-tuple(v_1040),3-proj-3-tuple(v_1040)))) in
        {569}let v_1047: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1045)) && success?(symmetricstatepack(1-proj-2-tuple(v_1045),2-proj-3-tuple(v_1040),3-proj-3-tuple(v_1040)))) then (if (not-caught-fail(v_1046) && success?(is-true(success?(1-proj-3-tuple(v_1046))))) then symmetricstatepack(1-proj-3-tuple(v_1046),2-proj-3-tuple(v_1046),hash(3-proj-3-tuple(v_1046),2-proj-2-tuple(v_1045))) else fail-any) else fail-any)) in
        {570}let v_1048: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1038)) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-3-tuple(v_1040))))) then (if (not-caught-fail(v_1045) && success?(is-true(success?(1-proj-2-tuple(v_1045))))) then (if not-caught-fail(v_1047) then (v_1047,2-proj-2-tuple(v_1045)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {571}let v_1049: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1048),2-proj-7-tuple(v_1038),3-proj-7-tuple(v_1038),4-proj-7-tuple(v_1038),5-proj-7-tuple(v_1038),6-proj-7-tuple(v_1038),7-proj-7-tuple(v_1038))) in
        {572}let v_1050: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1039),2-proj-3-tuple(v_1039),2-proj-2-tuple(v_1048))) in
        {573}let (hs_1051: handshakestate,message_d_1052: bitstring) = (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-7-tuple(v_1038))))) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then (if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-2-tuple(v_1048))))) then (if not-caught-fail(v_1049) then (if not-caught-fail(v_1050) then (v_1049,v_1050) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {574}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie,sid));
        {575}out(pub, message_d_1052)
    ) | (
        {577}event LeakS(phase0,bob);
        {578}out(pub, key_s(bob))
    ) | (
        {579}phase 1;
        {580}event LeakS(phase1,bob);
        {581}out(pub, key_s(bob))
    )
)

