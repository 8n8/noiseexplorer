File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 232, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 233, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 233, character 36:
Warning: identifier h rebound.
File "Xpsk1.noise.active.pv", line 242, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 243, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 248, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 263, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 274, character 6:
Warning: identifier e rebound.
File "Xpsk1.noise.active.pv", line 275, characters 6-7:
Warning: identifier ne rebound.
File "Xpsk1.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 279, character 6:
Warning: identifier s rebound.
File "Xpsk1.noise.active.pv", line 280, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 280, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "Xpsk1.noise.active.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 283, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 284, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 293, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 300, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 300, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 301, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 309, characters 6-7:
Warning: identifier re rebound.
File "Xpsk1.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 311, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 312, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 313, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 313, characters 48-53:
Warning: identifier valid1 rebound.
File "Xpsk1.noise.active.pv", line 314, characters 6-7:
Warning: identifier rs rebound.
File "Xpsk1.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 316, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 317, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 319, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 328, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 330, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 340, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 469, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 470, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 300, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 300, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 301, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 242, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 243, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 461, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 463, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 328, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 330, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 248, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 455, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 274, character 6:
Warning: identifier e rebound.
File "Xpsk1.noise.active.pv", line 275, characters 6-7:
Warning: identifier ne rebound.
File "Xpsk1.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 279, character 6:
Warning: identifier s rebound.
File "Xpsk1.noise.active.pv", line 280, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 280, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "Xpsk1.noise.active.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 283, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 284, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 242, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 243, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 232, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 233, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 233, character 36:
Warning: identifier h rebound.
File "Xpsk1.noise.active.pv", line 242, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 243, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 263, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 515, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 517, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 340, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 248, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 508, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 509, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "Xpsk1.noise.active.pv", line 293, characters 6-7:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 242, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 243, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 502, characters 8-9:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 309, characters 6-7:
Warning: identifier re rebound.
File "Xpsk1.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 311, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 312, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 313, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 313, characters 48-53:
Warning: identifier valid1 rebound.
File "Xpsk1.noise.active.pv", line 314, characters 6-7:
Warning: identifier rs rebound.
File "Xpsk1.noise.active.pv", line 315, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 316, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 317, characters 7-8:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 319, characters 7-8:
Warning: identifier hs rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 248, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 232, characters 7-8:
Warning: identifier ck rebound.
File "Xpsk1.noise.active.pv", line 233, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 233, character 36:
Warning: identifier h rebound.
File "Xpsk1.noise.active.pv", line 248, characters 7-8:
Warning: identifier cs rebound.
File "Xpsk1.noise.active.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Xpsk1.noise.active.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp_real(b_76,dhexp_real(a_75,g)) = dhexp_real(a_75,dhexp_real(b_76,g))
Completing equations...
Completed equations:
dhexp_real(b_76,dhexp_real(a_75,g)) = dhexp_real(a_75,dhexp_real(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_494: keypair = keypairpack(empty,empty) in
    {5}out(pub, getpublickey(s_494));
    (
        {6}let e_495: keypair = keypairpack(empty,empty) in
        {7}let v_496: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
        {8}let rs_497: key = getpublickey((if not-caught-fail(v_496) then keypairpack(validkey(v_496),key_s(bob)) else fail-any)) in
        {9}let re_498: key = empty in
        {10}let v_499: bitstring = catch-fail(hash(somename,empty)) in
        {11}let v_500: key = catch-fail(v_499) in
        {12}let v_501: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {13}let v_502: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_499) then (if not-caught-fail(v_500) then (if not-caught-fail(v_501) then symmetricstatepack(v_501,v_500,v_499) else fail-any) else fail-any) else fail-any))) in
        {14}let v_503: symmetricstate = catch-fail((if success?((if not-caught-fail(v_499) then (if not-caught-fail(v_500) then (if not-caught-fail(v_501) then symmetricstatepack(v_501,v_500,v_499) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-3-tuple(v_502))))) then symmetricstatepack(1-proj-3-tuple(v_502),2-proj-3-tuple(v_502),hash(3-proj-3-tuple(v_502),empty)) else fail-any) else fail-any)) in
        {15}let v_504: bitstring = catch-fail(symmetricstateunpack(v_503)) in
        {16}let v_505: symmetricstate = catch-fail((if (not-caught-fail(v_504) && success?(is-true(success?(1-proj-3-tuple(v_504))))) then symmetricstatepack(1-proj-3-tuple(v_504),2-proj-3-tuple(v_504),hash(3-proj-3-tuple(v_504),rs_497)) else fail-any)) in
        {17}let hs: handshakestate = (if not-caught-fail(v_503) then (if not-caught-fail(v_505) then handshakestatepack(v_505,s_494,e_495,rs_497,re_498,key_psk(alice,bob),true) else fail-any) else fail-any) in
        {18}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {88}get statestore(=alice,=bob,=sid,statepack_a(hs_506: handshakestate)) in
        {19}let v_507: bitstring = catch-fail(handshakestateunpack(hs_506)) in
        {20}let v_508: bitstring = catch-fail((empty,empty,empty)) in
        {21}let v_509: key = catch-fail(dhexp(key_e(alice,bob,sid),validkey(g))) in
        {22}let v_510: keypair = catch-fail((if not-caught-fail(v_509) then keypairpack(validkey(v_509),key_e(alice,bob,sid)) else fail-any)) in
        {23}let v_511: bitstring = catch-fail(getpublickey(v_510)) in
        {24}let v_512: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_507))) in
        {25}let v_513: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_507)) then (if (not-caught-fail(v_512) && success?(is-true(success?(1-proj-3-tuple(v_512))))) then symmetricstatepack(1-proj-3-tuple(v_512),2-proj-3-tuple(v_512),hash(3-proj-3-tuple(v_512),v_511)) else fail-any) else fail-any)) in
        {26}let v_514: bitstring = catch-fail(symmetricstateunpack(v_513)) in
        {27}let v_515: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_514),getpublickey(v_510))) in
        {28}let v_516: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_514),getpublickey(v_510))) in
        {29}let v_517: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_514),getpublickey(v_510))) in
        {30}let v_518: bitstring = catch-fail((if (success?(getpublickey(v_510)) && success?(2-proj-3-tuple(v_514))) then (if not-caught-fail(v_515) then (if not-caught-fail(v_516) then (if not-caught-fail(v_517) then (v_515,v_516,v_517) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {31}let v_519: symmetricstate = catch-fail((if success?(getpublickey(v_510)) then (if (not-caught-fail(v_514) && success?(is-true(success?(1-proj-3-tuple(v_514))))) then (if (not-caught-fail(v_518) && success?(is-true(success?(1-proj-3-tuple(v_518))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_518)) then cipherstatepack(2-proj-3-tuple(v_518),minnonce) else fail-any),1-proj-3-tuple(v_518),3-proj-3-tuple(v_514)) else fail-any) else fail-any) else fail-any)) in
        {32}let v_520: bitstring = catch-fail(keypairunpack(v_510)) in
        {33}let v_521: bitstring = catch-fail(symmetricstateunpack(v_519)) in
        {34}let v_522: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_521),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then dhexp(2-proj-2-tuple(v_520),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {35}let v_523: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_521),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then dhexp(2-proj-2-tuple(v_520),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {36}let v_524: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_521),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then dhexp(2-proj-2-tuple(v_520),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {37}let v_525: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then dhexp(2-proj-2-tuple(v_520),4-proj-7-tuple(v_507)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_521))) then (if not-caught-fail(v_522) then (if not-caught-fail(v_523) then (if not-caught-fail(v_524) then (v_522,v_523,v_524) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {38}let v_526: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-2-tuple(v_520))))) then dhexp(2-proj-2-tuple(v_520),4-proj-7-tuple(v_507)) else fail-any) else fail-any)) then (if (not-caught-fail(v_521) && success?(is-true(success?(1-proj-3-tuple(v_521))))) then (if (not-caught-fail(v_525) && success?(is-true(success?(1-proj-3-tuple(v_525))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_525)) then cipherstatepack(2-proj-3-tuple(v_525),minnonce) else fail-any),1-proj-3-tuple(v_525),3-proj-3-tuple(v_521)) else fail-any) else fail-any) else fail-any)) in
        {39}let v_527: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
        {40}let v_528: keypair = catch-fail((if not-caught-fail(v_527) then keypairpack(validkey(v_527),key_s(alice)) else fail-any)) in
        {41}let v_529: bitstring = catch-fail(symmetricstateunpack(v_526)) in
        {42}let v_530: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_529))) in
        {43}let v_531: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_530),2-proj-2-tuple(v_530),3-proj-3-tuple(v_529),getpublickey(v_528))) in
        {44}let v_532: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_529))) in
        {45}let v_533: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_530))) && success?(1-proj-3-tuple(v_529))) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-2-tuple(v_532))))) then cipherstatepack(1-proj-2-tuple(v_532),increment_nonce(2-proj-2-tuple(v_530))) else fail-any) else fail-any)) in
        {46}let v_534: bitstring = catch-fail((if (success?(getpublickey(v_528)) && (success?(3-proj-3-tuple(v_529)) && success?(1-proj-3-tuple(v_529)))) then (if (not-caught-fail(v_530) && success?(is-true(success?(1-proj-2-tuple(v_530))))) then (if not-caught-fail(v_531) then (if not-caught-fail(v_533) then (v_533,v_531) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {47}let v_535: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_534),2-proj-3-tuple(v_529),3-proj-3-tuple(v_529)))) in
        {48}let v_536: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_534)) && success?(symmetricstatepack(1-proj-2-tuple(v_534),2-proj-3-tuple(v_529),3-proj-3-tuple(v_529)))) then (if (not-caught-fail(v_535) && success?(is-true(success?(1-proj-3-tuple(v_535))))) then symmetricstatepack(1-proj-3-tuple(v_535),2-proj-3-tuple(v_535),hash(3-proj-3-tuple(v_535),2-proj-2-tuple(v_534))) else fail-any) else fail-any)) in
        {49}let v_537: bitstring = catch-fail((if success?(getpublickey(v_528)) then (if (not-caught-fail(v_529) && success?(is-true(success?(1-proj-3-tuple(v_529))))) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then (if not-caught-fail(v_536) then (v_536,2-proj-2-tuple(v_534)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {50}let v_538: bitstring = catch-fail(keypairunpack(v_528)) in
        {51}let v_539: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_537))) in
        {52}let v_540: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_539),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_538) && success?(is-true(success?(1-proj-2-tuple(v_538))))) then dhexp(2-proj-2-tuple(v_538),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {53}let v_541: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_539),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_538) && success?(is-true(success?(1-proj-2-tuple(v_538))))) then dhexp(2-proj-2-tuple(v_538),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {54}let v_542: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_539),(if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_538) && success?(is-true(success?(1-proj-2-tuple(v_538))))) then dhexp(2-proj-2-tuple(v_538),4-proj-7-tuple(v_507)) else fail-any) else fail-any))) in
        {55}let v_543: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_538) && success?(is-true(success?(1-proj-2-tuple(v_538))))) then dhexp(2-proj-2-tuple(v_538),4-proj-7-tuple(v_507)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_539))) then (if not-caught-fail(v_540) then (if not-caught-fail(v_541) then (if not-caught-fail(v_542) then (v_540,v_541,v_542) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {56}let v_544: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_507)) then (if (not-caught-fail(v_538) && success?(is-true(success?(1-proj-2-tuple(v_538))))) then dhexp(2-proj-2-tuple(v_538),4-proj-7-tuple(v_507)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_537))) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-3-tuple(v_539))))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-3-tuple(v_543))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_543)) then cipherstatepack(2-proj-3-tuple(v_543),minnonce) else fail-any),1-proj-3-tuple(v_543),3-proj-3-tuple(v_539)) else fail-any) else fail-any) else fail-any)) in
        {57}let v_545: bitstring = catch-fail(symmetricstateunpack(v_544)) in
        {58}let v_546: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_545),6-proj-7-tuple(v_507))) in
        {59}let v_547: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_545),6-proj-7-tuple(v_507))) in
        {60}let v_548: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_545),6-proj-7-tuple(v_507))) in
        {61}let v_549: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_507)) && success?(2-proj-3-tuple(v_545))) then (if not-caught-fail(v_546) then (if not-caught-fail(v_547) then (if not-caught-fail(v_548) then (v_546,v_547,v_548) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {62}let v_550: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_545),1-proj-3-tuple(v_549),3-proj-3-tuple(v_545)))) in
        {63}let v_551: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_549)) && success?(symmetricstatepack(1-proj-3-tuple(v_545),1-proj-3-tuple(v_549),3-proj-3-tuple(v_545)))) then (if (not-caught-fail(v_550) && success?(is-true(success?(1-proj-3-tuple(v_550))))) then symmetricstatepack(1-proj-3-tuple(v_550),2-proj-3-tuple(v_550),hash(3-proj-3-tuple(v_550),2-proj-3-tuple(v_549))) else fail-any) else fail-any))) in
        {64}let v_552: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_507)) then (if (not-caught-fail(v_545) && success?(is-true(success?(1-proj-3-tuple(v_545))))) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-3-tuple(v_549))))) then (if (not-caught-fail(v_551) && success?(is-true(success?(1-proj-3-tuple(v_551))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_549)) then cipherstatepack(3-proj-3-tuple(v_549),minnonce) else fail-any),1-proj-3-tuple(v_549),3-proj-3-tuple(v_551)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {65}let v_553: bitstring = catch-fail(symmetricstateunpack(v_552)) in
        {66}let v_554: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_553))) in
        {67}let v_555: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_554),2-proj-2-tuple(v_554),3-proj-3-tuple(v_553),msg_a(alice,bob,sid))) in
        {68}let v_556: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_553))) in
        {69}let v_557: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_554))) && success?(1-proj-3-tuple(v_553))) then (if (not-caught-fail(v_556) && success?(is-true(success?(1-proj-2-tuple(v_556))))) then cipherstatepack(1-proj-2-tuple(v_556),increment_nonce(2-proj-2-tuple(v_554))) else fail-any) else fail-any)) in
        {70}let v_558: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_553)) && success?(1-proj-3-tuple(v_553))) then (if (not-caught-fail(v_554) && success?(is-true(success?(1-proj-2-tuple(v_554))))) then (if not-caught-fail(v_555) then (if not-caught-fail(v_557) then (v_557,v_555) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {71}let v_559: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_558),2-proj-3-tuple(v_553),3-proj-3-tuple(v_553)))) in
        {72}let v_560: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_558)) && success?(symmetricstatepack(1-proj-2-tuple(v_558),2-proj-3-tuple(v_553),3-proj-3-tuple(v_553)))) then (if (not-caught-fail(v_559) && success?(is-true(success?(1-proj-3-tuple(v_559))))) then symmetricstatepack(1-proj-3-tuple(v_559),2-proj-3-tuple(v_559),hash(3-proj-3-tuple(v_559),2-proj-2-tuple(v_558))) else fail-any) else fail-any)) in
        {73}let v_561: bitstring = catch-fail((if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-3-tuple(v_553))))) then (if (not-caught-fail(v_558) && success?(is-true(success?(1-proj-2-tuple(v_558))))) then (if not-caught-fail(v_560) then (v_560,2-proj-2-tuple(v_558)) else fail-any) else fail-any) else fail-any)) in
        {74}let v_562: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_561),v_528,v_510,4-proj-7-tuple(v_507),5-proj-7-tuple(v_507),6-proj-7-tuple(v_507),7-proj-7-tuple(v_507))) in
        {75}let v_563: bitstring = catch-fail(concat3(v_511,2-proj-2-tuple(v_537),2-proj-2-tuple(v_561))) in
        {76}let v_564: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_561))) in
        {77}let v_565: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_564),zero)) in
        {78}let v_566: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_564),zero)) in
        {79}let v_567: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_564),zero)) in
        {80}let v_568: bitstring = catch-fail((if success?(2-proj-3-tuple(v_564)) then (if not-caught-fail(v_565) then (if not-caught-fail(v_566) then (if not-caught-fail(v_567) then (v_565,v_566,v_567) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {81}let v_569: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_568)) then cipherstatepack(1-proj-3-tuple(v_568),minnonce) else fail-any)) in
        {82}let v_570: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_568)) then cipherstatepack(2-proj-3-tuple(v_568),minnonce) else fail-any)) in
        {83}let v_571: bitstring = catch-fail((if success?(1-proj-2-tuple(v_561)) then (if (not-caught-fail(v_564) && success?(is-true(success?(1-proj-3-tuple(v_564))))) then (if (not-caught-fail(v_568) && success?(is-true(success?(1-proj-3-tuple(v_568))))) then (if not-caught-fail(v_569) then (if not-caught-fail(v_570) then (1-proj-2-tuple(v_561),v_569,v_570) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {84}let (hs_572: handshakestate,message_a: bitstring,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_507) && success?(is-true(success?(1-proj-7-tuple(v_507))))) then (if (not-caught-fail(v_508) && success?(is-true(success?(1-proj-3-tuple(v_508))))) then (if not-caught-fail(v_510) then (if not-caught-fail(v_511) then (if not-caught-fail(v_513) then (if not-caught-fail(v_519) then (if not-caught-fail(v_526) then (if not-caught-fail(v_528) then (if (not-caught-fail(v_537) && success?(is-true(success?(1-proj-2-tuple(v_537))))) then (if not-caught-fail(v_544) then (if not-caught-fail(v_552) then (if (not-caught-fail(v_561) && success?(is-true(success?(1-proj-2-tuple(v_561))))) then (if not-caught-fail(v_562) then (if not-caught-fail(v_563) then (if (not-caught-fail(v_571) && success?(is-true(success?(1-proj-3-tuple(v_571))))) then (v_562,v_563,2-proj-3-tuple(v_571),3-proj-3-tuple(v_571)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {85}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {86}insert statestore(alice,bob,sid,statepack_b(hs_572,cs1,cs2));
        {87}out(pub, message_a)
    ) | (
        {89}!
        {109}get statestore(=alice,=bob,=sid,statepack_b(hs_573: handshakestate,cs1_574: cipherstate,cs2_575: cipherstate)) in
        {90}let hs_576: handshakestate = handshakestatesetcs(hs_573,cs2_575) in
        {91}in(pub, message_b: bitstring);
        {92}let v_577: bitstring = catch-fail(handshakestateunpack(hs_576)) in
        {93}let v_578: bitstring = catch-fail(deconcat3(message_b)) in
        {94}let v_579: bool = catch-fail(true) in
        {95}let v_580: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_577))) in
        {96}let v_581: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_580))) in
        {97}let v_582: aead = catch-fail(decrypt(1-proj-2-tuple(v_581),2-proj-2-tuple(v_581),3-proj-3-tuple(v_580),3-proj-3-tuple(v_578))) in
        {98}let v_583: bitstring = catch-fail(aeadunpack(v_582)) in
        {99}let v_584: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_580))) in
        {100}let v_585: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_581))) && success?(1-proj-3-tuple(v_580))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-2-tuple(v_584))))) then cipherstatepack(1-proj-2-tuple(v_584),increment_nonce(2-proj-2-tuple(v_581))) else fail-any) else fail-any)) in
        {101}let v_586: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_578)) && (success?(3-proj-3-tuple(v_580)) && success?(1-proj-3-tuple(v_580)))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then (if not-caught-fail(v_582) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-3-tuple(v_583))))) then (if not-caught-fail(v_585) then (v_585,3-proj-3-tuple(v_583),1-proj-3-tuple(v_583)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {102}let v_587: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_586),2-proj-3-tuple(v_580),3-proj-3-tuple(v_580)))) in
        {103}let v_588: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_578)) && success?(symmetricstatepack(1-proj-3-tuple(v_586),2-proj-3-tuple(v_580),3-proj-3-tuple(v_580)))) then (if (not-caught-fail(v_587) && success?(is-true(success?(1-proj-3-tuple(v_587))))) then symmetricstatepack(1-proj-3-tuple(v_587),2-proj-3-tuple(v_587),hash(3-proj-3-tuple(v_587),3-proj-3-tuple(v_578))) else fail-any) else fail-any)) in
        {104}let v_589: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_578)) && success?(1-proj-7-tuple(v_577))) then (if (not-caught-fail(v_580) && success?(is-true(success?(1-proj-3-tuple(v_580))))) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then (if not-caught-fail(v_588) then (v_588,2-proj-3-tuple(v_586),3-proj-3-tuple(v_586)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {105}let v_590: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_589),2-proj-7-tuple(v_577),3-proj-7-tuple(v_577),4-proj-7-tuple(v_577),5-proj-7-tuple(v_577),6-proj-7-tuple(v_577),7-proj-7-tuple(v_577))) in
        {106}let (hs_591: handshakestate,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_577) && success?(is-true(success?(1-proj-7-tuple(v_577))))) then (if (not-caught-fail(v_578) && success?(is-true(success?(1-proj-3-tuple(v_578))))) then (if not-caught-fail(v_579) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-3-tuple(v_589))))) then (if (v_579 && 3-proj-3-tuple(v_589)) then (if not-caught-fail(v_590) then (v_590,2-proj-3-tuple(v_589),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {107}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {108}insert statestore(alice,bob,sid,statepack_c(hs_591,cs1_574,handshakestategetcs(hs_591)))
    ) | (
        {110}!
        {128}get statestore(=alice,=bob,=sid,statepack_c(hs_592: handshakestate,cs1_593: cipherstate,cs2_594: cipherstate)) in
        {111}let hs_595: handshakestate = handshakestatesetcs(hs_592,cs1_593) in
        {112}let v_596: bitstring = catch-fail(handshakestateunpack(hs_595)) in
        {113}let v_597: bitstring = catch-fail((empty,empty,empty)) in
        {114}let v_598: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_596))) in
        {115}let v_599: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_598))) in
        {116}let v_600: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_599),2-proj-2-tuple(v_599),3-proj-3-tuple(v_598),msg_c(alice,bob,sid))) in
        {117}let v_601: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_598))) in
        {118}let v_602: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_599))) && success?(1-proj-3-tuple(v_598))) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-2-tuple(v_601))))) then cipherstatepack(1-proj-2-tuple(v_601),increment_nonce(2-proj-2-tuple(v_599))) else fail-any) else fail-any)) in
        {119}let v_603: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_598)) && success?(1-proj-3-tuple(v_598))) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then (if not-caught-fail(v_600) then (if not-caught-fail(v_602) then (v_602,v_600) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {120}let v_604: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_603),2-proj-3-tuple(v_598),3-proj-3-tuple(v_598)))) in
        {121}let v_605: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_603)) && success?(symmetricstatepack(1-proj-2-tuple(v_603),2-proj-3-tuple(v_598),3-proj-3-tuple(v_598)))) then (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-3-tuple(v_604))))) then symmetricstatepack(1-proj-3-tuple(v_604),2-proj-3-tuple(v_604),hash(3-proj-3-tuple(v_604),2-proj-2-tuple(v_603))) else fail-any) else fail-any)) in
        {122}let v_606: bitstring = catch-fail((if success?(1-proj-7-tuple(v_596)) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-3-tuple(v_598))))) then (if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-2-tuple(v_603))))) then (if not-caught-fail(v_605) then (v_605,2-proj-2-tuple(v_603)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {123}let v_607: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_606),2-proj-7-tuple(v_596),3-proj-7-tuple(v_596),4-proj-7-tuple(v_596),5-proj-7-tuple(v_596),6-proj-7-tuple(v_596),7-proj-7-tuple(v_596))) in
        {124}let v_608: bitstring = catch-fail(concat3(1-proj-3-tuple(v_597),2-proj-3-tuple(v_597),2-proj-2-tuple(v_606))) in
        {125}let (hs_609: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_596) && success?(is-true(success?(1-proj-7-tuple(v_596))))) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then (if not-caught-fail(v_607) then (if not-caught-fail(v_608) then (v_607,v_608) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {126}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {127}out(pub, message_c)
    ) | (
        {129}event LeakPsk(phase0,alice,bob);
        {130}out(pub, key_psk(alice,bob))
    ) | (
        {131}phase 1;
        {132}event LeakPsk(phase1,alice,bob);
        {133}out(pub, key_psk(alice,bob))
    ) | (
        {134}event LeakS(phase0,alice);
        {135}out(pub, key_s(alice))
    ) | (
        {136}phase 1;
        {137}event LeakS(phase1,alice);
        {138}out(pub, key_s(alice))
    )
) | (
    {139}let s_610: keypair = keypairpack(empty,empty) in
    {140}out(pub, getpublickey(s_610));
    (
        {141}let e_611: keypair = keypairpack(empty,empty) in
        {142}let v_612: key = catch-fail(dhexp(key_s(charlie),validkey(g))) in
        {143}let rs_613: key = getpublickey((if not-caught-fail(v_612) then keypairpack(validkey(v_612),key_s(charlie)) else fail-any)) in
        {144}let re_614: key = empty in
        {145}let v_615: bitstring = catch-fail(hash(somename,empty)) in
        {146}let v_616: key = catch-fail(v_615) in
        {147}let v_617: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {148}let v_618: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_615) then (if not-caught-fail(v_616) then (if not-caught-fail(v_617) then symmetricstatepack(v_617,v_616,v_615) else fail-any) else fail-any) else fail-any))) in
        {149}let v_619: symmetricstate = catch-fail((if success?((if not-caught-fail(v_615) then (if not-caught-fail(v_616) then (if not-caught-fail(v_617) then symmetricstatepack(v_617,v_616,v_615) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-3-tuple(v_618))))) then symmetricstatepack(1-proj-3-tuple(v_618),2-proj-3-tuple(v_618),hash(3-proj-3-tuple(v_618),empty)) else fail-any) else fail-any)) in
        {150}let v_620: bitstring = catch-fail(symmetricstateunpack(v_619)) in
        {151}let v_621: symmetricstate = catch-fail((if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then symmetricstatepack(1-proj-3-tuple(v_620),2-proj-3-tuple(v_620),hash(3-proj-3-tuple(v_620),rs_613)) else fail-any)) in
        {152}let hs_622: handshakestate = (if not-caught-fail(v_619) then (if not-caught-fail(v_621) then handshakestatepack(v_621,s_610,e_611,rs_613,re_614,key_psk(alice,charlie),true) else fail-any) else fail-any) in
        {153}insert statestore(alice,charlie,sid,statepack_a(hs_622))
    ) | (
        {223}get statestore(=alice,=charlie,=sid,statepack_a(hs_623: handshakestate)) in
        {154}let v_624: bitstring = catch-fail(handshakestateunpack(hs_623)) in
        {155}let v_625: bitstring = catch-fail((empty,empty,empty)) in
        {156}let v_626: key = catch-fail(dhexp(key_e(alice,charlie,sid),validkey(g))) in
        {157}let v_627: keypair = catch-fail((if not-caught-fail(v_626) then keypairpack(validkey(v_626),key_e(alice,charlie,sid)) else fail-any)) in
        {158}let v_628: bitstring = catch-fail(getpublickey(v_627)) in
        {159}let v_629: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_624))) in
        {160}let v_630: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_624)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-3-tuple(v_629))))) then symmetricstatepack(1-proj-3-tuple(v_629),2-proj-3-tuple(v_629),hash(3-proj-3-tuple(v_629),v_628)) else fail-any) else fail-any)) in
        {161}let v_631: bitstring = catch-fail(symmetricstateunpack(v_630)) in
        {162}let v_632: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_631),getpublickey(v_627))) in
        {163}let v_633: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_631),getpublickey(v_627))) in
        {164}let v_634: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_631),getpublickey(v_627))) in
        {165}let v_635: bitstring = catch-fail((if (success?(getpublickey(v_627)) && success?(2-proj-3-tuple(v_631))) then (if not-caught-fail(v_632) then (if not-caught-fail(v_633) then (if not-caught-fail(v_634) then (v_632,v_633,v_634) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {166}let v_636: symmetricstate = catch-fail((if success?(getpublickey(v_627)) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-3-tuple(v_635))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_635)) then cipherstatepack(2-proj-3-tuple(v_635),minnonce) else fail-any),1-proj-3-tuple(v_635),3-proj-3-tuple(v_631)) else fail-any) else fail-any) else fail-any)) in
        {167}let v_637: bitstring = catch-fail(keypairunpack(v_627)) in
        {168}let v_638: bitstring = catch-fail(symmetricstateunpack(v_636)) in
        {169}let v_639: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_638),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then dhexp(2-proj-2-tuple(v_637),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {170}let v_640: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_638),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then dhexp(2-proj-2-tuple(v_637),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {171}let v_641: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_638),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then dhexp(2-proj-2-tuple(v_637),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {172}let v_642: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then dhexp(2-proj-2-tuple(v_637),4-proj-7-tuple(v_624)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_638))) then (if not-caught-fail(v_639) then (if not-caught-fail(v_640) then (if not-caught-fail(v_641) then (v_639,v_640,v_641) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {173}let v_643: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then dhexp(2-proj-2-tuple(v_637),4-proj-7-tuple(v_624)) else fail-any) else fail-any)) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-3-tuple(v_638))))) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_642)) then cipherstatepack(2-proj-3-tuple(v_642),minnonce) else fail-any),1-proj-3-tuple(v_642),3-proj-3-tuple(v_638)) else fail-any) else fail-any) else fail-any)) in
        {174}let v_644: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
        {175}let v_645: keypair = catch-fail((if not-caught-fail(v_644) then keypairpack(validkey(v_644),key_s(alice)) else fail-any)) in
        {176}let v_646: bitstring = catch-fail(symmetricstateunpack(v_643)) in
        {177}let v_647: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_646))) in
        {178}let v_648: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_647),2-proj-2-tuple(v_647),3-proj-3-tuple(v_646),getpublickey(v_645))) in
        {179}let v_649: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_646))) in
        {180}let v_650: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_647))) && success?(1-proj-3-tuple(v_646))) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-2-tuple(v_649))))) then cipherstatepack(1-proj-2-tuple(v_649),increment_nonce(2-proj-2-tuple(v_647))) else fail-any) else fail-any)) in
        {181}let v_651: bitstring = catch-fail((if (success?(getpublickey(v_645)) && (success?(3-proj-3-tuple(v_646)) && success?(1-proj-3-tuple(v_646)))) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-2-tuple(v_647))))) then (if not-caught-fail(v_648) then (if not-caught-fail(v_650) then (v_650,v_648) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {182}let v_652: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_651),2-proj-3-tuple(v_646),3-proj-3-tuple(v_646)))) in
        {183}let v_653: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_651)) && success?(symmetricstatepack(1-proj-2-tuple(v_651),2-proj-3-tuple(v_646),3-proj-3-tuple(v_646)))) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-3-tuple(v_652))))) then symmetricstatepack(1-proj-3-tuple(v_652),2-proj-3-tuple(v_652),hash(3-proj-3-tuple(v_652),2-proj-2-tuple(v_651))) else fail-any) else fail-any)) in
        {184}let v_654: bitstring = catch-fail((if success?(getpublickey(v_645)) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-3-tuple(v_646))))) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-2-tuple(v_651))))) then (if not-caught-fail(v_653) then (v_653,2-proj-2-tuple(v_651)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {185}let v_655: bitstring = catch-fail(keypairunpack(v_645)) in
        {186}let v_656: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_654))) in
        {187}let v_657: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_656),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {188}let v_658: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_656),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {189}let v_659: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_656),(if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_624)) else fail-any) else fail-any))) in
        {190}let v_660: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_624)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_656))) then (if not-caught-fail(v_657) then (if not-caught-fail(v_658) then (if not-caught-fail(v_659) then (v_657,v_658,v_659) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {191}let v_661: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_624)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_624)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_654))) then (if (not-caught-fail(v_656) && success?(is-true(success?(1-proj-3-tuple(v_656))))) then (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-3-tuple(v_660))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_660)) then cipherstatepack(2-proj-3-tuple(v_660),minnonce) else fail-any),1-proj-3-tuple(v_660),3-proj-3-tuple(v_656)) else fail-any) else fail-any) else fail-any)) in
        {192}let v_662: bitstring = catch-fail(symmetricstateunpack(v_661)) in
        {193}let v_663: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_662),6-proj-7-tuple(v_624))) in
        {194}let v_664: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_662),6-proj-7-tuple(v_624))) in
        {195}let v_665: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_662),6-proj-7-tuple(v_624))) in
        {196}let v_666: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_624)) && success?(2-proj-3-tuple(v_662))) then (if not-caught-fail(v_663) then (if not-caught-fail(v_664) then (if not-caught-fail(v_665) then (v_663,v_664,v_665) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {197}let v_667: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_662),1-proj-3-tuple(v_666),3-proj-3-tuple(v_662)))) in
        {198}let v_668: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_666)) && success?(symmetricstatepack(1-proj-3-tuple(v_662),1-proj-3-tuple(v_666),3-proj-3-tuple(v_662)))) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-3-tuple(v_667))))) then symmetricstatepack(1-proj-3-tuple(v_667),2-proj-3-tuple(v_667),hash(3-proj-3-tuple(v_667),2-proj-3-tuple(v_666))) else fail-any) else fail-any))) in
        {199}let v_669: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_624)) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-3-tuple(v_662))))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then (if (not-caught-fail(v_668) && success?(is-true(success?(1-proj-3-tuple(v_668))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_666)) then cipherstatepack(3-proj-3-tuple(v_666),minnonce) else fail-any),1-proj-3-tuple(v_666),3-proj-3-tuple(v_668)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {200}let v_670: bitstring = catch-fail(symmetricstateunpack(v_669)) in
        {201}let v_671: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {202}let v_672: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_671),2-proj-2-tuple(v_671),3-proj-3-tuple(v_670),msg_a(alice,charlie,sid))) in
        {203}let v_673: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {204}let v_674: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_671))) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then cipherstatepack(1-proj-2-tuple(v_673),increment_nonce(2-proj-2-tuple(v_671))) else fail-any) else fail-any)) in
        {205}let v_675: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_670)) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if not-caught-fail(v_672) then (if not-caught-fail(v_674) then (v_674,v_672) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {206}let v_676: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) in
        {207}let v_677: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_675)) && success?(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then symmetricstatepack(1-proj-3-tuple(v_676),2-proj-3-tuple(v_676),hash(3-proj-3-tuple(v_676),2-proj-2-tuple(v_675))) else fail-any) else fail-any)) in
        {208}let v_678: bitstring = catch-fail((if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-2-tuple(v_675))))) then (if not-caught-fail(v_677) then (v_677,2-proj-2-tuple(v_675)) else fail-any) else fail-any) else fail-any)) in
        {209}let v_679: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_678),v_645,v_627,4-proj-7-tuple(v_624),5-proj-7-tuple(v_624),6-proj-7-tuple(v_624),7-proj-7-tuple(v_624))) in
        {210}let v_680: bitstring = catch-fail(concat3(v_628,2-proj-2-tuple(v_654),2-proj-2-tuple(v_678))) in
        {211}let v_681: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_678))) in
        {212}let v_682: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_681),zero)) in
        {213}let v_683: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_681),zero)) in
        {214}let v_684: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_681),zero)) in
        {215}let v_685: bitstring = catch-fail((if success?(2-proj-3-tuple(v_681)) then (if not-caught-fail(v_682) then (if not-caught-fail(v_683) then (if not-caught-fail(v_684) then (v_682,v_683,v_684) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {216}let v_686: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_685)) then cipherstatepack(1-proj-3-tuple(v_685),minnonce) else fail-any)) in
        {217}let v_687: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_685)) then cipherstatepack(2-proj-3-tuple(v_685),minnonce) else fail-any)) in
        {218}let v_688: bitstring = catch-fail((if success?(1-proj-2-tuple(v_678)) then (if (not-caught-fail(v_681) && success?(is-true(success?(1-proj-3-tuple(v_681))))) then (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-3-tuple(v_685))))) then (if not-caught-fail(v_686) then (if not-caught-fail(v_687) then (1-proj-2-tuple(v_678),v_686,v_687) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {219}let (hs_689: handshakestate,message_a_690: bitstring,cs1_691: cipherstate,cs2_692: cipherstate) = (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-7-tuple(v_624))))) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-3-tuple(v_625))))) then (if not-caught-fail(v_627) then (if not-caught-fail(v_628) then (if not-caught-fail(v_630) then (if not-caught-fail(v_636) then (if not-caught-fail(v_643) then (if not-caught-fail(v_645) then (if (not-caught-fail(v_654) && success?(is-true(success?(1-proj-2-tuple(v_654))))) then (if not-caught-fail(v_661) then (if not-caught-fail(v_669) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-2-tuple(v_678))))) then (if not-caught-fail(v_679) then (if not-caught-fail(v_680) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-3-tuple(v_688))))) then (v_679,v_680,2-proj-3-tuple(v_688),3-proj-3-tuple(v_688)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {220}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {221}insert statestore(alice,charlie,sid,statepack_b(hs_689,cs1_691,cs2_692));
        {222}out(pub, message_a_690)
    ) | (
        {224}!
        {244}get statestore(=alice,=charlie,=sid,statepack_b(hs_693: handshakestate,cs1_694: cipherstate,cs2_695: cipherstate)) in
        {225}let hs_696: handshakestate = handshakestatesetcs(hs_693,cs2_695) in
        {226}in(pub, message_b_697: bitstring);
        {227}let v_698: bitstring = catch-fail(handshakestateunpack(hs_696)) in
        {228}let v_699: bitstring = catch-fail(deconcat3(message_b_697)) in
        {229}let v_700: bool = catch-fail(true) in
        {230}let v_701: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_698))) in
        {231}let v_702: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_701))) in
        {232}let v_703: aead = catch-fail(decrypt(1-proj-2-tuple(v_702),2-proj-2-tuple(v_702),3-proj-3-tuple(v_701),3-proj-3-tuple(v_699))) in
        {233}let v_704: bitstring = catch-fail(aeadunpack(v_703)) in
        {234}let v_705: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_701))) in
        {235}let v_706: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_702))) && success?(1-proj-3-tuple(v_701))) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-2-tuple(v_705))))) then cipherstatepack(1-proj-2-tuple(v_705),increment_nonce(2-proj-2-tuple(v_702))) else fail-any) else fail-any)) in
        {236}let v_707: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_699)) && (success?(3-proj-3-tuple(v_701)) && success?(1-proj-3-tuple(v_701)))) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-2-tuple(v_702))))) then (if not-caught-fail(v_703) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then (if not-caught-fail(v_706) then (v_706,3-proj-3-tuple(v_704),1-proj-3-tuple(v_704)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {237}let v_708: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_707),2-proj-3-tuple(v_701),3-proj-3-tuple(v_701)))) in
        {238}let v_709: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_699)) && success?(symmetricstatepack(1-proj-3-tuple(v_707),2-proj-3-tuple(v_701),3-proj-3-tuple(v_701)))) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-3-tuple(v_708))))) then symmetricstatepack(1-proj-3-tuple(v_708),2-proj-3-tuple(v_708),hash(3-proj-3-tuple(v_708),3-proj-3-tuple(v_699))) else fail-any) else fail-any)) in
        {239}let v_710: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_699)) && success?(1-proj-7-tuple(v_698))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-3-tuple(v_707))))) then (if not-caught-fail(v_709) then (v_709,2-proj-3-tuple(v_707),3-proj-3-tuple(v_707)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {240}let v_711: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_710),2-proj-7-tuple(v_698),3-proj-7-tuple(v_698),4-proj-7-tuple(v_698),5-proj-7-tuple(v_698),6-proj-7-tuple(v_698),7-proj-7-tuple(v_698))) in
        {241}let (hs_712: handshakestate,plaintext_b_713: bitstring,valid_714: bool) = (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-7-tuple(v_698))))) then (if (not-caught-fail(v_699) && success?(is-true(success?(1-proj-3-tuple(v_699))))) then (if not-caught-fail(v_700) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-3-tuple(v_710))))) then (if (v_700 && 3-proj-3-tuple(v_710)) then (if not-caught-fail(v_711) then (v_711,2-proj-3-tuple(v_710),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {242}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_713);
        {243}insert statestore(alice,charlie,sid,statepack_c(hs_712,cs1_694,handshakestategetcs(hs_712)))
    ) | (
        {245}!
        {263}get statestore(=alice,=charlie,=sid,statepack_c(hs_715: handshakestate,cs1_716: cipherstate,cs2_717: cipherstate)) in
        {246}let hs_718: handshakestate = handshakestatesetcs(hs_715,cs1_716) in
        {247}let v_719: bitstring = catch-fail(handshakestateunpack(hs_718)) in
        {248}let v_720: bitstring = catch-fail((empty,empty,empty)) in
        {249}let v_721: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_719))) in
        {250}let v_722: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_721))) in
        {251}let v_723: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_722),2-proj-2-tuple(v_722),3-proj-3-tuple(v_721),msg_c(alice,charlie,sid))) in
        {252}let v_724: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_721))) in
        {253}let v_725: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_722))) && success?(1-proj-3-tuple(v_721))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-2-tuple(v_724))))) then cipherstatepack(1-proj-2-tuple(v_724),increment_nonce(2-proj-2-tuple(v_722))) else fail-any) else fail-any)) in
        {254}let v_726: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_721)) && success?(1-proj-3-tuple(v_721))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-2-tuple(v_722))))) then (if not-caught-fail(v_723) then (if not-caught-fail(v_725) then (v_725,v_723) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {255}let v_727: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_726),2-proj-3-tuple(v_721),3-proj-3-tuple(v_721)))) in
        {256}let v_728: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_726)) && success?(symmetricstatepack(1-proj-2-tuple(v_726),2-proj-3-tuple(v_721),3-proj-3-tuple(v_721)))) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-3-tuple(v_727))))) then symmetricstatepack(1-proj-3-tuple(v_727),2-proj-3-tuple(v_727),hash(3-proj-3-tuple(v_727),2-proj-2-tuple(v_726))) else fail-any) else fail-any)) in
        {257}let v_729: bitstring = catch-fail((if success?(1-proj-7-tuple(v_719)) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-3-tuple(v_721))))) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-2-tuple(v_726))))) then (if not-caught-fail(v_728) then (v_728,2-proj-2-tuple(v_726)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {258}let v_730: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_729),2-proj-7-tuple(v_719),3-proj-7-tuple(v_719),4-proj-7-tuple(v_719),5-proj-7-tuple(v_719),6-proj-7-tuple(v_719),7-proj-7-tuple(v_719))) in
        {259}let v_731: bitstring = catch-fail(concat3(1-proj-3-tuple(v_720),2-proj-3-tuple(v_720),2-proj-2-tuple(v_729))) in
        {260}let (hs_732: handshakestate,message_c_733: bitstring) = (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-7-tuple(v_719))))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-3-tuple(v_720))))) then (if (not-caught-fail(v_729) && success?(is-true(success?(1-proj-2-tuple(v_729))))) then (if not-caught-fail(v_730) then (if not-caught-fail(v_731) then (v_730,v_731) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {261}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {262}out(pub, message_c_733)
    ) | (
        {264}event LeakPsk(phase0,alice,charlie);
        {265}out(pub, key_psk(alice,charlie))
    ) | (
        {266}phase 1;
        {267}event LeakPsk(phase1,alice,charlie);
        {268}out(pub, key_psk(alice,charlie))
    ) | (
        {269}event LeakS(phase0,alice);
        {270}out(pub, key_s(alice))
    ) | (
        {271}phase 1;
        {272}event LeakS(phase1,alice);
        {273}out(pub, key_s(alice))
    )
) | (
    {274}let v_734: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
    {275}let s_735: keypair = (if not-caught-fail(v_734) then keypairpack(validkey(v_734),key_s(bob)) else fail-any) in
    {276}out(pub, getpublickey(s_735));
    (
        {277}let e_736: keypair = keypairpack(empty,empty) in
        {278}let rs_737: key = empty in
        {279}let re_738: key = empty in
        {280}let v_739: bitstring = catch-fail(hash(somename,empty)) in
        {281}let v_740: key = catch-fail(v_739) in
        {282}let v_741: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {283}let v_742: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_739) then (if not-caught-fail(v_740) then (if not-caught-fail(v_741) then symmetricstatepack(v_741,v_740,v_739) else fail-any) else fail-any) else fail-any))) in
        {284}let v_743: symmetricstate = catch-fail((if success?((if not-caught-fail(v_739) then (if not-caught-fail(v_740) then (if not-caught-fail(v_741) then symmetricstatepack(v_741,v_740,v_739) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_742) && success?(is-true(success?(1-proj-3-tuple(v_742))))) then symmetricstatepack(1-proj-3-tuple(v_742),2-proj-3-tuple(v_742),hash(3-proj-3-tuple(v_742),empty)) else fail-any) else fail-any)) in
        {285}let v_744: bitstring = catch-fail(symmetricstateunpack(v_743)) in
        {286}let v_745: symmetricstate = catch-fail((if success?(getpublickey(s_735)) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-3-tuple(v_744))))) then symmetricstatepack(1-proj-3-tuple(v_744),2-proj-3-tuple(v_744),hash(3-proj-3-tuple(v_744),getpublickey(s_735))) else fail-any) else fail-any)) in
        {287}let hs_746: handshakestate = (if not-caught-fail(v_743) then (if not-caught-fail(v_745) then handshakestatepack(v_745,s_735,e_736,rs_737,re_738,key_psk(alice,bob),false) else fail-any) else fail-any) in
        {288}insert statestore(bob,alice,sid,statepack_a(hs_746))
    ) | (
        {358}get statestore(=bob,=alice,=sid,statepack_a(hs_747: handshakestate)) in
        {289}in(pub, message_a_748: bitstring);
        {290}let v_749: bitstring = catch-fail(handshakestateunpack(hs_747)) in
        {291}let v_750: bitstring = catch-fail(deconcat3(message_a_748)) in
        {292}let v_751: bool = catch-fail(true) in
        {293}let v_752: key = catch-fail(1-proj-3-tuple(v_750)) in
        {294}let v_753: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_749))) in
        {295}let v_754: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_749)) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-3-tuple(v_753))))) then symmetricstatepack(1-proj-3-tuple(v_753),2-proj-3-tuple(v_753),hash(3-proj-3-tuple(v_753),v_752)) else fail-any) else fail-any)) in
        {296}let v_755: bitstring = catch-fail(symmetricstateunpack(v_754)) in
        {297}let v_756: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_755),v_752)) in
        {298}let v_757: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_755),v_752)) in
        {299}let v_758: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_755),v_752)) in
        {300}let v_759: bitstring = catch-fail((if success?(2-proj-3-tuple(v_755)) then (if not-caught-fail(v_756) then (if not-caught-fail(v_757) then (if not-caught-fail(v_758) then (v_756,v_757,v_758) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {301}let v_760: symmetricstate = catch-fail((if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-3-tuple(v_755))))) then (if (not-caught-fail(v_759) && success?(is-true(success?(1-proj-3-tuple(v_759))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_759)) then cipherstatepack(2-proj-3-tuple(v_759),minnonce) else fail-any),1-proj-3-tuple(v_759),3-proj-3-tuple(v_755)) else fail-any) else fail-any)) in
        {302}let v_761: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_749))) in
        {303}let v_762: bitstring = catch-fail(symmetricstateunpack(v_760)) in
        {304}let v_763: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_762),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),v_752) else fail-any) else fail-any))) in
        {305}let v_764: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_762),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),v_752) else fail-any) else fail-any))) in
        {306}let v_765: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_762),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),v_752) else fail-any) else fail-any))) in
        {307}let v_766: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),v_752) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_762))) then (if not-caught-fail(v_763) then (if not-caught-fail(v_764) then (if not-caught-fail(v_765) then (v_763,v_764,v_765) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {308}let v_767: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),v_752) else fail-any) else fail-any)) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-3-tuple(v_766))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_766)) then cipherstatepack(2-proj-3-tuple(v_766),minnonce) else fail-any),1-proj-3-tuple(v_766),3-proj-3-tuple(v_762)) else fail-any) else fail-any) else fail-any)) in
        {309}let v_768: bitstring = catch-fail(symmetricstateunpack(v_767)) in
        {310}let v_769: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_768))) in
        {311}let v_770: aead = catch-fail(decrypt(1-proj-2-tuple(v_769),2-proj-2-tuple(v_769),3-proj-3-tuple(v_768),2-proj-3-tuple(v_750))) in
        {312}let v_771: bitstring = catch-fail(aeadunpack(v_770)) in
        {313}let v_772: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_768))) in
        {314}let v_773: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_769))) && success?(1-proj-3-tuple(v_768))) then (if (not-caught-fail(v_772) && success?(is-true(success?(1-proj-2-tuple(v_772))))) then cipherstatepack(1-proj-2-tuple(v_772),increment_nonce(2-proj-2-tuple(v_769))) else fail-any) else fail-any)) in
        {315}let v_774: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_750)) && (success?(3-proj-3-tuple(v_768)) && success?(1-proj-3-tuple(v_768)))) then (if (not-caught-fail(v_769) && success?(is-true(success?(1-proj-2-tuple(v_769))))) then (if not-caught-fail(v_770) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-3-tuple(v_771))))) then (if not-caught-fail(v_773) then (v_773,3-proj-3-tuple(v_771),1-proj-3-tuple(v_771)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {316}let v_775: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_774),2-proj-3-tuple(v_768),3-proj-3-tuple(v_768)))) in
        {317}let v_776: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_750)) && success?(symmetricstatepack(1-proj-3-tuple(v_774),2-proj-3-tuple(v_768),3-proj-3-tuple(v_768)))) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-3-tuple(v_775))))) then symmetricstatepack(1-proj-3-tuple(v_775),2-proj-3-tuple(v_775),hash(3-proj-3-tuple(v_775),2-proj-3-tuple(v_750))) else fail-any) else fail-any)) in
        {318}let v_777: bitstring = catch-fail((if success?(2-proj-3-tuple(v_750)) then (if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-3-tuple(v_768))))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then (if not-caught-fail(v_776) then (v_776,2-proj-3-tuple(v_774),3-proj-3-tuple(v_774)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {319}let v_778: key = catch-fail(2-proj-3-tuple(v_777)) in
        {320}let v_779: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_749))) in
        {321}let v_780: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_777))) in
        {322}let v_781: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_780),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then dhexp(2-proj-2-tuple(v_779),v_778) else fail-any) else fail-any))) in
        {323}let v_782: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_780),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then dhexp(2-proj-2-tuple(v_779),v_778) else fail-any) else fail-any))) in
        {324}let v_783: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_780),(if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then dhexp(2-proj-2-tuple(v_779),v_778) else fail-any) else fail-any))) in
        {325}let v_784: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then dhexp(2-proj-2-tuple(v_779),v_778) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_780))) then (if not-caught-fail(v_781) then (if not-caught-fail(v_782) then (if not-caught-fail(v_783) then (v_781,v_782,v_783) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {326}let v_785: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_749)) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-2-tuple(v_779))))) then dhexp(2-proj-2-tuple(v_779),v_778) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_777))) then (if (not-caught-fail(v_780) && success?(is-true(success?(1-proj-3-tuple(v_780))))) then (if (not-caught-fail(v_784) && success?(is-true(success?(1-proj-3-tuple(v_784))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_784)) then cipherstatepack(2-proj-3-tuple(v_784),minnonce) else fail-any),1-proj-3-tuple(v_784),3-proj-3-tuple(v_780)) else fail-any) else fail-any) else fail-any)) in
        {327}let v_786: bitstring = catch-fail(symmetricstateunpack(v_785)) in
        {328}let v_787: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_786),6-proj-7-tuple(v_749))) in
        {329}let v_788: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_786),6-proj-7-tuple(v_749))) in
        {330}let v_789: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_786),6-proj-7-tuple(v_749))) in
        {331}let v_790: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_749)) && success?(2-proj-3-tuple(v_786))) then (if not-caught-fail(v_787) then (if not-caught-fail(v_788) then (if not-caught-fail(v_789) then (v_787,v_788,v_789) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {332}let v_791: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_786),1-proj-3-tuple(v_790),3-proj-3-tuple(v_786)))) in
        {333}let v_792: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_790)) && success?(symmetricstatepack(1-proj-3-tuple(v_786),1-proj-3-tuple(v_790),3-proj-3-tuple(v_786)))) then (if (not-caught-fail(v_791) && success?(is-true(success?(1-proj-3-tuple(v_791))))) then symmetricstatepack(1-proj-3-tuple(v_791),2-proj-3-tuple(v_791),hash(3-proj-3-tuple(v_791),2-proj-3-tuple(v_790))) else fail-any) else fail-any))) in
        {334}let v_793: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_749)) then (if (not-caught-fail(v_786) && success?(is-true(success?(1-proj-3-tuple(v_786))))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-3-tuple(v_792))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_790)) then cipherstatepack(3-proj-3-tuple(v_790),minnonce) else fail-any),1-proj-3-tuple(v_790),3-proj-3-tuple(v_792)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {335}let v_794: bitstring = catch-fail(symmetricstateunpack(v_793)) in
        {336}let v_795: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_794))) in
        {337}let v_796: aead = catch-fail(decrypt(1-proj-2-tuple(v_795),2-proj-2-tuple(v_795),3-proj-3-tuple(v_794),3-proj-3-tuple(v_750))) in
        {338}let v_797: bitstring = catch-fail(aeadunpack(v_796)) in
        {339}let v_798: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_794))) in
        {340}let v_799: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_795))) && success?(1-proj-3-tuple(v_794))) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-2-tuple(v_798))))) then cipherstatepack(1-proj-2-tuple(v_798),increment_nonce(2-proj-2-tuple(v_795))) else fail-any) else fail-any)) in
        {341}let v_800: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_750)) && (success?(3-proj-3-tuple(v_794)) && success?(1-proj-3-tuple(v_794)))) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-2-tuple(v_795))))) then (if not-caught-fail(v_796) then (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-3-tuple(v_797))))) then (if not-caught-fail(v_799) then (v_799,3-proj-3-tuple(v_797),1-proj-3-tuple(v_797)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {342}let v_801: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_800),2-proj-3-tuple(v_794),3-proj-3-tuple(v_794)))) in
        {343}let v_802: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_750)) && success?(symmetricstatepack(1-proj-3-tuple(v_800),2-proj-3-tuple(v_794),3-proj-3-tuple(v_794)))) then (if (not-caught-fail(v_801) && success?(is-true(success?(1-proj-3-tuple(v_801))))) then symmetricstatepack(1-proj-3-tuple(v_801),2-proj-3-tuple(v_801),hash(3-proj-3-tuple(v_801),3-proj-3-tuple(v_750))) else fail-any) else fail-any)) in
        {344}let v_803: bitstring = catch-fail((if success?(3-proj-3-tuple(v_750)) then (if (not-caught-fail(v_794) && success?(is-true(success?(1-proj-3-tuple(v_794))))) then (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-3-tuple(v_800))))) then (if not-caught-fail(v_802) then (v_802,2-proj-3-tuple(v_800),3-proj-3-tuple(v_800)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {345}let v_804: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
        {346}let v_805: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_803),2-proj-7-tuple(v_749),3-proj-7-tuple(v_749),v_778,v_752,6-proj-7-tuple(v_749),7-proj-7-tuple(v_749))) in
        {347}let v_806: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_803))) in
        {348}let v_807: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_806),zero)) in
        {349}let v_808: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_806),zero)) in
        {350}let v_809: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_806),zero)) in
        {351}let v_810: bitstring = catch-fail((if success?(2-proj-3-tuple(v_806)) then (if not-caught-fail(v_807) then (if not-caught-fail(v_808) then (if not-caught-fail(v_809) then (v_807,v_808,v_809) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {352}let v_811: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_810)) then cipherstatepack(1-proj-3-tuple(v_810),minnonce) else fail-any)) in
        {353}let v_812: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_810)) then cipherstatepack(2-proj-3-tuple(v_810),minnonce) else fail-any)) in
        {354}let v_813: bitstring = catch-fail((if success?(1-proj-3-tuple(v_803)) then (if (not-caught-fail(v_806) && success?(is-true(success?(1-proj-3-tuple(v_806))))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if not-caught-fail(v_811) then (if not-caught-fail(v_812) then (1-proj-3-tuple(v_803),v_811,v_812) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {355}let (hs_814: handshakestate,plaintext_a: bitstring,valid_815: bool,cs1_816: cipherstate,cs2_817: cipherstate) = (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-7-tuple(v_749))))) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then (if not-caught-fail(v_751) then (if not-caught-fail(v_752) then (if not-caught-fail(v_754) then (if not-caught-fail(v_760) then (if not-caught-fail(v_767) then (if (not-caught-fail(v_777) && success?(is-true(success?(1-proj-3-tuple(v_777))))) then (if not-caught-fail(v_778) then (if not-caught-fail(v_785) then (if not-caught-fail(v_793) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-3-tuple(v_803))))) then (if ((3-proj-3-tuple(v_777) && 3-proj-3-tuple(v_803)) && (v_778 = getpublickey((if not-caught-fail(v_804) then keypairpack(validkey(v_804),key_s(alice)) else fail-any)))) then (if not-caught-fail(v_805) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-3-tuple(v_813))))) then (v_805,2-proj-3-tuple(v_803),true,2-proj-3-tuple(v_813),3-proj-3-tuple(v_813)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {356}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {357}insert statestore(bob,alice,sid,statepack_b(hs_814,cs1_816,cs2_817))
    ) | (
        {359}!
        {378}get statestore(=bob,=alice,=sid,statepack_b(hs_818: handshakestate,cs1_819: cipherstate,cs2_820: cipherstate)) in
        {360}let hs_821: handshakestate = handshakestatesetcs(hs_818,cs2_820) in
        {361}let v_822: bitstring = catch-fail(handshakestateunpack(hs_821)) in
        {362}let v_823: bitstring = catch-fail((empty,empty,empty)) in
        {363}let v_824: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_822))) in
        {364}let v_825: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_824))) in
        {365}let v_826: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_825),2-proj-2-tuple(v_825),3-proj-3-tuple(v_824),msg_b(bob,alice,sid))) in
        {366}let v_827: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_824))) in
        {367}let v_828: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_825))) && success?(1-proj-3-tuple(v_824))) then (if (not-caught-fail(v_827) && success?(is-true(success?(1-proj-2-tuple(v_827))))) then cipherstatepack(1-proj-2-tuple(v_827),increment_nonce(2-proj-2-tuple(v_825))) else fail-any) else fail-any)) in
        {368}let v_829: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_824)) && success?(1-proj-3-tuple(v_824))) then (if (not-caught-fail(v_825) && success?(is-true(success?(1-proj-2-tuple(v_825))))) then (if not-caught-fail(v_826) then (if not-caught-fail(v_828) then (v_828,v_826) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {369}let v_830: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_829),2-proj-3-tuple(v_824),3-proj-3-tuple(v_824)))) in
        {370}let v_831: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_829)) && success?(symmetricstatepack(1-proj-2-tuple(v_829),2-proj-3-tuple(v_824),3-proj-3-tuple(v_824)))) then (if (not-caught-fail(v_830) && success?(is-true(success?(1-proj-3-tuple(v_830))))) then symmetricstatepack(1-proj-3-tuple(v_830),2-proj-3-tuple(v_830),hash(3-proj-3-tuple(v_830),2-proj-2-tuple(v_829))) else fail-any) else fail-any)) in
        {371}let v_832: bitstring = catch-fail((if success?(1-proj-7-tuple(v_822)) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-3-tuple(v_824))))) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-2-tuple(v_829))))) then (if not-caught-fail(v_831) then (v_831,2-proj-2-tuple(v_829)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {372}let v_833: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_832),2-proj-7-tuple(v_822),3-proj-7-tuple(v_822),4-proj-7-tuple(v_822),5-proj-7-tuple(v_822),6-proj-7-tuple(v_822),7-proj-7-tuple(v_822))) in
        {373}let v_834: bitstring = catch-fail(concat3(1-proj-3-tuple(v_823),2-proj-3-tuple(v_823),2-proj-2-tuple(v_832))) in
        {374}let (hs_835: handshakestate,message_b_836: bitstring) = (if (not-caught-fail(v_822) && success?(is-true(success?(1-proj-7-tuple(v_822))))) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-2-tuple(v_832))))) then (if not-caught-fail(v_833) then (if not-caught-fail(v_834) then (v_833,v_834) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {375}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {376}insert statestore(bob,alice,sid,statepack_c(hs_835,cs1_819,handshakestategetcs(hs_835)));
        {377}out(pub, message_b_836)
    ) | (
        {379}!
        {399}get statestore(=bob,=alice,=sid,statepack_c(hs_837: handshakestate,cs1_838: cipherstate,cs2_839: cipherstate)) in
        {380}let hs_840: handshakestate = handshakestatesetcs(hs_837,cs1_838) in
        {381}in(pub, message_c_841: bitstring);
        {382}let v_842: bitstring = catch-fail(handshakestateunpack(hs_840)) in
        {383}let v_843: bitstring = catch-fail(deconcat3(message_c_841)) in
        {384}let v_844: bool = catch-fail(true) in
        {385}let v_845: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_842))) in
        {386}let v_846: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_845))) in
        {387}let v_847: aead = catch-fail(decrypt(1-proj-2-tuple(v_846),2-proj-2-tuple(v_846),3-proj-3-tuple(v_845),3-proj-3-tuple(v_843))) in
        {388}let v_848: bitstring = catch-fail(aeadunpack(v_847)) in
        {389}let v_849: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_845))) in
        {390}let v_850: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_846))) && success?(1-proj-3-tuple(v_845))) then (if (not-caught-fail(v_849) && success?(is-true(success?(1-proj-2-tuple(v_849))))) then cipherstatepack(1-proj-2-tuple(v_849),increment_nonce(2-proj-2-tuple(v_846))) else fail-any) else fail-any)) in
        {391}let v_851: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_843)) && (success?(3-proj-3-tuple(v_845)) && success?(1-proj-3-tuple(v_845)))) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-2-tuple(v_846))))) then (if not-caught-fail(v_847) then (if (not-caught-fail(v_848) && success?(is-true(success?(1-proj-3-tuple(v_848))))) then (if not-caught-fail(v_850) then (v_850,3-proj-3-tuple(v_848),1-proj-3-tuple(v_848)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {392}let v_852: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_851),2-proj-3-tuple(v_845),3-proj-3-tuple(v_845)))) in
        {393}let v_853: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_843)) && success?(symmetricstatepack(1-proj-3-tuple(v_851),2-proj-3-tuple(v_845),3-proj-3-tuple(v_845)))) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-3-tuple(v_852))))) then symmetricstatepack(1-proj-3-tuple(v_852),2-proj-3-tuple(v_852),hash(3-proj-3-tuple(v_852),3-proj-3-tuple(v_843))) else fail-any) else fail-any)) in
        {394}let v_854: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_843)) && success?(1-proj-7-tuple(v_842))) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-3-tuple(v_845))))) then (if (not-caught-fail(v_851) && success?(is-true(success?(1-proj-3-tuple(v_851))))) then (if not-caught-fail(v_853) then (v_853,2-proj-3-tuple(v_851),3-proj-3-tuple(v_851)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {395}let v_855: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_854),2-proj-7-tuple(v_842),3-proj-7-tuple(v_842),4-proj-7-tuple(v_842),5-proj-7-tuple(v_842),6-proj-7-tuple(v_842),7-proj-7-tuple(v_842))) in
        {396}let (hs_856: handshakestate,plaintext_c: bitstring,valid_857: bool) = (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-7-tuple(v_842))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-3-tuple(v_843))))) then (if not-caught-fail(v_844) then (if (not-caught-fail(v_854) && success?(is-true(success?(1-proj-3-tuple(v_854))))) then (if (v_844 && 3-proj-3-tuple(v_854)) then (if not-caught-fail(v_855) then (v_855,2-proj-3-tuple(v_854),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {397}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {398}event RecvEnd(valid_857)
    ) | (
        {400}event LeakPsk(phase0,alice,bob);
        {401}out(pub, key_psk(alice,bob))
    ) | (
        {402}phase 1;
        {403}event LeakPsk(phase1,alice,bob);
        {404}out(pub, key_psk(alice,bob))
    ) | (
        {405}event LeakS(phase0,bob);
        {406}out(pub, key_s(bob))
    ) | (
        {407}phase 1;
        {408}event LeakS(phase1,bob);
        {409}out(pub, key_s(bob))
    )
) | (
    {410}let v_858: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
    {411}let s_859: keypair = (if not-caught-fail(v_858) then keypairpack(validkey(v_858),key_s(bob)) else fail-any) in
    {412}out(pub, getpublickey(s_859));
    (
        {413}let e_860: keypair = keypairpack(empty,empty) in
        {414}let rs_861: key = empty in
        {415}let re_862: key = empty in
        {416}let v_863: bitstring = catch-fail(hash(somename,empty)) in
        {417}let v_864: key = catch-fail(v_863) in
        {418}let v_865: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {419}let v_866: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_863) then (if not-caught-fail(v_864) then (if not-caught-fail(v_865) then symmetricstatepack(v_865,v_864,v_863) else fail-any) else fail-any) else fail-any))) in
        {420}let v_867: symmetricstate = catch-fail((if success?((if not-caught-fail(v_863) then (if not-caught-fail(v_864) then (if not-caught-fail(v_865) then symmetricstatepack(v_865,v_864,v_863) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then symmetricstatepack(1-proj-3-tuple(v_866),2-proj-3-tuple(v_866),hash(3-proj-3-tuple(v_866),empty)) else fail-any) else fail-any)) in
        {421}let v_868: bitstring = catch-fail(symmetricstateunpack(v_867)) in
        {422}let v_869: symmetricstate = catch-fail((if success?(getpublickey(s_859)) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-3-tuple(v_868))))) then symmetricstatepack(1-proj-3-tuple(v_868),2-proj-3-tuple(v_868),hash(3-proj-3-tuple(v_868),getpublickey(s_859))) else fail-any) else fail-any)) in
        {423}let hs_870: handshakestate = (if not-caught-fail(v_867) then (if not-caught-fail(v_869) then handshakestatepack(v_869,s_859,e_860,rs_861,re_862,key_psk(charlie,bob),false) else fail-any) else fail-any) in
        {424}insert statestore(bob,charlie,sid,statepack_a(hs_870))
    ) | (
        {494}get statestore(=bob,=charlie,=sid,statepack_a(hs_871: handshakestate)) in
        {425}in(pub, message_a_872: bitstring);
        {426}let v_873: bitstring = catch-fail(handshakestateunpack(hs_871)) in
        {427}let v_874: bitstring = catch-fail(deconcat3(message_a_872)) in
        {428}let v_875: bool = catch-fail(true) in
        {429}let v_876: key = catch-fail(1-proj-3-tuple(v_874)) in
        {430}let v_877: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_873))) in
        {431}let v_878: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_873)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-3-tuple(v_877))))) then symmetricstatepack(1-proj-3-tuple(v_877),2-proj-3-tuple(v_877),hash(3-proj-3-tuple(v_877),v_876)) else fail-any) else fail-any)) in
        {432}let v_879: bitstring = catch-fail(symmetricstateunpack(v_878)) in
        {433}let v_880: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_879),v_876)) in
        {434}let v_881: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_879),v_876)) in
        {435}let v_882: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_879),v_876)) in
        {436}let v_883: bitstring = catch-fail((if success?(2-proj-3-tuple(v_879)) then (if not-caught-fail(v_880) then (if not-caught-fail(v_881) then (if not-caught-fail(v_882) then (v_880,v_881,v_882) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {437}let v_884: symmetricstate = catch-fail((if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-3-tuple(v_879))))) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_883)) then cipherstatepack(2-proj-3-tuple(v_883),minnonce) else fail-any),1-proj-3-tuple(v_883),3-proj-3-tuple(v_879)) else fail-any) else fail-any)) in
        {438}let v_885: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_873))) in
        {439}let v_886: bitstring = catch-fail(symmetricstateunpack(v_884)) in
        {440}let v_887: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_886),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),v_876) else fail-any) else fail-any))) in
        {441}let v_888: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_886),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),v_876) else fail-any) else fail-any))) in
        {442}let v_889: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_886),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),v_876) else fail-any) else fail-any))) in
        {443}let v_890: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),v_876) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_886))) then (if not-caught-fail(v_887) then (if not-caught-fail(v_888) then (if not-caught-fail(v_889) then (v_887,v_888,v_889) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {444}let v_891: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),v_876) else fail-any) else fail-any)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-3-tuple(v_886))))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-3-tuple(v_890))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_890)) then cipherstatepack(2-proj-3-tuple(v_890),minnonce) else fail-any),1-proj-3-tuple(v_890),3-proj-3-tuple(v_886)) else fail-any) else fail-any) else fail-any)) in
        {445}let v_892: bitstring = catch-fail(symmetricstateunpack(v_891)) in
        {446}let v_893: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_892))) in
        {447}let v_894: aead = catch-fail(decrypt(1-proj-2-tuple(v_893),2-proj-2-tuple(v_893),3-proj-3-tuple(v_892),2-proj-3-tuple(v_874))) in
        {448}let v_895: bitstring = catch-fail(aeadunpack(v_894)) in
        {449}let v_896: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_892))) in
        {450}let v_897: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_893))) && success?(1-proj-3-tuple(v_892))) then (if (not-caught-fail(v_896) && success?(is-true(success?(1-proj-2-tuple(v_896))))) then cipherstatepack(1-proj-2-tuple(v_896),increment_nonce(2-proj-2-tuple(v_893))) else fail-any) else fail-any)) in
        {451}let v_898: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_874)) && (success?(3-proj-3-tuple(v_892)) && success?(1-proj-3-tuple(v_892)))) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-2-tuple(v_893))))) then (if not-caught-fail(v_894) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-3-tuple(v_895))))) then (if not-caught-fail(v_897) then (v_897,3-proj-3-tuple(v_895),1-proj-3-tuple(v_895)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {452}let v_899: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_898),2-proj-3-tuple(v_892),3-proj-3-tuple(v_892)))) in
        {453}let v_900: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_874)) && success?(symmetricstatepack(1-proj-3-tuple(v_898),2-proj-3-tuple(v_892),3-proj-3-tuple(v_892)))) then (if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-3-tuple(v_899))))) then symmetricstatepack(1-proj-3-tuple(v_899),2-proj-3-tuple(v_899),hash(3-proj-3-tuple(v_899),2-proj-3-tuple(v_874))) else fail-any) else fail-any)) in
        {454}let v_901: bitstring = catch-fail((if success?(2-proj-3-tuple(v_874)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-3-tuple(v_898))))) then (if not-caught-fail(v_900) then (v_900,2-proj-3-tuple(v_898),3-proj-3-tuple(v_898)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {455}let v_902: key = catch-fail(2-proj-3-tuple(v_901)) in
        {456}let v_903: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_873))) in
        {457}let v_904: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_901))) in
        {458}let v_905: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_904),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then dhexp(2-proj-2-tuple(v_903),v_902) else fail-any) else fail-any))) in
        {459}let v_906: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_904),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then dhexp(2-proj-2-tuple(v_903),v_902) else fail-any) else fail-any))) in
        {460}let v_907: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_904),(if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then dhexp(2-proj-2-tuple(v_903),v_902) else fail-any) else fail-any))) in
        {461}let v_908: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then dhexp(2-proj-2-tuple(v_903),v_902) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_904))) then (if not-caught-fail(v_905) then (if not-caught-fail(v_906) then (if not-caught-fail(v_907) then (v_905,v_906,v_907) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {462}let v_909: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_873)) then (if (not-caught-fail(v_903) && success?(is-true(success?(1-proj-2-tuple(v_903))))) then dhexp(2-proj-2-tuple(v_903),v_902) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_901))) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-3-tuple(v_904))))) then (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-3-tuple(v_908))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_908)) then cipherstatepack(2-proj-3-tuple(v_908),minnonce) else fail-any),1-proj-3-tuple(v_908),3-proj-3-tuple(v_904)) else fail-any) else fail-any) else fail-any)) in
        {463}let v_910: bitstring = catch-fail(symmetricstateunpack(v_909)) in
        {464}let v_911: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_910),6-proj-7-tuple(v_873))) in
        {465}let v_912: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_910),6-proj-7-tuple(v_873))) in
        {466}let v_913: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_910),6-proj-7-tuple(v_873))) in
        {467}let v_914: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_873)) && success?(2-proj-3-tuple(v_910))) then (if not-caught-fail(v_911) then (if not-caught-fail(v_912) then (if not-caught-fail(v_913) then (v_911,v_912,v_913) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {468}let v_915: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_910),1-proj-3-tuple(v_914),3-proj-3-tuple(v_910)))) in
        {469}let v_916: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_914)) && success?(symmetricstatepack(1-proj-3-tuple(v_910),1-proj-3-tuple(v_914),3-proj-3-tuple(v_910)))) then (if (not-caught-fail(v_915) && success?(is-true(success?(1-proj-3-tuple(v_915))))) then symmetricstatepack(1-proj-3-tuple(v_915),2-proj-3-tuple(v_915),hash(3-proj-3-tuple(v_915),2-proj-3-tuple(v_914))) else fail-any) else fail-any))) in
        {470}let v_917: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_873)) then (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-3-tuple(v_910))))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-3-tuple(v_914))))) then (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-3-tuple(v_916))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_914)) then cipherstatepack(3-proj-3-tuple(v_914),minnonce) else fail-any),1-proj-3-tuple(v_914),3-proj-3-tuple(v_916)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {471}let v_918: bitstring = catch-fail(symmetricstateunpack(v_917)) in
        {472}let v_919: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_918))) in
        {473}let v_920: aead = catch-fail(decrypt(1-proj-2-tuple(v_919),2-proj-2-tuple(v_919),3-proj-3-tuple(v_918),3-proj-3-tuple(v_874))) in
        {474}let v_921: bitstring = catch-fail(aeadunpack(v_920)) in
        {475}let v_922: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_918))) in
        {476}let v_923: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_919))) && success?(1-proj-3-tuple(v_918))) then (if (not-caught-fail(v_922) && success?(is-true(success?(1-proj-2-tuple(v_922))))) then cipherstatepack(1-proj-2-tuple(v_922),increment_nonce(2-proj-2-tuple(v_919))) else fail-any) else fail-any)) in
        {477}let v_924: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_874)) && (success?(3-proj-3-tuple(v_918)) && success?(1-proj-3-tuple(v_918)))) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then (if not-caught-fail(v_920) then (if (not-caught-fail(v_921) && success?(is-true(success?(1-proj-3-tuple(v_921))))) then (if not-caught-fail(v_923) then (v_923,3-proj-3-tuple(v_921),1-proj-3-tuple(v_921)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {478}let v_925: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_924),2-proj-3-tuple(v_918),3-proj-3-tuple(v_918)))) in
        {479}let v_926: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_874)) && success?(symmetricstatepack(1-proj-3-tuple(v_924),2-proj-3-tuple(v_918),3-proj-3-tuple(v_918)))) then (if (not-caught-fail(v_925) && success?(is-true(success?(1-proj-3-tuple(v_925))))) then symmetricstatepack(1-proj-3-tuple(v_925),2-proj-3-tuple(v_925),hash(3-proj-3-tuple(v_925),3-proj-3-tuple(v_874))) else fail-any) else fail-any)) in
        {480}let v_927: bitstring = catch-fail((if success?(3-proj-3-tuple(v_874)) then (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-3-tuple(v_918))))) then (if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-3-tuple(v_924))))) then (if not-caught-fail(v_926) then (v_926,2-proj-3-tuple(v_924),3-proj-3-tuple(v_924)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {481}let v_928: key = catch-fail(dhexp(key_s(charlie),validkey(g))) in
        {482}let v_929: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_927),2-proj-7-tuple(v_873),3-proj-7-tuple(v_873),v_902,v_876,6-proj-7-tuple(v_873),7-proj-7-tuple(v_873))) in
        {483}let v_930: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_927))) in
        {484}let v_931: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_930),zero)) in
        {485}let v_932: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_930),zero)) in
        {486}let v_933: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_930),zero)) in
        {487}let v_934: bitstring = catch-fail((if success?(2-proj-3-tuple(v_930)) then (if not-caught-fail(v_931) then (if not-caught-fail(v_932) then (if not-caught-fail(v_933) then (v_931,v_932,v_933) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {488}let v_935: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_934)) then cipherstatepack(1-proj-3-tuple(v_934),minnonce) else fail-any)) in
        {489}let v_936: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_934)) then cipherstatepack(2-proj-3-tuple(v_934),minnonce) else fail-any)) in
        {490}let v_937: bitstring = catch-fail((if success?(1-proj-3-tuple(v_927)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-3-tuple(v_930))))) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-3-tuple(v_934))))) then (if not-caught-fail(v_935) then (if not-caught-fail(v_936) then (1-proj-3-tuple(v_927),v_935,v_936) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {491}let (hs_938: handshakestate,plaintext_a_939: bitstring,valid_940: bool,cs1_941: cipherstate,cs2_942: cipherstate) = (if (not-caught-fail(v_873) && success?(is-true(success?(1-proj-7-tuple(v_873))))) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then (if not-caught-fail(v_875) then (if not-caught-fail(v_876) then (if not-caught-fail(v_878) then (if not-caught-fail(v_884) then (if not-caught-fail(v_891) then (if (not-caught-fail(v_901) && success?(is-true(success?(1-proj-3-tuple(v_901))))) then (if not-caught-fail(v_902) then (if not-caught-fail(v_909) then (if not-caught-fail(v_917) then (if (not-caught-fail(v_927) && success?(is-true(success?(1-proj-3-tuple(v_927))))) then (if ((3-proj-3-tuple(v_901) && 3-proj-3-tuple(v_927)) && (v_902 = getpublickey((if not-caught-fail(v_928) then keypairpack(validkey(v_928),key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_929) then (if (not-caught-fail(v_937) && success?(is-true(success?(1-proj-3-tuple(v_937))))) then (v_929,2-proj-3-tuple(v_927),true,2-proj-3-tuple(v_937),3-proj-3-tuple(v_937)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {492}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_939);
        {493}insert statestore(bob,charlie,sid,statepack_b(hs_938,cs1_941,cs2_942))
    ) | (
        {495}!
        {514}get statestore(=bob,=charlie,=sid,statepack_b(hs_943: handshakestate,cs1_944: cipherstate,cs2_945: cipherstate)) in
        {496}let hs_946: handshakestate = handshakestatesetcs(hs_943,cs2_945) in
        {497}let v_947: bitstring = catch-fail(handshakestateunpack(hs_946)) in
        {498}let v_948: bitstring = catch-fail((empty,empty,empty)) in
        {499}let v_949: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_947))) in
        {500}let v_950: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_949))) in
        {501}let v_951: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_950),2-proj-2-tuple(v_950),3-proj-3-tuple(v_949),msg_b(bob,charlie,sid))) in
        {502}let v_952: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_949))) in
        {503}let v_953: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_950))) && success?(1-proj-3-tuple(v_949))) then (if (not-caught-fail(v_952) && success?(is-true(success?(1-proj-2-tuple(v_952))))) then cipherstatepack(1-proj-2-tuple(v_952),increment_nonce(2-proj-2-tuple(v_950))) else fail-any) else fail-any)) in
        {504}let v_954: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_949)) && success?(1-proj-3-tuple(v_949))) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-2-tuple(v_950))))) then (if not-caught-fail(v_951) then (if not-caught-fail(v_953) then (v_953,v_951) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {505}let v_955: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_954),2-proj-3-tuple(v_949),3-proj-3-tuple(v_949)))) in
        {506}let v_956: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_954)) && success?(symmetricstatepack(1-proj-2-tuple(v_954),2-proj-3-tuple(v_949),3-proj-3-tuple(v_949)))) then (if (not-caught-fail(v_955) && success?(is-true(success?(1-proj-3-tuple(v_955))))) then symmetricstatepack(1-proj-3-tuple(v_955),2-proj-3-tuple(v_955),hash(3-proj-3-tuple(v_955),2-proj-2-tuple(v_954))) else fail-any) else fail-any)) in
        {507}let v_957: bitstring = catch-fail((if success?(1-proj-7-tuple(v_947)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-3-tuple(v_949))))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-2-tuple(v_954))))) then (if not-caught-fail(v_956) then (v_956,2-proj-2-tuple(v_954)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {508}let v_958: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_957),2-proj-7-tuple(v_947),3-proj-7-tuple(v_947),4-proj-7-tuple(v_947),5-proj-7-tuple(v_947),6-proj-7-tuple(v_947),7-proj-7-tuple(v_947))) in
        {509}let v_959: bitstring = catch-fail(concat3(1-proj-3-tuple(v_948),2-proj-3-tuple(v_948),2-proj-2-tuple(v_957))) in
        {510}let (hs_960: handshakestate,message_b_961: bitstring) = (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-7-tuple(v_947))))) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-3-tuple(v_948))))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then (if not-caught-fail(v_958) then (if not-caught-fail(v_959) then (v_958,v_959) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {511}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {512}insert statestore(bob,charlie,sid,statepack_c(hs_960,cs1_944,handshakestategetcs(hs_960)));
        {513}out(pub, message_b_961)
    ) | (
        {515}!
        {535}get statestore(=bob,=charlie,=sid,statepack_c(hs_962: handshakestate,cs1_963: cipherstate,cs2_964: cipherstate)) in
        {516}let hs_965: handshakestate = handshakestatesetcs(hs_962,cs1_963) in
        {517}in(pub, message_c_966: bitstring);
        {518}let v_967: bitstring = catch-fail(handshakestateunpack(hs_965)) in
        {519}let v_968: bitstring = catch-fail(deconcat3(message_c_966)) in
        {520}let v_969: bool = catch-fail(true) in
        {521}let v_970: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_967))) in
        {522}let v_971: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_970))) in
        {523}let v_972: aead = catch-fail(decrypt(1-proj-2-tuple(v_971),2-proj-2-tuple(v_971),3-proj-3-tuple(v_970),3-proj-3-tuple(v_968))) in
        {524}let v_973: bitstring = catch-fail(aeadunpack(v_972)) in
        {525}let v_974: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_970))) in
        {526}let v_975: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_971))) && success?(1-proj-3-tuple(v_970))) then (if (not-caught-fail(v_974) && success?(is-true(success?(1-proj-2-tuple(v_974))))) then cipherstatepack(1-proj-2-tuple(v_974),increment_nonce(2-proj-2-tuple(v_971))) else fail-any) else fail-any)) in
        {527}let v_976: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_968)) && (success?(3-proj-3-tuple(v_970)) && success?(1-proj-3-tuple(v_970)))) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-2-tuple(v_971))))) then (if not-caught-fail(v_972) then (if (not-caught-fail(v_973) && success?(is-true(success?(1-proj-3-tuple(v_973))))) then (if not-caught-fail(v_975) then (v_975,3-proj-3-tuple(v_973),1-proj-3-tuple(v_973)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {528}let v_977: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_976),2-proj-3-tuple(v_970),3-proj-3-tuple(v_970)))) in
        {529}let v_978: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_968)) && success?(symmetricstatepack(1-proj-3-tuple(v_976),2-proj-3-tuple(v_970),3-proj-3-tuple(v_970)))) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-3-tuple(v_977))))) then symmetricstatepack(1-proj-3-tuple(v_977),2-proj-3-tuple(v_977),hash(3-proj-3-tuple(v_977),3-proj-3-tuple(v_968))) else fail-any) else fail-any)) in
        {530}let v_979: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_968)) && success?(1-proj-7-tuple(v_967))) then (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-3-tuple(v_970))))) then (if (not-caught-fail(v_976) && success?(is-true(success?(1-proj-3-tuple(v_976))))) then (if not-caught-fail(v_978) then (v_978,2-proj-3-tuple(v_976),3-proj-3-tuple(v_976)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {531}let v_980: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_979),2-proj-7-tuple(v_967),3-proj-7-tuple(v_967),4-proj-7-tuple(v_967),5-proj-7-tuple(v_967),6-proj-7-tuple(v_967),7-proj-7-tuple(v_967))) in
        {532}let (hs_981: handshakestate,plaintext_c_982: bitstring,valid_983: bool) = (if (not-caught-fail(v_967) && success?(is-true(success?(1-proj-7-tuple(v_967))))) then (if (not-caught-fail(v_968) && success?(is-true(success?(1-proj-3-tuple(v_968))))) then (if not-caught-fail(v_969) then (if (not-caught-fail(v_979) && success?(is-true(success?(1-proj-3-tuple(v_979))))) then (if (v_969 && 3-proj-3-tuple(v_979)) then (if not-caught-fail(v_980) then (v_980,2-proj-3-tuple(v_979),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {533}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_982);
        {534}event RecvEnd(valid_983)
    ) | (
        {536}event LeakPsk(phase0,charlie,bob);
        {537}out(pub, key_psk(charlie,bob))
    ) | (
        {538}phase 1;
        {539}event LeakPsk(phase1,charlie,bob);
        {540}out(pub, key_psk(charlie,bob))
    ) | (
        {541}event LeakS(phase0,bob);
        {542}out(pub, key_s(bob))
    ) | (
        {543}phase 1;
        {544}event LeakS(phase1,bob);
        {545}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1101,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1101,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,bob)) && event(LeakPsk(phase1,alice,bob))); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,bob)) && event(LeakPsk(phase1,alice,bob)) && event(LeakS(p,alice)) && event(LeakPsk(p,alice,bob))); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1101,stagepack_b(sid_b),m)) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1101,stagepack_b(sid_b),m)) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,alice)) && event(LeakPsk(phase1,alice,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,alice)) && event(LeakPsk(phase1,alice,bob)) && event(LeakS(p,bob)) && event(LeakPsk(p,alice,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1101,stagepack_c(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1101,stagepack_c(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,bob)) && event(LeakPsk(phase1,alice,bob))); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase1,bob)) && event(LeakPsk(phase1,alice,bob)) && event(LeakS(p,alice)) && event(LeakPsk(p,alice,bob))); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 127 rules in the queue.
400 rules inserted. The rule base contains 387 rules. 142 rules in the queue.
600 rules inserted. The rule base contains 561 rules. 135 rules in the queue.
800 rules inserted. The rule base contains 761 rules. 197 rules in the queue.
1000 rules inserted. The rule base contains 921 rules. 216 rules in the queue.
1200 rules inserted. The rule base contains 1068 rules. 234 rules in the queue.
1400 rules inserted. The rule base contains 1201 rules. 204 rules in the queue.
1600 rules inserted. The rule base contains 1345 rules. 230 rules in the queue.
1800 rules inserted. The rule base contains 1488 rules. 231 rules in the queue.
2000 rules inserted. The rule base contains 1627 rules. 248 rules in the queue.
2200 rules inserted. The rule base contains 1734 rules. 259 rules in the queue.
2400 rules inserted. The rule base contains 1886 rules. 259 rules in the queue.
2600 rules inserted. The rule base contains 2006 rules. 234 rules in the queue.
2800 rules inserted. The rule base contains 2174 rules. 252 rules in the queue.
3000 rules inserted. The rule base contains 2319 rules. 283 rules in the queue.
3200 rules inserted. The rule base contains 2487 rules. 344 rules in the queue.
3400 rules inserted. The rule base contains 2564 rules. 390 rules in the queue.
3600 rules inserted. The rule base contains 2648 rules. 398 rules in the queue.
3800 rules inserted. The rule base contains 2742 rules. 425 rules in the queue.
4000 rules inserted. The rule base contains 2773 rules. 428 rules in the queue.
4200 rules inserted. The rule base contains 2810 rules. 408 rules in the queue.
4400 rules inserted. The rule base contains 2864 rules. 441 rules in the queue.
4600 rules inserted. The rule base contains 2965 rules. 440 rules in the queue.
4800 rules inserted. The rule base contains 3005 rules. 437 rules in the queue.
5000 rules inserted. The rule base contains 3109 rules. 422 rules in the queue.
5200 rules inserted. The rule base contains 3172 rules. 412 rules in the queue.
5400 rules inserted. The rule base contains 3233 rules. 370 rules in the queue.
5600 rules inserted. The rule base contains 3317 rules. 403 rules in the queue.
5800 rules inserted. The rule base contains 3410 rules. 395 rules in the queue.
6000 rules inserted. The rule base contains 3526 rules. 400 rules in the queue.
6200 rules inserted. The rule base contains 3655 rules. 389 rules in the queue.
6400 rules inserted. The rule base contains 3755 rules. 387 rules in the queue.
6600 rules inserted. The rule base contains 3879 rules. 358 rules in the queue.
6800 rules inserted. The rule base contains 3943 rules. 384 rules in the queue.
7000 rules inserted. The rule base contains 4025 rules. 427 rules in the queue.
7200 rules inserted. The rule base contains 4151 rules. 492 rules in the queue.
7400 rules inserted. The rule base contains 4254 rules. 570 rules in the queue.
7600 rules inserted. The rule base contains 4371 rules. 593 rules in the queue.
7800 rules inserted. The rule base contains 4493 rules. 627 rules in the queue.
8000 rules inserted. The rule base contains 4636 rules. 700 rules in the queue.
8200 rules inserted. The rule base contains 4777 rules. 680 rules in the queue.
8400 rules inserted. The rule base contains 4910 rules. 661 rules in the queue.
8600 rules inserted. The rule base contains 5040 rules. 658 rules in the queue.
8800 rules inserted. The rule base contains 5102 rules. 545 rules in the queue.
9000 rules inserted. The rule base contains 5231 rules. 566 rules in the queue.
9200 rules inserted. The rule base contains 5373 rules. 580 rules in the queue.
9400 rules inserted. The rule base contains 5491 rules. 594 rules in the queue.
9600 rules inserted. The rule base contains 5636 rules. 636 rules in the queue.
9800 rules inserted. The rule base contains 5803 rules. 686 rules in the queue.
10000 rules inserted. The rule base contains 5955 rules. 718 rules in the queue.
10200 rules inserted. The rule base contains 6102 rules. 756 rules in the queue.
10400 rules inserted. The rule base contains 6221 rules. 788 rules in the queue.
10600 rules inserted. The rule base contains 6358 rules. 797 rules in the queue.
10800 rules inserted. The rule base contains 6522 rules. 810 rules in the queue.
11000 rules inserted. The rule base contains 6664 rules. 837 rules in the queue.
11200 rules inserted. The rule base contains 6809 rules. 861 rules in the queue.
11400 rules inserted. The rule base contains 6958 rules. 843 rules in the queue.
11600 rules inserted. The rule base contains 7129 rules. 864 rules in the queue.
11800 rules inserted. The rule base contains 7277 rules. 887 rules in the queue.
12000 rules inserted. The rule base contains 7437 rules. 914 rules in the queue.
12200 rules inserted. The rule base contains 7632 rules. 936 rules in the queue.
12400 rules inserted. The rule base contains 7790 rules. 952 rules in the queue.
12600 rules inserted. The rule base contains 7939 rules. 989 rules in the queue.
12800 rules inserted. The rule base contains 8070 rules. 1017 rules in the queue.
13000 rules inserted. The rule base contains 8270 rules. 1048 rules in the queue.
13200 rules inserted. The rule base contains 8448 rules. 1052 rules in the queue.
13400 rules inserted. The rule base contains 8631 rules. 1086 rules in the queue.
13600 rules inserted. The rule base contains 8750 rules. 1123 rules in the queue.
13800 rules inserted. The rule base contains 8876 rules. 1155 rules in the queue.
14000 rules inserted. The rule base contains 9076 rules. 1182 rules in the queue.
14200 rules inserted. The rule base contains 9261 rules. 1197 rules in the queue.
14400 rules inserted. The rule base contains 9449 rules. 1244 rules in the queue.
14600 rules inserted. The rule base contains 9595 rules. 1275 rules in the queue.
14800 rules inserted. The rule base contains 9715 rules. 1304 rules in the queue.
15000 rules inserted. The rule base contains 9847 rules. 1359 rules in the queue.
15200 rules inserted. The rule base contains 10047 rules. 1395 rules in the queue.
15400 rules inserted. The rule base contains 10217 rules. 1441 rules in the queue.
15600 rules inserted. The rule base contains 10387 rules. 1475 rules in the queue.
15800 rules inserted. The rule base contains 10527 rules. 1500 rules in the queue.
16000 rules inserted. The rule base contains 10626 rules. 1521 rules in the queue.
16200 rules inserted. The rule base contains 10710 rules. 1527 rules in the queue.
16400 rules inserted. The rule base contains 10884 rules. 1547 rules in the queue.
16600 rules inserted. The rule base contains 11076 rules. 1607 rules in the queue.
16800 rules inserted. The rule base contains 11214 rules. 1606 rules in the queue.
17000 rules inserted. The rule base contains 11358 rules. 1626 rules in the queue.
17200 rules inserted. The rule base contains 11494 rules. 1636 rules in the queue.
17400 rules inserted. The rule base contains 11572 rules. 1636 rules in the queue.
17600 rules inserted. The rule base contains 11641 rules. 1637 rules in the queue.
17800 rules inserted. The rule base contains 11754 rules. 1653 rules in the queue.
18000 rules inserted. The rule base contains 11921 rules. 1654 rules in the queue.
18200 rules inserted. The rule base contains 12060 rules. 1664 rules in the queue.
18400 rules inserted. The rule base contains 12191 rules. 1681 rules in the queue.
18600 rules inserted. The rule base contains 12298 rules. 1682 rules in the queue.
18800 rules inserted. The rule base contains 12384 rules. 1677 rules in the queue.
19000 rules inserted. The rule base contains 12457 rules. 1674 rules in the queue.
19200 rules inserted. The rule base contains 12513 rules. 1679 rules in the queue.
19400 rules inserted. The rule base contains 12588 rules. 1673 rules in the queue.
19600 rules inserted. The rule base contains 12707 rules. 1686 rules in the queue.
19800 rules inserted. The rule base contains 12775 rules. 1675 rules in the queue.
20000 rules inserted. The rule base contains 12869 rules. 1668 rules in the queue.
20200 rules inserted. The rule base contains 12942 rules. 1662 rules in the queue.
20400 rules inserted. The rule base contains 13034 rules. 1676 rules in the queue.
20600 rules inserted. The rule base contains 13129 rules. 1679 rules in the queue.
20800 rules inserted. The rule base contains 13189 rules. 1695 rules in the queue.
21000 rules inserted. The rule base contains 13243 rules. 1680 rules in the queue.
21200 rules inserted. The rule base contains 13313 rules. 1675 rules in the queue.
21400 rules inserted. The rule base contains 13429 rules. 1687 rules in the queue.
21600 rules inserted. The rule base contains 13528 rules. 1689 rules in the queue.
21800 rules inserted. The rule base contains 13628 rules. 1689 rules in the queue.
22000 rules inserted. The rule base contains 13729 rules. 1702 rules in the queue.
22200 rules inserted. The rule base contains 13816 rules. 1734 rules in the queue.
22400 rules inserted. The rule base contains 13956 rules. 1755 rules in the queue.
22600 rules inserted. The rule base contains 14051 rules. 1752 rules in the queue.
22800 rules inserted. The rule base contains 14198 rules. 1769 rules in the queue.
23000 rules inserted. The rule base contains 14345 rules. 1776 rules in the queue.
23200 rules inserted. The rule base contains 14477 rules. 1779 rules in the queue.
23400 rules inserted. The rule base contains 14571 rules. 1813 rules in the queue.
23600 rules inserted. The rule base contains 14664 rules. 1830 rules in the queue.
23800 rules inserted. The rule base contains 14725 rules. 1862 rules in the queue.
24000 rules inserted. The rule base contains 14881 rules. 1916 rules in the queue.
24200 rules inserted. The rule base contains 15047 rules. 1941 rules in the queue.
24400 rules inserted. The rule base contains 15215 rules. 1969 rules in the queue.
24600 rules inserted. The rule base contains 15376 rules. 2015 rules in the queue.
24800 rules inserted. The rule base contains 15521 rules. 2042 rules in the queue.
25000 rules inserted. The rule base contains 15664 rules. 2044 rules in the queue.
25200 rules inserted. The rule base contains 15779 rules. 2061 rules in the queue.
25400 rules inserted. The rule base contains 15875 rules. 2085 rules in the queue.
25600 rules inserted. The rule base contains 15958 rules. 2114 rules in the queue.
25800 rules inserted. The rule base contains 16063 rules. 2144 rules in the queue.
26000 rules inserted. The rule base contains 16220 rules. 2189 rules in the queue.
26200 rules inserted. The rule base contains 16393 rules. 2191 rules in the queue.
26400 rules inserted. The rule base contains 16511 rules. 2195 rules in the queue.
26600 rules inserted. The rule base contains 16649 rules. 2235 rules in the queue.
26800 rules inserted. The rule base contains 16776 rules. 2257 rules in the queue.
27000 rules inserted. The rule base contains 16864 rules. 2261 rules in the queue.
27200 rules inserted. The rule base contains 16960 rules. 2291 rules in the queue.
27400 rules inserted. The rule base contains 17084 rules. 2315 rules in the queue.
27600 rules inserted. The rule base contains 17145 rules. 2320 rules in the queue.
27800 rules inserted. The rule base contains 17231 rules. 2324 rules in the queue.
28000 rules inserted. The rule base contains 17335 rules. 2352 rules in the queue.
28200 rules inserted. The rule base contains 17516 rules. 2396 rules in the queue.
28400 rules inserted. The rule base contains 17630 rules. 2402 rules in the queue.
28600 rules inserted. The rule base contains 17741 rules. 2418 rules in the queue.
28800 rules inserted. The rule base contains 17903 rules. 2433 rules in the queue.
29000 rules inserted. The rule base contains 18001 rules. 2459 rules in the queue.
29200 rules inserted. The rule base contains 18118 rules. 2467 rules in the queue.
29400 rules inserted. The rule base contains 18226 rules. 2488 rules in the queue.
29600 rules inserted. The rule base contains 18341 rules. 2501 rules in the queue.
29800 rules inserted. The rule base contains 18415 rules. 2486 rules in the queue.
30000 rules inserted. The rule base contains 18482 rules. 2491 rules in the queue.
30200 rules inserted. The rule base contains 18615 rules. 2527 rules in the queue.
30400 rules inserted. The rule base contains 18770 rules. 2575 rules in the queue.
30600 rules inserted. The rule base contains 18940 rules. 2595 rules in the queue.
30800 rules inserted. The rule base contains 19065 rules. 2620 rules in the queue.
31000 rules inserted. The rule base contains 19172 rules. 2629 rules in the queue.
31200 rules inserted. The rule base contains 19333 rules. 2631 rules in the queue.
31400 rules inserted. The rule base contains 19439 rules. 2656 rules in the queue.
31600 rules inserted. The rule base contains 19559 rules. 2629 rules in the queue.
31800 rules inserted. The rule base contains 19661 rules. 2634 rules in the queue.
32000 rules inserted. The rule base contains 19783 rules. 2644 rules in the queue.
32200 rules inserted. The rule base contains 19858 rules. 2637 rules in the queue.
32400 rules inserted. The rule base contains 19937 rules. 2546 rules in the queue.
32600 rules inserted. The rule base contains 20091 rules. 2587 rules in the queue.
32800 rules inserted. The rule base contains 20244 rules. 2622 rules in the queue.
33000 rules inserted. The rule base contains 20404 rules. 2629 rules in the queue.
33200 rules inserted. The rule base contains 20550 rules. 2622 rules in the queue.
33400 rules inserted. The rule base contains 20696 rules. 2610 rules in the queue.
33600 rules inserted. The rule base contains 20826 rules. 2609 rules in the queue.
33800 rules inserted. The rule base contains 20951 rules. 2595 rules in the queue.
34000 rules inserted. The rule base contains 21067 rules. 2574 rules in the queue.
34200 rules inserted. The rule base contains 21195 rules. 2512 rules in the queue.
34400 rules inserted. The rule base contains 21296 rules. 2506 rules in the queue.
34600 rules inserted. The rule base contains 21399 rules. 2474 rules in the queue.
34800 rules inserted. The rule base contains 21333 rules. 2326 rules in the queue.
35000 rules inserted. The rule base contains 21501 rules. 2403 rules in the queue.
35200 rules inserted. The rule base contains 21649 rules. 2410 rules in the queue.
35400 rules inserted. The rule base contains 21806 rules. 2438 rules in the queue.
35600 rules inserted. The rule base contains 21955 rules. 2388 rules in the queue.
35800 rules inserted. The rule base contains 22105 rules. 2344 rules in the queue.
36000 rules inserted. The rule base contains 22229 rules. 2211 rules in the queue.
36200 rules inserted. The rule base contains 22365 rules. 2175 rules in the queue.
36400 rules inserted. The rule base contains 22479 rules. 2123 rules in the queue.
