File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 234, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 235, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 235, character 36:
Warning: identifier h rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 274, character 6:
Warning: identifier e rebound.
File "XX.noise.active.pv", line 275, characters 6-7:
Warning: identifier ne rebound.
File "XX.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 278, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 278, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 279, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 286, character 6:
Warning: identifier e rebound.
File "XX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ne rebound.
File "XX.noise.active.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "XX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 302, character 6:
Warning: identifier s rebound.
File "XX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XX.noise.active.pv", line 304, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 314, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 314, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 315, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 331, characters 6-7:
Warning: identifier re rebound.
File "XX.noise.active.pv", line 332, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 334, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 336, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 344, characters 6-7:
Warning: identifier re rebound.
File "XX.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 347, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 348, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 348, characters 48-53:
Warning: identifier valid1 rebound.
File "XX.noise.active.pv", line 349, characters 6-7:
Warning: identifier rs rebound.
File "XX.noise.active.pv", line 350, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 351, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 353, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 361, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 361, characters 48-53:
Warning: identifier valid1 rebound.
File "XX.noise.active.pv", line 362, characters 6-7:
Warning: identifier rs rebound.
File "XX.noise.active.pv", line 363, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 375, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 377, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 385, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 387, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 559, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 560, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 550, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 552, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 375, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 377, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 543, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 302, character 6:
Warning: identifier s rebound.
File "XX.noise.active.pv", line 303, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 303, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XX.noise.active.pv", line 304, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 536, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 344, characters 6-7:
Warning: identifier re rebound.
File "XX.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 347, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 348, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 348, characters 48-53:
Warning: identifier valid1 rebound.
File "XX.noise.active.pv", line 349, characters 6-7:
Warning: identifier rs rebound.
File "XX.noise.active.pv", line 350, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 351, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 353, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 528, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 274, character 6:
Warning: identifier e rebound.
File "XX.noise.active.pv", line 275, characters 6-7:
Warning: identifier ne rebound.
File "XX.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 278, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 278, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 279, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 618, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 620, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 385, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 387, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 610, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 611, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 314, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 314, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 315, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 603, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 361, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 361, characters 48-53:
Warning: identifier valid1 rebound.
File "XX.noise.active.pv", line 362, characters 6-7:
Warning: identifier rs rebound.
File "XX.noise.active.pv", line 363, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 595, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 286, character 6:
Warning: identifier e rebound.
File "XX.noise.active.pv", line 287, characters 6-7:
Warning: identifier ne rebound.
File "XX.noise.active.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 291, character 6:
Warning: identifier s rebound.
File "XX.noise.active.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 292, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XX.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 294, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XX.noise.active.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 225, characters 7-8:
Warning: identifier ck rebound.
File "XX.noise.active.pv", line 244, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 245, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 588, characters 8-9:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 331, characters 6-7:
Warning: identifier re rebound.
File "XX.noise.active.pv", line 332, characters 6-7:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 334, characters 7-8:
Warning: identifier ss rebound.
File "XX.noise.active.pv", line 336, characters 7-8:
Warning: identifier hs rebound.
File "XX.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XX.noise.active.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_575: keypair = keypairpack(empty,empty) in
    {5}out(pub, getpublickey(s_575));
    (
        {6}let e_576: keypair = keypairpack(empty,empty) in
        {7}let rs_577: key = empty in
        {8}let re_578: key = empty in
        {9}let v_579: bitstring = catch-fail(hash(somename,empty)) in
        {10}let v_580: key = catch-fail(v_579) in
        {11}let v_581: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {12}let v_582: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (if not-caught-fail(v_581) then symmetricstatepack(v_581,v_580,v_579) else fail-any) else fail-any) else fail-any))) in
        {13}let v_583: symmetricstate = catch-fail((if success?((if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (if not-caught-fail(v_581) then symmetricstatepack(v_581,v_580,v_579) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_582) && success?(is-true(success?(1-proj-3-tuple(v_582))))) then symmetricstatepack(1-proj-3-tuple(v_582),2-proj-3-tuple(v_582),hash(3-proj-3-tuple(v_582),empty)) else fail-any) else fail-any)) in
        {14}let hs: handshakestate = (if not-caught-fail(v_583) then handshakestatepack(v_583,s_575,e_576,rs_577,re_578,empty,true) else fail-any) in
        {15}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {38}get statestore(=alice,=bob,=sid,statepack_a(hs_584: handshakestate)) in
        {16}let v_585: bitstring = catch-fail(handshakestateunpack(hs_584)) in
        {17}let v_586: bitstring = catch-fail((empty,empty,empty)) in
        {18}let v_587: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {19}let v_588: keypair = catch-fail((if not-caught-fail(v_587) then keypairpack(v_587,key_e(alice,bob,sid)) else fail-any)) in
        {20}let v_589: bitstring = catch-fail(getpublickey(v_588)) in
        {21}let v_590: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_585))) in
        {22}let v_591: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_585)) then (if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then symmetricstatepack(1-proj-3-tuple(v_590),2-proj-3-tuple(v_590),hash(3-proj-3-tuple(v_590),v_589)) else fail-any) else fail-any)) in
        {23}let v_592: bitstring = catch-fail(symmetricstateunpack(v_591)) in
        {24}let v_593: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_592))) in
        {25}let v_594: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_593),2-proj-2-tuple(v_593),3-proj-3-tuple(v_592),msg_a(alice,bob,sid))) in
        {26}let v_595: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_592))) in
        {27}let v_596: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_593))) && success?(1-proj-3-tuple(v_592))) then (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-2-tuple(v_595))))) then cipherstatepack(1-proj-2-tuple(v_595),increment_nonce(2-proj-2-tuple(v_593))) else fail-any) else fail-any)) in
        {28}let v_597: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_592)) && success?(1-proj-3-tuple(v_592))) then (if (not-caught-fail(v_593) && success?(is-true(success?(1-proj-2-tuple(v_593))))) then (if not-caught-fail(v_594) then (if not-caught-fail(v_596) then (v_596,v_594) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {29}let v_598: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_597),2-proj-3-tuple(v_592),3-proj-3-tuple(v_592)))) in
        {30}let v_599: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_597)) && success?(symmetricstatepack(1-proj-2-tuple(v_597),2-proj-3-tuple(v_592),3-proj-3-tuple(v_592)))) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-3-tuple(v_598))))) then symmetricstatepack(1-proj-3-tuple(v_598),2-proj-3-tuple(v_598),hash(3-proj-3-tuple(v_598),2-proj-2-tuple(v_597))) else fail-any) else fail-any)) in
        {31}let v_600: bitstring = catch-fail((if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-3-tuple(v_592))))) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-2-tuple(v_597))))) then (if not-caught-fail(v_599) then (v_599,2-proj-2-tuple(v_597)) else fail-any) else fail-any) else fail-any)) in
        {32}let v_601: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_600),2-proj-7-tuple(v_585),v_588,4-proj-7-tuple(v_585),5-proj-7-tuple(v_585),6-proj-7-tuple(v_585),7-proj-7-tuple(v_585))) in
        {33}let v_602: bitstring = catch-fail(concat3(v_589,2-proj-3-tuple(v_586),2-proj-2-tuple(v_600))) in
        {34}let (hs_603: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-7-tuple(v_585))))) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then (if not-caught-fail(v_588) then (if not-caught-fail(v_589) then (if not-caught-fail(v_591) then (if (not-caught-fail(v_600) && success?(is-true(success?(1-proj-2-tuple(v_600))))) then (if not-caught-fail(v_601) then (if not-caught-fail(v_602) then (v_601,v_602) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {35}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {36}insert statestore(alice,bob,sid,statepack_b(hs_603));
        {37}out(pub, message_a)
    ) | (
        {86}get statestore(=alice,=bob,=sid,statepack_b(hs_604: handshakestate)) in
        {39}in(pub, message_b: bitstring);
        {40}let v_605: bitstring = catch-fail(handshakestateunpack(hs_604)) in
        {41}let v_606: bitstring = catch-fail(deconcat3(message_b)) in
        {42}let v_607: bool = catch-fail(true) in
        {43}let v_608: key = catch-fail(1-proj-3-tuple(v_606)) in
        {44}let v_609: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_605))) in
        {45}let v_610: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_605)) then (if (not-caught-fail(v_609) && success?(is-true(success?(1-proj-3-tuple(v_609))))) then symmetricstatepack(1-proj-3-tuple(v_609),2-proj-3-tuple(v_609),hash(3-proj-3-tuple(v_609),v_608)) else fail-any) else fail-any)) in
        {46}let v_611: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_605))) in
        {47}let v_612: bitstring = catch-fail(symmetricstateunpack(v_610)) in
        {48}let v_613: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_612),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-2-tuple(v_611))))) then dhexp(2-proj-2-tuple(v_611),v_608) else fail-any) else fail-any))) in
        {49}let v_614: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_612),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-2-tuple(v_611))))) then dhexp(2-proj-2-tuple(v_611),v_608) else fail-any) else fail-any))) in
        {50}let v_615: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_612),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-2-tuple(v_611))))) then dhexp(2-proj-2-tuple(v_611),v_608) else fail-any) else fail-any))) in
        {51}let v_616: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-2-tuple(v_611))))) then dhexp(2-proj-2-tuple(v_611),v_608) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_612))) then (if not-caught-fail(v_613) then (if not-caught-fail(v_614) then (if not-caught-fail(v_615) then (v_613,v_614,v_615) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {52}let v_617: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-2-tuple(v_611))))) then dhexp(2-proj-2-tuple(v_611),v_608) else fail-any) else fail-any)) then (if (not-caught-fail(v_612) && success?(is-true(success?(1-proj-3-tuple(v_612))))) then (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-3-tuple(v_616))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_616)) then cipherstatepack(2-proj-3-tuple(v_616),minnonce) else fail-any),1-proj-3-tuple(v_616),3-proj-3-tuple(v_612)) else fail-any) else fail-any) else fail-any)) in
        {53}let v_618: bitstring = catch-fail(symmetricstateunpack(v_617)) in
        {54}let v_619: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_618))) in
        {55}let v_620: aead = catch-fail(decrypt(1-proj-2-tuple(v_619),2-proj-2-tuple(v_619),3-proj-3-tuple(v_618),2-proj-3-tuple(v_606))) in
        {56}let v_621: bitstring = catch-fail(aeadunpack(v_620)) in
        {57}let v_622: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_618))) in
        {58}let v_623: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_619))) && success?(1-proj-3-tuple(v_618))) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then cipherstatepack(1-proj-2-tuple(v_622),increment_nonce(2-proj-2-tuple(v_619))) else fail-any) else fail-any)) in
        {59}let v_624: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_606)) && (success?(3-proj-3-tuple(v_618)) && success?(1-proj-3-tuple(v_618)))) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then (if not-caught-fail(v_620) then (if (not-caught-fail(v_621) && success?(is-true(success?(1-proj-3-tuple(v_621))))) then (if not-caught-fail(v_623) then (v_623,3-proj-3-tuple(v_621),1-proj-3-tuple(v_621)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {60}let v_625: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_624),2-proj-3-tuple(v_618),3-proj-3-tuple(v_618)))) in
        {61}let v_626: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_606)) && success?(symmetricstatepack(1-proj-3-tuple(v_624),2-proj-3-tuple(v_618),3-proj-3-tuple(v_618)))) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-3-tuple(v_625))))) then symmetricstatepack(1-proj-3-tuple(v_625),2-proj-3-tuple(v_625),hash(3-proj-3-tuple(v_625),2-proj-3-tuple(v_606))) else fail-any) else fail-any)) in
        {62}let v_627: bitstring = catch-fail((if success?(2-proj-3-tuple(v_606)) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-3-tuple(v_618))))) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-3-tuple(v_624))))) then (if not-caught-fail(v_626) then (v_626,2-proj-3-tuple(v_624),3-proj-3-tuple(v_624)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {63}let v_628: key = catch-fail(2-proj-3-tuple(v_627)) in
        {64}let v_629: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_605))) in
        {65}let v_630: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_627))) in
        {66}let v_631: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_630),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then dhexp(2-proj-2-tuple(v_629),v_628) else fail-any) else fail-any))) in
        {67}let v_632: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_630),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then dhexp(2-proj-2-tuple(v_629),v_628) else fail-any) else fail-any))) in
        {68}let v_633: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_630),(if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then dhexp(2-proj-2-tuple(v_629),v_628) else fail-any) else fail-any))) in
        {69}let v_634: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then dhexp(2-proj-2-tuple(v_629),v_628) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_630))) then (if not-caught-fail(v_631) then (if not-caught-fail(v_632) then (if not-caught-fail(v_633) then (v_631,v_632,v_633) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {70}let v_635: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_605)) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-2-tuple(v_629))))) then dhexp(2-proj-2-tuple(v_629),v_628) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_627))) then (if (not-caught-fail(v_630) && success?(is-true(success?(1-proj-3-tuple(v_630))))) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_634)) then cipherstatepack(2-proj-3-tuple(v_634),minnonce) else fail-any),1-proj-3-tuple(v_634),3-proj-3-tuple(v_630)) else fail-any) else fail-any) else fail-any)) in
        {71}let v_636: bitstring = catch-fail(symmetricstateunpack(v_635)) in
        {72}let v_637: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_636))) in
        {73}let v_638: aead = catch-fail(decrypt(1-proj-2-tuple(v_637),2-proj-2-tuple(v_637),3-proj-3-tuple(v_636),3-proj-3-tuple(v_606))) in
        {74}let v_639: bitstring = catch-fail(aeadunpack(v_638)) in
        {75}let v_640: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_636))) in
        {76}let v_641: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_637))) && success?(1-proj-3-tuple(v_636))) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then cipherstatepack(1-proj-2-tuple(v_640),increment_nonce(2-proj-2-tuple(v_637))) else fail-any) else fail-any)) in
        {77}let v_642: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_606)) && (success?(3-proj-3-tuple(v_636)) && success?(1-proj-3-tuple(v_636)))) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then (if not-caught-fail(v_638) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-3-tuple(v_639))))) then (if not-caught-fail(v_641) then (v_641,3-proj-3-tuple(v_639),1-proj-3-tuple(v_639)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {78}let v_643: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_642),2-proj-3-tuple(v_636),3-proj-3-tuple(v_636)))) in
        {79}let v_644: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_606)) && success?(symmetricstatepack(1-proj-3-tuple(v_642),2-proj-3-tuple(v_636),3-proj-3-tuple(v_636)))) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-3-tuple(v_643))))) then symmetricstatepack(1-proj-3-tuple(v_643),2-proj-3-tuple(v_643),hash(3-proj-3-tuple(v_643),3-proj-3-tuple(v_606))) else fail-any) else fail-any)) in
        {80}let v_645: bitstring = catch-fail((if success?(3-proj-3-tuple(v_606)) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then (if not-caught-fail(v_644) then (v_644,2-proj-3-tuple(v_642),3-proj-3-tuple(v_642)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {81}let v_646: key = catch-fail(dhexp(key_s(bob),g)) in
        {82}let v_647: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_645),2-proj-7-tuple(v_605),3-proj-7-tuple(v_605),v_628,v_608,6-proj-7-tuple(v_605),7-proj-7-tuple(v_605))) in
        {83}let (hs_648: handshakestate,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-7-tuple(v_605))))) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-3-tuple(v_606))))) then (if not-caught-fail(v_607) then (if not-caught-fail(v_608) then (if not-caught-fail(v_610) then (if not-caught-fail(v_617) then (if (not-caught-fail(v_627) && success?(is-true(success?(1-proj-3-tuple(v_627))))) then (if not-caught-fail(v_628) then (if not-caught-fail(v_635) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then (if ((3-proj-3-tuple(v_627) && 3-proj-3-tuple(v_645)) && (v_628 = getpublickey((if not-caught-fail(v_646) then keypairpack(v_646,key_s(bob)) else fail-any)))) then (if not-caught-fail(v_647) then (v_647,2-proj-3-tuple(v_645),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {84}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {85}insert statestore(alice,bob,sid,statepack_c(hs_648))
    ) | (
        {130}get statestore(=alice,=bob,=sid,statepack_c(hs_649: handshakestate)) in
        {87}let v_650: bitstring = catch-fail(handshakestateunpack(hs_649)) in
        {88}let v_651: bitstring = catch-fail((empty,empty,empty)) in
        {89}let v_652: key = catch-fail(dhexp(key_s(alice),g)) in
        {90}let v_653: keypair = catch-fail((if not-caught-fail(v_652) then keypairpack(v_652,key_s(alice)) else fail-any)) in
        {91}let v_654: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_650))) in
        {92}let v_655: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_654))) in
        {93}let v_656: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_655),2-proj-2-tuple(v_655),3-proj-3-tuple(v_654),getpublickey(v_653))) in
        {94}let v_657: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_654))) in
        {95}let v_658: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_655))) && success?(1-proj-3-tuple(v_654))) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then cipherstatepack(1-proj-2-tuple(v_657),increment_nonce(2-proj-2-tuple(v_655))) else fail-any) else fail-any)) in
        {96}let v_659: bitstring = catch-fail((if (success?(getpublickey(v_653)) && (success?(3-proj-3-tuple(v_654)) && success?(1-proj-3-tuple(v_654)))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then (if not-caught-fail(v_656) then (if not-caught-fail(v_658) then (v_658,v_656) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {97}let v_660: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_659),2-proj-3-tuple(v_654),3-proj-3-tuple(v_654)))) in
        {98}let v_661: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_659)) && success?(symmetricstatepack(1-proj-2-tuple(v_659),2-proj-3-tuple(v_654),3-proj-3-tuple(v_654)))) then (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-3-tuple(v_660))))) then symmetricstatepack(1-proj-3-tuple(v_660),2-proj-3-tuple(v_660),hash(3-proj-3-tuple(v_660),2-proj-2-tuple(v_659))) else fail-any) else fail-any)) in
        {99}let v_662: bitstring = catch-fail((if (success?(getpublickey(v_653)) && success?(1-proj-7-tuple(v_650))) then (if (not-caught-fail(v_654) && success?(is-true(success?(1-proj-3-tuple(v_654))))) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-2-tuple(v_659))))) then (if not-caught-fail(v_661) then (v_661,2-proj-2-tuple(v_659)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {100}let v_663: bitstring = catch-fail(keypairunpack(v_653)) in
        {101}let v_664: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_662))) in
        {102}let v_665: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_664),(if success?(5-proj-7-tuple(v_650)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then dhexp(2-proj-2-tuple(v_663),5-proj-7-tuple(v_650)) else fail-any) else fail-any))) in
        {103}let v_666: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_664),(if success?(5-proj-7-tuple(v_650)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then dhexp(2-proj-2-tuple(v_663),5-proj-7-tuple(v_650)) else fail-any) else fail-any))) in
        {104}let v_667: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_664),(if success?(5-proj-7-tuple(v_650)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then dhexp(2-proj-2-tuple(v_663),5-proj-7-tuple(v_650)) else fail-any) else fail-any))) in
        {105}let v_668: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_650)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then dhexp(2-proj-2-tuple(v_663),5-proj-7-tuple(v_650)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_664))) then (if not-caught-fail(v_665) then (if not-caught-fail(v_666) then (if not-caught-fail(v_667) then (v_665,v_666,v_667) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {106}let v_669: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_650)) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then dhexp(2-proj-2-tuple(v_663),5-proj-7-tuple(v_650)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_662))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-3-tuple(v_664))))) then (if (not-caught-fail(v_668) && success?(is-true(success?(1-proj-3-tuple(v_668))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_668)) then cipherstatepack(2-proj-3-tuple(v_668),minnonce) else fail-any),1-proj-3-tuple(v_668),3-proj-3-tuple(v_664)) else fail-any) else fail-any) else fail-any)) in
        {107}let v_670: bitstring = catch-fail(symmetricstateunpack(v_669)) in
        {108}let v_671: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {109}let v_672: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_671),2-proj-2-tuple(v_671),3-proj-3-tuple(v_670),msg_c(alice,bob,sid))) in
        {110}let v_673: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {111}let v_674: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_671))) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then cipherstatepack(1-proj-2-tuple(v_673),increment_nonce(2-proj-2-tuple(v_671))) else fail-any) else fail-any)) in
        {112}let v_675: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_670)) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if not-caught-fail(v_672) then (if not-caught-fail(v_674) then (v_674,v_672) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {113}let v_676: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) in
        {114}let v_677: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_675)) && success?(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then symmetricstatepack(1-proj-3-tuple(v_676),2-proj-3-tuple(v_676),hash(3-proj-3-tuple(v_676),2-proj-2-tuple(v_675))) else fail-any) else fail-any)) in
        {115}let v_678: bitstring = catch-fail((if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-2-tuple(v_675))))) then (if not-caught-fail(v_677) then (v_677,2-proj-2-tuple(v_675)) else fail-any) else fail-any) else fail-any)) in
        {116}let v_679: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_678),v_653,3-proj-7-tuple(v_650),4-proj-7-tuple(v_650),5-proj-7-tuple(v_650),6-proj-7-tuple(v_650),7-proj-7-tuple(v_650))) in
        {117}let v_680: bitstring = catch-fail(concat3(1-proj-3-tuple(v_651),2-proj-2-tuple(v_662),2-proj-2-tuple(v_678))) in
        {118}let v_681: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_678))) in
        {119}let v_682: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_681),zero)) in
        {120}let v_683: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_681),zero)) in
        {121}let v_684: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_681),zero)) in
        {122}let v_685: bitstring = catch-fail((if success?(2-proj-3-tuple(v_681)) then (if not-caught-fail(v_682) then (if not-caught-fail(v_683) then (if not-caught-fail(v_684) then (v_682,v_683,v_684) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {123}let v_686: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_685)) then cipherstatepack(1-proj-3-tuple(v_685),minnonce) else fail-any)) in
        {124}let v_687: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_685)) then cipherstatepack(2-proj-3-tuple(v_685),minnonce) else fail-any)) in
        {125}let v_688: bitstring = catch-fail((if success?(1-proj-2-tuple(v_678)) then (if (not-caught-fail(v_681) && success?(is-true(success?(1-proj-3-tuple(v_681))))) then (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-3-tuple(v_685))))) then (if not-caught-fail(v_686) then (if not-caught-fail(v_687) then (1-proj-2-tuple(v_678),v_686,v_687) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {126}let (hs_689: handshakestate,message_c: bitstring,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-7-tuple(v_650))))) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-3-tuple(v_651))))) then (if not-caught-fail(v_653) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-2-tuple(v_662))))) then (if not-caught-fail(v_669) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-2-tuple(v_678))))) then (if not-caught-fail(v_679) then (if not-caught-fail(v_680) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-3-tuple(v_688))))) then (v_679,v_680,2-proj-3-tuple(v_688),3-proj-3-tuple(v_688)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {127}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {128}insert statestore(alice,bob,sid,statepack_d(hs_689,cs1,cs2));
        {129}out(pub, message_c)
    ) | (
        {131}!
        {151}get statestore(=alice,=bob,=sid,statepack_d(hs_690: handshakestate,cs1_691: cipherstate,cs2_692: cipherstate)) in
        {132}let hs_693: handshakestate = handshakestatesetcs(hs_690,cs2_692) in
        {133}in(pub, message_d: bitstring);
        {134}let v_694: bitstring = catch-fail(handshakestateunpack(hs_693)) in
        {135}let v_695: bitstring = catch-fail(deconcat3(message_d)) in
        {136}let v_696: bool = catch-fail(true) in
        {137}let v_697: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_694))) in
        {138}let v_698: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_697))) in
        {139}let v_699: aead = catch-fail(decrypt(1-proj-2-tuple(v_698),2-proj-2-tuple(v_698),3-proj-3-tuple(v_697),3-proj-3-tuple(v_695))) in
        {140}let v_700: bitstring = catch-fail(aeadunpack(v_699)) in
        {141}let v_701: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_697))) in
        {142}let v_702: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_698))) && success?(1-proj-3-tuple(v_697))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-2-tuple(v_701))))) then cipherstatepack(1-proj-2-tuple(v_701),increment_nonce(2-proj-2-tuple(v_698))) else fail-any) else fail-any)) in
        {143}let v_703: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_695)) && (success?(3-proj-3-tuple(v_697)) && success?(1-proj-3-tuple(v_697)))) then (if (not-caught-fail(v_698) && success?(is-true(success?(1-proj-2-tuple(v_698))))) then (if not-caught-fail(v_699) then (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-3-tuple(v_700))))) then (if not-caught-fail(v_702) then (v_702,3-proj-3-tuple(v_700),1-proj-3-tuple(v_700)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {144}let v_704: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_703),2-proj-3-tuple(v_697),3-proj-3-tuple(v_697)))) in
        {145}let v_705: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_695)) && success?(symmetricstatepack(1-proj-3-tuple(v_703),2-proj-3-tuple(v_697),3-proj-3-tuple(v_697)))) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then symmetricstatepack(1-proj-3-tuple(v_704),2-proj-3-tuple(v_704),hash(3-proj-3-tuple(v_704),3-proj-3-tuple(v_695))) else fail-any) else fail-any)) in
        {146}let v_706: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_695)) && success?(1-proj-7-tuple(v_694))) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then (if (not-caught-fail(v_703) && success?(is-true(success?(1-proj-3-tuple(v_703))))) then (if not-caught-fail(v_705) then (v_705,2-proj-3-tuple(v_703),3-proj-3-tuple(v_703)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {147}let v_707: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_706),2-proj-7-tuple(v_694),3-proj-7-tuple(v_694),4-proj-7-tuple(v_694),5-proj-7-tuple(v_694),6-proj-7-tuple(v_694),7-proj-7-tuple(v_694))) in
        {148}let (hs_708: handshakestate,plaintext_d: bitstring,valid_709: bool) = (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-7-tuple(v_694))))) then (if (not-caught-fail(v_695) && success?(is-true(success?(1-proj-3-tuple(v_695))))) then (if not-caught-fail(v_696) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-3-tuple(v_706))))) then (if (v_696 && 3-proj-3-tuple(v_706)) then (if not-caught-fail(v_707) then (v_707,2-proj-3-tuple(v_706),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {149}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {150}insert statestore(alice,bob,sid,statepack_e(hs_708,cs1_691,handshakestategetcs(hs_708)))
    ) | (
        {152}!
        {170}get statestore(=alice,=bob,=sid,statepack_e(hs_710: handshakestate,cs1_711: cipherstate,cs2_712: cipherstate)) in
        {153}let hs_713: handshakestate = handshakestatesetcs(hs_710,cs1_711) in
        {154}let v_714: bitstring = catch-fail(handshakestateunpack(hs_713)) in
        {155}let v_715: bitstring = catch-fail((empty,empty,empty)) in
        {156}let v_716: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_714))) in
        {157}let v_717: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_716))) in
        {158}let v_718: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_717),2-proj-2-tuple(v_717),3-proj-3-tuple(v_716),msg_e(alice,bob,sid))) in
        {159}let v_719: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_716))) in
        {160}let v_720: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_717))) && success?(1-proj-3-tuple(v_716))) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then cipherstatepack(1-proj-2-tuple(v_719),increment_nonce(2-proj-2-tuple(v_717))) else fail-any) else fail-any)) in
        {161}let v_721: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_716)) && success?(1-proj-3-tuple(v_716))) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-2-tuple(v_717))))) then (if not-caught-fail(v_718) then (if not-caught-fail(v_720) then (v_720,v_718) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {162}let v_722: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_721),2-proj-3-tuple(v_716),3-proj-3-tuple(v_716)))) in
        {163}let v_723: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_721)) && success?(symmetricstatepack(1-proj-2-tuple(v_721),2-proj-3-tuple(v_716),3-proj-3-tuple(v_716)))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-3-tuple(v_722))))) then symmetricstatepack(1-proj-3-tuple(v_722),2-proj-3-tuple(v_722),hash(3-proj-3-tuple(v_722),2-proj-2-tuple(v_721))) else fail-any) else fail-any)) in
        {164}let v_724: bitstring = catch-fail((if success?(1-proj-7-tuple(v_714)) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-3-tuple(v_716))))) then (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-2-tuple(v_721))))) then (if not-caught-fail(v_723) then (v_723,2-proj-2-tuple(v_721)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {165}let v_725: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_724),2-proj-7-tuple(v_714),3-proj-7-tuple(v_714),4-proj-7-tuple(v_714),5-proj-7-tuple(v_714),6-proj-7-tuple(v_714),7-proj-7-tuple(v_714))) in
        {166}let v_726: bitstring = catch-fail(concat3(1-proj-3-tuple(v_715),2-proj-3-tuple(v_715),2-proj-2-tuple(v_724))) in
        {167}let (hs_727: handshakestate,message_e: bitstring) = (if (not-caught-fail(v_714) && success?(is-true(success?(1-proj-7-tuple(v_714))))) then (if (not-caught-fail(v_715) && success?(is-true(success?(1-proj-3-tuple(v_715))))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-2-tuple(v_724))))) then (if not-caught-fail(v_725) then (if not-caught-fail(v_726) then (v_725,v_726) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {168}event SendMsg(alice,bob,stagepack_e(sid),msg_e(alice,bob,sid));
        {169}out(pub, message_e)
    ) | (
        {171}event LeakS(phase0,alice);
        {172}out(pub, key_s(alice))
    ) | (
        {173}phase 1;
        {174}event LeakS(phase1,alice);
        {175}out(pub, key_s(alice))
    )
) | (
    {176}let s_728: keypair = keypairpack(empty,empty) in
    {177}out(pub, getpublickey(s_728));
    (
        {178}let e_729: keypair = keypairpack(empty,empty) in
        {179}let rs_730: key = empty in
        {180}let re_731: key = empty in
        {181}let v_732: bitstring = catch-fail(hash(somename,empty)) in
        {182}let v_733: key = catch-fail(v_732) in
        {183}let v_734: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {184}let v_735: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_732) then (if not-caught-fail(v_733) then (if not-caught-fail(v_734) then symmetricstatepack(v_734,v_733,v_732) else fail-any) else fail-any) else fail-any))) in
        {185}let v_736: symmetricstate = catch-fail((if success?((if not-caught-fail(v_732) then (if not-caught-fail(v_733) then (if not-caught-fail(v_734) then symmetricstatepack(v_734,v_733,v_732) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-3-tuple(v_735))))) then symmetricstatepack(1-proj-3-tuple(v_735),2-proj-3-tuple(v_735),hash(3-proj-3-tuple(v_735),empty)) else fail-any) else fail-any)) in
        {186}let hs_737: handshakestate = (if not-caught-fail(v_736) then handshakestatepack(v_736,s_728,e_729,rs_730,re_731,empty,true) else fail-any) in
        {187}insert statestore(alice,charlie,sid,statepack_a(hs_737))
    ) | (
        {210}get statestore(=alice,=charlie,=sid,statepack_a(hs_738: handshakestate)) in
        {188}let v_739: bitstring = catch-fail(handshakestateunpack(hs_738)) in
        {189}let v_740: bitstring = catch-fail((empty,empty,empty)) in
        {190}let v_741: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {191}let v_742: keypair = catch-fail((if not-caught-fail(v_741) then keypairpack(v_741,key_e(alice,charlie,sid)) else fail-any)) in
        {192}let v_743: bitstring = catch-fail(getpublickey(v_742)) in
        {193}let v_744: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_739))) in
        {194}let v_745: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_739)) then (if (not-caught-fail(v_744) && success?(is-true(success?(1-proj-3-tuple(v_744))))) then symmetricstatepack(1-proj-3-tuple(v_744),2-proj-3-tuple(v_744),hash(3-proj-3-tuple(v_744),v_743)) else fail-any) else fail-any)) in
        {195}let v_746: bitstring = catch-fail(symmetricstateunpack(v_745)) in
        {196}let v_747: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_746))) in
        {197}let v_748: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_747),2-proj-2-tuple(v_747),3-proj-3-tuple(v_746),msg_a(alice,charlie,sid))) in
        {198}let v_749: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_746))) in
        {199}let v_750: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_747))) && success?(1-proj-3-tuple(v_746))) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-2-tuple(v_749))))) then cipherstatepack(1-proj-2-tuple(v_749),increment_nonce(2-proj-2-tuple(v_747))) else fail-any) else fail-any)) in
        {200}let v_751: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_746)) && success?(1-proj-3-tuple(v_746))) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-2-tuple(v_747))))) then (if not-caught-fail(v_748) then (if not-caught-fail(v_750) then (v_750,v_748) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {201}let v_752: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_751),2-proj-3-tuple(v_746),3-proj-3-tuple(v_746)))) in
        {202}let v_753: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_751)) && success?(symmetricstatepack(1-proj-2-tuple(v_751),2-proj-3-tuple(v_746),3-proj-3-tuple(v_746)))) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-3-tuple(v_752))))) then symmetricstatepack(1-proj-3-tuple(v_752),2-proj-3-tuple(v_752),hash(3-proj-3-tuple(v_752),2-proj-2-tuple(v_751))) else fail-any) else fail-any)) in
        {203}let v_754: bitstring = catch-fail((if (not-caught-fail(v_746) && success?(is-true(success?(1-proj-3-tuple(v_746))))) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then (if not-caught-fail(v_753) then (v_753,2-proj-2-tuple(v_751)) else fail-any) else fail-any) else fail-any)) in
        {204}let v_755: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_754),2-proj-7-tuple(v_739),v_742,4-proj-7-tuple(v_739),5-proj-7-tuple(v_739),6-proj-7-tuple(v_739),7-proj-7-tuple(v_739))) in
        {205}let v_756: bitstring = catch-fail(concat3(v_743,2-proj-3-tuple(v_740),2-proj-2-tuple(v_754))) in
        {206}let (hs_757: handshakestate,message_a_758: bitstring) = (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-7-tuple(v_739))))) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-3-tuple(v_740))))) then (if not-caught-fail(v_742) then (if not-caught-fail(v_743) then (if not-caught-fail(v_745) then (if (not-caught-fail(v_754) && success?(is-true(success?(1-proj-2-tuple(v_754))))) then (if not-caught-fail(v_755) then (if not-caught-fail(v_756) then (v_755,v_756) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {207}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {208}insert statestore(alice,charlie,sid,statepack_b(hs_757));
        {209}out(pub, message_a_758)
    ) | (
        {258}get statestore(=alice,=charlie,=sid,statepack_b(hs_759: handshakestate)) in
        {211}in(pub, message_b_760: bitstring);
        {212}let v_761: bitstring = catch-fail(handshakestateunpack(hs_759)) in
        {213}let v_762: bitstring = catch-fail(deconcat3(message_b_760)) in
        {214}let v_763: bool = catch-fail(true) in
        {215}let v_764: key = catch-fail(1-proj-3-tuple(v_762)) in
        {216}let v_765: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_761))) in
        {217}let v_766: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_761)) then (if (not-caught-fail(v_765) && success?(is-true(success?(1-proj-3-tuple(v_765))))) then symmetricstatepack(1-proj-3-tuple(v_765),2-proj-3-tuple(v_765),hash(3-proj-3-tuple(v_765),v_764)) else fail-any) else fail-any)) in
        {218}let v_767: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_761))) in
        {219}let v_768: bitstring = catch-fail(symmetricstateunpack(v_766)) in
        {220}let v_769: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_768),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-2-tuple(v_767))))) then dhexp(2-proj-2-tuple(v_767),v_764) else fail-any) else fail-any))) in
        {221}let v_770: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_768),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-2-tuple(v_767))))) then dhexp(2-proj-2-tuple(v_767),v_764) else fail-any) else fail-any))) in
        {222}let v_771: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_768),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-2-tuple(v_767))))) then dhexp(2-proj-2-tuple(v_767),v_764) else fail-any) else fail-any))) in
        {223}let v_772: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-2-tuple(v_767))))) then dhexp(2-proj-2-tuple(v_767),v_764) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_768))) then (if not-caught-fail(v_769) then (if not-caught-fail(v_770) then (if not-caught-fail(v_771) then (v_769,v_770,v_771) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {224}let v_773: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-2-tuple(v_767))))) then dhexp(2-proj-2-tuple(v_767),v_764) else fail-any) else fail-any)) then (if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-3-tuple(v_768))))) then (if (not-caught-fail(v_772) && success?(is-true(success?(1-proj-3-tuple(v_772))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_772)) then cipherstatepack(2-proj-3-tuple(v_772),minnonce) else fail-any),1-proj-3-tuple(v_772),3-proj-3-tuple(v_768)) else fail-any) else fail-any) else fail-any)) in
        {225}let v_774: bitstring = catch-fail(symmetricstateunpack(v_773)) in
        {226}let v_775: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_774))) in
        {227}let v_776: aead = catch-fail(decrypt(1-proj-2-tuple(v_775),2-proj-2-tuple(v_775),3-proj-3-tuple(v_774),2-proj-3-tuple(v_762))) in
        {228}let v_777: bitstring = catch-fail(aeadunpack(v_776)) in
        {229}let v_778: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_774))) in
        {230}let v_779: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_775))) && success?(1-proj-3-tuple(v_774))) then (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-2-tuple(v_778))))) then cipherstatepack(1-proj-2-tuple(v_778),increment_nonce(2-proj-2-tuple(v_775))) else fail-any) else fail-any)) in
        {231}let v_780: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_762)) && (success?(3-proj-3-tuple(v_774)) && success?(1-proj-3-tuple(v_774)))) then (if (not-caught-fail(v_775) && success?(is-true(success?(1-proj-2-tuple(v_775))))) then (if not-caught-fail(v_776) then (if (not-caught-fail(v_777) && success?(is-true(success?(1-proj-3-tuple(v_777))))) then (if not-caught-fail(v_779) then (v_779,3-proj-3-tuple(v_777),1-proj-3-tuple(v_777)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {232}let v_781: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_780),2-proj-3-tuple(v_774),3-proj-3-tuple(v_774)))) in
        {233}let v_782: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_762)) && success?(symmetricstatepack(1-proj-3-tuple(v_780),2-proj-3-tuple(v_774),3-proj-3-tuple(v_774)))) then (if (not-caught-fail(v_781) && success?(is-true(success?(1-proj-3-tuple(v_781))))) then symmetricstatepack(1-proj-3-tuple(v_781),2-proj-3-tuple(v_781),hash(3-proj-3-tuple(v_781),2-proj-3-tuple(v_762))) else fail-any) else fail-any)) in
        {234}let v_783: bitstring = catch-fail((if success?(2-proj-3-tuple(v_762)) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then (if (not-caught-fail(v_780) && success?(is-true(success?(1-proj-3-tuple(v_780))))) then (if not-caught-fail(v_782) then (v_782,2-proj-3-tuple(v_780),3-proj-3-tuple(v_780)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {235}let v_784: key = catch-fail(2-proj-3-tuple(v_783)) in
        {236}let v_785: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_761))) in
        {237}let v_786: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_783))) in
        {238}let v_787: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_786),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then dhexp(2-proj-2-tuple(v_785),v_784) else fail-any) else fail-any))) in
        {239}let v_788: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_786),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then dhexp(2-proj-2-tuple(v_785),v_784) else fail-any) else fail-any))) in
        {240}let v_789: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_786),(if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then dhexp(2-proj-2-tuple(v_785),v_784) else fail-any) else fail-any))) in
        {241}let v_790: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then dhexp(2-proj-2-tuple(v_785),v_784) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_786))) then (if not-caught-fail(v_787) then (if not-caught-fail(v_788) then (if not-caught-fail(v_789) then (v_787,v_788,v_789) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {242}let v_791: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_761)) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then dhexp(2-proj-2-tuple(v_785),v_784) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_783))) then (if (not-caught-fail(v_786) && success?(is-true(success?(1-proj-3-tuple(v_786))))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_790)) then cipherstatepack(2-proj-3-tuple(v_790),minnonce) else fail-any),1-proj-3-tuple(v_790),3-proj-3-tuple(v_786)) else fail-any) else fail-any) else fail-any)) in
        {243}let v_792: bitstring = catch-fail(symmetricstateunpack(v_791)) in
        {244}let v_793: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_792))) in
        {245}let v_794: aead = catch-fail(decrypt(1-proj-2-tuple(v_793),2-proj-2-tuple(v_793),3-proj-3-tuple(v_792),3-proj-3-tuple(v_762))) in
        {246}let v_795: bitstring = catch-fail(aeadunpack(v_794)) in
        {247}let v_796: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_792))) in
        {248}let v_797: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_793))) && success?(1-proj-3-tuple(v_792))) then (if (not-caught-fail(v_796) && success?(is-true(success?(1-proj-2-tuple(v_796))))) then cipherstatepack(1-proj-2-tuple(v_796),increment_nonce(2-proj-2-tuple(v_793))) else fail-any) else fail-any)) in
        {249}let v_798: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_762)) && (success?(3-proj-3-tuple(v_792)) && success?(1-proj-3-tuple(v_792)))) then (if (not-caught-fail(v_793) && success?(is-true(success?(1-proj-2-tuple(v_793))))) then (if not-caught-fail(v_794) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-3-tuple(v_795))))) then (if not-caught-fail(v_797) then (v_797,3-proj-3-tuple(v_795),1-proj-3-tuple(v_795)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {250}let v_799: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_798),2-proj-3-tuple(v_792),3-proj-3-tuple(v_792)))) in
        {251}let v_800: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_762)) && success?(symmetricstatepack(1-proj-3-tuple(v_798),2-proj-3-tuple(v_792),3-proj-3-tuple(v_792)))) then (if (not-caught-fail(v_799) && success?(is-true(success?(1-proj-3-tuple(v_799))))) then symmetricstatepack(1-proj-3-tuple(v_799),2-proj-3-tuple(v_799),hash(3-proj-3-tuple(v_799),3-proj-3-tuple(v_762))) else fail-any) else fail-any)) in
        {252}let v_801: bitstring = catch-fail((if success?(3-proj-3-tuple(v_762)) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-3-tuple(v_792))))) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-3-tuple(v_798))))) then (if not-caught-fail(v_800) then (v_800,2-proj-3-tuple(v_798),3-proj-3-tuple(v_798)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {253}let v_802: key = catch-fail(dhexp(key_s(charlie),g)) in
        {254}let v_803: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_801),2-proj-7-tuple(v_761),3-proj-7-tuple(v_761),v_784,v_764,6-proj-7-tuple(v_761),7-proj-7-tuple(v_761))) in
        {255}let (hs_804: handshakestate,plaintext_b_805: bitstring,valid_806: bool) = (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-7-tuple(v_761))))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then (if not-caught-fail(v_763) then (if not-caught-fail(v_764) then (if not-caught-fail(v_766) then (if not-caught-fail(v_773) then (if (not-caught-fail(v_783) && success?(is-true(success?(1-proj-3-tuple(v_783))))) then (if not-caught-fail(v_784) then (if not-caught-fail(v_791) then (if (not-caught-fail(v_801) && success?(is-true(success?(1-proj-3-tuple(v_801))))) then (if ((3-proj-3-tuple(v_783) && 3-proj-3-tuple(v_801)) && (v_784 = getpublickey((if not-caught-fail(v_802) then keypairpack(v_802,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_803) then (v_803,2-proj-3-tuple(v_801),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {256}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_805);
        {257}insert statestore(alice,charlie,sid,statepack_c(hs_804))
    ) | (
        {302}get statestore(=alice,=charlie,=sid,statepack_c(hs_807: handshakestate)) in
        {259}let v_808: bitstring = catch-fail(handshakestateunpack(hs_807)) in
        {260}let v_809: bitstring = catch-fail((empty,empty,empty)) in
        {261}let v_810: key = catch-fail(dhexp(key_s(alice),g)) in
        {262}let v_811: keypair = catch-fail((if not-caught-fail(v_810) then keypairpack(v_810,key_s(alice)) else fail-any)) in
        {263}let v_812: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_808))) in
        {264}let v_813: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_812))) in
        {265}let v_814: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_813),2-proj-2-tuple(v_813),3-proj-3-tuple(v_812),getpublickey(v_811))) in
        {266}let v_815: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_812))) in
        {267}let v_816: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_813))) && success?(1-proj-3-tuple(v_812))) then (if (not-caught-fail(v_815) && success?(is-true(success?(1-proj-2-tuple(v_815))))) then cipherstatepack(1-proj-2-tuple(v_815),increment_nonce(2-proj-2-tuple(v_813))) else fail-any) else fail-any)) in
        {268}let v_817: bitstring = catch-fail((if (success?(getpublickey(v_811)) && (success?(3-proj-3-tuple(v_812)) && success?(1-proj-3-tuple(v_812)))) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then (if not-caught-fail(v_814) then (if not-caught-fail(v_816) then (v_816,v_814) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {269}let v_818: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_817),2-proj-3-tuple(v_812),3-proj-3-tuple(v_812)))) in
        {270}let v_819: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_817)) && success?(symmetricstatepack(1-proj-2-tuple(v_817),2-proj-3-tuple(v_812),3-proj-3-tuple(v_812)))) then (if (not-caught-fail(v_818) && success?(is-true(success?(1-proj-3-tuple(v_818))))) then symmetricstatepack(1-proj-3-tuple(v_818),2-proj-3-tuple(v_818),hash(3-proj-3-tuple(v_818),2-proj-2-tuple(v_817))) else fail-any) else fail-any)) in
        {271}let v_820: bitstring = catch-fail((if (success?(getpublickey(v_811)) && success?(1-proj-7-tuple(v_808))) then (if (not-caught-fail(v_812) && success?(is-true(success?(1-proj-3-tuple(v_812))))) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-2-tuple(v_817))))) then (if not-caught-fail(v_819) then (v_819,2-proj-2-tuple(v_817)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {272}let v_821: bitstring = catch-fail(keypairunpack(v_811)) in
        {273}let v_822: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_820))) in
        {274}let v_823: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_822),(if success?(5-proj-7-tuple(v_808)) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then dhexp(2-proj-2-tuple(v_821),5-proj-7-tuple(v_808)) else fail-any) else fail-any))) in
        {275}let v_824: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_822),(if success?(5-proj-7-tuple(v_808)) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then dhexp(2-proj-2-tuple(v_821),5-proj-7-tuple(v_808)) else fail-any) else fail-any))) in
        {276}let v_825: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_822),(if success?(5-proj-7-tuple(v_808)) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then dhexp(2-proj-2-tuple(v_821),5-proj-7-tuple(v_808)) else fail-any) else fail-any))) in
        {277}let v_826: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_808)) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then dhexp(2-proj-2-tuple(v_821),5-proj-7-tuple(v_808)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_822))) then (if not-caught-fail(v_823) then (if not-caught-fail(v_824) then (if not-caught-fail(v_825) then (v_823,v_824,v_825) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {278}let v_827: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_808)) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-2-tuple(v_821))))) then dhexp(2-proj-2-tuple(v_821),5-proj-7-tuple(v_808)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_820))) then (if (not-caught-fail(v_822) && success?(is-true(success?(1-proj-3-tuple(v_822))))) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_826)) then cipherstatepack(2-proj-3-tuple(v_826),minnonce) else fail-any),1-proj-3-tuple(v_826),3-proj-3-tuple(v_822)) else fail-any) else fail-any) else fail-any)) in
        {279}let v_828: bitstring = catch-fail(symmetricstateunpack(v_827)) in
        {280}let v_829: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_828))) in
        {281}let v_830: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_829),2-proj-2-tuple(v_829),3-proj-3-tuple(v_828),msg_c(alice,charlie,sid))) in
        {282}let v_831: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_828))) in
        {283}let v_832: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_829))) && success?(1-proj-3-tuple(v_828))) then (if (not-caught-fail(v_831) && success?(is-true(success?(1-proj-2-tuple(v_831))))) then cipherstatepack(1-proj-2-tuple(v_831),increment_nonce(2-proj-2-tuple(v_829))) else fail-any) else fail-any)) in
        {284}let v_833: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_828)) && success?(1-proj-3-tuple(v_828))) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-2-tuple(v_829))))) then (if not-caught-fail(v_830) then (if not-caught-fail(v_832) then (v_832,v_830) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {285}let v_834: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_833),2-proj-3-tuple(v_828),3-proj-3-tuple(v_828)))) in
        {286}let v_835: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_833)) && success?(symmetricstatepack(1-proj-2-tuple(v_833),2-proj-3-tuple(v_828),3-proj-3-tuple(v_828)))) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-3-tuple(v_834))))) then symmetricstatepack(1-proj-3-tuple(v_834),2-proj-3-tuple(v_834),hash(3-proj-3-tuple(v_834),2-proj-2-tuple(v_833))) else fail-any) else fail-any)) in
        {287}let v_836: bitstring = catch-fail((if (not-caught-fail(v_828) && success?(is-true(success?(1-proj-3-tuple(v_828))))) then (if (not-caught-fail(v_833) && success?(is-true(success?(1-proj-2-tuple(v_833))))) then (if not-caught-fail(v_835) then (v_835,2-proj-2-tuple(v_833)) else fail-any) else fail-any) else fail-any)) in
        {288}let v_837: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_836),v_811,3-proj-7-tuple(v_808),4-proj-7-tuple(v_808),5-proj-7-tuple(v_808),6-proj-7-tuple(v_808),7-proj-7-tuple(v_808))) in
        {289}let v_838: bitstring = catch-fail(concat3(1-proj-3-tuple(v_809),2-proj-2-tuple(v_820),2-proj-2-tuple(v_836))) in
        {290}let v_839: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_836))) in
        {291}let v_840: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_839),zero)) in
        {292}let v_841: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_839),zero)) in
        {293}let v_842: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_839),zero)) in
        {294}let v_843: bitstring = catch-fail((if success?(2-proj-3-tuple(v_839)) then (if not-caught-fail(v_840) then (if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (v_840,v_841,v_842) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {295}let v_844: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_843)) then cipherstatepack(1-proj-3-tuple(v_843),minnonce) else fail-any)) in
        {296}let v_845: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_843)) then cipherstatepack(2-proj-3-tuple(v_843),minnonce) else fail-any)) in
        {297}let v_846: bitstring = catch-fail((if success?(1-proj-2-tuple(v_836)) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-3-tuple(v_843))))) then (if not-caught-fail(v_844) then (if not-caught-fail(v_845) then (1-proj-2-tuple(v_836),v_844,v_845) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {298}let (hs_847: handshakestate,message_c_848: bitstring,cs1_849: cipherstate,cs2_850: cipherstate) = (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-7-tuple(v_808))))) then (if (not-caught-fail(v_809) && success?(is-true(success?(1-proj-3-tuple(v_809))))) then (if not-caught-fail(v_811) then (if (not-caught-fail(v_820) && success?(is-true(success?(1-proj-2-tuple(v_820))))) then (if not-caught-fail(v_827) then (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-2-tuple(v_836))))) then (if not-caught-fail(v_837) then (if not-caught-fail(v_838) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-3-tuple(v_846))))) then (v_837,v_838,2-proj-3-tuple(v_846),3-proj-3-tuple(v_846)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {299}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {300}insert statestore(alice,charlie,sid,statepack_d(hs_847,cs1_849,cs2_850));
        {301}out(pub, message_c_848)
    ) | (
        {303}!
        {323}get statestore(=alice,=charlie,=sid,statepack_d(hs_851: handshakestate,cs1_852: cipherstate,cs2_853: cipherstate)) in
        {304}let hs_854: handshakestate = handshakestatesetcs(hs_851,cs2_853) in
        {305}in(pub, message_d_855: bitstring);
        {306}let v_856: bitstring = catch-fail(handshakestateunpack(hs_854)) in
        {307}let v_857: bitstring = catch-fail(deconcat3(message_d_855)) in
        {308}let v_858: bool = catch-fail(true) in
        {309}let v_859: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_856))) in
        {310}let v_860: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_859))) in
        {311}let v_861: aead = catch-fail(decrypt(1-proj-2-tuple(v_860),2-proj-2-tuple(v_860),3-proj-3-tuple(v_859),3-proj-3-tuple(v_857))) in
        {312}let v_862: bitstring = catch-fail(aeadunpack(v_861)) in
        {313}let v_863: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_859))) in
        {314}let v_864: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_860))) && success?(1-proj-3-tuple(v_859))) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-2-tuple(v_863))))) then cipherstatepack(1-proj-2-tuple(v_863),increment_nonce(2-proj-2-tuple(v_860))) else fail-any) else fail-any)) in
        {315}let v_865: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_857)) && (success?(3-proj-3-tuple(v_859)) && success?(1-proj-3-tuple(v_859)))) then (if (not-caught-fail(v_860) && success?(is-true(success?(1-proj-2-tuple(v_860))))) then (if not-caught-fail(v_861) then (if (not-caught-fail(v_862) && success?(is-true(success?(1-proj-3-tuple(v_862))))) then (if not-caught-fail(v_864) then (v_864,3-proj-3-tuple(v_862),1-proj-3-tuple(v_862)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {316}let v_866: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_865),2-proj-3-tuple(v_859),3-proj-3-tuple(v_859)))) in
        {317}let v_867: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_857)) && success?(symmetricstatepack(1-proj-3-tuple(v_865),2-proj-3-tuple(v_859),3-proj-3-tuple(v_859)))) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then symmetricstatepack(1-proj-3-tuple(v_866),2-proj-3-tuple(v_866),hash(3-proj-3-tuple(v_866),3-proj-3-tuple(v_857))) else fail-any) else fail-any)) in
        {318}let v_868: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_857)) && success?(1-proj-7-tuple(v_856))) then (if (not-caught-fail(v_859) && success?(is-true(success?(1-proj-3-tuple(v_859))))) then (if (not-caught-fail(v_865) && success?(is-true(success?(1-proj-3-tuple(v_865))))) then (if not-caught-fail(v_867) then (v_867,2-proj-3-tuple(v_865),3-proj-3-tuple(v_865)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {319}let v_869: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_868),2-proj-7-tuple(v_856),3-proj-7-tuple(v_856),4-proj-7-tuple(v_856),5-proj-7-tuple(v_856),6-proj-7-tuple(v_856),7-proj-7-tuple(v_856))) in
        {320}let (hs_870: handshakestate,plaintext_d_871: bitstring,valid_872: bool) = (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-7-tuple(v_856))))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then (if not-caught-fail(v_858) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-3-tuple(v_868))))) then (if (v_858 && 3-proj-3-tuple(v_868)) then (if not-caught-fail(v_869) then (v_869,2-proj-3-tuple(v_868),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {321}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_871);
        {322}insert statestore(alice,charlie,sid,statepack_e(hs_870,cs1_852,handshakestategetcs(hs_870)))
    ) | (
        {324}!
        {342}get statestore(=alice,=charlie,=sid,statepack_e(hs_873: handshakestate,cs1_874: cipherstate,cs2_875: cipherstate)) in
        {325}let hs_876: handshakestate = handshakestatesetcs(hs_873,cs1_874) in
        {326}let v_877: bitstring = catch-fail(handshakestateunpack(hs_876)) in
        {327}let v_878: bitstring = catch-fail((empty,empty,empty)) in
        {328}let v_879: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_877))) in
        {329}let v_880: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_879))) in
        {330}let v_881: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_880),2-proj-2-tuple(v_880),3-proj-3-tuple(v_879),msg_e(alice,charlie,sid))) in
        {331}let v_882: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_879))) in
        {332}let v_883: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_880))) && success?(1-proj-3-tuple(v_879))) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then cipherstatepack(1-proj-2-tuple(v_882),increment_nonce(2-proj-2-tuple(v_880))) else fail-any) else fail-any)) in
        {333}let v_884: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_879)) && success?(1-proj-3-tuple(v_879))) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-2-tuple(v_880))))) then (if not-caught-fail(v_881) then (if not-caught-fail(v_883) then (v_883,v_881) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {334}let v_885: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_884),2-proj-3-tuple(v_879),3-proj-3-tuple(v_879)))) in
        {335}let v_886: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_884)) && success?(symmetricstatepack(1-proj-2-tuple(v_884),2-proj-3-tuple(v_879),3-proj-3-tuple(v_879)))) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-3-tuple(v_885))))) then symmetricstatepack(1-proj-3-tuple(v_885),2-proj-3-tuple(v_885),hash(3-proj-3-tuple(v_885),2-proj-2-tuple(v_884))) else fail-any) else fail-any)) in
        {336}let v_887: bitstring = catch-fail((if success?(1-proj-7-tuple(v_877)) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-3-tuple(v_879))))) then (if (not-caught-fail(v_884) && success?(is-true(success?(1-proj-2-tuple(v_884))))) then (if not-caught-fail(v_886) then (v_886,2-proj-2-tuple(v_884)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {337}let v_888: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_887),2-proj-7-tuple(v_877),3-proj-7-tuple(v_877),4-proj-7-tuple(v_877),5-proj-7-tuple(v_877),6-proj-7-tuple(v_877),7-proj-7-tuple(v_877))) in
        {338}let v_889: bitstring = catch-fail(concat3(1-proj-3-tuple(v_878),2-proj-3-tuple(v_878),2-proj-2-tuple(v_887))) in
        {339}let (hs_890: handshakestate,message_e_891: bitstring) = (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-7-tuple(v_877))))) then (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-3-tuple(v_878))))) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-2-tuple(v_887))))) then (if not-caught-fail(v_888) then (if not-caught-fail(v_889) then (v_888,v_889) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {340}event SendMsg(alice,charlie,stagepack_e(sid),msg_e(alice,charlie,sid));
        {341}out(pub, message_e_891)
    ) | (
        {343}event LeakS(phase0,alice);
        {344}out(pub, key_s(alice))
    ) | (
        {345}phase 1;
        {346}event LeakS(phase1,alice);
        {347}out(pub, key_s(alice))
    )
) | (
    {348}let s_892: keypair = keypairpack(empty,empty) in
    {349}out(pub, getpublickey(s_892));
    (
        {350}let e_893: keypair = keypairpack(empty,empty) in
        {351}let rs_894: key = empty in
        {352}let re_895: key = empty in
        {353}let v_896: bitstring = catch-fail(hash(somename,empty)) in
        {354}let v_897: key = catch-fail(v_896) in
        {355}let v_898: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {356}let v_899: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_896) then (if not-caught-fail(v_897) then (if not-caught-fail(v_898) then symmetricstatepack(v_898,v_897,v_896) else fail-any) else fail-any) else fail-any))) in
        {357}let v_900: symmetricstate = catch-fail((if success?((if not-caught-fail(v_896) then (if not-caught-fail(v_897) then (if not-caught-fail(v_898) then symmetricstatepack(v_898,v_897,v_896) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-3-tuple(v_899))))) then symmetricstatepack(1-proj-3-tuple(v_899),2-proj-3-tuple(v_899),hash(3-proj-3-tuple(v_899),empty)) else fail-any) else fail-any)) in
        {358}let hs_901: handshakestate = (if not-caught-fail(v_900) then handshakestatepack(v_900,s_892,e_893,rs_894,re_895,empty,false) else fail-any) in
        {359}insert statestore(bob,alice,sid,statepack_a(hs_901))
    ) | (
        {381}get statestore(=bob,=alice,=sid,statepack_a(hs_902: handshakestate)) in
        {360}in(pub, message_a_903: bitstring);
        {361}let v_904: bitstring = catch-fail(handshakestateunpack(hs_902)) in
        {362}let v_905: bitstring = catch-fail(deconcat3(message_a_903)) in
        {363}let v_906: bool = catch-fail(true) in
        {364}let v_907: key = catch-fail(1-proj-3-tuple(v_905)) in
        {365}let v_908: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_904))) in
        {366}let v_909: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_904)) then (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-3-tuple(v_908))))) then symmetricstatepack(1-proj-3-tuple(v_908),2-proj-3-tuple(v_908),hash(3-proj-3-tuple(v_908),v_907)) else fail-any) else fail-any)) in
        {367}let v_910: bitstring = catch-fail(symmetricstateunpack(v_909)) in
        {368}let v_911: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_910))) in
        {369}let v_912: aead = catch-fail(decrypt(1-proj-2-tuple(v_911),2-proj-2-tuple(v_911),3-proj-3-tuple(v_910),3-proj-3-tuple(v_905))) in
        {370}let v_913: bitstring = catch-fail(aeadunpack(v_912)) in
        {371}let v_914: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_910))) in
        {372}let v_915: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_911))) && success?(1-proj-3-tuple(v_910))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-2-tuple(v_914))))) then cipherstatepack(1-proj-2-tuple(v_914),increment_nonce(2-proj-2-tuple(v_911))) else fail-any) else fail-any)) in
        {373}let v_916: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_905)) && (success?(3-proj-3-tuple(v_910)) && success?(1-proj-3-tuple(v_910)))) then (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-2-tuple(v_911))))) then (if not-caught-fail(v_912) then (if (not-caught-fail(v_913) && success?(is-true(success?(1-proj-3-tuple(v_913))))) then (if not-caught-fail(v_915) then (v_915,3-proj-3-tuple(v_913),1-proj-3-tuple(v_913)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {374}let v_917: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_916),2-proj-3-tuple(v_910),3-proj-3-tuple(v_910)))) in
        {375}let v_918: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_905)) && success?(symmetricstatepack(1-proj-3-tuple(v_916),2-proj-3-tuple(v_910),3-proj-3-tuple(v_910)))) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then symmetricstatepack(1-proj-3-tuple(v_917),2-proj-3-tuple(v_917),hash(3-proj-3-tuple(v_917),3-proj-3-tuple(v_905))) else fail-any) else fail-any)) in
        {376}let v_919: bitstring = catch-fail((if success?(3-proj-3-tuple(v_905)) then (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-3-tuple(v_910))))) then (if (not-caught-fail(v_916) && success?(is-true(success?(1-proj-3-tuple(v_916))))) then (if not-caught-fail(v_918) then (v_918,2-proj-3-tuple(v_916),3-proj-3-tuple(v_916)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {377}let v_920: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_919),2-proj-7-tuple(v_904),3-proj-7-tuple(v_904),4-proj-7-tuple(v_904),v_907,6-proj-7-tuple(v_904),7-proj-7-tuple(v_904))) in
        {378}let (hs_921: handshakestate,plaintext_a: bitstring,valid_922: bool) = (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-7-tuple(v_904))))) then (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-3-tuple(v_905))))) then (if not-caught-fail(v_906) then (if not-caught-fail(v_907) then (if not-caught-fail(v_909) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-3-tuple(v_919))))) then (if (v_906 && 3-proj-3-tuple(v_919)) then (if not-caught-fail(v_920) then (v_920,2-proj-3-tuple(v_919),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {379}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {380}insert statestore(bob,alice,sid,statepack_b(hs_921))
    ) | (
        {429}get statestore(=bob,=alice,=sid,statepack_b(hs_923: handshakestate)) in
        {382}let v_924: bitstring = catch-fail(handshakestateunpack(hs_923)) in
        {383}let v_925: bitstring = catch-fail((empty,empty,empty)) in
        {384}let v_926: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {385}let v_927: keypair = catch-fail((if not-caught-fail(v_926) then keypairpack(v_926,key_e(bob,alice,sid)) else fail-any)) in
        {386}let v_928: bitstring = catch-fail(getpublickey(v_927)) in
        {387}let v_929: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_924))) in
        {388}let v_930: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_924)) then (if (not-caught-fail(v_929) && success?(is-true(success?(1-proj-3-tuple(v_929))))) then symmetricstatepack(1-proj-3-tuple(v_929),2-proj-3-tuple(v_929),hash(3-proj-3-tuple(v_929),v_928)) else fail-any) else fail-any)) in
        {389}let v_931: bitstring = catch-fail(keypairunpack(v_927)) in
        {390}let v_932: bitstring = catch-fail(symmetricstateunpack(v_930)) in
        {391}let v_933: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_932),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then dhexp(2-proj-2-tuple(v_931),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {392}let v_934: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_932),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then dhexp(2-proj-2-tuple(v_931),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {393}let v_935: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_932),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then dhexp(2-proj-2-tuple(v_931),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {394}let v_936: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then dhexp(2-proj-2-tuple(v_931),5-proj-7-tuple(v_924)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_932))) then (if not-caught-fail(v_933) then (if not-caught-fail(v_934) then (if not-caught-fail(v_935) then (v_933,v_934,v_935) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {395}let v_937: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then dhexp(2-proj-2-tuple(v_931),5-proj-7-tuple(v_924)) else fail-any) else fail-any)) then (if (not-caught-fail(v_932) && success?(is-true(success?(1-proj-3-tuple(v_932))))) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_936)) then cipherstatepack(2-proj-3-tuple(v_936),minnonce) else fail-any),1-proj-3-tuple(v_936),3-proj-3-tuple(v_932)) else fail-any) else fail-any) else fail-any)) in
        {396}let v_938: key = catch-fail(dhexp(key_s(bob),g)) in
        {397}let v_939: keypair = catch-fail((if not-caught-fail(v_938) then keypairpack(v_938,key_s(bob)) else fail-any)) in
        {398}let v_940: bitstring = catch-fail(symmetricstateunpack(v_937)) in
        {399}let v_941: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_940))) in
        {400}let v_942: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_941),2-proj-2-tuple(v_941),3-proj-3-tuple(v_940),getpublickey(v_939))) in
        {401}let v_943: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_940))) in
        {402}let v_944: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_941))) && success?(1-proj-3-tuple(v_940))) then (if (not-caught-fail(v_943) && success?(is-true(success?(1-proj-2-tuple(v_943))))) then cipherstatepack(1-proj-2-tuple(v_943),increment_nonce(2-proj-2-tuple(v_941))) else fail-any) else fail-any)) in
        {403}let v_945: bitstring = catch-fail((if (success?(getpublickey(v_939)) && (success?(3-proj-3-tuple(v_940)) && success?(1-proj-3-tuple(v_940)))) then (if (not-caught-fail(v_941) && success?(is-true(success?(1-proj-2-tuple(v_941))))) then (if not-caught-fail(v_942) then (if not-caught-fail(v_944) then (v_944,v_942) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {404}let v_946: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_945),2-proj-3-tuple(v_940),3-proj-3-tuple(v_940)))) in
        {405}let v_947: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_945)) && success?(symmetricstatepack(1-proj-2-tuple(v_945),2-proj-3-tuple(v_940),3-proj-3-tuple(v_940)))) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-3-tuple(v_946))))) then symmetricstatepack(1-proj-3-tuple(v_946),2-proj-3-tuple(v_946),hash(3-proj-3-tuple(v_946),2-proj-2-tuple(v_945))) else fail-any) else fail-any)) in
        {406}let v_948: bitstring = catch-fail((if success?(getpublickey(v_939)) then (if (not-caught-fail(v_940) && success?(is-true(success?(1-proj-3-tuple(v_940))))) then (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-2-tuple(v_945))))) then (if not-caught-fail(v_947) then (v_947,2-proj-2-tuple(v_945)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {407}let v_949: bitstring = catch-fail(keypairunpack(v_939)) in
        {408}let v_950: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_948))) in
        {409}let v_951: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_950),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {410}let v_952: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_950),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {411}let v_953: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_950),(if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),5-proj-7-tuple(v_924)) else fail-any) else fail-any))) in
        {412}let v_954: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),5-proj-7-tuple(v_924)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_950))) then (if not-caught-fail(v_951) then (if not-caught-fail(v_952) then (if not-caught-fail(v_953) then (v_951,v_952,v_953) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {413}let v_955: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_924)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then dhexp(2-proj-2-tuple(v_949),5-proj-7-tuple(v_924)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_948))) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-3-tuple(v_950))))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-3-tuple(v_954))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_954)) then cipherstatepack(2-proj-3-tuple(v_954),minnonce) else fail-any),1-proj-3-tuple(v_954),3-proj-3-tuple(v_950)) else fail-any) else fail-any) else fail-any)) in
        {414}let v_956: bitstring = catch-fail(symmetricstateunpack(v_955)) in
        {415}let v_957: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {416}let v_958: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_957),2-proj-2-tuple(v_957),3-proj-3-tuple(v_956),msg_b(bob,alice,sid))) in
        {417}let v_959: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_956))) in
        {418}let v_960: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_957))) && success?(1-proj-3-tuple(v_956))) then (if (not-caught-fail(v_959) && success?(is-true(success?(1-proj-2-tuple(v_959))))) then cipherstatepack(1-proj-2-tuple(v_959),increment_nonce(2-proj-2-tuple(v_957))) else fail-any) else fail-any)) in
        {419}let v_961: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_956)) && success?(1-proj-3-tuple(v_956))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then (if not-caught-fail(v_958) then (if not-caught-fail(v_960) then (v_960,v_958) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {420}let v_962: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_961),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) in
        {421}let v_963: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_961)) && success?(symmetricstatepack(1-proj-2-tuple(v_961),2-proj-3-tuple(v_956),3-proj-3-tuple(v_956)))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_962),hash(3-proj-3-tuple(v_962),2-proj-2-tuple(v_961))) else fail-any) else fail-any)) in
        {422}let v_964: bitstring = catch-fail((if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-3-tuple(v_956))))) then (if (not-caught-fail(v_961) && success?(is-true(success?(1-proj-2-tuple(v_961))))) then (if not-caught-fail(v_963) then (v_963,2-proj-2-tuple(v_961)) else fail-any) else fail-any) else fail-any)) in
        {423}let v_965: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_964),v_939,v_927,4-proj-7-tuple(v_924),5-proj-7-tuple(v_924),6-proj-7-tuple(v_924),7-proj-7-tuple(v_924))) in
        {424}let v_966: bitstring = catch-fail(concat3(v_928,2-proj-2-tuple(v_948),2-proj-2-tuple(v_964))) in
        {425}let (hs_967: handshakestate,message_b_968: bitstring) = (if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-7-tuple(v_924))))) then (if (not-caught-fail(v_925) && success?(is-true(success?(1-proj-3-tuple(v_925))))) then (if not-caught-fail(v_927) then (if not-caught-fail(v_928) then (if not-caught-fail(v_930) then (if not-caught-fail(v_937) then (if not-caught-fail(v_939) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then (if not-caught-fail(v_955) then (if (not-caught-fail(v_964) && success?(is-true(success?(1-proj-2-tuple(v_964))))) then (if not-caught-fail(v_965) then (if not-caught-fail(v_966) then (v_965,v_966) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {426}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {427}insert statestore(bob,alice,sid,statepack_c(hs_967));
        {428}out(pub, message_b_968)
    ) | (
        {475}get statestore(=bob,=alice,=sid,statepack_c(hs_969: handshakestate)) in
        {430}in(pub, message_c_970: bitstring);
        {431}let v_971: bitstring = catch-fail(handshakestateunpack(hs_969)) in
        {432}let v_972: bitstring = catch-fail(deconcat3(message_c_970)) in
        {433}let v_973: bool = catch-fail(true) in
        {434}let v_974: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_971))) in
        {435}let v_975: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_974))) in
        {436}let v_976: aead = catch-fail(decrypt(1-proj-2-tuple(v_975),2-proj-2-tuple(v_975),3-proj-3-tuple(v_974),2-proj-3-tuple(v_972))) in
        {437}let v_977: bitstring = catch-fail(aeadunpack(v_976)) in
        {438}let v_978: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_974))) in
        {439}let v_979: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_975))) && success?(1-proj-3-tuple(v_974))) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-2-tuple(v_978))))) then cipherstatepack(1-proj-2-tuple(v_978),increment_nonce(2-proj-2-tuple(v_975))) else fail-any) else fail-any)) in
        {440}let v_980: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_972)) && (success?(3-proj-3-tuple(v_974)) && success?(1-proj-3-tuple(v_974)))) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-2-tuple(v_975))))) then (if not-caught-fail(v_976) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-3-tuple(v_977))))) then (if not-caught-fail(v_979) then (v_979,3-proj-3-tuple(v_977),1-proj-3-tuple(v_977)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {441}let v_981: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_980),2-proj-3-tuple(v_974),3-proj-3-tuple(v_974)))) in
        {442}let v_982: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_972)) && success?(symmetricstatepack(1-proj-3-tuple(v_980),2-proj-3-tuple(v_974),3-proj-3-tuple(v_974)))) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then symmetricstatepack(1-proj-3-tuple(v_981),2-proj-3-tuple(v_981),hash(3-proj-3-tuple(v_981),2-proj-3-tuple(v_972))) else fail-any) else fail-any)) in
        {443}let v_983: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_972)) && success?(1-proj-7-tuple(v_971))) then (if (not-caught-fail(v_974) && success?(is-true(success?(1-proj-3-tuple(v_974))))) then (if (not-caught-fail(v_980) && success?(is-true(success?(1-proj-3-tuple(v_980))))) then (if not-caught-fail(v_982) then (v_982,2-proj-3-tuple(v_980),3-proj-3-tuple(v_980)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {444}let v_984: key = catch-fail(2-proj-3-tuple(v_983)) in
        {445}let v_985: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_971))) in
        {446}let v_986: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_983))) in
        {447}let v_987: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_986),(if success?(3-proj-7-tuple(v_971)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then dhexp(2-proj-2-tuple(v_985),v_984) else fail-any) else fail-any))) in
        {448}let v_988: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_986),(if success?(3-proj-7-tuple(v_971)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then dhexp(2-proj-2-tuple(v_985),v_984) else fail-any) else fail-any))) in
        {449}let v_989: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_986),(if success?(3-proj-7-tuple(v_971)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then dhexp(2-proj-2-tuple(v_985),v_984) else fail-any) else fail-any))) in
        {450}let v_990: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_971)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then dhexp(2-proj-2-tuple(v_985),v_984) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_986))) then (if not-caught-fail(v_987) then (if not-caught-fail(v_988) then (if not-caught-fail(v_989) then (v_987,v_988,v_989) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {451}let v_991: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_971)) then (if (not-caught-fail(v_985) && success?(is-true(success?(1-proj-2-tuple(v_985))))) then dhexp(2-proj-2-tuple(v_985),v_984) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_983))) then (if (not-caught-fail(v_986) && success?(is-true(success?(1-proj-3-tuple(v_986))))) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-3-tuple(v_990))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_990)) then cipherstatepack(2-proj-3-tuple(v_990),minnonce) else fail-any),1-proj-3-tuple(v_990),3-proj-3-tuple(v_986)) else fail-any) else fail-any) else fail-any)) in
        {452}let v_992: bitstring = catch-fail(symmetricstateunpack(v_991)) in
        {453}let v_993: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_992))) in
        {454}let v_994: aead = catch-fail(decrypt(1-proj-2-tuple(v_993),2-proj-2-tuple(v_993),3-proj-3-tuple(v_992),3-proj-3-tuple(v_972))) in
        {455}let v_995: bitstring = catch-fail(aeadunpack(v_994)) in
        {456}let v_996: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_992))) in
        {457}let v_997: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_993))) && success?(1-proj-3-tuple(v_992))) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-2-tuple(v_996))))) then cipherstatepack(1-proj-2-tuple(v_996),increment_nonce(2-proj-2-tuple(v_993))) else fail-any) else fail-any)) in
        {458}let v_998: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_972)) && (success?(3-proj-3-tuple(v_992)) && success?(1-proj-3-tuple(v_992)))) then (if (not-caught-fail(v_993) && success?(is-true(success?(1-proj-2-tuple(v_993))))) then (if not-caught-fail(v_994) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then (if not-caught-fail(v_997) then (v_997,3-proj-3-tuple(v_995),1-proj-3-tuple(v_995)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {459}let v_999: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_998),2-proj-3-tuple(v_992),3-proj-3-tuple(v_992)))) in
        {460}let v_1000: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_972)) && success?(symmetricstatepack(1-proj-3-tuple(v_998),2-proj-3-tuple(v_992),3-proj-3-tuple(v_992)))) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then symmetricstatepack(1-proj-3-tuple(v_999),2-proj-3-tuple(v_999),hash(3-proj-3-tuple(v_999),3-proj-3-tuple(v_972))) else fail-any) else fail-any)) in
        {461}let v_1001: bitstring = catch-fail((if success?(3-proj-3-tuple(v_972)) then (if (not-caught-fail(v_992) && success?(is-true(success?(1-proj-3-tuple(v_992))))) then (if (not-caught-fail(v_998) && success?(is-true(success?(1-proj-3-tuple(v_998))))) then (if not-caught-fail(v_1000) then (v_1000,2-proj-3-tuple(v_998),3-proj-3-tuple(v_998)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {462}let v_1002: key = catch-fail(dhexp(key_s(alice),g)) in
        {463}let v_1003: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1001),2-proj-7-tuple(v_971),3-proj-7-tuple(v_971),v_984,5-proj-7-tuple(v_971),6-proj-7-tuple(v_971),7-proj-7-tuple(v_971))) in
        {464}let v_1004: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1001))) in
        {465}let v_1005: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1004),zero)) in
        {466}let v_1006: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1004),zero)) in
        {467}let v_1007: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1004),zero)) in
        {468}let v_1008: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1004)) then (if not-caught-fail(v_1005) then (if not-caught-fail(v_1006) then (if not-caught-fail(v_1007) then (v_1005,v_1006,v_1007) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {469}let v_1009: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1008)) then cipherstatepack(1-proj-3-tuple(v_1008),minnonce) else fail-any)) in
        {470}let v_1010: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1008)) then cipherstatepack(2-proj-3-tuple(v_1008),minnonce) else fail-any)) in
        {471}let v_1011: bitstring = catch-fail((if success?(1-proj-3-tuple(v_1001)) then (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-3-tuple(v_1004))))) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-3-tuple(v_1008))))) then (if not-caught-fail(v_1009) then (if not-caught-fail(v_1010) then (1-proj-3-tuple(v_1001),v_1009,v_1010) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {472}let (hs_1012: handshakestate,plaintext_c: bitstring,valid_1013: bool,cs1_1014: cipherstate,cs2_1015: cipherstate) = (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-7-tuple(v_971))))) then (if (not-caught-fail(v_972) && success?(is-true(success?(1-proj-3-tuple(v_972))))) then (if not-caught-fail(v_973) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-3-tuple(v_983))))) then (if not-caught-fail(v_984) then (if not-caught-fail(v_991) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-3-tuple(v_1001))))) then (if ((3-proj-3-tuple(v_983) && 3-proj-3-tuple(v_1001)) && (v_984 = getpublickey((if not-caught-fail(v_1002) then keypairpack(v_1002,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_1003) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-3-tuple(v_1011))))) then (v_1003,2-proj-3-tuple(v_1001),true,2-proj-3-tuple(v_1011),3-proj-3-tuple(v_1011)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {473}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {474}insert statestore(bob,alice,sid,statepack_d(hs_1012,cs1_1014,cs2_1015))
    ) | (
        {476}!
        {495}get statestore(=bob,=alice,=sid,statepack_d(hs_1016: handshakestate,cs1_1017: cipherstate,cs2_1018: cipherstate)) in
        {477}let hs_1019: handshakestate = handshakestatesetcs(hs_1016,cs2_1018) in
        {478}let v_1020: bitstring = catch-fail(handshakestateunpack(hs_1019)) in
        {479}let v_1021: bitstring = catch-fail((empty,empty,empty)) in
        {480}let v_1022: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1020))) in
        {481}let v_1023: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1022))) in
        {482}let v_1024: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1023),2-proj-2-tuple(v_1023),3-proj-3-tuple(v_1022),msg_d(bob,alice,sid))) in
        {483}let v_1025: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1022))) in
        {484}let v_1026: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1023))) && success?(1-proj-3-tuple(v_1022))) then (if (not-caught-fail(v_1025) && success?(is-true(success?(1-proj-2-tuple(v_1025))))) then cipherstatepack(1-proj-2-tuple(v_1025),increment_nonce(2-proj-2-tuple(v_1023))) else fail-any) else fail-any)) in
        {485}let v_1027: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1022)) && success?(1-proj-3-tuple(v_1022))) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-2-tuple(v_1023))))) then (if not-caught-fail(v_1024) then (if not-caught-fail(v_1026) then (v_1026,v_1024) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {486}let v_1028: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1027),2-proj-3-tuple(v_1022),3-proj-3-tuple(v_1022)))) in
        {487}let v_1029: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1027)) && success?(symmetricstatepack(1-proj-2-tuple(v_1027),2-proj-3-tuple(v_1022),3-proj-3-tuple(v_1022)))) then (if (not-caught-fail(v_1028) && success?(is-true(success?(1-proj-3-tuple(v_1028))))) then symmetricstatepack(1-proj-3-tuple(v_1028),2-proj-3-tuple(v_1028),hash(3-proj-3-tuple(v_1028),2-proj-2-tuple(v_1027))) else fail-any) else fail-any)) in
        {488}let v_1030: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1020)) then (if (not-caught-fail(v_1022) && success?(is-true(success?(1-proj-3-tuple(v_1022))))) then (if (not-caught-fail(v_1027) && success?(is-true(success?(1-proj-2-tuple(v_1027))))) then (if not-caught-fail(v_1029) then (v_1029,2-proj-2-tuple(v_1027)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {489}let v_1031: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1030),2-proj-7-tuple(v_1020),3-proj-7-tuple(v_1020),4-proj-7-tuple(v_1020),5-proj-7-tuple(v_1020),6-proj-7-tuple(v_1020),7-proj-7-tuple(v_1020))) in
        {490}let v_1032: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1021),2-proj-3-tuple(v_1021),2-proj-2-tuple(v_1030))) in
        {491}let (hs_1033: handshakestate,message_d_1034: bitstring) = (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-7-tuple(v_1020))))) then (if (not-caught-fail(v_1021) && success?(is-true(success?(1-proj-3-tuple(v_1021))))) then (if (not-caught-fail(v_1030) && success?(is-true(success?(1-proj-2-tuple(v_1030))))) then (if not-caught-fail(v_1031) then (if not-caught-fail(v_1032) then (v_1031,v_1032) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {492}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice,sid));
        {493}insert statestore(bob,alice,sid,statepack_e(hs_1033,cs1_1017,handshakestategetcs(hs_1033)));
        {494}out(pub, message_d_1034)
    ) | (
        {496}!
        {516}get statestore(=bob,=alice,=sid,statepack_e(hs_1035: handshakestate,cs1_1036: cipherstate,cs2_1037: cipherstate)) in
        {497}let hs_1038: handshakestate = handshakestatesetcs(hs_1035,cs1_1036) in
        {498}in(pub, message_e_1039: bitstring);
        {499}let v_1040: bitstring = catch-fail(handshakestateunpack(hs_1038)) in
        {500}let v_1041: bitstring = catch-fail(deconcat3(message_e_1039)) in
        {501}let v_1042: bool = catch-fail(true) in
        {502}let v_1043: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1040))) in
        {503}let v_1044: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1043))) in
        {504}let v_1045: aead = catch-fail(decrypt(1-proj-2-tuple(v_1044),2-proj-2-tuple(v_1044),3-proj-3-tuple(v_1043),3-proj-3-tuple(v_1041))) in
        {505}let v_1046: bitstring = catch-fail(aeadunpack(v_1045)) in
        {506}let v_1047: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1043))) in
        {507}let v_1048: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1044))) && success?(1-proj-3-tuple(v_1043))) then (if (not-caught-fail(v_1047) && success?(is-true(success?(1-proj-2-tuple(v_1047))))) then cipherstatepack(1-proj-2-tuple(v_1047),increment_nonce(2-proj-2-tuple(v_1044))) else fail-any) else fail-any)) in
        {508}let v_1049: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1041)) && (success?(3-proj-3-tuple(v_1043)) && success?(1-proj-3-tuple(v_1043)))) then (if (not-caught-fail(v_1044) && success?(is-true(success?(1-proj-2-tuple(v_1044))))) then (if not-caught-fail(v_1045) then (if (not-caught-fail(v_1046) && success?(is-true(success?(1-proj-3-tuple(v_1046))))) then (if not-caught-fail(v_1048) then (v_1048,3-proj-3-tuple(v_1046),1-proj-3-tuple(v_1046)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {509}let v_1050: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1049),2-proj-3-tuple(v_1043),3-proj-3-tuple(v_1043)))) in
        {510}let v_1051: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1041)) && success?(symmetricstatepack(1-proj-3-tuple(v_1049),2-proj-3-tuple(v_1043),3-proj-3-tuple(v_1043)))) then (if (not-caught-fail(v_1050) && success?(is-true(success?(1-proj-3-tuple(v_1050))))) then symmetricstatepack(1-proj-3-tuple(v_1050),2-proj-3-tuple(v_1050),hash(3-proj-3-tuple(v_1050),3-proj-3-tuple(v_1041))) else fail-any) else fail-any)) in
        {511}let v_1052: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1041)) && success?(1-proj-7-tuple(v_1040))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-3-tuple(v_1043))))) then (if (not-caught-fail(v_1049) && success?(is-true(success?(1-proj-3-tuple(v_1049))))) then (if not-caught-fail(v_1051) then (v_1051,2-proj-3-tuple(v_1049),3-proj-3-tuple(v_1049)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {512}let v_1053: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1052),2-proj-7-tuple(v_1040),3-proj-7-tuple(v_1040),4-proj-7-tuple(v_1040),5-proj-7-tuple(v_1040),6-proj-7-tuple(v_1040),7-proj-7-tuple(v_1040))) in
        {513}let (hs_1054: handshakestate,plaintext_e: bitstring,valid_1055: bool) = (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-7-tuple(v_1040))))) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-3-tuple(v_1041))))) then (if not-caught-fail(v_1042) then (if (not-caught-fail(v_1052) && success?(is-true(success?(1-proj-3-tuple(v_1052))))) then (if (v_1042 && 3-proj-3-tuple(v_1052)) then (if not-caught-fail(v_1053) then (v_1053,2-proj-3-tuple(v_1052),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {514}event RecvMsg(bob,alice,stagepack_e(sid),plaintext_e);
        {515}event RecvEnd(valid_1055)
    ) | (
        {517}event LeakS(phase0,bob);
        {518}out(pub, key_s(bob))
    ) | (
        {519}phase 1;
        {520}event LeakS(phase1,bob);
        {521}out(pub, key_s(bob))
    )
) | (
    {522}let s_1056: keypair = keypairpack(empty,empty) in
    {523}out(pub, getpublickey(s_1056));
    (
        {524}let e_1057: keypair = keypairpack(empty,empty) in
        {525}let rs_1058: key = empty in
        {526}let re_1059: key = empty in
        {527}let v_1060: bitstring = catch-fail(hash(somename,empty)) in
        {528}let v_1061: key = catch-fail(v_1060) in
        {529}let v_1062: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {530}let v_1063: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_1060) then (if not-caught-fail(v_1061) then (if not-caught-fail(v_1062) then symmetricstatepack(v_1062,v_1061,v_1060) else fail-any) else fail-any) else fail-any))) in
        {531}let v_1064: symmetricstate = catch-fail((if success?((if not-caught-fail(v_1060) then (if not-caught-fail(v_1061) then (if not-caught-fail(v_1062) then symmetricstatepack(v_1062,v_1061,v_1060) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_1063) && success?(is-true(success?(1-proj-3-tuple(v_1063))))) then symmetricstatepack(1-proj-3-tuple(v_1063),2-proj-3-tuple(v_1063),hash(3-proj-3-tuple(v_1063),empty)) else fail-any) else fail-any)) in
        {532}let hs_1065: handshakestate = (if not-caught-fail(v_1064) then handshakestatepack(v_1064,s_1056,e_1057,rs_1058,re_1059,empty,false) else fail-any) in
        {533}insert statestore(bob,charlie,sid,statepack_a(hs_1065))
    ) | (
        {555}get statestore(=bob,=charlie,=sid,statepack_a(hs_1066: handshakestate)) in
        {534}in(pub, message_a_1067: bitstring);
        {535}let v_1068: bitstring = catch-fail(handshakestateunpack(hs_1066)) in
        {536}let v_1069: bitstring = catch-fail(deconcat3(message_a_1067)) in
        {537}let v_1070: bool = catch-fail(true) in
        {538}let v_1071: key = catch-fail(1-proj-3-tuple(v_1069)) in
        {539}let v_1072: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1068))) in
        {540}let v_1073: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1068)) then (if (not-caught-fail(v_1072) && success?(is-true(success?(1-proj-3-tuple(v_1072))))) then symmetricstatepack(1-proj-3-tuple(v_1072),2-proj-3-tuple(v_1072),hash(3-proj-3-tuple(v_1072),v_1071)) else fail-any) else fail-any)) in
        {541}let v_1074: bitstring = catch-fail(symmetricstateunpack(v_1073)) in
        {542}let v_1075: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1074))) in
        {543}let v_1076: aead = catch-fail(decrypt(1-proj-2-tuple(v_1075),2-proj-2-tuple(v_1075),3-proj-3-tuple(v_1074),3-proj-3-tuple(v_1069))) in
        {544}let v_1077: bitstring = catch-fail(aeadunpack(v_1076)) in
        {545}let v_1078: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1074))) in
        {546}let v_1079: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1075))) && success?(1-proj-3-tuple(v_1074))) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then cipherstatepack(1-proj-2-tuple(v_1078),increment_nonce(2-proj-2-tuple(v_1075))) else fail-any) else fail-any)) in
        {547}let v_1080: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1069)) && (success?(3-proj-3-tuple(v_1074)) && success?(1-proj-3-tuple(v_1074)))) then (if (not-caught-fail(v_1075) && success?(is-true(success?(1-proj-2-tuple(v_1075))))) then (if not-caught-fail(v_1076) then (if (not-caught-fail(v_1077) && success?(is-true(success?(1-proj-3-tuple(v_1077))))) then (if not-caught-fail(v_1079) then (v_1079,3-proj-3-tuple(v_1077),1-proj-3-tuple(v_1077)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {548}let v_1081: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1080),2-proj-3-tuple(v_1074),3-proj-3-tuple(v_1074)))) in
        {549}let v_1082: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1069)) && success?(symmetricstatepack(1-proj-3-tuple(v_1080),2-proj-3-tuple(v_1074),3-proj-3-tuple(v_1074)))) then (if (not-caught-fail(v_1081) && success?(is-true(success?(1-proj-3-tuple(v_1081))))) then symmetricstatepack(1-proj-3-tuple(v_1081),2-proj-3-tuple(v_1081),hash(3-proj-3-tuple(v_1081),3-proj-3-tuple(v_1069))) else fail-any) else fail-any)) in
        {550}let v_1083: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1069)) then (if (not-caught-fail(v_1074) && success?(is-true(success?(1-proj-3-tuple(v_1074))))) then (if (not-caught-fail(v_1080) && success?(is-true(success?(1-proj-3-tuple(v_1080))))) then (if not-caught-fail(v_1082) then (v_1082,2-proj-3-tuple(v_1080),3-proj-3-tuple(v_1080)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {551}let v_1084: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1083),2-proj-7-tuple(v_1068),3-proj-7-tuple(v_1068),4-proj-7-tuple(v_1068),v_1071,6-proj-7-tuple(v_1068),7-proj-7-tuple(v_1068))) in
        {552}let (hs_1085: handshakestate,plaintext_a_1086: bitstring,valid_1087: bool) = (if (not-caught-fail(v_1068) && success?(is-true(success?(1-proj-7-tuple(v_1068))))) then (if (not-caught-fail(v_1069) && success?(is-true(success?(1-proj-3-tuple(v_1069))))) then (if not-caught-fail(v_1070) then (if not-caught-fail(v_1071) then (if not-caught-fail(v_1073) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then (if (v_1070 && 3-proj-3-tuple(v_1083)) then (if not-caught-fail(v_1084) then (v_1084,2-proj-3-tuple(v_1083),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {553}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_1086);
        {554}insert statestore(bob,charlie,sid,statepack_b(hs_1085))
    ) | (
        {603}get statestore(=bob,=charlie,=sid,statepack_b(hs_1088: handshakestate)) in
        {556}let v_1089: bitstring = catch-fail(handshakestateunpack(hs_1088)) in
        {557}let v_1090: bitstring = catch-fail((empty,empty,empty)) in
        {558}let v_1091: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {559}let v_1092: keypair = catch-fail((if not-caught-fail(v_1091) then keypairpack(v_1091,key_e(bob,charlie,sid)) else fail-any)) in
        {560}let v_1093: bitstring = catch-fail(getpublickey(v_1092)) in
        {561}let v_1094: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1089))) in
        {562}let v_1095: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1094) && success?(is-true(success?(1-proj-3-tuple(v_1094))))) then symmetricstatepack(1-proj-3-tuple(v_1094),2-proj-3-tuple(v_1094),hash(3-proj-3-tuple(v_1094),v_1093)) else fail-any) else fail-any)) in
        {563}let v_1096: bitstring = catch-fail(keypairunpack(v_1092)) in
        {564}let v_1097: bitstring = catch-fail(symmetricstateunpack(v_1095)) in
        {565}let v_1098: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1097),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-2-tuple(v_1096))))) then dhexp(2-proj-2-tuple(v_1096),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {566}let v_1099: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1097),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-2-tuple(v_1096))))) then dhexp(2-proj-2-tuple(v_1096),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {567}let v_1100: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1097),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-2-tuple(v_1096))))) then dhexp(2-proj-2-tuple(v_1096),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {568}let v_1101: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-2-tuple(v_1096))))) then dhexp(2-proj-2-tuple(v_1096),5-proj-7-tuple(v_1089)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1097))) then (if not-caught-fail(v_1098) then (if not-caught-fail(v_1099) then (if not-caught-fail(v_1100) then (v_1098,v_1099,v_1100) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {569}let v_1102: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-2-tuple(v_1096))))) then dhexp(2-proj-2-tuple(v_1096),5-proj-7-tuple(v_1089)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1097) && success?(is-true(success?(1-proj-3-tuple(v_1097))))) then (if (not-caught-fail(v_1101) && success?(is-true(success?(1-proj-3-tuple(v_1101))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1101)) then cipherstatepack(2-proj-3-tuple(v_1101),minnonce) else fail-any),1-proj-3-tuple(v_1101),3-proj-3-tuple(v_1097)) else fail-any) else fail-any) else fail-any)) in
        {570}let v_1103: key = catch-fail(dhexp(key_s(bob),g)) in
        {571}let v_1104: keypair = catch-fail((if not-caught-fail(v_1103) then keypairpack(v_1103,key_s(bob)) else fail-any)) in
        {572}let v_1105: bitstring = catch-fail(symmetricstateunpack(v_1102)) in
        {573}let v_1106: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1105))) in
        {574}let v_1107: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1106),2-proj-2-tuple(v_1106),3-proj-3-tuple(v_1105),getpublickey(v_1104))) in
        {575}let v_1108: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1105))) in
        {576}let v_1109: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1106))) && success?(1-proj-3-tuple(v_1105))) then (if (not-caught-fail(v_1108) && success?(is-true(success?(1-proj-2-tuple(v_1108))))) then cipherstatepack(1-proj-2-tuple(v_1108),increment_nonce(2-proj-2-tuple(v_1106))) else fail-any) else fail-any)) in
        {577}let v_1110: bitstring = catch-fail((if (success?(getpublickey(v_1104)) && (success?(3-proj-3-tuple(v_1105)) && success?(1-proj-3-tuple(v_1105)))) then (if (not-caught-fail(v_1106) && success?(is-true(success?(1-proj-2-tuple(v_1106))))) then (if not-caught-fail(v_1107) then (if not-caught-fail(v_1109) then (v_1109,v_1107) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {578}let v_1111: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1110),2-proj-3-tuple(v_1105),3-proj-3-tuple(v_1105)))) in
        {579}let v_1112: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1110)) && success?(symmetricstatepack(1-proj-2-tuple(v_1110),2-proj-3-tuple(v_1105),3-proj-3-tuple(v_1105)))) then (if (not-caught-fail(v_1111) && success?(is-true(success?(1-proj-3-tuple(v_1111))))) then symmetricstatepack(1-proj-3-tuple(v_1111),2-proj-3-tuple(v_1111),hash(3-proj-3-tuple(v_1111),2-proj-2-tuple(v_1110))) else fail-any) else fail-any)) in
        {580}let v_1113: bitstring = catch-fail((if success?(getpublickey(v_1104)) then (if (not-caught-fail(v_1105) && success?(is-true(success?(1-proj-3-tuple(v_1105))))) then (if (not-caught-fail(v_1110) && success?(is-true(success?(1-proj-2-tuple(v_1110))))) then (if not-caught-fail(v_1112) then (v_1112,2-proj-2-tuple(v_1110)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {581}let v_1114: bitstring = catch-fail(keypairunpack(v_1104)) in
        {582}let v_1115: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1113))) in
        {583}let v_1116: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1115),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-2-tuple(v_1114))))) then dhexp(2-proj-2-tuple(v_1114),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {584}let v_1117: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1115),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-2-tuple(v_1114))))) then dhexp(2-proj-2-tuple(v_1114),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {585}let v_1118: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1115),(if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-2-tuple(v_1114))))) then dhexp(2-proj-2-tuple(v_1114),5-proj-7-tuple(v_1089)) else fail-any) else fail-any))) in
        {586}let v_1119: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-2-tuple(v_1114))))) then dhexp(2-proj-2-tuple(v_1114),5-proj-7-tuple(v_1089)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1115))) then (if not-caught-fail(v_1116) then (if not-caught-fail(v_1117) then (if not-caught-fail(v_1118) then (v_1116,v_1117,v_1118) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {587}let v_1120: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1089)) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-2-tuple(v_1114))))) then dhexp(2-proj-2-tuple(v_1114),5-proj-7-tuple(v_1089)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_1113))) then (if (not-caught-fail(v_1115) && success?(is-true(success?(1-proj-3-tuple(v_1115))))) then (if (not-caught-fail(v_1119) && success?(is-true(success?(1-proj-3-tuple(v_1119))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1119)) then cipherstatepack(2-proj-3-tuple(v_1119),minnonce) else fail-any),1-proj-3-tuple(v_1119),3-proj-3-tuple(v_1115)) else fail-any) else fail-any) else fail-any)) in
        {588}let v_1121: bitstring = catch-fail(symmetricstateunpack(v_1120)) in
        {589}let v_1122: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1121))) in
        {590}let v_1123: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1122),2-proj-2-tuple(v_1122),3-proj-3-tuple(v_1121),msg_b(bob,charlie,sid))) in
        {591}let v_1124: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1121))) in
        {592}let v_1125: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1122))) && success?(1-proj-3-tuple(v_1121))) then (if (not-caught-fail(v_1124) && success?(is-true(success?(1-proj-2-tuple(v_1124))))) then cipherstatepack(1-proj-2-tuple(v_1124),increment_nonce(2-proj-2-tuple(v_1122))) else fail-any) else fail-any)) in
        {593}let v_1126: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1121)) && success?(1-proj-3-tuple(v_1121))) then (if (not-caught-fail(v_1122) && success?(is-true(success?(1-proj-2-tuple(v_1122))))) then (if not-caught-fail(v_1123) then (if not-caught-fail(v_1125) then (v_1125,v_1123) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {594}let v_1127: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1126),2-proj-3-tuple(v_1121),3-proj-3-tuple(v_1121)))) in
        {595}let v_1128: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1126)) && success?(symmetricstatepack(1-proj-2-tuple(v_1126),2-proj-3-tuple(v_1121),3-proj-3-tuple(v_1121)))) then (if (not-caught-fail(v_1127) && success?(is-true(success?(1-proj-3-tuple(v_1127))))) then symmetricstatepack(1-proj-3-tuple(v_1127),2-proj-3-tuple(v_1127),hash(3-proj-3-tuple(v_1127),2-proj-2-tuple(v_1126))) else fail-any) else fail-any)) in
        {596}let v_1129: bitstring = catch-fail((if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-3-tuple(v_1121))))) then (if (not-caught-fail(v_1126) && success?(is-true(success?(1-proj-2-tuple(v_1126))))) then (if not-caught-fail(v_1128) then (v_1128,2-proj-2-tuple(v_1126)) else fail-any) else fail-any) else fail-any)) in
        {597}let v_1130: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1129),v_1104,v_1092,4-proj-7-tuple(v_1089),5-proj-7-tuple(v_1089),6-proj-7-tuple(v_1089),7-proj-7-tuple(v_1089))) in
        {598}let v_1131: bitstring = catch-fail(concat3(v_1093,2-proj-2-tuple(v_1113),2-proj-2-tuple(v_1129))) in
        {599}let (hs_1132: handshakestate,message_b_1133: bitstring) = (if (not-caught-fail(v_1089) && success?(is-true(success?(1-proj-7-tuple(v_1089))))) then (if (not-caught-fail(v_1090) && success?(is-true(success?(1-proj-3-tuple(v_1090))))) then (if not-caught-fail(v_1092) then (if not-caught-fail(v_1093) then (if not-caught-fail(v_1095) then (if not-caught-fail(v_1102) then (if not-caught-fail(v_1104) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then (if not-caught-fail(v_1120) then (if (not-caught-fail(v_1129) && success?(is-true(success?(1-proj-2-tuple(v_1129))))) then (if not-caught-fail(v_1130) then (if not-caught-fail(v_1131) then (v_1130,v_1131) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {600}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {601}insert statestore(bob,charlie,sid,statepack_c(hs_1132));
        {602}out(pub, message_b_1133)
    ) | (
        {649}get statestore(=bob,=charlie,=sid,statepack_c(hs_1134: handshakestate)) in
        {604}in(pub, message_c_1135: bitstring);
        {605}let v_1136: bitstring = catch-fail(handshakestateunpack(hs_1134)) in
        {606}let v_1137: bitstring = catch-fail(deconcat3(message_c_1135)) in
        {607}let v_1138: bool = catch-fail(true) in
        {608}let v_1139: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1136))) in
        {609}let v_1140: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1139))) in
        {610}let v_1141: aead = catch-fail(decrypt(1-proj-2-tuple(v_1140),2-proj-2-tuple(v_1140),3-proj-3-tuple(v_1139),2-proj-3-tuple(v_1137))) in
        {611}let v_1142: bitstring = catch-fail(aeadunpack(v_1141)) in
        {612}let v_1143: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1139))) in
        {613}let v_1144: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1140))) && success?(1-proj-3-tuple(v_1139))) then (if (not-caught-fail(v_1143) && success?(is-true(success?(1-proj-2-tuple(v_1143))))) then cipherstatepack(1-proj-2-tuple(v_1143),increment_nonce(2-proj-2-tuple(v_1140))) else fail-any) else fail-any)) in
        {614}let v_1145: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1137)) && (success?(3-proj-3-tuple(v_1139)) && success?(1-proj-3-tuple(v_1139)))) then (if (not-caught-fail(v_1140) && success?(is-true(success?(1-proj-2-tuple(v_1140))))) then (if not-caught-fail(v_1141) then (if (not-caught-fail(v_1142) && success?(is-true(success?(1-proj-3-tuple(v_1142))))) then (if not-caught-fail(v_1144) then (v_1144,3-proj-3-tuple(v_1142),1-proj-3-tuple(v_1142)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {615}let v_1146: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1145),2-proj-3-tuple(v_1139),3-proj-3-tuple(v_1139)))) in
        {616}let v_1147: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1137)) && success?(symmetricstatepack(1-proj-3-tuple(v_1145),2-proj-3-tuple(v_1139),3-proj-3-tuple(v_1139)))) then (if (not-caught-fail(v_1146) && success?(is-true(success?(1-proj-3-tuple(v_1146))))) then symmetricstatepack(1-proj-3-tuple(v_1146),2-proj-3-tuple(v_1146),hash(3-proj-3-tuple(v_1146),2-proj-3-tuple(v_1137))) else fail-any) else fail-any)) in
        {617}let v_1148: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1137)) && success?(1-proj-7-tuple(v_1136))) then (if (not-caught-fail(v_1139) && success?(is-true(success?(1-proj-3-tuple(v_1139))))) then (if (not-caught-fail(v_1145) && success?(is-true(success?(1-proj-3-tuple(v_1145))))) then (if not-caught-fail(v_1147) then (v_1147,2-proj-3-tuple(v_1145),3-proj-3-tuple(v_1145)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {618}let v_1149: key = catch-fail(2-proj-3-tuple(v_1148)) in
        {619}let v_1150: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1136))) in
        {620}let v_1151: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1148))) in
        {621}let v_1152: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1151),(if success?(3-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),v_1149) else fail-any) else fail-any))) in
        {622}let v_1153: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1151),(if success?(3-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),v_1149) else fail-any) else fail-any))) in
        {623}let v_1154: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1151),(if success?(3-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),v_1149) else fail-any) else fail-any))) in
        {624}let v_1155: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),v_1149) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1151))) then (if not-caught-fail(v_1152) then (if not-caught-fail(v_1153) then (if not-caught-fail(v_1154) then (v_1152,v_1153,v_1154) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {625}let v_1156: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-2-tuple(v_1150))))) then dhexp(2-proj-2-tuple(v_1150),v_1149) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_1148))) then (if (not-caught-fail(v_1151) && success?(is-true(success?(1-proj-3-tuple(v_1151))))) then (if (not-caught-fail(v_1155) && success?(is-true(success?(1-proj-3-tuple(v_1155))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1155)) then cipherstatepack(2-proj-3-tuple(v_1155),minnonce) else fail-any),1-proj-3-tuple(v_1155),3-proj-3-tuple(v_1151)) else fail-any) else fail-any) else fail-any)) in
        {626}let v_1157: bitstring = catch-fail(symmetricstateunpack(v_1156)) in
        {627}let v_1158: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1157))) in
        {628}let v_1159: aead = catch-fail(decrypt(1-proj-2-tuple(v_1158),2-proj-2-tuple(v_1158),3-proj-3-tuple(v_1157),3-proj-3-tuple(v_1137))) in
        {629}let v_1160: bitstring = catch-fail(aeadunpack(v_1159)) in
        {630}let v_1161: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1157))) in
        {631}let v_1162: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1158))) && success?(1-proj-3-tuple(v_1157))) then (if (not-caught-fail(v_1161) && success?(is-true(success?(1-proj-2-tuple(v_1161))))) then cipherstatepack(1-proj-2-tuple(v_1161),increment_nonce(2-proj-2-tuple(v_1158))) else fail-any) else fail-any)) in
        {632}let v_1163: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1137)) && (success?(3-proj-3-tuple(v_1157)) && success?(1-proj-3-tuple(v_1157)))) then (if (not-caught-fail(v_1158) && success?(is-true(success?(1-proj-2-tuple(v_1158))))) then (if not-caught-fail(v_1159) then (if (not-caught-fail(v_1160) && success?(is-true(success?(1-proj-3-tuple(v_1160))))) then (if not-caught-fail(v_1162) then (v_1162,3-proj-3-tuple(v_1160),1-proj-3-tuple(v_1160)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {633}let v_1164: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1163),2-proj-3-tuple(v_1157),3-proj-3-tuple(v_1157)))) in
        {634}let v_1165: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1137)) && success?(symmetricstatepack(1-proj-3-tuple(v_1163),2-proj-3-tuple(v_1157),3-proj-3-tuple(v_1157)))) then (if (not-caught-fail(v_1164) && success?(is-true(success?(1-proj-3-tuple(v_1164))))) then symmetricstatepack(1-proj-3-tuple(v_1164),2-proj-3-tuple(v_1164),hash(3-proj-3-tuple(v_1164),3-proj-3-tuple(v_1137))) else fail-any) else fail-any)) in
        {635}let v_1166: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1137)) then (if (not-caught-fail(v_1157) && success?(is-true(success?(1-proj-3-tuple(v_1157))))) then (if (not-caught-fail(v_1163) && success?(is-true(success?(1-proj-3-tuple(v_1163))))) then (if not-caught-fail(v_1165) then (v_1165,2-proj-3-tuple(v_1163),3-proj-3-tuple(v_1163)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {636}let v_1167: key = catch-fail(dhexp(key_s(charlie),g)) in
        {637}let v_1168: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1166),2-proj-7-tuple(v_1136),3-proj-7-tuple(v_1136),v_1149,5-proj-7-tuple(v_1136),6-proj-7-tuple(v_1136),7-proj-7-tuple(v_1136))) in
        {638}let v_1169: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1166))) in
        {639}let v_1170: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1169),zero)) in
        {640}let v_1171: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1169),zero)) in
        {641}let v_1172: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1169),zero)) in
        {642}let v_1173: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1169)) then (if not-caught-fail(v_1170) then (if not-caught-fail(v_1171) then (if not-caught-fail(v_1172) then (v_1170,v_1171,v_1172) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {643}let v_1174: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1173)) then cipherstatepack(1-proj-3-tuple(v_1173),minnonce) else fail-any)) in
        {644}let v_1175: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1173)) then cipherstatepack(2-proj-3-tuple(v_1173),minnonce) else fail-any)) in
        {645}let v_1176: bitstring = catch-fail((if success?(1-proj-3-tuple(v_1166)) then (if (not-caught-fail(v_1169) && success?(is-true(success?(1-proj-3-tuple(v_1169))))) then (if (not-caught-fail(v_1173) && success?(is-true(success?(1-proj-3-tuple(v_1173))))) then (if not-caught-fail(v_1174) then (if not-caught-fail(v_1175) then (1-proj-3-tuple(v_1166),v_1174,v_1175) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {646}let (hs_1177: handshakestate,plaintext_c_1178: bitstring,valid_1179: bool,cs1_1180: cipherstate,cs2_1181: cipherstate) = (if (not-caught-fail(v_1136) && success?(is-true(success?(1-proj-7-tuple(v_1136))))) then (if (not-caught-fail(v_1137) && success?(is-true(success?(1-proj-3-tuple(v_1137))))) then (if not-caught-fail(v_1138) then (if (not-caught-fail(v_1148) && success?(is-true(success?(1-proj-3-tuple(v_1148))))) then (if not-caught-fail(v_1149) then (if not-caught-fail(v_1156) then (if (not-caught-fail(v_1166) && success?(is-true(success?(1-proj-3-tuple(v_1166))))) then (if ((3-proj-3-tuple(v_1148) && 3-proj-3-tuple(v_1166)) && (v_1149 = getpublickey((if not-caught-fail(v_1167) then keypairpack(v_1167,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1168) then (if (not-caught-fail(v_1176) && success?(is-true(success?(1-proj-3-tuple(v_1176))))) then (v_1168,2-proj-3-tuple(v_1166),true,2-proj-3-tuple(v_1176),3-proj-3-tuple(v_1176)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {647}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1178);
        {648}insert statestore(bob,charlie,sid,statepack_d(hs_1177,cs1_1180,cs2_1181))
    ) | (
        {650}!
        {669}get statestore(=bob,=charlie,=sid,statepack_d(hs_1182: handshakestate,cs1_1183: cipherstate,cs2_1184: cipherstate)) in
        {651}let hs_1185: handshakestate = handshakestatesetcs(hs_1182,cs2_1184) in
        {652}let v_1186: bitstring = catch-fail(handshakestateunpack(hs_1185)) in
        {653}let v_1187: bitstring = catch-fail((empty,empty,empty)) in
        {654}let v_1188: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1186))) in
        {655}let v_1189: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1188))) in
        {656}let v_1190: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1189),2-proj-2-tuple(v_1189),3-proj-3-tuple(v_1188),msg_d(bob,charlie,sid))) in
        {657}let v_1191: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1188))) in
        {658}let v_1192: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1189))) && success?(1-proj-3-tuple(v_1188))) then (if (not-caught-fail(v_1191) && success?(is-true(success?(1-proj-2-tuple(v_1191))))) then cipherstatepack(1-proj-2-tuple(v_1191),increment_nonce(2-proj-2-tuple(v_1189))) else fail-any) else fail-any)) in
        {659}let v_1193: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1188)) && success?(1-proj-3-tuple(v_1188))) then (if (not-caught-fail(v_1189) && success?(is-true(success?(1-proj-2-tuple(v_1189))))) then (if not-caught-fail(v_1190) then (if not-caught-fail(v_1192) then (v_1192,v_1190) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {660}let v_1194: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1193),2-proj-3-tuple(v_1188),3-proj-3-tuple(v_1188)))) in
        {661}let v_1195: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1193)) && success?(symmetricstatepack(1-proj-2-tuple(v_1193),2-proj-3-tuple(v_1188),3-proj-3-tuple(v_1188)))) then (if (not-caught-fail(v_1194) && success?(is-true(success?(1-proj-3-tuple(v_1194))))) then symmetricstatepack(1-proj-3-tuple(v_1194),2-proj-3-tuple(v_1194),hash(3-proj-3-tuple(v_1194),2-proj-2-tuple(v_1193))) else fail-any) else fail-any)) in
        {662}let v_1196: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1186)) then (if (not-caught-fail(v_1188) && success?(is-true(success?(1-proj-3-tuple(v_1188))))) then (if (not-caught-fail(v_1193) && success?(is-true(success?(1-proj-2-tuple(v_1193))))) then (if not-caught-fail(v_1195) then (v_1195,2-proj-2-tuple(v_1193)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {663}let v_1197: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1196),2-proj-7-tuple(v_1186),3-proj-7-tuple(v_1186),4-proj-7-tuple(v_1186),5-proj-7-tuple(v_1186),6-proj-7-tuple(v_1186),7-proj-7-tuple(v_1186))) in
        {664}let v_1198: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1187),2-proj-3-tuple(v_1187),2-proj-2-tuple(v_1196))) in
        {665}let (hs_1199: handshakestate,message_d_1200: bitstring) = (if (not-caught-fail(v_1186) && success?(is-true(success?(1-proj-7-tuple(v_1186))))) then (if (not-caught-fail(v_1187) && success?(is-true(success?(1-proj-3-tuple(v_1187))))) then (if (not-caught-fail(v_1196) && success?(is-true(success?(1-proj-2-tuple(v_1196))))) then (if not-caught-fail(v_1197) then (if not-caught-fail(v_1198) then (v_1197,v_1198) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {666}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie,sid));
        {667}insert statestore(bob,charlie,sid,statepack_e(hs_1199,cs1_1183,handshakestategetcs(hs_1199)));
        {668}out(pub, message_d_1200)
    ) | (
        {670}!
        {690}get statestore(=bob,=charlie,=sid,statepack_e(hs_1201: handshakestate,cs1_1202: cipherstate,cs2_1203: cipherstate)) in
        {671}let hs_1204: handshakestate = handshakestatesetcs(hs_1201,cs1_1202) in
        {672}in(pub, message_e_1205: bitstring);
        {673}let v_1206: bitstring = catch-fail(handshakestateunpack(hs_1204)) in
        {674}let v_1207: bitstring = catch-fail(deconcat3(message_e_1205)) in
        {675}let v_1208: bool = catch-fail(true) in
        {676}let v_1209: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1206))) in
        {677}let v_1210: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1209))) in
        {678}let v_1211: aead = catch-fail(decrypt(1-proj-2-tuple(v_1210),2-proj-2-tuple(v_1210),3-proj-3-tuple(v_1209),3-proj-3-tuple(v_1207))) in
        {679}let v_1212: bitstring = catch-fail(aeadunpack(v_1211)) in
        {680}let v_1213: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1209))) in
        {681}let v_1214: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1210))) && success?(1-proj-3-tuple(v_1209))) then (if (not-caught-fail(v_1213) && success?(is-true(success?(1-proj-2-tuple(v_1213))))) then cipherstatepack(1-proj-2-tuple(v_1213),increment_nonce(2-proj-2-tuple(v_1210))) else fail-any) else fail-any)) in
        {682}let v_1215: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1207)) && (success?(3-proj-3-tuple(v_1209)) && success?(1-proj-3-tuple(v_1209)))) then (if (not-caught-fail(v_1210) && success?(is-true(success?(1-proj-2-tuple(v_1210))))) then (if not-caught-fail(v_1211) then (if (not-caught-fail(v_1212) && success?(is-true(success?(1-proj-3-tuple(v_1212))))) then (if not-caught-fail(v_1214) then (v_1214,3-proj-3-tuple(v_1212),1-proj-3-tuple(v_1212)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {683}let v_1216: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1215),2-proj-3-tuple(v_1209),3-proj-3-tuple(v_1209)))) in
        {684}let v_1217: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1207)) && success?(symmetricstatepack(1-proj-3-tuple(v_1215),2-proj-3-tuple(v_1209),3-proj-3-tuple(v_1209)))) then (if (not-caught-fail(v_1216) && success?(is-true(success?(1-proj-3-tuple(v_1216))))) then symmetricstatepack(1-proj-3-tuple(v_1216),2-proj-3-tuple(v_1216),hash(3-proj-3-tuple(v_1216),3-proj-3-tuple(v_1207))) else fail-any) else fail-any)) in
        {685}let v_1218: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1207)) && success?(1-proj-7-tuple(v_1206))) then (if (not-caught-fail(v_1209) && success?(is-true(success?(1-proj-3-tuple(v_1209))))) then (if (not-caught-fail(v_1215) && success?(is-true(success?(1-proj-3-tuple(v_1215))))) then (if not-caught-fail(v_1217) then (v_1217,2-proj-3-tuple(v_1215),3-proj-3-tuple(v_1215)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {686}let v_1219: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1218),2-proj-7-tuple(v_1206),3-proj-7-tuple(v_1206),4-proj-7-tuple(v_1206),5-proj-7-tuple(v_1206),6-proj-7-tuple(v_1206),7-proj-7-tuple(v_1206))) in
        {687}let (hs_1220: handshakestate,plaintext_e_1221: bitstring,valid_1222: bool) = (if (not-caught-fail(v_1206) && success?(is-true(success?(1-proj-7-tuple(v_1206))))) then (if (not-caught-fail(v_1207) && success?(is-true(success?(1-proj-3-tuple(v_1207))))) then (if not-caught-fail(v_1208) then (if (not-caught-fail(v_1218) && success?(is-true(success?(1-proj-3-tuple(v_1218))))) then (if (v_1208 && 3-proj-3-tuple(v_1218)) then (if not-caught-fail(v_1219) then (v_1219,2-proj-3-tuple(v_1218),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {688}event RecvMsg(bob,charlie,stagepack_e(sid),plaintext_e_1221);
        {689}event RecvEnd(valid_1222)
    ) | (
        {691}event LeakS(phase0,bob);
        {692}out(pub, key_s(bob))
    ) | (
        {693}phase 1;
        {694}event LeakS(phase1,bob);
        {695}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1325,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1325,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1325,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1325,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1325,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_e(alice,bob,sid_a)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 182 rules in the queue.
400 rules inserted. The rule base contains 396 rules. 78 rules in the queue.
600 rules inserted. The rule base contains 588 rules. 166 rules in the queue.
800 rules inserted. The rule base contains 784 rules. 609 rules in the queue.
1000 rules inserted. The rule base contains 968 rules. 574 rules in the queue.
1200 rules inserted. The rule base contains 1153 rules. 534 rules in the queue.
1400 rules inserted. The rule base contains 1339 rules. 538 rules in the queue.
1600 rules inserted. The rule base contains 1539 rules. 672 rules in the queue.
1800 rules inserted. The rule base contains 1733 rules. 797 rules in the queue.
2000 rules inserted. The rule base contains 1923 rules. 820 rules in the queue.
2200 rules inserted. The rule base contains 2123 rules. 952 rules in the queue.
2400 rules inserted. The rule base contains 2321 rules. 1016 rules in the queue.
2600 rules inserted. The rule base contains 2521 rules. 1156 rules in the queue.
2800 rules inserted. The rule base contains 2659 rules. 1229 rules in the queue.
3000 rules inserted. The rule base contains 2764 rules. 1210 rules in the queue.
3200 rules inserted. The rule base contains 2909 rules. 1176 rules in the queue.
3400 rules inserted. The rule base contains 3001 rules. 1185 rules in the queue.
3600 rules inserted. The rule base contains 3122 rules. 1136 rules in the queue.
3800 rules inserted. The rule base contains 3256 rules. 1078 rules in the queue.
4000 rules inserted. The rule base contains 3366 rules. 1063 rules in the queue.
4200 rules inserted. The rule base contains 3549 rules. 1146 rules in the queue.
4400 rules inserted. The rule base contains 3740 rules. 1293 rules in the queue.
4600 rules inserted. The rule base contains 3922 rules. 1437 rules in the queue.
4800 rules inserted. The rule base contains 4104 rules. 1448 rules in the queue.
5000 rules inserted. The rule base contains 4251 rules. 1588 rules in the queue.
5200 rules inserted. The rule base contains 4392 rules. 1615 rules in the queue.
5400 rules inserted. The rule base contains 4554 rules. 1656 rules in the queue.
5600 rules inserted. The rule base contains 4730 rules. 1712 rules in the queue.
5800 rules inserted. The rule base contains 4926 rules. 2436 rules in the queue.
6000 rules inserted. The rule base contains 5011 rules. 2469 rules in the queue.
6200 rules inserted. The rule base contains 5153 rules. 2481 rules in the queue.
6400 rules inserted. The rule base contains 5345 rules. 3205 rules in the queue.
6600 rules inserted. The rule base contains 5530 rules. 3251 rules in the queue.
6800 rules inserted. The rule base contains 5644 rules. 3252 rules in the queue.
7000 rules inserted. The rule base contains 5758 rules. 3255 rules in the queue.
7200 rules inserted. The rule base contains 5881 rules. 3255 rules in the queue.
7400 rules inserted. The rule base contains 6040 rules. 3243 rules in the queue.
7600 rules inserted. The rule base contains 6219 rules. 3179 rules in the queue.
7800 rules inserted. The rule base contains 6398 rules. 3129 rules in the queue.
8000 rules inserted. The rule base contains 6585 rules. 3079 rules in the queue.
8200 rules inserted. The rule base contains 6777 rules. 3039 rules in the queue.
8400 rules inserted. The rule base contains 6852 rules. 3117 rules in the queue.
8600 rules inserted. The rule base contains 6963 rules. 3127 rules in the queue.
8800 rules inserted. The rule base contains 7117 rules. 3089 rules in the queue.
9000 rules inserted. The rule base contains 7308 rules. 3046 rules in the queue.
9200 rules inserted. The rule base contains 7487 rules. 2996 rules in the queue.
9400 rules inserted. The rule base contains 7673 rules. 2946 rules in the queue.
9600 rules inserted. The rule base contains 7774 rules. 2975 rules in the queue.
9800 rules inserted. The rule base contains 7943 rules. 2978 rules in the queue.
10000 rules inserted. The rule base contains 8112 rules. 2973 rules in the queue.
10200 rules inserted. The rule base contains 8279 rules. 2961 rules in the queue.
10400 rules inserted. The rule base contains 8444 rules. 2953 rules in the queue.
10600 rules inserted. The rule base contains 8626 rules. 3046 rules in the queue.
10800 rules inserted. The rule base contains 8819 rules. 3053 rules in the queue.
11000 rules inserted. The rule base contains 9019 rules. 3067 rules in the queue.
11200 rules inserted. The rule base contains 9029 rules. 3166 rules in the queue.
11400 rules inserted. The rule base contains 8913 rules. 3286 rules in the queue.
11600 rules inserted. The rule base contains 9047 rules. 3271 rules in the queue.
11800 rules inserted. The rule base contains 9201 rules. 3285 rules in the queue.
12000 rules inserted. The rule base contains 9394 rules. 3363 rules in the queue.
12200 rules inserted. The rule base contains 9594 rules. 3377 rules in the queue.
12400 rules inserted. The rule base contains 9794 rules. 3391 rules in the queue.
12600 rules inserted. The rule base contains 9484 rules. 3612 rules in the queue.
12800 rules inserted. The rule base contains 9625 rules. 3622 rules in the queue.
13000 rules inserted. The rule base contains 9757 rules. 3640 rules in the queue.
13200 rules inserted. The rule base contains 9884 rules. 3650 rules in the queue.
13400 rules inserted. The rule base contains 10024 rules. 3664 rules in the queue.
13600 rules inserted. The rule base contains 10224 rules. 3594 rules in the queue.
13800 rules inserted. The rule base contains 10424 rules. 3608 rules in the queue.
14000 rules inserted. The rule base contains 10624 rules. 3622 rules in the queue.
14200 rules inserted. The rule base contains 10816 rules. 3636 rules in the queue.
14400 rules inserted. The rule base contains 10710 rules. 3584 rules in the queue.
14600 rules inserted. The rule base contains 10801 rules. 3587 rules in the queue.
14800 rules inserted. The rule base contains 10930 rules. 3584 rules in the queue.
15000 rules inserted. The rule base contains 11079 rules. 3581 rules in the queue.
15200 rules inserted. The rule base contains 11279 rules. 3518 rules in the queue.
15400 rules inserted. The rule base contains 11479 rules. 3532 rules in the queue.
15600 rules inserted. The rule base contains 11679 rules. 3546 rules in the queue.
15800 rules inserted. The rule base contains 11809 rules. 3536 rules in the queue.
16000 rules inserted. The rule base contains 11689 rules. 3490 rules in the queue.
16200 rules inserted. The rule base contains 11817 rules. 3562 rules in the queue.
16400 rules inserted. The rule base contains 11965 rules. 3599 rules in the queue.
16600 rules inserted. The rule base contains 12112 rules. 3638 rules in the queue.
16800 rules inserted. The rule base contains 12258 rules. 3668 rules in the queue.
17000 rules inserted. The rule base contains 12396 rules. 3702 rules in the queue.
17200 rules inserted. The rule base contains 12536 rules. 3738 rules in the queue.
17400 rules inserted. The rule base contains 12664 rules. 3756 rules in the queue.
17600 rules inserted. The rule base contains 12786 rules. 3757 rules in the queue.
17800 rules inserted. The rule base contains 12803 rules. 3825 rules in the queue.
18000 rules inserted. The rule base contains 12477 rules. 3879 rules in the queue.
18200 rules inserted. The rule base contains 12648 rules. 3895 rules in the queue.
18400 rules inserted. The rule base contains 12825 rules. 3916 rules in the queue.
18600 rules inserted. The rule base contains 12925 rules. 3948 rules in the queue.
18800 rules inserted. The rule base contains 13005 rules. 3961 rules in the queue.
19000 rules inserted. The rule base contains 13077 rules. 3965 rules in the queue.
19200 rules inserted. The rule base contains 13138 rules. 4040 rules in the queue.
19400 rules inserted. The rule base contains 12544 rules. 4068 rules in the queue.
19600 rules inserted. The rule base contains 12591 rules. 4109 rules in the queue.
19800 rules inserted. The rule base contains 12695 rules. 4067 rules in the queue.
20000 rules inserted. The rule base contains 12805 rules. 4032 rules in the queue.
20200 rules inserted. The rule base contains 12906 rules. 3982 rules in the queue.
20400 rules inserted. The rule base contains 13022 rules. 3950 rules in the queue.
20600 rules inserted. The rule base contains 13166 rules. 3899 rules in the queue.
20800 rules inserted. The rule base contains 13317 rules. 3864 rules in the queue.
21000 rules inserted. The rule base contains 13457 rules. 3859 rules in the queue.
21200 rules inserted. The rule base contains 13643 rules. 3854 rules in the queue.
21400 rules inserted. The rule base contains 13760 rules. 3856 rules in the queue.
21600 rules inserted. The rule base contains 13820 rules. 3794 rules in the queue.
21800 rules inserted. The rule base contains 13918 rules. 3740 rules in the queue.
22000 rules inserted. The rule base contains 14094 rules. 3712 rules in the queue.
22200 rules inserted. The rule base contains 14251 rules. 3677 rules in the queue.
22400 rules inserted. The rule base contains 14431 rules. 3667 rules in the queue.
22600 rules inserted. The rule base contains 14621 rules. 3672 rules in the queue.
22800 rules inserted. The rule base contains 14795 rules. 3665 rules in the queue.
23000 rules inserted. The rule base contains 14932 rules. 3672 rules in the queue.
23200 rules inserted. The rule base contains 14962 rules. 3662 rules in the queue.
23400 rules inserted. The rule base contains 15064 rules. 3651 rules in the queue.
23600 rules inserted. The rule base contains 15176 rules. 3650 rules in the queue.
23800 rules inserted. The rule base contains 15302 rules. 3648 rules in the queue.
24000 rules inserted. The rule base contains 15411 rules. 3646 rules in the queue.
24200 rules inserted. The rule base contains 15519 rules. 3663 rules in the queue.
24400 rules inserted. The rule base contains 15473 rules. 3724 rules in the queue.
24600 rules inserted. The rule base contains 15288 rules. 3732 rules in the queue.
24800 rules inserted. The rule base contains 15242 rules. 3746 rules in the queue.
25000 rules inserted. The rule base contains 15331 rules. 3738 rules in the queue.
25200 rules inserted. The rule base contains 15431 rules. 3726 rules in the queue.
25400 rules inserted. The rule base contains 15524 rules. 3738 rules in the queue.
25600 rules inserted. The rule base contains 15611 rules. 3747 rules in the queue.
25800 rules inserted. The rule base contains 15613 rules. 3845 rules in the queue.
26000 rules inserted. The rule base contains 15531 rules. 3849 rules in the queue.
26200 rules inserted. The rule base contains 15436 rules. 3875 rules in the queue.
26400 rules inserted. The rule base contains 15390 rules. 3846 rules in the queue.
26600 rules inserted. The rule base contains 15498 rules. 3840 rules in the queue.
26800 rules inserted. The rule base contains 15606 rules. 3841 rules in the queue.
27000 rules inserted. The rule base contains 15706 rules. 3842 rules in the queue.
27200 rules inserted. The rule base contains 15825 rules. 3835 rules in the queue.
27400 rules inserted. The rule base contains 15954 rules. 3831 rules in the queue.
27600 rules inserted. The rule base contains 16154 rules. 3840 rules in the queue.
27800 rules inserted. The rule base contains 16313 rules. 3848 rules in the queue.
28000 rules inserted. The rule base contains 16412 rules. 3841 rules in the queue.
28200 rules inserted. The rule base contains 16550 rules. 3842 rules in the queue.
28400 rules inserted. The rule base contains 16705 rules. 3840 rules in the queue.
28600 rules inserted. The rule base contains 16823 rules. 3860 rules in the queue.
28800 rules inserted. The rule base contains 16986 rules. 3862 rules in the queue.
29000 rules inserted. The rule base contains 17185 rules. 3868 rules in the queue.
29200 rules inserted. The rule base contains 17385 rules. 3878 rules in the queue.
29400 rules inserted. The rule base contains 17577 rules. 3878 rules in the queue.
29600 rules inserted. The rule base contains 17717 rules. 3877 rules in the queue.
29800 rules inserted. The rule base contains 17841 rules. 3875 rules in the queue.
30000 rules inserted. The rule base contains 17979 rules. 3874 rules in the queue.
30200 rules inserted. The rule base contains 18053 rules. 3840 rules in the queue.
30400 rules inserted. The rule base contains 18173 rules. 3823 rules in the queue.
30600 rules inserted. The rule base contains 18283 rules. 3809 rules in the queue.
30800 rules inserted. The rule base contains 18378 rules. 3773 rules in the queue.
31000 rules inserted. The rule base contains 18488 rules. 3742 rules in the queue.
31200 rules inserted. The rule base contains 18677 rules. 3760 rules in the queue.
31400 rules inserted. The rule base contains 18877 rules. 3780 rules in the queue.
31600 rules inserted. The rule base contains 18727 rules. 3800 rules in the queue.
31800 rules inserted. The rule base contains 18762 rules. 3806 rules in the queue.
32000 rules inserted. The rule base contains 18754 rules. 3808 rules in the queue.
32200 rules inserted. The rule base contains 18913 rules. 3811 rules in the queue.
32400 rules inserted. The rule base contains 19078 rules. 3804 rules in the queue.
32600 rules inserted. The rule base contains 19267 rules. 3822 rules in the queue.
32800 rules inserted. The rule base contains 19467 rules. 3822 rules in the queue.
33000 rules inserted. The rule base contains 19667 rules. 3842 rules in the queue.
33200 rules inserted. The rule base contains 19717 rules. 3855 rules in the queue.
33400 rules inserted. The rule base contains 19745 rules. 3868 rules in the queue.
33600 rules inserted. The rule base contains 19760 rules. 3868 rules in the queue.
33800 rules inserted. The rule base contains 19744 rules. 3870 rules in the queue.
34000 rules inserted. The rule base contains 19881 rules. 3849 rules in the queue.
34200 rules inserted. The rule base contains 20050 rules. 3880 rules in the queue.
34400 rules inserted. The rule base contains 20229 rules. 3895 rules in the queue.
34600 rules inserted. The rule base contains 20408 rules. 3917 rules in the queue.
34800 rules inserted. The rule base contains 20602 rules. 3948 rules in the queue.
35000 rules inserted. The rule base contains 20800 rules. 3961 rules in the queue.
35200 rules inserted. The rule base contains 20929 rules. 3973 rules in the queue.
35400 rules inserted. The rule base contains 20841 rules. 3980 rules in the queue.
35600 rules inserted. The rule base contains 20915 rules. 3983 rules in the queue.
35800 rules inserted. The rule base contains 20971 rules. 4010 rules in the queue.
36000 rules inserted. The rule base contains 21145 rules. 4060 rules in the queue.
36200 rules inserted. The rule base contains 21340 rules. 4087 rules in the queue.
36400 rules inserted. The rule base contains 21533 rules. 4107 rules in the queue.
36600 rules inserted. The rule base contains 21733 rules. 4113 rules in the queue.
36800 rules inserted. The rule base contains 21927 rules. 4129 rules in the queue.
37000 rules inserted. The rule base contains 21989 rules. 4130 rules in the queue.
37200 rules inserted. The rule base contains 22057 rules. 4135 rules in the queue.
37400 rules inserted. The rule base contains 22101 rules. 4139 rules in the queue.
37600 rules inserted. The rule base contains 22116 rules. 4144 rules in the queue.
37800 rules inserted. The rule base contains 22228 rules. 4144 rules in the queue.
38000 rules inserted. The rule base contains 22356 rules. 4127 rules in the queue.
38200 rules inserted. The rule base contains 22477 rules. 4096 rules in the queue.
38400 rules inserted. The rule base contains 22599 rules. 4066 rules in the queue.
38600 rules inserted. The rule base contains 22771 rules. 4059 rules in the queue.
38800 rules inserted. The rule base contains 22965 rules. 4056 rules in the queue.
39000 rules inserted. The rule base contains 23089 rules. 4060 rules in the queue.
39200 rules inserted. The rule base contains 23002 rules. 4076 rules in the queue.
39400 rules inserted. The rule base contains 23073 rules. 4080 rules in the queue.
39600 rules inserted. The rule base contains 23043 rules. 4050 rules in the queue.
39800 rules inserted. The rule base contains 23196 rules. 4064 rules in the queue.
40000 rules inserted. The rule base contains 23366 rules. 4077 rules in the queue.
40200 rules inserted. The rule base contains 23547 rules. 4074 rules in the queue.
40400 rules inserted. The rule base contains 23742 rules. 4078 rules in the queue.
40600 rules inserted. The rule base contains 23933 rules. 4079 rules in the queue.
40800 rules inserted. The rule base contains 24104 rules. 4075 rules in the queue.
41000 rules inserted. The rule base contains 24182 rules. 4078 rules in the queue.
41200 rules inserted. The rule base contains 24213 rules. 4090 rules in the queue.
41400 rules inserted. The rule base contains 24264 rules. 4092 rules in the queue.
41600 rules inserted. The rule base contains 24234 rules. 4096 rules in the queue.
41800 rules inserted. The rule base contains 24384 rules. 4113 rules in the queue.
42000 rules inserted. The rule base contains 24513 rules. 4108 rules in the queue.
42200 rules inserted. The rule base contains 24661 rules. 4115 rules in the queue.
42400 rules inserted. The rule base contains 24807 rules. 4136 rules in the queue.
42600 rules inserted. The rule base contains 24918 rules. 4140 rules in the queue.
42800 rules inserted. The rule base contains 25026 rules. 4141 rules in the queue.
43000 rules inserted. The rule base contains 24957 rules. 4151 rules in the queue.
43200 rules inserted. The rule base contains 24930 rules. 4138 rules in the queue.
43400 rules inserted. The rule base contains 24909 rules. 4139 rules in the queue.
43600 rules inserted. The rule base contains 24907 rules. 4155 rules in the queue.
43800 rules inserted. The rule base contains 25057 rules. 4161 rules in the queue.
44000 rules inserted. The rule base contains 25211 rules. 4175 rules in the queue.
44200 rules inserted. The rule base contains 25312 rules. 4178 rules in the queue.
44400 rules inserted. The rule base contains 25423 rules. 4174 rules in the queue.
44600 rules inserted. The rule base contains 25527 rules. 4169 rules in the queue.
44800 rules inserted. The rule base contains 25579 rules. 4165 rules in the queue.
45000 rules inserted. The rule base contains 25582 rules. 4163 rules in the queue.
45200 rules inserted. The rule base contains 25524 rules. 4151 rules in the queue.
45400 rules inserted. The rule base contains 25499 rules. 4149 rules in the queue.
45600 rules inserted. The rule base contains 25464 rules. 4228 rules in the queue.
45800 rules inserted. The rule base contains 25533 rules. 4215 rules in the queue.
46000 rules inserted. The rule base contains 25654 rules. 4218 rules in the queue.
46200 rules inserted. The rule base contains 25791 rules. 4231 rules in the queue.
46400 rules inserted. The rule base contains 25936 rules. 4243 rules in the queue.
46600 rules inserted. The rule base contains 26120 rules. 4258 rules in the queue.
46800 rules inserted. The rule base contains 26300 rules. 4223 rules in the queue.
47000 rules inserted. The rule base contains 26377 rules. 4225 rules in the queue.
47200 rules inserted. The rule base contains 26460 rules. 4223 rules in the queue.
47400 rules inserted. The rule base contains 26562 rules. 4222 rules in the queue.
47600 rules inserted. The rule base contains 26214 rules. 4538 rules in the queue.
47800 rules inserted. The rule base contains 26285 rules. 4547 rules in the queue.
48000 rules inserted. The rule base contains 26382 rules. 4553 rules in the queue.
48200 rules inserted. The rule base contains 26535 rules. 4564 rules in the queue.
48400 rules inserted. The rule base contains 26727 rules. 4573 rules in the queue.
48600 rules inserted. The rule base contains 26907 rules. 4539 rules in the queue.
48800 rules inserted. The rule base contains 27083 rules. 4538 rules in the queue.
49000 rules inserted. The rule base contains 27201 rules. 4538 rules in the queue.
49200 rules inserted. The rule base contains 27292 rules. 4537 rules in the queue.
49400 rules inserted. The rule base contains 27407 rules. 4538 rules in the queue.
49600 rules inserted. The rule base contains 27180 rules. 4688 rules in the queue.
49800 rules inserted. The rule base contains 27278 rules. 4868 rules in the queue.
50000 rules inserted. The rule base contains 27357 rules. 4891 rules in the queue.
50200 rules inserted. The rule base contains 27421 rules. 4894 rules in the queue.
50400 rules inserted. The rule base contains 27527 rules. 4906 rules in the queue.
50600 rules inserted. The rule base contains 27636 rules. 4951 rules in the queue.
50800 rules inserted. The rule base contains 27710 rules. 4927 rules in the queue.
51000 rules inserted. The rule base contains 27732 rules. 4902 rules in the queue.
51200 rules inserted. The rule base contains 27548 rules. 4887 rules in the queue.
51400 rules inserted. The rule base contains 27458 rules. 4878 rules in the queue.
51600 rules inserted. The rule base contains 27428 rules. 4862 rules in the queue.
51800 rules inserted. The rule base contains 27492 rules. 4893 rules in the queue.
52000 rules inserted. The rule base contains 27443 rules. 4864 rules in the queue.
52200 rules inserted. The rule base contains 27503 rules. 4878 rules in the queue.
52400 rules inserted. The rule base contains 27556 rules. 4882 rules in the queue.
52600 rules inserted. The rule base contains 27655 rules. 4896 rules in the queue.
52800 rules inserted. The rule base contains 27740 rules. 4897 rules in the queue.
53000 rules inserted. The rule base contains 27780 rules. 4873 rules in the queue.
53200 rules inserted. The rule base contains 27705 rules. 4867 rules in the queue.
53400 rules inserted. The rule base contains 27637 rules. 4861 rules in the queue.
53600 rules inserted. The rule base contains 27508 rules. 4850 rules in the queue.
53800 rules inserted. The rule base contains 27477 rules. 4836 rules in the queue.
54000 rules inserted. The rule base contains 27521 rules. 4852 rules in the queue.
54200 rules inserted. The rule base contains 27630 rules. 4890 rules in the queue.
54400 rules inserted. The rule base contains 27813 rules. 4935 rules in the queue.
54600 rules inserted. The rule base contains 27881 rules. 4890 rules in the queue.
54800 rules inserted. The rule base contains 27953 rules. 4891 rules in the queue.
55000 rules inserted. The rule base contains 28001 rules. 4877 rules in the queue.
55200 rules inserted. The rule base contains 28084 rules. 4859 rules in the queue.
55400 rules inserted. The rule base contains 28192 rules. 4849 rules in the queue.
55600 rules inserted. The rule base contains 28316 rules. 4803 rules in the queue.
55800 rules inserted. The rule base contains 28432 rules. 4808 rules in the queue.
56000 rules inserted. The rule base contains 28536 rules. 4803 rules in the queue.
56200 rules inserted. The rule base contains 28638 rules. 4797 rules in the queue.
56400 rules inserted. The rule base contains 28699 rules. 4810 rules in the queue.
56600 rules inserted. The rule base contains 28562 rules. 4795 rules in the queue.
56800 rules inserted. The rule base contains 28572 rules. 4791 rules in the queue.
57000 rules inserted. The rule base contains 28661 rules. 4788 rules in the queue.
57200 rules inserted. The rule base contains 28792 rules. 4784 rules in the queue.
57400 rules inserted. The rule base contains 28903 rules. 4737 rules in the queue.
57600 rules inserted. The rule base contains 29063 rules. 4733 rules in the queue.
57800 rules inserted. The rule base contains 29180 rules. 4740 rules in the queue.
58000 rules inserted. The rule base contains 29311 rules. 4733 rules in the queue.
58200 rules inserted. The rule base contains 29417 rules. 4729 rules in the queue.
58400 rules inserted. The rule base contains 29507 rules. 4726 rules in the queue.
58600 rules inserted. The rule base contains 29573 rules. 4739 rules in the queue.
58800 rules inserted. The rule base contains 29499 rules. 4735 rules in the queue.
59000 rules inserted. The rule base contains 29681 rules. 4683 rules in the queue.
59200 rules inserted. The rule base contains 29861 rules. 4623 rules in the queue.
59400 rules inserted. The rule base contains 29994 rules. 4539 rules in the queue.
59600 rules inserted. The rule base contains 30099 rules. 4538 rules in the queue.
59800 rules inserted. The rule base contains 30202 rules. 4490 rules in the queue.
60000 rules inserted. The rule base contains 30297 rules. 4455 rules in the queue.
60200 rules inserted. The rule base contains 30428 rules. 4444 rules in the queue.
60400 rules inserted. The rule base contains 30628 rules. 4483 rules in the queue.
60600 rules inserted. The rule base contains 30553 rules. 4475 rules in the queue.
60800 rules inserted. The rule base contains 30590 rules. 4497 rules in the queue.
61000 rules inserted. The rule base contains 30663 rules. 4508 rules in the queue.
61200 rules inserted. The rule base contains 30613 rules. 4506 rules in the queue.
61400 rules inserted. The rule base contains 30392 rules. 4340 rules in the queue.
61600 rules inserted. The rule base contains 30514 rules. 4293 rules in the queue.
61800 rules inserted. The rule base contains 30645 rules. 4232 rules in the queue.
62000 rules inserted. The rule base contains 30804 rules. 4254 rules in the queue.
62200 rules inserted. The rule base contains 31004 rules. 4310 rules in the queue.
62400 rules inserted. The rule base contains 31176 rules. 4319 rules in the queue.
62600 rules inserted. The rule base contains 31211 rules. 4335 rules in the queue.
62800 rules inserted. The rule base contains 31233 rules. 4356 rules in the queue.
63000 rules inserted. The rule base contains 31306 rules. 4412 rules in the queue.
63200 rules inserted. The rule base contains 31293 rules. 4412 rules in the queue.
63400 rules inserted. The rule base contains 31065 rules. 4361 rules in the queue.
63600 rules inserted. The rule base contains 31251 rules. 4403 rules in the queue.
63800 rules inserted. The rule base contains 31451 rules. 4360 rules in the queue.
64000 rules inserted. The rule base contains 31569 rules. 4341 rules in the queue.
64200 rules inserted. The rule base contains 31672 rules. 4326 rules in the queue.
64400 rules inserted. The rule base contains 31735 rules. 4310 rules in the queue.
64600 rules inserted. The rule base contains 31854 rules. 4270 rules in the queue.
64800 rules inserted. The rule base contains 31867 rules. 4261 rules in the queue.
65000 rules inserted. The rule base contains 31831 rules. 4251 rules in the queue.
65200 rules inserted. The rule base contains 31864 rules. 4229 rules in the queue.
65400 rules inserted. The rule base contains 31879 rules. 4207 rules in the queue.
65600 rules inserted. The rule base contains 31076 rules. 4026 rules in the queue.
65800 rules inserted. The rule base contains 31256 rules. 4010 rules in the queue.
66000 rules inserted. The rule base contains 31388 rules. 3993 rules in the queue.
66200 rules inserted. The rule base contains 31516 rules. 3953 rules in the queue.
66400 rules inserted. The rule base contains 31645 rules. 3915 rules in the queue.
66600 rules inserted. The rule base contains 31739 rules. 3895 rules in the queue.
66800 rules inserted. The rule base contains 31763 rules. 3881 rules in the queue.
67000 rules inserted. The rule base contains 31769 rules. 3851 rules in the queue.
67200 rules inserted. The rule base contains 31813 rules. 3823 rules in the queue.
67400 rules inserted. The rule base contains 31869 rules. 3780 rules in the queue.
67600 rules inserted. The rule base contains 31018 rules. 3694 rules in the queue.
67800 rules inserted. The rule base contains 31157 rules. 3713 rules in the queue.
68000 rules inserted. The rule base contains 31300 rules. 3734 rules in the queue.
68200 rules inserted. The rule base contains 31465 rules. 3710 rules in the queue.
68400 rules inserted. The rule base contains 31646 rules. 3656 rules in the queue.
68600 rules inserted. The rule base contains 31802 rules. 3631 rules in the queue.
68800 rules inserted. The rule base contains 31927 rules. 3686 rules in the queue.
69000 rules inserted. The rule base contains 31900 rules. 3731 rules in the queue.
