File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 249, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 250, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 250, character 36:
Warning: identifier h rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 285, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "XK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "XK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 297, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 298, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 306, character 6:
Warning: identifier e rebound.
File "XK.noise.active.pv", line 307, characters 6-7:
Warning: identifier ne rebound.
File "XK.noise.active.pv", line 308, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 319, character 6:
Warning: identifier s rebound.
File "XK.noise.active.pv", line 320, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 320, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XK.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 331, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 338, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 339, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 348, characters 6-7:
Warning: identifier re rebound.
File "XK.noise.active.pv", line 349, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 351, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 362, characters 6-7:
Warning: identifier re rebound.
File "XK.noise.active.pv", line 363, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 365, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 366, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 368, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 376, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 376, characters 48-53:
Warning: identifier valid1 rebound.
File "XK.noise.active.pv", line 377, characters 6-7:
Warning: identifier rs rebound.
File "XK.noise.active.pv", line 378, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 379, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 381, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 389, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 391, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 399, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 401, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 574, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 338, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 338, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 339, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 567, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 389, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 391, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 559, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 319, character 6:
Warning: identifier s rebound.
File "XK.noise.active.pv", line 320, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 320, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "XK.noise.active.pv", line 321, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 322, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 322, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 323, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 552, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 362, characters 6-7:
Warning: identifier re rebound.
File "XK.noise.active.pv", line 363, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 365, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 366, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 368, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 544, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 292, character 6:
Warning: identifier e rebound.
File "XK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ne rebound.
File "XK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 297, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 298, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 632, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 399, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 401, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 624, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 330, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 330, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 331, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 617, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 376, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 376, characters 48-53:
Warning: identifier valid1 rebound.
File "XK.noise.active.pv", line 377, characters 6-7:
Warning: identifier rs rebound.
File "XK.noise.active.pv", line 378, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 379, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 381, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 609, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 306, character 6:
Warning: identifier e rebound.
File "XK.noise.active.pv", line 307, characters 6-7:
Warning: identifier ne rebound.
File "XK.noise.active.pv", line 308, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 311, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "XK.noise.active.pv", line 312, characters 6-7:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 259, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 602, characters 8-9:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 348, characters 6-7:
Warning: identifier re rebound.
File "XK.noise.active.pv", line 349, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 351, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 352, characters 7-8:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 354, characters 7-8:
Warning: identifier hs rebound.
File "XK.noise.active.pv", line 240, characters 7-8:
Warning: identifier ck rebound.
File "XK.noise.active.pv", line 265, characters 7-8:
Warning: identifier cs rebound.
File "XK.noise.active.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "XK.noise.active.pv", line 285, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
(
    {3}let them: principal = bob in
    {4}let me: principal = alice in
    {5}let s_529: keypair = keypairpack(empty,empty) in
    {6}out(pub, getpublickey(s_529));
    (
        {7}let e_530: keypair = keypairpack(empty,empty) in
        {8}let v_531: key = catch-fail(dhexp(key_s(them),g)) in
        {9}let rs_532: key = getpublickey((if not-caught-fail(v_531) then keypairpack(v_531,key_s(them)) else fail-any)) in
        {10}let re_533: key = empty in
        {11}let v_534: bitstring = catch-fail(hash(somename,empty)) in
        {12}let v_535: key = catch-fail(v_534) in
        {13}let v_536: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {14}let v_537: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_534) then (if not-caught-fail(v_535) then (if not-caught-fail(v_536) then symmetricstatepack(v_536,v_535,v_534) else fail-any) else fail-any) else fail-any))) in
        {15}let v_538: symmetricstate = catch-fail((if success?((if not-caught-fail(v_534) then (if not-caught-fail(v_535) then (if not-caught-fail(v_536) then symmetricstatepack(v_536,v_535,v_534) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_537) && success?(is-true(success?(1-proj-3-tuple(v_537))))) then symmetricstatepack(1-proj-3-tuple(v_537),2-proj-3-tuple(v_537),hash(3-proj-3-tuple(v_537),empty)) else fail-any) else fail-any)) in
        {16}let v_539: bitstring = catch-fail(symmetricstateunpack(v_538)) in
        {17}let v_540: symmetricstate = catch-fail((if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-3-tuple(v_539))))) then symmetricstatepack(1-proj-3-tuple(v_539),2-proj-3-tuple(v_539),hash(3-proj-3-tuple(v_539),rs_532)) else fail-any)) in
        {18}let hs: handshakestate = (if not-caught-fail(v_538) then (if not-caught-fail(v_540) then handshakestatepack(v_540,s_529,e_530,rs_532,re_533,empty,true) else fail-any) else fail-any) in
        {19}insert statestore(me,them,statepack_a(hs))
    ) | (
        {50}get statestore(=me,=them,statepack_a(hs_541: handshakestate)) in
        {20}let v_542: bitstring = catch-fail(handshakestateunpack(hs_541)) in
        {21}let v_543: bitstring = catch-fail((empty,empty,empty)) in
        {22}new key_e[me,them]: key;
        {23}let v_544: key = catch-fail(dhexp(key_e,g)) in
        {24}let v_545: keypair = catch-fail((if not-caught-fail(v_544) then keypairpack(v_544,key_e) else fail-any)) in
        {25}let v_546: bitstring = catch-fail(getpublickey(v_545)) in
        {26}let v_547: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_542))) in
        {27}let v_548: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_542)) then (if (not-caught-fail(v_547) && success?(is-true(success?(1-proj-3-tuple(v_547))))) then symmetricstatepack(1-proj-3-tuple(v_547),2-proj-3-tuple(v_547),hash(3-proj-3-tuple(v_547),v_546)) else fail-any) else fail-any)) in
        {28}let v_549: bitstring = catch-fail(keypairunpack(v_545)) in
        {29}let v_550: bitstring = catch-fail(symmetricstateunpack(v_548)) in
        {30}let v_551: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_550),(if success?(4-proj-7-tuple(v_542)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then dhexp(2-proj-2-tuple(v_549),4-proj-7-tuple(v_542)) else fail-any) else fail-any))) in
        {31}let v_552: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_550),(if success?(4-proj-7-tuple(v_542)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then dhexp(2-proj-2-tuple(v_549),4-proj-7-tuple(v_542)) else fail-any) else fail-any))) in
        {32}let v_553: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_550),(if success?(4-proj-7-tuple(v_542)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then dhexp(2-proj-2-tuple(v_549),4-proj-7-tuple(v_542)) else fail-any) else fail-any))) in
        {33}let v_554: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_542)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then dhexp(2-proj-2-tuple(v_549),4-proj-7-tuple(v_542)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_550))) then (if not-caught-fail(v_551) then (if not-caught-fail(v_552) then (if not-caught-fail(v_553) then (v_551,v_552,v_553) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {34}let v_555: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_542)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then dhexp(2-proj-2-tuple(v_549),4-proj-7-tuple(v_542)) else fail-any) else fail-any)) then (if (not-caught-fail(v_550) && success?(is-true(success?(1-proj-3-tuple(v_550))))) then (if (not-caught-fail(v_554) && success?(is-true(success?(1-proj-3-tuple(v_554))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_554)) then cipherstatepack(2-proj-3-tuple(v_554),minnonce) else fail-any),1-proj-3-tuple(v_554),3-proj-3-tuple(v_550)) else fail-any) else fail-any) else fail-any)) in
        {35}let v_556: bitstring = catch-fail(symmetricstateunpack(v_555)) in
        {36}let v_557: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_556))) in
        {37}let v_558: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_557),2-proj-2-tuple(v_557),3-proj-3-tuple(v_556),msg_a(me,them))) in
        {38}let v_559: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_556))) in
        {39}let v_560: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_557))) && success?(1-proj-3-tuple(v_556))) then (if (not-caught-fail(v_559) && success?(is-true(success?(1-proj-2-tuple(v_559))))) then cipherstatepack(1-proj-2-tuple(v_559),increment_nonce(2-proj-2-tuple(v_557))) else fail-any) else fail-any)) in
        {40}let v_561: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_556)) && success?(1-proj-3-tuple(v_556))) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-2-tuple(v_557))))) then (if not-caught-fail(v_558) then (if not-caught-fail(v_560) then (v_560,v_558) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {41}let v_562: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_561),2-proj-3-tuple(v_556),3-proj-3-tuple(v_556)))) in
        {42}let v_563: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_561)) && success?(symmetricstatepack(1-proj-2-tuple(v_561),2-proj-3-tuple(v_556),3-proj-3-tuple(v_556)))) then (if (not-caught-fail(v_562) && success?(is-true(success?(1-proj-3-tuple(v_562))))) then symmetricstatepack(1-proj-3-tuple(v_562),2-proj-3-tuple(v_562),hash(3-proj-3-tuple(v_562),2-proj-2-tuple(v_561))) else fail-any) else fail-any)) in
        {43}let v_564: bitstring = catch-fail((if (not-caught-fail(v_556) && success?(is-true(success?(1-proj-3-tuple(v_556))))) then (if (not-caught-fail(v_561) && success?(is-true(success?(1-proj-2-tuple(v_561))))) then (if not-caught-fail(v_563) then (v_563,2-proj-2-tuple(v_561)) else fail-any) else fail-any) else fail-any)) in
        {44}let v_565: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_564),2-proj-7-tuple(v_542),v_545,4-proj-7-tuple(v_542),5-proj-7-tuple(v_542),6-proj-7-tuple(v_542),7-proj-7-tuple(v_542))) in
        {45}let v_566: bitstring = catch-fail(concat3(v_546,2-proj-3-tuple(v_543),2-proj-2-tuple(v_564))) in
        {46}let (hs_567: handshakestate,re_568: key,message_a: bitstring) = (if (not-caught-fail(v_542) && success?(is-true(success?(1-proj-7-tuple(v_542))))) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-3-tuple(v_543))))) then (if not-caught-fail(v_545) then (if not-caught-fail(v_546) then (if not-caught-fail(v_548) then (if not-caught-fail(v_555) then (if (not-caught-fail(v_564) && success?(is-true(success?(1-proj-2-tuple(v_564))))) then (if not-caught-fail(v_565) then (if not-caught-fail(v_566) then (v_565,5-proj-7-tuple(v_542),v_566) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {47}event SendMsg(me,them,stage_a,msg_a(me,them),true);
        {48}insert statestore(me,them,statepack_b(hs_567));
        {49}out(pub, message_a)
    ) | (
        {79}get statestore(=me,=them,statepack_b(hs_569: handshakestate)) in
        {51}in(pub, message_b: bitstring);
        {52}let v_570: bitstring = catch-fail(handshakestateunpack(hs_569)) in
        {53}let v_571: bitstring = catch-fail(deconcat3(message_b)) in
        {54}let v_572: bool = catch-fail(true) in
        {55}let v_573: key = catch-fail(1-proj-3-tuple(v_571)) in
        {56}let v_574: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_570))) in
        {57}let v_575: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_570)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-3-tuple(v_574))))) then symmetricstatepack(1-proj-3-tuple(v_574),2-proj-3-tuple(v_574),hash(3-proj-3-tuple(v_574),v_573)) else fail-any) else fail-any)) in
        {58}let v_576: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_570))) in
        {59}let v_577: bitstring = catch-fail(symmetricstateunpack(v_575)) in
        {60}let v_578: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_577),(if success?(3-proj-7-tuple(v_570)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_573) else fail-any) else fail-any))) in
        {61}let v_579: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_577),(if success?(3-proj-7-tuple(v_570)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_573) else fail-any) else fail-any))) in
        {62}let v_580: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_577),(if success?(3-proj-7-tuple(v_570)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_573) else fail-any) else fail-any))) in
        {63}let v_581: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_570)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_573) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_577))) then (if not-caught-fail(v_578) then (if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (v_578,v_579,v_580) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {64}let v_582: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_570)) then (if (not-caught-fail(v_576) && success?(is-true(success?(1-proj-2-tuple(v_576))))) then dhexp(2-proj-2-tuple(v_576),v_573) else fail-any) else fail-any)) then (if (not-caught-fail(v_577) && success?(is-true(success?(1-proj-3-tuple(v_577))))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-3-tuple(v_581))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_581)) then cipherstatepack(2-proj-3-tuple(v_581),minnonce) else fail-any),1-proj-3-tuple(v_581),3-proj-3-tuple(v_577)) else fail-any) else fail-any) else fail-any)) in
        {65}let v_583: bitstring = catch-fail(symmetricstateunpack(v_582)) in
        {66}let v_584: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_583))) in
        {67}let v_585: aead = catch-fail(decrypt(1-proj-2-tuple(v_584),2-proj-2-tuple(v_584),3-proj-3-tuple(v_583),3-proj-3-tuple(v_571))) in
        {68}let v_586: bitstring = catch-fail(aeadunpack(v_585)) in
        {69}let v_587: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_583))) in
        {70}let v_588: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_584))) && success?(1-proj-3-tuple(v_583))) then (if (not-caught-fail(v_587) && success?(is-true(success?(1-proj-2-tuple(v_587))))) then cipherstatepack(1-proj-2-tuple(v_587),increment_nonce(2-proj-2-tuple(v_584))) else fail-any) else fail-any)) in
        {71}let v_589: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_571)) && (success?(3-proj-3-tuple(v_583)) && success?(1-proj-3-tuple(v_583)))) then (if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-2-tuple(v_584))))) then (if not-caught-fail(v_585) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then (if not-caught-fail(v_588) then (v_588,3-proj-3-tuple(v_586),1-proj-3-tuple(v_586)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {72}let v_590: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_589),2-proj-3-tuple(v_583),3-proj-3-tuple(v_583)))) in
        {73}let v_591: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_571)) && success?(symmetricstatepack(1-proj-3-tuple(v_589),2-proj-3-tuple(v_583),3-proj-3-tuple(v_583)))) then (if (not-caught-fail(v_590) && success?(is-true(success?(1-proj-3-tuple(v_590))))) then symmetricstatepack(1-proj-3-tuple(v_590),2-proj-3-tuple(v_590),hash(3-proj-3-tuple(v_590),3-proj-3-tuple(v_571))) else fail-any) else fail-any)) in
        {74}let v_592: bitstring = catch-fail((if success?(3-proj-3-tuple(v_571)) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-3-tuple(v_583))))) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-3-tuple(v_589))))) then (if not-caught-fail(v_591) then (v_591,2-proj-3-tuple(v_589),3-proj-3-tuple(v_589)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {75}let v_593: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_592),2-proj-7-tuple(v_570),3-proj-7-tuple(v_570),4-proj-7-tuple(v_570),v_573,6-proj-7-tuple(v_570),7-proj-7-tuple(v_570))) in
        {76}let (hs_594: handshakestate,re_595: key,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_570) && success?(is-true(success?(1-proj-7-tuple(v_570))))) then (if (not-caught-fail(v_571) && success?(is-true(success?(1-proj-3-tuple(v_571))))) then (if not-caught-fail(v_572) then (if not-caught-fail(v_573) then (if not-caught-fail(v_575) then (if not-caught-fail(v_582) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-3-tuple(v_592))))) then (if (v_572 && 3-proj-3-tuple(v_592)) then (if not-caught-fail(v_593) then (v_593,getpublickey(3-proj-7-tuple(v_570)),2-proj-3-tuple(v_592),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {77}event RecvMsg(me,them,stage_b,plaintext_b,valid);
        {78}insert statestore(me,them,statepack_c(hs_594))
    ) | (
        {115}get statestore(=me,=them,statepack_c(hs_596: handshakestate)) in
        {80}let v_597: bitstring = catch-fail(handshakestateunpack(hs_596)) in
        {81}let v_598: bitstring = catch-fail((empty,empty,empty)) in
        {82}let v_599: key = catch-fail(dhexp(key_s(me),g)) in
        {83}let v_600: keypair = catch-fail((if not-caught-fail(v_599) then keypairpack(v_599,key_s(me)) else fail-any)) in
        {84}let v_601: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_597))) in
        {85}let v_602: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_601))) in
        {86}let v_603: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_602),2-proj-2-tuple(v_602),3-proj-3-tuple(v_601),getpublickey(v_600))) in
        {87}let v_604: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_601))) in
        {88}let v_605: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_602))) && success?(1-proj-3-tuple(v_601))) then (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-2-tuple(v_604))))) then cipherstatepack(1-proj-2-tuple(v_604),increment_nonce(2-proj-2-tuple(v_602))) else fail-any) else fail-any)) in
        {89}let v_606: bitstring = catch-fail((if (success?(getpublickey(v_600)) && (success?(3-proj-3-tuple(v_601)) && success?(1-proj-3-tuple(v_601)))) then (if (not-caught-fail(v_602) && success?(is-true(success?(1-proj-2-tuple(v_602))))) then (if not-caught-fail(v_603) then (if not-caught-fail(v_605) then (v_605,v_603) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {90}let v_607: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_606),2-proj-3-tuple(v_601),3-proj-3-tuple(v_601)))) in
        {91}let v_608: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_606)) && success?(symmetricstatepack(1-proj-2-tuple(v_606),2-proj-3-tuple(v_601),3-proj-3-tuple(v_601)))) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-3-tuple(v_607))))) then symmetricstatepack(1-proj-3-tuple(v_607),2-proj-3-tuple(v_607),hash(3-proj-3-tuple(v_607),2-proj-2-tuple(v_606))) else fail-any) else fail-any)) in
        {92}let v_609: bitstring = catch-fail((if (success?(getpublickey(v_600)) && success?(1-proj-7-tuple(v_597))) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-3-tuple(v_601))))) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then (if not-caught-fail(v_608) then (v_608,2-proj-2-tuple(v_606)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {93}let v_610: bitstring = catch-fail(keypairunpack(v_600)) in
        {94}let v_611: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_609))) in
        {95}let v_612: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_611),(if success?(5-proj-7-tuple(v_597)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),5-proj-7-tuple(v_597)) else fail-any) else fail-any))) in
        {96}let v_613: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_611),(if success?(5-proj-7-tuple(v_597)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),5-proj-7-tuple(v_597)) else fail-any) else fail-any))) in
        {97}let v_614: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_611),(if success?(5-proj-7-tuple(v_597)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),5-proj-7-tuple(v_597)) else fail-any) else fail-any))) in
        {98}let v_615: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_597)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),5-proj-7-tuple(v_597)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_611))) then (if not-caught-fail(v_612) then (if not-caught-fail(v_613) then (if not-caught-fail(v_614) then (v_612,v_613,v_614) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {99}let v_616: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_597)) then (if (not-caught-fail(v_610) && success?(is-true(success?(1-proj-2-tuple(v_610))))) then dhexp(2-proj-2-tuple(v_610),5-proj-7-tuple(v_597)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_609))) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-3-tuple(v_611))))) then (if (not-caught-fail(v_615) && success?(is-true(success?(1-proj-3-tuple(v_615))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_615)) then cipherstatepack(2-proj-3-tuple(v_615),minnonce) else fail-any),1-proj-3-tuple(v_615),3-proj-3-tuple(v_611)) else fail-any) else fail-any) else fail-any)) in
        {100}let v_617: bitstring = catch-fail(symmetricstateunpack(v_616)) in
        {101}let v_618: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {102}let v_619: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_618),2-proj-2-tuple(v_618),3-proj-3-tuple(v_617),msg_c(me,them))) in
        {103}let v_620: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_617))) in
        {104}let v_621: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_618))) && success?(1-proj-3-tuple(v_617))) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-2-tuple(v_620))))) then cipherstatepack(1-proj-2-tuple(v_620),increment_nonce(2-proj-2-tuple(v_618))) else fail-any) else fail-any)) in
        {105}let v_622: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_617)) && success?(1-proj-3-tuple(v_617))) then (if (not-caught-fail(v_618) && success?(is-true(success?(1-proj-2-tuple(v_618))))) then (if not-caught-fail(v_619) then (if not-caught-fail(v_621) then (v_621,v_619) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {106}let v_623: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_622),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) in
        {107}let v_624: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_622)) && success?(symmetricstatepack(1-proj-2-tuple(v_622),2-proj-3-tuple(v_617),3-proj-3-tuple(v_617)))) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-3-tuple(v_623))))) then symmetricstatepack(1-proj-3-tuple(v_623),2-proj-3-tuple(v_623),hash(3-proj-3-tuple(v_623),2-proj-2-tuple(v_622))) else fail-any) else fail-any)) in
        {108}let v_625: bitstring = catch-fail((if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-3-tuple(v_617))))) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-2-tuple(v_622))))) then (if not-caught-fail(v_624) then (v_624,2-proj-2-tuple(v_622)) else fail-any) else fail-any) else fail-any)) in
        {109}let v_626: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_625),v_600,3-proj-7-tuple(v_597),4-proj-7-tuple(v_597),5-proj-7-tuple(v_597),6-proj-7-tuple(v_597),7-proj-7-tuple(v_597))) in
        {110}let v_627: bitstring = catch-fail(concat3(1-proj-3-tuple(v_598),2-proj-2-tuple(v_609),2-proj-2-tuple(v_625))) in
        {111}let (hs_628: handshakestate,re_629: key,message_c: bitstring) = (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-7-tuple(v_597))))) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-3-tuple(v_598))))) then (if not-caught-fail(v_600) then (if (not-caught-fail(v_609) && success?(is-true(success?(1-proj-2-tuple(v_609))))) then (if not-caught-fail(v_616) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then (if not-caught-fail(v_626) then (if not-caught-fail(v_627) then (v_626,5-proj-7-tuple(v_597),v_627) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {112}event SendMsg(me,them,stage_c,msg_c(me,them),true);
        {113}insert statestore(me,them,statepack_d(hs_628));
        {114}out(pub, message_c)
    ) | (
        {134}get statestore(=me,=them,statepack_d(hs_630: handshakestate)) in
        {116}in(pub, message_d: bitstring);
        {117}let v_631: bitstring = catch-fail(handshakestateunpack(hs_630)) in
        {118}let v_632: bitstring = catch-fail(deconcat3(message_d)) in
        {119}let v_633: bool = catch-fail(true) in
        {120}let v_634: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_631))) in
        {121}let v_635: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_634))) in
        {122}let v_636: aead = catch-fail(decrypt(1-proj-2-tuple(v_635),2-proj-2-tuple(v_635),3-proj-3-tuple(v_634),3-proj-3-tuple(v_632))) in
        {123}let v_637: bitstring = catch-fail(aeadunpack(v_636)) in
        {124}let v_638: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_634))) in
        {125}let v_639: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_635))) && success?(1-proj-3-tuple(v_634))) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-2-tuple(v_638))))) then cipherstatepack(1-proj-2-tuple(v_638),increment_nonce(2-proj-2-tuple(v_635))) else fail-any) else fail-any)) in
        {126}let v_640: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_632)) && (success?(3-proj-3-tuple(v_634)) && success?(1-proj-3-tuple(v_634)))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then (if not-caught-fail(v_636) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-3-tuple(v_637))))) then (if not-caught-fail(v_639) then (v_639,3-proj-3-tuple(v_637),1-proj-3-tuple(v_637)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {127}let v_641: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_640),2-proj-3-tuple(v_634),3-proj-3-tuple(v_634)))) in
        {128}let v_642: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_632)) && success?(symmetricstatepack(1-proj-3-tuple(v_640),2-proj-3-tuple(v_634),3-proj-3-tuple(v_634)))) then (if (not-caught-fail(v_641) && success?(is-true(success?(1-proj-3-tuple(v_641))))) then symmetricstatepack(1-proj-3-tuple(v_641),2-proj-3-tuple(v_641),hash(3-proj-3-tuple(v_641),3-proj-3-tuple(v_632))) else fail-any) else fail-any)) in
        {129}let v_643: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_632)) && success?(1-proj-7-tuple(v_631))) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-3-tuple(v_640))))) then (if not-caught-fail(v_642) then (v_642,2-proj-3-tuple(v_640),3-proj-3-tuple(v_640)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {130}let v_644: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_643),2-proj-7-tuple(v_631),3-proj-7-tuple(v_631),4-proj-7-tuple(v_631),5-proj-7-tuple(v_631),6-proj-7-tuple(v_631),7-proj-7-tuple(v_631))) in
        {131}let (hs_645: handshakestate,re_646: key,plaintext_d: bitstring,valid_647: bool) = (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-7-tuple(v_631))))) then (if (not-caught-fail(v_632) && success?(is-true(success?(1-proj-3-tuple(v_632))))) then (if not-caught-fail(v_633) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-3-tuple(v_643))))) then (if (v_633 && 3-proj-3-tuple(v_643)) then (if not-caught-fail(v_644) then (v_644,getpublickey(3-proj-7-tuple(v_631)),2-proj-3-tuple(v_643),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {132}event RecvMsg(me,them,stage_d,plaintext_d,valid_647);
        {133}insert statestore(me,them,statepack_e(hs_645))
    ) | (
        {160}get statestore(=me,=them,statepack_e(hs_648: handshakestate)) in
        {135}let v_649: bitstring = catch-fail(handshakestateunpack(hs_648)) in
        {136}let v_650: bitstring = catch-fail((empty,empty,empty)) in
        {137}let v_651: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_649))) in
        {138}let v_652: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_651))) in
        {139}let v_653: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_652),2-proj-2-tuple(v_652),3-proj-3-tuple(v_651),msg_e(me,them))) in
        {140}let v_654: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_651))) in
        {141}let v_655: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_652))) && success?(1-proj-3-tuple(v_651))) then (if (not-caught-fail(v_654) && success?(is-true(success?(1-proj-2-tuple(v_654))))) then cipherstatepack(1-proj-2-tuple(v_654),increment_nonce(2-proj-2-tuple(v_652))) else fail-any) else fail-any)) in
        {142}let v_656: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_651)) && success?(1-proj-3-tuple(v_651))) then (if (not-caught-fail(v_652) && success?(is-true(success?(1-proj-2-tuple(v_652))))) then (if not-caught-fail(v_653) then (if not-caught-fail(v_655) then (v_655,v_653) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {143}let v_657: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_656),2-proj-3-tuple(v_651),3-proj-3-tuple(v_651)))) in
        {144}let v_658: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_656)) && success?(symmetricstatepack(1-proj-2-tuple(v_656),2-proj-3-tuple(v_651),3-proj-3-tuple(v_651)))) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-3-tuple(v_657))))) then symmetricstatepack(1-proj-3-tuple(v_657),2-proj-3-tuple(v_657),hash(3-proj-3-tuple(v_657),2-proj-2-tuple(v_656))) else fail-any) else fail-any)) in
        {145}let v_659: bitstring = catch-fail((if success?(1-proj-7-tuple(v_649)) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-3-tuple(v_651))))) then (if (not-caught-fail(v_656) && success?(is-true(success?(1-proj-2-tuple(v_656))))) then (if not-caught-fail(v_658) then (v_658,2-proj-2-tuple(v_656)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {146}let v_660: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_659),2-proj-7-tuple(v_649),3-proj-7-tuple(v_649),4-proj-7-tuple(v_649),5-proj-7-tuple(v_649),6-proj-7-tuple(v_649),7-proj-7-tuple(v_649))) in
        {147}let v_661: bitstring = catch-fail(concat3(1-proj-3-tuple(v_650),2-proj-3-tuple(v_650),2-proj-2-tuple(v_659))) in
        {148}let v_662: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_659))) in
        {149}let v_663: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_662),zero)) in
        {150}let v_664: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_662),zero)) in
        {151}let v_665: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_662),zero)) in
        {152}let v_666: bitstring = catch-fail((if success?(2-proj-3-tuple(v_662)) then (if not-caught-fail(v_663) then (if not-caught-fail(v_664) then (if not-caught-fail(v_665) then (v_663,v_664,v_665) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {153}let v_667: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_666)) then cipherstatepack(1-proj-3-tuple(v_666),minnonce) else fail-any)) in
        {154}let v_668: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_666)) then cipherstatepack(2-proj-3-tuple(v_666),minnonce) else fail-any)) in
        {155}let v_669: bitstring = catch-fail((if success?(1-proj-2-tuple(v_659)) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-3-tuple(v_662))))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then (if not-caught-fail(v_667) then (if not-caught-fail(v_668) then (1-proj-2-tuple(v_659),v_667,v_668) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {156}let (hs_670: handshakestate,re_671: key,message_e: bitstring,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-7-tuple(v_649))))) then (if (not-caught-fail(v_650) && success?(is-true(success?(1-proj-3-tuple(v_650))))) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-2-tuple(v_659))))) then (if not-caught-fail(v_660) then (if not-caught-fail(v_661) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-3-tuple(v_669))))) then (v_660,5-proj-7-tuple(v_649),v_661,2-proj-3-tuple(v_669),3-proj-3-tuple(v_669)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {157}event SendMsg(me,them,stage_e,msg_e(me,them),true);
        {158}insert statestore(me,them,statepack_f(hs_670));
        {159}out(pub, message_e)
    ) | (
        {161}event LeakS(phase0,me);
        {162}out(pub, key_s(me))
    ) | (
        {163}phase 1;
        {164}event LeakS(phase1,me);
        {165}out(pub, key_s(me))
    )
) | (
    {166}let them_672: principal = charlie in
    {167}let me_673: principal = alice in
    {168}let s_674: keypair = keypairpack(empty,empty) in
    {169}out(pub, getpublickey(s_674));
    (
        {170}let e_675: keypair = keypairpack(empty,empty) in
        {171}let v_676: key = catch-fail(dhexp(key_s(them_672),g)) in
        {172}let rs_677: key = getpublickey((if not-caught-fail(v_676) then keypairpack(v_676,key_s(them_672)) else fail-any)) in
        {173}let re_678: key = empty in
        {174}let v_679: bitstring = catch-fail(hash(somename,empty)) in
        {175}let v_680: key = catch-fail(v_679) in
        {176}let v_681: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {177}let v_682: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_679) then (if not-caught-fail(v_680) then (if not-caught-fail(v_681) then symmetricstatepack(v_681,v_680,v_679) else fail-any) else fail-any) else fail-any))) in
        {178}let v_683: symmetricstate = catch-fail((if success?((if not-caught-fail(v_679) then (if not-caught-fail(v_680) then (if not-caught-fail(v_681) then symmetricstatepack(v_681,v_680,v_679) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_682) && success?(is-true(success?(1-proj-3-tuple(v_682))))) then symmetricstatepack(1-proj-3-tuple(v_682),2-proj-3-tuple(v_682),hash(3-proj-3-tuple(v_682),empty)) else fail-any) else fail-any)) in
        {179}let v_684: bitstring = catch-fail(symmetricstateunpack(v_683)) in
        {180}let v_685: symmetricstate = catch-fail((if (not-caught-fail(v_684) && success?(is-true(success?(1-proj-3-tuple(v_684))))) then symmetricstatepack(1-proj-3-tuple(v_684),2-proj-3-tuple(v_684),hash(3-proj-3-tuple(v_684),rs_677)) else fail-any)) in
        {181}let hs_686: handshakestate = (if not-caught-fail(v_683) then (if not-caught-fail(v_685) then handshakestatepack(v_685,s_674,e_675,rs_677,re_678,empty,true) else fail-any) else fail-any) in
        {182}insert statestore(me_673,them_672,statepack_a(hs_686))
    ) | (
        {213}get statestore(=me_673,=them_672,statepack_a(hs_687: handshakestate)) in
        {183}let v_688: bitstring = catch-fail(handshakestateunpack(hs_687)) in
        {184}let v_689: bitstring = catch-fail((empty,empty,empty)) in
        {185}new key_e_690[me_673,them_672]: key;
        {186}let v_691: key = catch-fail(dhexp(key_e_690,g)) in
        {187}let v_692: keypair = catch-fail((if not-caught-fail(v_691) then keypairpack(v_691,key_e_690) else fail-any)) in
        {188}let v_693: bitstring = catch-fail(getpublickey(v_692)) in
        {189}let v_694: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_688))) in
        {190}let v_695: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_688)) then (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-3-tuple(v_694))))) then symmetricstatepack(1-proj-3-tuple(v_694),2-proj-3-tuple(v_694),hash(3-proj-3-tuple(v_694),v_693)) else fail-any) else fail-any)) in
        {191}let v_696: bitstring = catch-fail(keypairunpack(v_692)) in
        {192}let v_697: bitstring = catch-fail(symmetricstateunpack(v_695)) in
        {193}let v_698: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_697),(if success?(4-proj-7-tuple(v_688)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then dhexp(2-proj-2-tuple(v_696),4-proj-7-tuple(v_688)) else fail-any) else fail-any))) in
        {194}let v_699: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_697),(if success?(4-proj-7-tuple(v_688)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then dhexp(2-proj-2-tuple(v_696),4-proj-7-tuple(v_688)) else fail-any) else fail-any))) in
        {195}let v_700: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_697),(if success?(4-proj-7-tuple(v_688)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then dhexp(2-proj-2-tuple(v_696),4-proj-7-tuple(v_688)) else fail-any) else fail-any))) in
        {196}let v_701: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_688)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then dhexp(2-proj-2-tuple(v_696),4-proj-7-tuple(v_688)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_697))) then (if not-caught-fail(v_698) then (if not-caught-fail(v_699) then (if not-caught-fail(v_700) then (v_698,v_699,v_700) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {197}let v_702: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_688)) then (if (not-caught-fail(v_696) && success?(is-true(success?(1-proj-2-tuple(v_696))))) then dhexp(2-proj-2-tuple(v_696),4-proj-7-tuple(v_688)) else fail-any) else fail-any)) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_701)) then cipherstatepack(2-proj-3-tuple(v_701),minnonce) else fail-any),1-proj-3-tuple(v_701),3-proj-3-tuple(v_697)) else fail-any) else fail-any) else fail-any)) in
        {198}let v_703: bitstring = catch-fail(symmetricstateunpack(v_702)) in
        {199}let v_704: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_703))) in
        {200}let v_705: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_704),2-proj-2-tuple(v_704),3-proj-3-tuple(v_703),msg_a(me_673,them_672))) in
        {201}let v_706: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_703))) in
        {202}let v_707: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_704))) && success?(1-proj-3-tuple(v_703))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-2-tuple(v_706))))) then cipherstatepack(1-proj-2-tuple(v_706),increment_nonce(2-proj-2-tuple(v_704))) else fail-any) else fail-any)) in
        {203}let v_708: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_703)) && success?(1-proj-3-tuple(v_703))) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-2-tuple(v_704))))) then (if not-caught-fail(v_705) then (if not-caught-fail(v_707) then (v_707,v_705) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {204}let v_709: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_708),2-proj-3-tuple(v_703),3-proj-3-tuple(v_703)))) in
        {205}let v_710: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_708)) && success?(symmetricstatepack(1-proj-2-tuple(v_708),2-proj-3-tuple(v_703),3-proj-3-tuple(v_703)))) then (if (not-caught-fail(v_709) && success?(is-true(success?(1-proj-3-tuple(v_709))))) then symmetricstatepack(1-proj-3-tuple(v_709),2-proj-3-tuple(v_709),hash(3-proj-3-tuple(v_709),2-proj-2-tuple(v_708))) else fail-any) else fail-any)) in
        {206}let v_711: bitstring = catch-fail((if (not-caught-fail(v_703) && success?(is-true(success?(1-proj-3-tuple(v_703))))) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-2-tuple(v_708))))) then (if not-caught-fail(v_710) then (v_710,2-proj-2-tuple(v_708)) else fail-any) else fail-any) else fail-any)) in
        {207}let v_712: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_711),2-proj-7-tuple(v_688),v_692,4-proj-7-tuple(v_688),5-proj-7-tuple(v_688),6-proj-7-tuple(v_688),7-proj-7-tuple(v_688))) in
        {208}let v_713: bitstring = catch-fail(concat3(v_693,2-proj-3-tuple(v_689),2-proj-2-tuple(v_711))) in
        {209}let (hs_714: handshakestate,re_715: key,message_a_716: bitstring) = (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-7-tuple(v_688))))) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-3-tuple(v_689))))) then (if not-caught-fail(v_692) then (if not-caught-fail(v_693) then (if not-caught-fail(v_695) then (if not-caught-fail(v_702) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then (if not-caught-fail(v_712) then (if not-caught-fail(v_713) then (v_712,5-proj-7-tuple(v_688),v_713) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {210}event SendMsg(me_673,them_672,stage_a,msg_a(me_673,them_672),true);
        {211}insert statestore(me_673,them_672,statepack_b(hs_714));
        {212}out(pub, message_a_716)
    ) | (
        {242}get statestore(=me_673,=them_672,statepack_b(hs_717: handshakestate)) in
        {214}in(pub, message_b_718: bitstring);
        {215}let v_719: bitstring = catch-fail(handshakestateunpack(hs_717)) in
        {216}let v_720: bitstring = catch-fail(deconcat3(message_b_718)) in
        {217}let v_721: bool = catch-fail(true) in
        {218}let v_722: key = catch-fail(1-proj-3-tuple(v_720)) in
        {219}let v_723: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_719))) in
        {220}let v_724: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_719)) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then symmetricstatepack(1-proj-3-tuple(v_723),2-proj-3-tuple(v_723),hash(3-proj-3-tuple(v_723),v_722)) else fail-any) else fail-any)) in
        {221}let v_725: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_719))) in
        {222}let v_726: bitstring = catch-fail(symmetricstateunpack(v_724)) in
        {223}let v_727: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_726),(if success?(3-proj-7-tuple(v_719)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),v_722) else fail-any) else fail-any))) in
        {224}let v_728: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_726),(if success?(3-proj-7-tuple(v_719)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),v_722) else fail-any) else fail-any))) in
        {225}let v_729: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_726),(if success?(3-proj-7-tuple(v_719)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),v_722) else fail-any) else fail-any))) in
        {226}let v_730: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_719)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),v_722) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_726))) then (if not-caught-fail(v_727) then (if not-caught-fail(v_728) then (if not-caught-fail(v_729) then (v_727,v_728,v_729) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {227}let v_731: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_719)) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),v_722) else fail-any) else fail-any)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-3-tuple(v_726))))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-3-tuple(v_730))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_730)) then cipherstatepack(2-proj-3-tuple(v_730),minnonce) else fail-any),1-proj-3-tuple(v_730),3-proj-3-tuple(v_726)) else fail-any) else fail-any) else fail-any)) in
        {228}let v_732: bitstring = catch-fail(symmetricstateunpack(v_731)) in
        {229}let v_733: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_732))) in
        {230}let v_734: aead = catch-fail(decrypt(1-proj-2-tuple(v_733),2-proj-2-tuple(v_733),3-proj-3-tuple(v_732),3-proj-3-tuple(v_720))) in
        {231}let v_735: bitstring = catch-fail(aeadunpack(v_734)) in
        {232}let v_736: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_732))) in
        {233}let v_737: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_733))) && success?(1-proj-3-tuple(v_732))) then (if (not-caught-fail(v_736) && success?(is-true(success?(1-proj-2-tuple(v_736))))) then cipherstatepack(1-proj-2-tuple(v_736),increment_nonce(2-proj-2-tuple(v_733))) else fail-any) else fail-any)) in
        {234}let v_738: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_720)) && (success?(3-proj-3-tuple(v_732)) && success?(1-proj-3-tuple(v_732)))) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then (if not-caught-fail(v_734) then (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-3-tuple(v_735))))) then (if not-caught-fail(v_737) then (v_737,3-proj-3-tuple(v_735),1-proj-3-tuple(v_735)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {235}let v_739: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_738),2-proj-3-tuple(v_732),3-proj-3-tuple(v_732)))) in
        {236}let v_740: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_720)) && success?(symmetricstatepack(1-proj-3-tuple(v_738),2-proj-3-tuple(v_732),3-proj-3-tuple(v_732)))) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then symmetricstatepack(1-proj-3-tuple(v_739),2-proj-3-tuple(v_739),hash(3-proj-3-tuple(v_739),3-proj-3-tuple(v_720))) else fail-any) else fail-any)) in
        {237}let v_741: bitstring = catch-fail((if success?(3-proj-3-tuple(v_720)) then (if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-3-tuple(v_732))))) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-3-tuple(v_738))))) then (if not-caught-fail(v_740) then (v_740,2-proj-3-tuple(v_738),3-proj-3-tuple(v_738)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {238}let v_742: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_741),2-proj-7-tuple(v_719),3-proj-7-tuple(v_719),4-proj-7-tuple(v_719),v_722,6-proj-7-tuple(v_719),7-proj-7-tuple(v_719))) in
        {239}let (hs_743: handshakestate,re_744: key,plaintext_b_745: bitstring,valid_746: bool) = (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-7-tuple(v_719))))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-3-tuple(v_720))))) then (if not-caught-fail(v_721) then (if not-caught-fail(v_722) then (if not-caught-fail(v_724) then (if not-caught-fail(v_731) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-3-tuple(v_741))))) then (if (v_721 && 3-proj-3-tuple(v_741)) then (if not-caught-fail(v_742) then (v_742,getpublickey(3-proj-7-tuple(v_719)),2-proj-3-tuple(v_741),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {240}event RecvMsg(me_673,them_672,stage_b,plaintext_b_745,valid_746);
        {241}insert statestore(me_673,them_672,statepack_c(hs_743))
    ) | (
        {278}get statestore(=me_673,=them_672,statepack_c(hs_747: handshakestate)) in
        {243}let v_748: bitstring = catch-fail(handshakestateunpack(hs_747)) in
        {244}let v_749: bitstring = catch-fail((empty,empty,empty)) in
        {245}let v_750: key = catch-fail(dhexp(key_s(me_673),g)) in
        {246}let v_751: keypair = catch-fail((if not-caught-fail(v_750) then keypairpack(v_750,key_s(me_673)) else fail-any)) in
        {247}let v_752: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_748))) in
        {248}let v_753: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_752))) in
        {249}let v_754: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_753),2-proj-2-tuple(v_753),3-proj-3-tuple(v_752),getpublickey(v_751))) in
        {250}let v_755: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_752))) in
        {251}let v_756: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_753))) && success?(1-proj-3-tuple(v_752))) then (if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-2-tuple(v_755))))) then cipherstatepack(1-proj-2-tuple(v_755),increment_nonce(2-proj-2-tuple(v_753))) else fail-any) else fail-any)) in
        {252}let v_757: bitstring = catch-fail((if (success?(getpublickey(v_751)) && (success?(3-proj-3-tuple(v_752)) && success?(1-proj-3-tuple(v_752)))) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-2-tuple(v_753))))) then (if not-caught-fail(v_754) then (if not-caught-fail(v_756) then (v_756,v_754) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {253}let v_758: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_757),2-proj-3-tuple(v_752),3-proj-3-tuple(v_752)))) in
        {254}let v_759: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_757)) && success?(symmetricstatepack(1-proj-2-tuple(v_757),2-proj-3-tuple(v_752),3-proj-3-tuple(v_752)))) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-3-tuple(v_758))))) then symmetricstatepack(1-proj-3-tuple(v_758),2-proj-3-tuple(v_758),hash(3-proj-3-tuple(v_758),2-proj-2-tuple(v_757))) else fail-any) else fail-any)) in
        {255}let v_760: bitstring = catch-fail((if (success?(getpublickey(v_751)) && success?(1-proj-7-tuple(v_748))) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-3-tuple(v_752))))) then (if (not-caught-fail(v_757) && success?(is-true(success?(1-proj-2-tuple(v_757))))) then (if not-caught-fail(v_759) then (v_759,2-proj-2-tuple(v_757)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {256}let v_761: bitstring = catch-fail(keypairunpack(v_751)) in
        {257}let v_762: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_760))) in
        {258}let v_763: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_762),(if success?(5-proj-7-tuple(v_748)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),5-proj-7-tuple(v_748)) else fail-any) else fail-any))) in
        {259}let v_764: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_762),(if success?(5-proj-7-tuple(v_748)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),5-proj-7-tuple(v_748)) else fail-any) else fail-any))) in
        {260}let v_765: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_762),(if success?(5-proj-7-tuple(v_748)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),5-proj-7-tuple(v_748)) else fail-any) else fail-any))) in
        {261}let v_766: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_748)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),5-proj-7-tuple(v_748)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_762))) then (if not-caught-fail(v_763) then (if not-caught-fail(v_764) then (if not-caught-fail(v_765) then (v_763,v_764,v_765) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {262}let v_767: symmetricstate = catch-fail((if (success?((if success?(5-proj-7-tuple(v_748)) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-2-tuple(v_761))))) then dhexp(2-proj-2-tuple(v_761),5-proj-7-tuple(v_748)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_760))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then (if (not-caught-fail(v_766) && success?(is-true(success?(1-proj-3-tuple(v_766))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_766)) then cipherstatepack(2-proj-3-tuple(v_766),minnonce) else fail-any),1-proj-3-tuple(v_766),3-proj-3-tuple(v_762)) else fail-any) else fail-any) else fail-any)) in
        {263}let v_768: bitstring = catch-fail(symmetricstateunpack(v_767)) in
        {264}let v_769: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_768))) in
        {265}let v_770: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_769),2-proj-2-tuple(v_769),3-proj-3-tuple(v_768),msg_c(me_673,them_672))) in
        {266}let v_771: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_768))) in
        {267}let v_772: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_769))) && success?(1-proj-3-tuple(v_768))) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-2-tuple(v_771))))) then cipherstatepack(1-proj-2-tuple(v_771),increment_nonce(2-proj-2-tuple(v_769))) else fail-any) else fail-any)) in
        {268}let v_773: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_768)) && success?(1-proj-3-tuple(v_768))) then (if (not-caught-fail(v_769) && success?(is-true(success?(1-proj-2-tuple(v_769))))) then (if not-caught-fail(v_770) then (if not-caught-fail(v_772) then (v_772,v_770) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {269}let v_774: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_773),2-proj-3-tuple(v_768),3-proj-3-tuple(v_768)))) in
        {270}let v_775: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_773)) && success?(symmetricstatepack(1-proj-2-tuple(v_773),2-proj-3-tuple(v_768),3-proj-3-tuple(v_768)))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then symmetricstatepack(1-proj-3-tuple(v_774),2-proj-3-tuple(v_774),hash(3-proj-3-tuple(v_774),2-proj-2-tuple(v_773))) else fail-any) else fail-any)) in
        {271}let v_776: bitstring = catch-fail((if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-3-tuple(v_768))))) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-2-tuple(v_773))))) then (if not-caught-fail(v_775) then (v_775,2-proj-2-tuple(v_773)) else fail-any) else fail-any) else fail-any)) in
        {272}let v_777: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_776),v_751,3-proj-7-tuple(v_748),4-proj-7-tuple(v_748),5-proj-7-tuple(v_748),6-proj-7-tuple(v_748),7-proj-7-tuple(v_748))) in
        {273}let v_778: bitstring = catch-fail(concat3(1-proj-3-tuple(v_749),2-proj-2-tuple(v_760),2-proj-2-tuple(v_776))) in
        {274}let (hs_779: handshakestate,re_780: key,message_c_781: bitstring) = (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-7-tuple(v_748))))) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-3-tuple(v_749))))) then (if not-caught-fail(v_751) then (if (not-caught-fail(v_760) && success?(is-true(success?(1-proj-2-tuple(v_760))))) then (if not-caught-fail(v_767) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-2-tuple(v_776))))) then (if not-caught-fail(v_777) then (if not-caught-fail(v_778) then (v_777,5-proj-7-tuple(v_748),v_778) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {275}event SendMsg(me_673,them_672,stage_c,msg_c(me_673,them_672),true);
        {276}insert statestore(me_673,them_672,statepack_d(hs_779));
        {277}out(pub, message_c_781)
    ) | (
        {297}get statestore(=me_673,=them_672,statepack_d(hs_782: handshakestate)) in
        {279}in(pub, message_d_783: bitstring);
        {280}let v_784: bitstring = catch-fail(handshakestateunpack(hs_782)) in
        {281}let v_785: bitstring = catch-fail(deconcat3(message_d_783)) in
        {282}let v_786: bool = catch-fail(true) in
        {283}let v_787: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_784))) in
        {284}let v_788: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_787))) in
        {285}let v_789: aead = catch-fail(decrypt(1-proj-2-tuple(v_788),2-proj-2-tuple(v_788),3-proj-3-tuple(v_787),3-proj-3-tuple(v_785))) in
        {286}let v_790: bitstring = catch-fail(aeadunpack(v_789)) in
        {287}let v_791: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_787))) in
        {288}let v_792: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_788))) && success?(1-proj-3-tuple(v_787))) then (if (not-caught-fail(v_791) && success?(is-true(success?(1-proj-2-tuple(v_791))))) then cipherstatepack(1-proj-2-tuple(v_791),increment_nonce(2-proj-2-tuple(v_788))) else fail-any) else fail-any)) in
        {289}let v_793: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_785)) && (success?(3-proj-3-tuple(v_787)) && success?(1-proj-3-tuple(v_787)))) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-2-tuple(v_788))))) then (if not-caught-fail(v_789) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-3-tuple(v_790))))) then (if not-caught-fail(v_792) then (v_792,3-proj-3-tuple(v_790),1-proj-3-tuple(v_790)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {290}let v_794: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_793),2-proj-3-tuple(v_787),3-proj-3-tuple(v_787)))) in
        {291}let v_795: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_785)) && success?(symmetricstatepack(1-proj-3-tuple(v_793),2-proj-3-tuple(v_787),3-proj-3-tuple(v_787)))) then (if (not-caught-fail(v_794) && success?(is-true(success?(1-proj-3-tuple(v_794))))) then symmetricstatepack(1-proj-3-tuple(v_794),2-proj-3-tuple(v_794),hash(3-proj-3-tuple(v_794),3-proj-3-tuple(v_785))) else fail-any) else fail-any)) in
        {292}let v_796: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_785)) && success?(1-proj-7-tuple(v_784))) then (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-3-tuple(v_787))))) then (if (not-caught-fail(v_793) && success?(is-true(success?(1-proj-3-tuple(v_793))))) then (if not-caught-fail(v_795) then (v_795,2-proj-3-tuple(v_793),3-proj-3-tuple(v_793)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {293}let v_797: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_796),2-proj-7-tuple(v_784),3-proj-7-tuple(v_784),4-proj-7-tuple(v_784),5-proj-7-tuple(v_784),6-proj-7-tuple(v_784),7-proj-7-tuple(v_784))) in
        {294}let (hs_798: handshakestate,re_799: key,plaintext_d_800: bitstring,valid_801: bool) = (if (not-caught-fail(v_784) && success?(is-true(success?(1-proj-7-tuple(v_784))))) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-3-tuple(v_785))))) then (if not-caught-fail(v_786) then (if (not-caught-fail(v_796) && success?(is-true(success?(1-proj-3-tuple(v_796))))) then (if (v_786 && 3-proj-3-tuple(v_796)) then (if not-caught-fail(v_797) then (v_797,getpublickey(3-proj-7-tuple(v_784)),2-proj-3-tuple(v_796),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {295}event RecvMsg(me_673,them_672,stage_d,plaintext_d_800,valid_801);
        {296}insert statestore(me_673,them_672,statepack_e(hs_798))
    ) | (
        {323}get statestore(=me_673,=them_672,statepack_e(hs_802: handshakestate)) in
        {298}let v_803: bitstring = catch-fail(handshakestateunpack(hs_802)) in
        {299}let v_804: bitstring = catch-fail((empty,empty,empty)) in
        {300}let v_805: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_803))) in
        {301}let v_806: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_805))) in
        {302}let v_807: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_806),2-proj-2-tuple(v_806),3-proj-3-tuple(v_805),msg_e(me_673,them_672))) in
        {303}let v_808: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_805))) in
        {304}let v_809: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_806))) && success?(1-proj-3-tuple(v_805))) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-2-tuple(v_808))))) then cipherstatepack(1-proj-2-tuple(v_808),increment_nonce(2-proj-2-tuple(v_806))) else fail-any) else fail-any)) in
        {305}let v_810: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_805)) && success?(1-proj-3-tuple(v_805))) then (if (not-caught-fail(v_806) && success?(is-true(success?(1-proj-2-tuple(v_806))))) then (if not-caught-fail(v_807) then (if not-caught-fail(v_809) then (v_809,v_807) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {306}let v_811: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_810),2-proj-3-tuple(v_805),3-proj-3-tuple(v_805)))) in
        {307}let v_812: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_810)) && success?(symmetricstatepack(1-proj-2-tuple(v_810),2-proj-3-tuple(v_805),3-proj-3-tuple(v_805)))) then (if (not-caught-fail(v_811) && success?(is-true(success?(1-proj-3-tuple(v_811))))) then symmetricstatepack(1-proj-3-tuple(v_811),2-proj-3-tuple(v_811),hash(3-proj-3-tuple(v_811),2-proj-2-tuple(v_810))) else fail-any) else fail-any)) in
        {308}let v_813: bitstring = catch-fail((if success?(1-proj-7-tuple(v_803)) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-2-tuple(v_810))))) then (if not-caught-fail(v_812) then (v_812,2-proj-2-tuple(v_810)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {309}let v_814: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_813),2-proj-7-tuple(v_803),3-proj-7-tuple(v_803),4-proj-7-tuple(v_803),5-proj-7-tuple(v_803),6-proj-7-tuple(v_803),7-proj-7-tuple(v_803))) in
        {310}let v_815: bitstring = catch-fail(concat3(1-proj-3-tuple(v_804),2-proj-3-tuple(v_804),2-proj-2-tuple(v_813))) in
        {311}let v_816: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_813))) in
        {312}let v_817: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_816),zero)) in
        {313}let v_818: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_816),zero)) in
        {314}let v_819: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_816),zero)) in
        {315}let v_820: bitstring = catch-fail((if success?(2-proj-3-tuple(v_816)) then (if not-caught-fail(v_817) then (if not-caught-fail(v_818) then (if not-caught-fail(v_819) then (v_817,v_818,v_819) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {316}let v_821: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_820)) then cipherstatepack(1-proj-3-tuple(v_820),minnonce) else fail-any)) in
        {317}let v_822: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_820)) then cipherstatepack(2-proj-3-tuple(v_820),minnonce) else fail-any)) in
        {318}let v_823: bitstring = catch-fail((if success?(1-proj-2-tuple(v_813)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-3-tuple(v_816))))) then (if (not-caught-fail(v_820) && success?(is-true(success?(1-proj-3-tuple(v_820))))) then (if not-caught-fail(v_821) then (if not-caught-fail(v_822) then (1-proj-2-tuple(v_813),v_821,v_822) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {319}let (hs_824: handshakestate,re_825: key,message_e_826: bitstring,cs1_827: cipherstate,cs2_828: cipherstate) = (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-7-tuple(v_803))))) then (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-3-tuple(v_804))))) then (if (not-caught-fail(v_813) && success?(is-true(success?(1-proj-2-tuple(v_813))))) then (if not-caught-fail(v_814) then (if not-caught-fail(v_815) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (v_814,5-proj-7-tuple(v_803),v_815,2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {320}event SendMsg(me_673,them_672,stage_e,msg_e(me_673,them_672),true);
        {321}insert statestore(me_673,them_672,statepack_f(hs_824));
        {322}out(pub, message_e_826)
    ) | (
        {324}event LeakS(phase0,me_673);
        {325}out(pub, key_s(me_673))
    ) | (
        {326}phase 1;
        {327}event LeakS(phase1,me_673);
        {328}out(pub, key_s(me_673))
    )
) | (
    {329}let them_829: principal = alice in
    {330}let me_830: principal = bob in
    {331}let v_831: key = catch-fail(dhexp(key_s(me_830),g)) in
    {332}let s_832: keypair = (if not-caught-fail(v_831) then keypairpack(v_831,key_s(me_830)) else fail-any) in
    {333}out(pub, getpublickey(s_832));
    (
        {334}let e_833: keypair = keypairpack(empty,empty) in
        {335}let rs_834: key = empty in
        {336}let re_835: key = empty in
        {337}let v_836: bitstring = catch-fail(hash(somename,empty)) in
        {338}let v_837: key = catch-fail(v_836) in
        {339}let v_838: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {340}let v_839: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_836) then (if not-caught-fail(v_837) then (if not-caught-fail(v_838) then symmetricstatepack(v_838,v_837,v_836) else fail-any) else fail-any) else fail-any))) in
        {341}let v_840: symmetricstate = catch-fail((if success?((if not-caught-fail(v_836) then (if not-caught-fail(v_837) then (if not-caught-fail(v_838) then symmetricstatepack(v_838,v_837,v_836) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then symmetricstatepack(1-proj-3-tuple(v_839),2-proj-3-tuple(v_839),hash(3-proj-3-tuple(v_839),empty)) else fail-any) else fail-any)) in
        {342}let v_841: bitstring = catch-fail(symmetricstateunpack(v_840)) in
        {343}let v_842: symmetricstate = catch-fail((if success?(getpublickey(s_832)) then (if (not-caught-fail(v_841) && success?(is-true(success?(1-proj-3-tuple(v_841))))) then symmetricstatepack(1-proj-3-tuple(v_841),2-proj-3-tuple(v_841),hash(3-proj-3-tuple(v_841),getpublickey(s_832))) else fail-any) else fail-any)) in
        {344}let hs_843: handshakestate = (if not-caught-fail(v_840) then (if not-caught-fail(v_842) then handshakestatepack(v_842,s_832,e_833,rs_834,re_835,empty,false) else fail-any) else fail-any) in
        {345}insert statestore(me_830,them_829,statepack_a(hs_843))
    ) | (
        {374}get statestore(=me_830,=them_829,statepack_a(hs_844: handshakestate)) in
        {346}in(pub, message_a_845: bitstring);
        {347}let v_846: bitstring = catch-fail(handshakestateunpack(hs_844)) in
        {348}let v_847: bitstring = catch-fail(deconcat3(message_a_845)) in
        {349}let v_848: bool = catch-fail(true) in
        {350}let v_849: key = catch-fail(1-proj-3-tuple(v_847)) in
        {351}let v_850: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_846))) in
        {352}let v_851: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_846)) then (if (not-caught-fail(v_850) && success?(is-true(success?(1-proj-3-tuple(v_850))))) then symmetricstatepack(1-proj-3-tuple(v_850),2-proj-3-tuple(v_850),hash(3-proj-3-tuple(v_850),v_849)) else fail-any) else fail-any)) in
        {353}let v_852: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_846))) in
        {354}let v_853: bitstring = catch-fail(symmetricstateunpack(v_851)) in
        {355}let v_854: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_853),(if success?(2-proj-7-tuple(v_846)) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then dhexp(2-proj-2-tuple(v_852),v_849) else fail-any) else fail-any))) in
        {356}let v_855: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_853),(if success?(2-proj-7-tuple(v_846)) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then dhexp(2-proj-2-tuple(v_852),v_849) else fail-any) else fail-any))) in
        {357}let v_856: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_853),(if success?(2-proj-7-tuple(v_846)) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then dhexp(2-proj-2-tuple(v_852),v_849) else fail-any) else fail-any))) in
        {358}let v_857: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_846)) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then dhexp(2-proj-2-tuple(v_852),v_849) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_853))) then (if not-caught-fail(v_854) then (if not-caught-fail(v_855) then (if not-caught-fail(v_856) then (v_854,v_855,v_856) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {359}let v_858: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_846)) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-2-tuple(v_852))))) then dhexp(2-proj-2-tuple(v_852),v_849) else fail-any) else fail-any)) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-3-tuple(v_853))))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_857)) then cipherstatepack(2-proj-3-tuple(v_857),minnonce) else fail-any),1-proj-3-tuple(v_857),3-proj-3-tuple(v_853)) else fail-any) else fail-any) else fail-any)) in
        {360}let v_859: bitstring = catch-fail(symmetricstateunpack(v_858)) in
        {361}let v_860: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_859))) in
        {362}let v_861: aead = catch-fail(decrypt(1-proj-2-tuple(v_860),2-proj-2-tuple(v_860),3-proj-3-tuple(v_859),3-proj-3-tuple(v_847))) in
        {363}let v_862: bitstring = catch-fail(aeadunpack(v_861)) in
        {364}let v_863: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_859))) in
        {365}let v_864: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_860))) && success?(1-proj-3-tuple(v_859))) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-2-tuple(v_863))))) then cipherstatepack(1-proj-2-tuple(v_863),increment_nonce(2-proj-2-tuple(v_860))) else fail-any) else fail-any)) in
        {366}let v_865: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_847)) && (success?(3-proj-3-tuple(v_859)) && success?(1-proj-3-tuple(v_859)))) then (if (not-caught-fail(v_860) && success?(is-true(success?(1-proj-2-tuple(v_860))))) then (if not-caught-fail(v_861) then (if (not-caught-fail(v_862) && success?(is-true(success?(1-proj-3-tuple(v_862))))) then (if not-caught-fail(v_864) then (v_864,3-proj-3-tuple(v_862),1-proj-3-tuple(v_862)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {367}let v_866: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_865),2-proj-3-tuple(v_859),3-proj-3-tuple(v_859)))) in
        {368}let v_867: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_847)) && success?(symmetricstatepack(1-proj-3-tuple(v_865),2-proj-3-tuple(v_859),3-proj-3-tuple(v_859)))) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then symmetricstatepack(1-proj-3-tuple(v_866),2-proj-3-tuple(v_866),hash(3-proj-3-tuple(v_866),3-proj-3-tuple(v_847))) else fail-any) else fail-any)) in
        {369}let v_868: bitstring = catch-fail((if success?(3-proj-3-tuple(v_847)) then (if (not-caught-fail(v_859) && success?(is-true(success?(1-proj-3-tuple(v_859))))) then (if (not-caught-fail(v_865) && success?(is-true(success?(1-proj-3-tuple(v_865))))) then (if not-caught-fail(v_867) then (v_867,2-proj-3-tuple(v_865),3-proj-3-tuple(v_865)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {370}let v_869: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_868),2-proj-7-tuple(v_846),3-proj-7-tuple(v_846),4-proj-7-tuple(v_846),v_849,6-proj-7-tuple(v_846),7-proj-7-tuple(v_846))) in
        {371}let (hs_870: handshakestate,re_871: key,plaintext_a: bitstring,valid_872: bool) = (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-7-tuple(v_846))))) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-3-tuple(v_847))))) then (if not-caught-fail(v_848) then (if not-caught-fail(v_849) then (if not-caught-fail(v_851) then (if not-caught-fail(v_858) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-3-tuple(v_868))))) then (if (v_848 && 3-proj-3-tuple(v_868)) then (if not-caught-fail(v_869) then (v_869,getpublickey(3-proj-7-tuple(v_846)),2-proj-3-tuple(v_868),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {372}event RecvMsg(me_830,them_829,stage_a,plaintext_a,valid_872);
        {373}insert statestore(me_830,them_829,statepack_b(hs_870))
    ) | (
        {405}get statestore(=me_830,=them_829,statepack_b(hs_873: handshakestate)) in
        {375}let v_874: bitstring = catch-fail(handshakestateunpack(hs_873)) in
        {376}let v_875: bitstring = catch-fail((empty,empty,empty)) in
        {377}new key_e_876[me_830,them_829]: key;
        {378}let v_877: key = catch-fail(dhexp(key_e_876,g)) in
        {379}let v_878: keypair = catch-fail((if not-caught-fail(v_877) then keypairpack(v_877,key_e_876) else fail-any)) in
        {380}let v_879: bitstring = catch-fail(getpublickey(v_878)) in
        {381}let v_880: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_874))) in
        {382}let v_881: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_874)) then (if (not-caught-fail(v_880) && success?(is-true(success?(1-proj-3-tuple(v_880))))) then symmetricstatepack(1-proj-3-tuple(v_880),2-proj-3-tuple(v_880),hash(3-proj-3-tuple(v_880),v_879)) else fail-any) else fail-any)) in
        {383}let v_882: bitstring = catch-fail(keypairunpack(v_878)) in
        {384}let v_883: bitstring = catch-fail(symmetricstateunpack(v_881)) in
        {385}let v_884: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_883),(if success?(5-proj-7-tuple(v_874)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),5-proj-7-tuple(v_874)) else fail-any) else fail-any))) in
        {386}let v_885: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_883),(if success?(5-proj-7-tuple(v_874)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),5-proj-7-tuple(v_874)) else fail-any) else fail-any))) in
        {387}let v_886: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_883),(if success?(5-proj-7-tuple(v_874)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),5-proj-7-tuple(v_874)) else fail-any) else fail-any))) in
        {388}let v_887: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_874)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),5-proj-7-tuple(v_874)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_883))) then (if not-caught-fail(v_884) then (if not-caught-fail(v_885) then (if not-caught-fail(v_886) then (v_884,v_885,v_886) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {389}let v_888: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_874)) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-2-tuple(v_882))))) then dhexp(2-proj-2-tuple(v_882),5-proj-7-tuple(v_874)) else fail-any) else fail-any)) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-3-tuple(v_887))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_887)) then cipherstatepack(2-proj-3-tuple(v_887),minnonce) else fail-any),1-proj-3-tuple(v_887),3-proj-3-tuple(v_883)) else fail-any) else fail-any) else fail-any)) in
        {390}let v_889: bitstring = catch-fail(symmetricstateunpack(v_888)) in
        {391}let v_890: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_889))) in
        {392}let v_891: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_890),2-proj-2-tuple(v_890),3-proj-3-tuple(v_889),msg_b(me_830,them_829))) in
        {393}let v_892: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_889))) in
        {394}let v_893: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_890))) && success?(1-proj-3-tuple(v_889))) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then cipherstatepack(1-proj-2-tuple(v_892),increment_nonce(2-proj-2-tuple(v_890))) else fail-any) else fail-any)) in
        {395}let v_894: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_889)) && success?(1-proj-3-tuple(v_889))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-2-tuple(v_890))))) then (if not-caught-fail(v_891) then (if not-caught-fail(v_893) then (v_893,v_891) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {396}let v_895: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_894),2-proj-3-tuple(v_889),3-proj-3-tuple(v_889)))) in
        {397}let v_896: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_894)) && success?(symmetricstatepack(1-proj-2-tuple(v_894),2-proj-3-tuple(v_889),3-proj-3-tuple(v_889)))) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-3-tuple(v_895))))) then symmetricstatepack(1-proj-3-tuple(v_895),2-proj-3-tuple(v_895),hash(3-proj-3-tuple(v_895),2-proj-2-tuple(v_894))) else fail-any) else fail-any)) in
        {398}let v_897: bitstring = catch-fail((if (not-caught-fail(v_889) && success?(is-true(success?(1-proj-3-tuple(v_889))))) then (if (not-caught-fail(v_894) && success?(is-true(success?(1-proj-2-tuple(v_894))))) then (if not-caught-fail(v_896) then (v_896,2-proj-2-tuple(v_894)) else fail-any) else fail-any) else fail-any)) in
        {399}let v_898: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_897),2-proj-7-tuple(v_874),v_878,4-proj-7-tuple(v_874),5-proj-7-tuple(v_874),6-proj-7-tuple(v_874),7-proj-7-tuple(v_874))) in
        {400}let v_899: bitstring = catch-fail(concat3(v_879,2-proj-3-tuple(v_875),2-proj-2-tuple(v_897))) in
        {401}let (hs_900: handshakestate,re_901: key,message_b_902: bitstring) = (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-7-tuple(v_874))))) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-3-tuple(v_875))))) then (if not-caught-fail(v_878) then (if not-caught-fail(v_879) then (if not-caught-fail(v_881) then (if not-caught-fail(v_888) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-2-tuple(v_897))))) then (if not-caught-fail(v_898) then (if not-caught-fail(v_899) then (v_898,5-proj-7-tuple(v_874),v_899) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {402}event SendMsg(me_830,them_829,stage_b,msg_b(me_830,them_829),true);
        {403}insert statestore(me_830,them_829,statepack_c(hs_900));
        {404}out(pub, message_b_902)
    ) | (
        {443}get statestore(=me_830,=them_829,statepack_c(hs_903: handshakestate)) in
        {406}in(pub, message_c_904: bitstring);
        {407}let v_905: bitstring = catch-fail(handshakestateunpack(hs_903)) in
        {408}let v_906: bitstring = catch-fail(deconcat3(message_c_904)) in
        {409}let v_907: bool = catch-fail(true) in
        {410}let v_908: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_905))) in
        {411}let v_909: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_908))) in
        {412}let v_910: aead = catch-fail(decrypt(1-proj-2-tuple(v_909),2-proj-2-tuple(v_909),3-proj-3-tuple(v_908),2-proj-3-tuple(v_906))) in
        {413}let v_911: bitstring = catch-fail(aeadunpack(v_910)) in
        {414}let v_912: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_908))) in
        {415}let v_913: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_909))) && success?(1-proj-3-tuple(v_908))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-2-tuple(v_912))))) then cipherstatepack(1-proj-2-tuple(v_912),increment_nonce(2-proj-2-tuple(v_909))) else fail-any) else fail-any)) in
        {416}let v_914: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_906)) && (success?(3-proj-3-tuple(v_908)) && success?(1-proj-3-tuple(v_908)))) then (if (not-caught-fail(v_909) && success?(is-true(success?(1-proj-2-tuple(v_909))))) then (if not-caught-fail(v_910) then (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then (if not-caught-fail(v_913) then (v_913,3-proj-3-tuple(v_911),1-proj-3-tuple(v_911)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {417}let v_915: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_914),2-proj-3-tuple(v_908),3-proj-3-tuple(v_908)))) in
        {418}let v_916: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_906)) && success?(symmetricstatepack(1-proj-3-tuple(v_914),2-proj-3-tuple(v_908),3-proj-3-tuple(v_908)))) then (if (not-caught-fail(v_915) && success?(is-true(success?(1-proj-3-tuple(v_915))))) then symmetricstatepack(1-proj-3-tuple(v_915),2-proj-3-tuple(v_915),hash(3-proj-3-tuple(v_915),2-proj-3-tuple(v_906))) else fail-any) else fail-any)) in
        {419}let v_917: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_906)) && success?(1-proj-7-tuple(v_905))) then (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-3-tuple(v_908))))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-3-tuple(v_914))))) then (if not-caught-fail(v_916) then (v_916,2-proj-3-tuple(v_914),3-proj-3-tuple(v_914)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {420}let v_918: key = catch-fail(2-proj-3-tuple(v_917)) in
        {421}let v_919: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_905))) in
        {422}let v_920: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_917))) in
        {423}let v_921: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_920),(if success?(3-proj-7-tuple(v_905)) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then dhexp(2-proj-2-tuple(v_919),v_918) else fail-any) else fail-any))) in
        {424}let v_922: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_920),(if success?(3-proj-7-tuple(v_905)) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then dhexp(2-proj-2-tuple(v_919),v_918) else fail-any) else fail-any))) in
        {425}let v_923: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_920),(if success?(3-proj-7-tuple(v_905)) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then dhexp(2-proj-2-tuple(v_919),v_918) else fail-any) else fail-any))) in
        {426}let v_924: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_905)) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then dhexp(2-proj-2-tuple(v_919),v_918) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_920))) then (if not-caught-fail(v_921) then (if not-caught-fail(v_922) then (if not-caught-fail(v_923) then (v_921,v_922,v_923) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {427}let v_925: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_905)) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-2-tuple(v_919))))) then dhexp(2-proj-2-tuple(v_919),v_918) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_917))) then (if (not-caught-fail(v_920) && success?(is-true(success?(1-proj-3-tuple(v_920))))) then (if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-3-tuple(v_924))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_924)) then cipherstatepack(2-proj-3-tuple(v_924),minnonce) else fail-any),1-proj-3-tuple(v_924),3-proj-3-tuple(v_920)) else fail-any) else fail-any) else fail-any)) in
        {428}let v_926: bitstring = catch-fail(symmetricstateunpack(v_925)) in
        {429}let v_927: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_926))) in
        {430}let v_928: aead = catch-fail(decrypt(1-proj-2-tuple(v_927),2-proj-2-tuple(v_927),3-proj-3-tuple(v_926),3-proj-3-tuple(v_906))) in
        {431}let v_929: bitstring = catch-fail(aeadunpack(v_928)) in
        {432}let v_930: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_926))) in
        {433}let v_931: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_927))) && success?(1-proj-3-tuple(v_926))) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then cipherstatepack(1-proj-2-tuple(v_930),increment_nonce(2-proj-2-tuple(v_927))) else fail-any) else fail-any)) in
        {434}let v_932: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_906)) && (success?(3-proj-3-tuple(v_926)) && success?(1-proj-3-tuple(v_926)))) then (if (not-caught-fail(v_927) && success?(is-true(success?(1-proj-2-tuple(v_927))))) then (if not-caught-fail(v_928) then (if (not-caught-fail(v_929) && success?(is-true(success?(1-proj-3-tuple(v_929))))) then (if not-caught-fail(v_931) then (v_931,3-proj-3-tuple(v_929),1-proj-3-tuple(v_929)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {435}let v_933: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_932),2-proj-3-tuple(v_926),3-proj-3-tuple(v_926)))) in
        {436}let v_934: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_906)) && success?(symmetricstatepack(1-proj-3-tuple(v_932),2-proj-3-tuple(v_926),3-proj-3-tuple(v_926)))) then (if (not-caught-fail(v_933) && success?(is-true(success?(1-proj-3-tuple(v_933))))) then symmetricstatepack(1-proj-3-tuple(v_933),2-proj-3-tuple(v_933),hash(3-proj-3-tuple(v_933),3-proj-3-tuple(v_906))) else fail-any) else fail-any)) in
        {437}let v_935: bitstring = catch-fail((if success?(3-proj-3-tuple(v_906)) then (if (not-caught-fail(v_926) && success?(is-true(success?(1-proj-3-tuple(v_926))))) then (if (not-caught-fail(v_932) && success?(is-true(success?(1-proj-3-tuple(v_932))))) then (if not-caught-fail(v_934) then (v_934,2-proj-3-tuple(v_932),3-proj-3-tuple(v_932)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {438}let v_936: key = catch-fail(dhexp(key_s(them_829),g)) in
        {439}let v_937: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_935),2-proj-7-tuple(v_905),3-proj-7-tuple(v_905),v_918,5-proj-7-tuple(v_905),6-proj-7-tuple(v_905),7-proj-7-tuple(v_905))) in
        {440}let (hs_938: handshakestate,re_939: key,plaintext_c: bitstring,valid_940: bool) = (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-7-tuple(v_905))))) then (if (not-caught-fail(v_906) && success?(is-true(success?(1-proj-3-tuple(v_906))))) then (if not-caught-fail(v_907) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then (if not-caught-fail(v_918) then (if not-caught-fail(v_925) then (if (not-caught-fail(v_935) && success?(is-true(success?(1-proj-3-tuple(v_935))))) then (if ((3-proj-3-tuple(v_917) && 3-proj-3-tuple(v_935)) && (v_918 = getpublickey((if not-caught-fail(v_936) then keypairpack(v_936,key_s(them_829)) else fail-any)))) then (if not-caught-fail(v_937) then (v_937,getpublickey(3-proj-7-tuple(v_905)),2-proj-3-tuple(v_935),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {441}event RecvMsg(me_830,them_829,stage_c,plaintext_c,valid_940);
        {442}insert statestore(me_830,them_829,statepack_d(hs_938))
    ) | (
        {461}get statestore(=me_830,=them_829,statepack_d(hs_941: handshakestate)) in
        {444}let v_942: bitstring = catch-fail(handshakestateunpack(hs_941)) in
        {445}let v_943: bitstring = catch-fail((empty,empty,empty)) in
        {446}let v_944: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_942))) in
        {447}let v_945: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_944))) in
        {448}let v_946: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_945),2-proj-2-tuple(v_945),3-proj-3-tuple(v_944),msg_d(me_830,them_829))) in
        {449}let v_947: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_944))) in
        {450}let v_948: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_945))) && success?(1-proj-3-tuple(v_944))) then (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-2-tuple(v_947))))) then cipherstatepack(1-proj-2-tuple(v_947),increment_nonce(2-proj-2-tuple(v_945))) else fail-any) else fail-any)) in
        {451}let v_949: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_944)) && success?(1-proj-3-tuple(v_944))) then (if (not-caught-fail(v_945) && success?(is-true(success?(1-proj-2-tuple(v_945))))) then (if not-caught-fail(v_946) then (if not-caught-fail(v_948) then (v_948,v_946) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {452}let v_950: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_949),2-proj-3-tuple(v_944),3-proj-3-tuple(v_944)))) in
        {453}let v_951: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_949)) && success?(symmetricstatepack(1-proj-2-tuple(v_949),2-proj-3-tuple(v_944),3-proj-3-tuple(v_944)))) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-3-tuple(v_950))))) then symmetricstatepack(1-proj-3-tuple(v_950),2-proj-3-tuple(v_950),hash(3-proj-3-tuple(v_950),2-proj-2-tuple(v_949))) else fail-any) else fail-any)) in
        {454}let v_952: bitstring = catch-fail((if success?(1-proj-7-tuple(v_942)) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-2-tuple(v_949))))) then (if not-caught-fail(v_951) then (v_951,2-proj-2-tuple(v_949)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {455}let v_953: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_952),2-proj-7-tuple(v_942),3-proj-7-tuple(v_942),4-proj-7-tuple(v_942),5-proj-7-tuple(v_942),6-proj-7-tuple(v_942),7-proj-7-tuple(v_942))) in
        {456}let v_954: bitstring = catch-fail(concat3(1-proj-3-tuple(v_943),2-proj-3-tuple(v_943),2-proj-2-tuple(v_952))) in
        {457}let (hs_955: handshakestate,re_956: key,message_d_957: bitstring) = (if (not-caught-fail(v_942) && success?(is-true(success?(1-proj-7-tuple(v_942))))) then (if (not-caught-fail(v_943) && success?(is-true(success?(1-proj-3-tuple(v_943))))) then (if (not-caught-fail(v_952) && success?(is-true(success?(1-proj-2-tuple(v_952))))) then (if not-caught-fail(v_953) then (if not-caught-fail(v_954) then (v_953,5-proj-7-tuple(v_942),v_954) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {458}event SendMsg(me_830,them_829,stage_d,msg_d(me_830,them_829),true);
        {459}insert statestore(me_830,them_829,statepack_e(hs_955));
        {460}out(pub, message_d_957)
    ) | (
        {489}get statestore(=me_830,=them_829,statepack_e(hs_958: handshakestate)) in
        {462}in(pub, message_e_959: bitstring);
        {463}let v_960: bitstring = catch-fail(handshakestateunpack(hs_958)) in
        {464}let v_961: bitstring = catch-fail(deconcat3(message_e_959)) in
        {465}let v_962: bool = catch-fail(true) in
        {466}let v_963: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_960))) in
        {467}let v_964: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_963))) in
        {468}let v_965: aead = catch-fail(decrypt(1-proj-2-tuple(v_964),2-proj-2-tuple(v_964),3-proj-3-tuple(v_963),3-proj-3-tuple(v_961))) in
        {469}let v_966: bitstring = catch-fail(aeadunpack(v_965)) in
        {470}let v_967: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_963))) in
        {471}let v_968: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_964))) && success?(1-proj-3-tuple(v_963))) then (if (not-caught-fail(v_967) && success?(is-true(success?(1-proj-2-tuple(v_967))))) then cipherstatepack(1-proj-2-tuple(v_967),increment_nonce(2-proj-2-tuple(v_964))) else fail-any) else fail-any)) in
        {472}let v_969: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_961)) && (success?(3-proj-3-tuple(v_963)) && success?(1-proj-3-tuple(v_963)))) then (if (not-caught-fail(v_964) && success?(is-true(success?(1-proj-2-tuple(v_964))))) then (if not-caught-fail(v_965) then (if (not-caught-fail(v_966) && success?(is-true(success?(1-proj-3-tuple(v_966))))) then (if not-caught-fail(v_968) then (v_968,3-proj-3-tuple(v_966),1-proj-3-tuple(v_966)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {473}let v_970: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_969),2-proj-3-tuple(v_963),3-proj-3-tuple(v_963)))) in
        {474}let v_971: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_961)) && success?(symmetricstatepack(1-proj-3-tuple(v_969),2-proj-3-tuple(v_963),3-proj-3-tuple(v_963)))) then (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-3-tuple(v_970))))) then symmetricstatepack(1-proj-3-tuple(v_970),2-proj-3-tuple(v_970),hash(3-proj-3-tuple(v_970),3-proj-3-tuple(v_961))) else fail-any) else fail-any)) in
        {475}let v_972: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_961)) && success?(1-proj-7-tuple(v_960))) then (if (not-caught-fail(v_963) && success?(is-true(success?(1-proj-3-tuple(v_963))))) then (if (not-caught-fail(v_969) && success?(is-true(success?(1-proj-3-tuple(v_969))))) then (if not-caught-fail(v_971) then (v_971,2-proj-3-tuple(v_969),3-proj-3-tuple(v_969)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {476}let v_973: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_972),2-proj-7-tuple(v_960),3-proj-7-tuple(v_960),4-proj-7-tuple(v_960),5-proj-7-tuple(v_960),6-proj-7-tuple(v_960),7-proj-7-tuple(v_960))) in
        {477}let v_974: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_972))) in
        {478}let v_975: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_974),zero)) in
        {479}let v_976: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_974),zero)) in
        {480}let v_977: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_974),zero)) in
        {481}let v_978: bitstring = catch-fail((if success?(2-proj-3-tuple(v_974)) then (if not-caught-fail(v_975) then (if not-caught-fail(v_976) then (if not-caught-fail(v_977) then (v_975,v_976,v_977) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {482}let v_979: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_978)) then cipherstatepack(1-proj-3-tuple(v_978),minnonce) else fail-any)) in
        {483}let v_980: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_978)) then cipherstatepack(2-proj-3-tuple(v_978),minnonce) else fail-any)) in
        {484}let v_981: bitstring = catch-fail((if success?(1-proj-3-tuple(v_972)) then (if (not-caught-fail(v_974) && success?(is-true(success?(1-proj-3-tuple(v_974))))) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-3-tuple(v_978))))) then (if not-caught-fail(v_979) then (if not-caught-fail(v_980) then (1-proj-3-tuple(v_972),v_979,v_980) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {485}let (hs_982: handshakestate,re_983: key,plaintext_e: bitstring,valid_984: bool,cs1_985: cipherstate,cs2_986: cipherstate) = (if (not-caught-fail(v_960) && success?(is-true(success?(1-proj-7-tuple(v_960))))) then (if (not-caught-fail(v_961) && success?(is-true(success?(1-proj-3-tuple(v_961))))) then (if not-caught-fail(v_962) then (if (not-caught-fail(v_972) && success?(is-true(success?(1-proj-3-tuple(v_972))))) then (if (v_962 && 3-proj-3-tuple(v_972)) then (if not-caught-fail(v_973) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then (v_973,getpublickey(3-proj-7-tuple(v_960)),2-proj-3-tuple(v_972),true,2-proj-3-tuple(v_981),3-proj-3-tuple(v_981)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {486}event RecvMsg(me_830,them_829,stage_e,plaintext_e,valid_984);
        {487}insert statestore(me_830,them_829,statepack_f(hs_982));
        {488}event RecvEnd(valid_984)
    ) | (
        {490}event LeakS(phase0,me_830);
        {491}out(pub, key_s(me_830))
    ) | (
        {492}phase 1;
        {493}event LeakS(phase1,me_830);
        {494}out(pub, key_s(me_830))
    )
) | (
    {495}let them_987: principal = charlie in
    {496}let me_988: principal = bob in
    {497}let v_989: key = catch-fail(dhexp(key_s(me_988),g)) in
    {498}let s_990: keypair = (if not-caught-fail(v_989) then keypairpack(v_989,key_s(me_988)) else fail-any) in
    {499}out(pub, getpublickey(s_990));
    (
        {500}let e_991: keypair = keypairpack(empty,empty) in
        {501}let rs_992: key = empty in
        {502}let re_993: key = empty in
        {503}let v_994: bitstring = catch-fail(hash(somename,empty)) in
        {504}let v_995: key = catch-fail(v_994) in
        {505}let v_996: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {506}let v_997: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_994) then (if not-caught-fail(v_995) then (if not-caught-fail(v_996) then symmetricstatepack(v_996,v_995,v_994) else fail-any) else fail-any) else fail-any))) in
        {507}let v_998: symmetricstate = catch-fail((if success?((if not-caught-fail(v_994) then (if not-caught-fail(v_995) then (if not-caught-fail(v_996) then symmetricstatepack(v_996,v_995,v_994) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then symmetricstatepack(1-proj-3-tuple(v_997),2-proj-3-tuple(v_997),hash(3-proj-3-tuple(v_997),empty)) else fail-any) else fail-any)) in
        {508}let v_999: bitstring = catch-fail(symmetricstateunpack(v_998)) in
        {509}let v_1000: symmetricstate = catch-fail((if success?(getpublickey(s_990)) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then symmetricstatepack(1-proj-3-tuple(v_999),2-proj-3-tuple(v_999),hash(3-proj-3-tuple(v_999),getpublickey(s_990))) else fail-any) else fail-any)) in
        {510}let hs_1001: handshakestate = (if not-caught-fail(v_998) then (if not-caught-fail(v_1000) then handshakestatepack(v_1000,s_990,e_991,rs_992,re_993,empty,false) else fail-any) else fail-any) in
        {511}insert statestore(me_988,them_987,statepack_a(hs_1001))
    ) | (
        {540}get statestore(=me_988,=them_987,statepack_a(hs_1002: handshakestate)) in
        {512}in(pub, message_a_1003: bitstring);
        {513}let v_1004: bitstring = catch-fail(handshakestateunpack(hs_1002)) in
        {514}let v_1005: bitstring = catch-fail(deconcat3(message_a_1003)) in
        {515}let v_1006: bool = catch-fail(true) in
        {516}let v_1007: key = catch-fail(1-proj-3-tuple(v_1005)) in
        {517}let v_1008: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1004))) in
        {518}let v_1009: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-3-tuple(v_1008))))) then symmetricstatepack(1-proj-3-tuple(v_1008),2-proj-3-tuple(v_1008),hash(3-proj-3-tuple(v_1008),v_1007)) else fail-any) else fail-any)) in
        {519}let v_1010: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_1004))) in
        {520}let v_1011: bitstring = catch-fail(symmetricstateunpack(v_1009)) in
        {521}let v_1012: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1011),(if success?(2-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then dhexp(2-proj-2-tuple(v_1010),v_1007) else fail-any) else fail-any))) in
        {522}let v_1013: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1011),(if success?(2-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then dhexp(2-proj-2-tuple(v_1010),v_1007) else fail-any) else fail-any))) in
        {523}let v_1014: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1011),(if success?(2-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then dhexp(2-proj-2-tuple(v_1010),v_1007) else fail-any) else fail-any))) in
        {524}let v_1015: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then dhexp(2-proj-2-tuple(v_1010),v_1007) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1011))) then (if not-caught-fail(v_1012) then (if not-caught-fail(v_1013) then (if not-caught-fail(v_1014) then (v_1012,v_1013,v_1014) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {525}let v_1016: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_1004)) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then dhexp(2-proj-2-tuple(v_1010),v_1007) else fail-any) else fail-any)) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-3-tuple(v_1011))))) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-3-tuple(v_1015))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1015)) then cipherstatepack(2-proj-3-tuple(v_1015),minnonce) else fail-any),1-proj-3-tuple(v_1015),3-proj-3-tuple(v_1011)) else fail-any) else fail-any) else fail-any)) in
        {526}let v_1017: bitstring = catch-fail(symmetricstateunpack(v_1016)) in
        {527}let v_1018: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1017))) in
        {528}let v_1019: aead = catch-fail(decrypt(1-proj-2-tuple(v_1018),2-proj-2-tuple(v_1018),3-proj-3-tuple(v_1017),3-proj-3-tuple(v_1005))) in
        {529}let v_1020: bitstring = catch-fail(aeadunpack(v_1019)) in
        {530}let v_1021: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1017))) in
        {531}let v_1022: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1018))) && success?(1-proj-3-tuple(v_1017))) then (if (not-caught-fail(v_1021) && success?(is-true(success?(1-proj-2-tuple(v_1021))))) then cipherstatepack(1-proj-2-tuple(v_1021),increment_nonce(2-proj-2-tuple(v_1018))) else fail-any) else fail-any)) in
        {532}let v_1023: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1005)) && (success?(3-proj-3-tuple(v_1017)) && success?(1-proj-3-tuple(v_1017)))) then (if (not-caught-fail(v_1018) && success?(is-true(success?(1-proj-2-tuple(v_1018))))) then (if not-caught-fail(v_1019) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then (if not-caught-fail(v_1022) then (v_1022,3-proj-3-tuple(v_1020),1-proj-3-tuple(v_1020)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {533}let v_1024: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1023),2-proj-3-tuple(v_1017),3-proj-3-tuple(v_1017)))) in
        {534}let v_1025: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1005)) && success?(symmetricstatepack(1-proj-3-tuple(v_1023),2-proj-3-tuple(v_1017),3-proj-3-tuple(v_1017)))) then (if (not-caught-fail(v_1024) && success?(is-true(success?(1-proj-3-tuple(v_1024))))) then symmetricstatepack(1-proj-3-tuple(v_1024),2-proj-3-tuple(v_1024),hash(3-proj-3-tuple(v_1024),3-proj-3-tuple(v_1005))) else fail-any) else fail-any)) in
        {535}let v_1026: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1005)) then (if (not-caught-fail(v_1017) && success?(is-true(success?(1-proj-3-tuple(v_1017))))) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-3-tuple(v_1023))))) then (if not-caught-fail(v_1025) then (v_1025,2-proj-3-tuple(v_1023),3-proj-3-tuple(v_1023)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {536}let v_1027: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1026),2-proj-7-tuple(v_1004),3-proj-7-tuple(v_1004),4-proj-7-tuple(v_1004),v_1007,6-proj-7-tuple(v_1004),7-proj-7-tuple(v_1004))) in
        {537}let (hs_1028: handshakestate,re_1029: key,plaintext_a_1030: bitstring,valid_1031: bool) = (if (not-caught-fail(v_1004) && success?(is-true(success?(1-proj-7-tuple(v_1004))))) then (if (not-caught-fail(v_1005) && success?(is-true(success?(1-proj-3-tuple(v_1005))))) then (if not-caught-fail(v_1006) then (if not-caught-fail(v_1007) then (if not-caught-fail(v_1009) then (if not-caught-fail(v_1016) then (if (not-caught-fail(v_1026) && success?(is-true(success?(1-proj-3-tuple(v_1026))))) then (if (v_1006 && 3-proj-3-tuple(v_1026)) then (if not-caught-fail(v_1027) then (v_1027,getpublickey(3-proj-7-tuple(v_1004)),2-proj-3-tuple(v_1026),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {538}event RecvMsg(me_988,them_987,stage_a,plaintext_a_1030,valid_1031);
        {539}insert statestore(me_988,them_987,statepack_b(hs_1028))
    ) | (
        {571}get statestore(=me_988,=them_987,statepack_b(hs_1032: handshakestate)) in
        {541}let v_1033: bitstring = catch-fail(handshakestateunpack(hs_1032)) in
        {542}let v_1034: bitstring = catch-fail((empty,empty,empty)) in
        {543}new key_e_1035[me_988,them_987]: key;
        {544}let v_1036: key = catch-fail(dhexp(key_e_1035,g)) in
        {545}let v_1037: keypair = catch-fail((if not-caught-fail(v_1036) then keypairpack(v_1036,key_e_1035) else fail-any)) in
        {546}let v_1038: bitstring = catch-fail(getpublickey(v_1037)) in
        {547}let v_1039: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1033))) in
        {548}let v_1040: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then symmetricstatepack(1-proj-3-tuple(v_1039),2-proj-3-tuple(v_1039),hash(3-proj-3-tuple(v_1039),v_1038)) else fail-any) else fail-any)) in
        {549}let v_1041: bitstring = catch-fail(keypairunpack(v_1037)) in
        {550}let v_1042: bitstring = catch-fail(symmetricstateunpack(v_1040)) in
        {551}let v_1043: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1042),(if success?(5-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then dhexp(2-proj-2-tuple(v_1041),5-proj-7-tuple(v_1033)) else fail-any) else fail-any))) in
        {552}let v_1044: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1042),(if success?(5-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then dhexp(2-proj-2-tuple(v_1041),5-proj-7-tuple(v_1033)) else fail-any) else fail-any))) in
        {553}let v_1045: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1042),(if success?(5-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then dhexp(2-proj-2-tuple(v_1041),5-proj-7-tuple(v_1033)) else fail-any) else fail-any))) in
        {554}let v_1046: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then dhexp(2-proj-2-tuple(v_1041),5-proj-7-tuple(v_1033)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1042))) then (if not-caught-fail(v_1043) then (if not-caught-fail(v_1044) then (if not-caught-fail(v_1045) then (v_1043,v_1044,v_1045) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {555}let v_1047: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1033)) then (if (not-caught-fail(v_1041) && success?(is-true(success?(1-proj-2-tuple(v_1041))))) then dhexp(2-proj-2-tuple(v_1041),5-proj-7-tuple(v_1033)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1042) && success?(is-true(success?(1-proj-3-tuple(v_1042))))) then (if (not-caught-fail(v_1046) && success?(is-true(success?(1-proj-3-tuple(v_1046))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1046)) then cipherstatepack(2-proj-3-tuple(v_1046),minnonce) else fail-any),1-proj-3-tuple(v_1046),3-proj-3-tuple(v_1042)) else fail-any) else fail-any) else fail-any)) in
        {556}let v_1048: bitstring = catch-fail(symmetricstateunpack(v_1047)) in
        {557}let v_1049: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1048))) in
        {558}let v_1050: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1049),2-proj-2-tuple(v_1049),3-proj-3-tuple(v_1048),msg_b(me_988,them_987))) in
        {559}let v_1051: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1048))) in
        {560}let v_1052: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1049))) && success?(1-proj-3-tuple(v_1048))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-2-tuple(v_1051))))) then cipherstatepack(1-proj-2-tuple(v_1051),increment_nonce(2-proj-2-tuple(v_1049))) else fail-any) else fail-any)) in
        {561}let v_1053: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1048)) && success?(1-proj-3-tuple(v_1048))) then (if (not-caught-fail(v_1049) && success?(is-true(success?(1-proj-2-tuple(v_1049))))) then (if not-caught-fail(v_1050) then (if not-caught-fail(v_1052) then (v_1052,v_1050) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {562}let v_1054: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1053),2-proj-3-tuple(v_1048),3-proj-3-tuple(v_1048)))) in
        {563}let v_1055: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1053)) && success?(symmetricstatepack(1-proj-2-tuple(v_1053),2-proj-3-tuple(v_1048),3-proj-3-tuple(v_1048)))) then (if (not-caught-fail(v_1054) && success?(is-true(success?(1-proj-3-tuple(v_1054))))) then symmetricstatepack(1-proj-3-tuple(v_1054),2-proj-3-tuple(v_1054),hash(3-proj-3-tuple(v_1054),2-proj-2-tuple(v_1053))) else fail-any) else fail-any)) in
        {564}let v_1056: bitstring = catch-fail((if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-3-tuple(v_1048))))) then (if (not-caught-fail(v_1053) && success?(is-true(success?(1-proj-2-tuple(v_1053))))) then (if not-caught-fail(v_1055) then (v_1055,2-proj-2-tuple(v_1053)) else fail-any) else fail-any) else fail-any)) in
        {565}let v_1057: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1056),2-proj-7-tuple(v_1033),v_1037,4-proj-7-tuple(v_1033),5-proj-7-tuple(v_1033),6-proj-7-tuple(v_1033),7-proj-7-tuple(v_1033))) in
        {566}let v_1058: bitstring = catch-fail(concat3(v_1038,2-proj-3-tuple(v_1034),2-proj-2-tuple(v_1056))) in
        {567}let (hs_1059: handshakestate,re_1060: key,message_b_1061: bitstring) = (if (not-caught-fail(v_1033) && success?(is-true(success?(1-proj-7-tuple(v_1033))))) then (if (not-caught-fail(v_1034) && success?(is-true(success?(1-proj-3-tuple(v_1034))))) then (if not-caught-fail(v_1037) then (if not-caught-fail(v_1038) then (if not-caught-fail(v_1040) then (if not-caught-fail(v_1047) then (if (not-caught-fail(v_1056) && success?(is-true(success?(1-proj-2-tuple(v_1056))))) then (if not-caught-fail(v_1057) then (if not-caught-fail(v_1058) then (v_1057,5-proj-7-tuple(v_1033),v_1058) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {568}event SendMsg(me_988,them_987,stage_b,msg_b(me_988,them_987),true);
        {569}insert statestore(me_988,them_987,statepack_c(hs_1059));
        {570}out(pub, message_b_1061)
    ) | (
        {609}get statestore(=me_988,=them_987,statepack_c(hs_1062: handshakestate)) in
        {572}in(pub, message_c_1063: bitstring);
        {573}let v_1064: bitstring = catch-fail(handshakestateunpack(hs_1062)) in
        {574}let v_1065: bitstring = catch-fail(deconcat3(message_c_1063)) in
        {575}let v_1066: bool = catch-fail(true) in
        {576}let v_1067: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1064))) in
        {577}let v_1068: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1067))) in
        {578}let v_1069: aead = catch-fail(decrypt(1-proj-2-tuple(v_1068),2-proj-2-tuple(v_1068),3-proj-3-tuple(v_1067),2-proj-3-tuple(v_1065))) in
        {579}let v_1070: bitstring = catch-fail(aeadunpack(v_1069)) in
        {580}let v_1071: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1067))) in
        {581}let v_1072: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1068))) && success?(1-proj-3-tuple(v_1067))) then (if (not-caught-fail(v_1071) && success?(is-true(success?(1-proj-2-tuple(v_1071))))) then cipherstatepack(1-proj-2-tuple(v_1071),increment_nonce(2-proj-2-tuple(v_1068))) else fail-any) else fail-any)) in
        {582}let v_1073: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1065)) && (success?(3-proj-3-tuple(v_1067)) && success?(1-proj-3-tuple(v_1067)))) then (if (not-caught-fail(v_1068) && success?(is-true(success?(1-proj-2-tuple(v_1068))))) then (if not-caught-fail(v_1069) then (if (not-caught-fail(v_1070) && success?(is-true(success?(1-proj-3-tuple(v_1070))))) then (if not-caught-fail(v_1072) then (v_1072,3-proj-3-tuple(v_1070),1-proj-3-tuple(v_1070)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {583}let v_1074: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1073),2-proj-3-tuple(v_1067),3-proj-3-tuple(v_1067)))) in
        {584}let v_1075: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1065)) && success?(symmetricstatepack(1-proj-3-tuple(v_1073),2-proj-3-tuple(v_1067),3-proj-3-tuple(v_1067)))) then (if (not-caught-fail(v_1074) && success?(is-true(success?(1-proj-3-tuple(v_1074))))) then symmetricstatepack(1-proj-3-tuple(v_1074),2-proj-3-tuple(v_1074),hash(3-proj-3-tuple(v_1074),2-proj-3-tuple(v_1065))) else fail-any) else fail-any)) in
        {585}let v_1076: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1065)) && success?(1-proj-7-tuple(v_1064))) then (if (not-caught-fail(v_1067) && success?(is-true(success?(1-proj-3-tuple(v_1067))))) then (if (not-caught-fail(v_1073) && success?(is-true(success?(1-proj-3-tuple(v_1073))))) then (if not-caught-fail(v_1075) then (v_1075,2-proj-3-tuple(v_1073),3-proj-3-tuple(v_1073)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {586}let v_1077: key = catch-fail(2-proj-3-tuple(v_1076)) in
        {587}let v_1078: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_1064))) in
        {588}let v_1079: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1076))) in
        {589}let v_1080: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1079),(if success?(3-proj-7-tuple(v_1064)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then dhexp(2-proj-2-tuple(v_1078),v_1077) else fail-any) else fail-any))) in
        {590}let v_1081: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1079),(if success?(3-proj-7-tuple(v_1064)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then dhexp(2-proj-2-tuple(v_1078),v_1077) else fail-any) else fail-any))) in
        {591}let v_1082: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1079),(if success?(3-proj-7-tuple(v_1064)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then dhexp(2-proj-2-tuple(v_1078),v_1077) else fail-any) else fail-any))) in
        {592}let v_1083: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_1064)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then dhexp(2-proj-2-tuple(v_1078),v_1077) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1079))) then (if not-caught-fail(v_1080) then (if not-caught-fail(v_1081) then (if not-caught-fail(v_1082) then (v_1080,v_1081,v_1082) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {593}let v_1084: symmetricstate = catch-fail((if (success?((if success?(3-proj-7-tuple(v_1064)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-2-tuple(v_1078))))) then dhexp(2-proj-2-tuple(v_1078),v_1077) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_1076))) then (if (not-caught-fail(v_1079) && success?(is-true(success?(1-proj-3-tuple(v_1079))))) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1083)) then cipherstatepack(2-proj-3-tuple(v_1083),minnonce) else fail-any),1-proj-3-tuple(v_1083),3-proj-3-tuple(v_1079)) else fail-any) else fail-any) else fail-any)) in
        {594}let v_1085: bitstring = catch-fail(symmetricstateunpack(v_1084)) in
        {595}let v_1086: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1085))) in
        {596}let v_1087: aead = catch-fail(decrypt(1-proj-2-tuple(v_1086),2-proj-2-tuple(v_1086),3-proj-3-tuple(v_1085),3-proj-3-tuple(v_1065))) in
        {597}let v_1088: bitstring = catch-fail(aeadunpack(v_1087)) in
        {598}let v_1089: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1085))) in
        {599}let v_1090: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1086))) && success?(1-proj-3-tuple(v_1085))) then (if (not-caught-fail(v_1089) && success?(is-true(success?(1-proj-2-tuple(v_1089))))) then cipherstatepack(1-proj-2-tuple(v_1089),increment_nonce(2-proj-2-tuple(v_1086))) else fail-any) else fail-any)) in
        {600}let v_1091: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1065)) && (success?(3-proj-3-tuple(v_1085)) && success?(1-proj-3-tuple(v_1085)))) then (if (not-caught-fail(v_1086) && success?(is-true(success?(1-proj-2-tuple(v_1086))))) then (if not-caught-fail(v_1087) then (if (not-caught-fail(v_1088) && success?(is-true(success?(1-proj-3-tuple(v_1088))))) then (if not-caught-fail(v_1090) then (v_1090,3-proj-3-tuple(v_1088),1-proj-3-tuple(v_1088)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {601}let v_1092: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1091),2-proj-3-tuple(v_1085),3-proj-3-tuple(v_1085)))) in
        {602}let v_1093: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1065)) && success?(symmetricstatepack(1-proj-3-tuple(v_1091),2-proj-3-tuple(v_1085),3-proj-3-tuple(v_1085)))) then (if (not-caught-fail(v_1092) && success?(is-true(success?(1-proj-3-tuple(v_1092))))) then symmetricstatepack(1-proj-3-tuple(v_1092),2-proj-3-tuple(v_1092),hash(3-proj-3-tuple(v_1092),3-proj-3-tuple(v_1065))) else fail-any) else fail-any)) in
        {603}let v_1094: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1065)) then (if (not-caught-fail(v_1085) && success?(is-true(success?(1-proj-3-tuple(v_1085))))) then (if (not-caught-fail(v_1091) && success?(is-true(success?(1-proj-3-tuple(v_1091))))) then (if not-caught-fail(v_1093) then (v_1093,2-proj-3-tuple(v_1091),3-proj-3-tuple(v_1091)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {604}let v_1095: key = catch-fail(dhexp(key_s(them_987),g)) in
        {605}let v_1096: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1094),2-proj-7-tuple(v_1064),3-proj-7-tuple(v_1064),v_1077,5-proj-7-tuple(v_1064),6-proj-7-tuple(v_1064),7-proj-7-tuple(v_1064))) in
        {606}let (hs_1097: handshakestate,re_1098: key,plaintext_c_1099: bitstring,valid_1100: bool) = (if (not-caught-fail(v_1064) && success?(is-true(success?(1-proj-7-tuple(v_1064))))) then (if (not-caught-fail(v_1065) && success?(is-true(success?(1-proj-3-tuple(v_1065))))) then (if not-caught-fail(v_1066) then (if (not-caught-fail(v_1076) && success?(is-true(success?(1-proj-3-tuple(v_1076))))) then (if not-caught-fail(v_1077) then (if not-caught-fail(v_1084) then (if (not-caught-fail(v_1094) && success?(is-true(success?(1-proj-3-tuple(v_1094))))) then (if ((3-proj-3-tuple(v_1076) && 3-proj-3-tuple(v_1094)) && (v_1077 = getpublickey((if not-caught-fail(v_1095) then keypairpack(v_1095,key_s(them_987)) else fail-any)))) then (if not-caught-fail(v_1096) then (v_1096,getpublickey(3-proj-7-tuple(v_1064)),2-proj-3-tuple(v_1094),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {607}event RecvMsg(me_988,them_987,stage_c,plaintext_c_1099,valid_1100);
        {608}insert statestore(me_988,them_987,statepack_d(hs_1097))
    ) | (
        {627}get statestore(=me_988,=them_987,statepack_d(hs_1101: handshakestate)) in
        {610}let v_1102: bitstring = catch-fail(handshakestateunpack(hs_1101)) in
        {611}let v_1103: bitstring = catch-fail((empty,empty,empty)) in
        {612}let v_1104: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1102))) in
        {613}let v_1105: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1104))) in
        {614}let v_1106: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1105),2-proj-2-tuple(v_1105),3-proj-3-tuple(v_1104),msg_d(me_988,them_987))) in
        {615}let v_1107: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1104))) in
        {616}let v_1108: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1105))) && success?(1-proj-3-tuple(v_1104))) then (if (not-caught-fail(v_1107) && success?(is-true(success?(1-proj-2-tuple(v_1107))))) then cipherstatepack(1-proj-2-tuple(v_1107),increment_nonce(2-proj-2-tuple(v_1105))) else fail-any) else fail-any)) in
        {617}let v_1109: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1104)) && success?(1-proj-3-tuple(v_1104))) then (if (not-caught-fail(v_1105) && success?(is-true(success?(1-proj-2-tuple(v_1105))))) then (if not-caught-fail(v_1106) then (if not-caught-fail(v_1108) then (v_1108,v_1106) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {618}let v_1110: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1109),2-proj-3-tuple(v_1104),3-proj-3-tuple(v_1104)))) in
        {619}let v_1111: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1109)) && success?(symmetricstatepack(1-proj-2-tuple(v_1109),2-proj-3-tuple(v_1104),3-proj-3-tuple(v_1104)))) then (if (not-caught-fail(v_1110) && success?(is-true(success?(1-proj-3-tuple(v_1110))))) then symmetricstatepack(1-proj-3-tuple(v_1110),2-proj-3-tuple(v_1110),hash(3-proj-3-tuple(v_1110),2-proj-2-tuple(v_1109))) else fail-any) else fail-any)) in
        {620}let v_1112: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1102)) then (if (not-caught-fail(v_1104) && success?(is-true(success?(1-proj-3-tuple(v_1104))))) then (if (not-caught-fail(v_1109) && success?(is-true(success?(1-proj-2-tuple(v_1109))))) then (if not-caught-fail(v_1111) then (v_1111,2-proj-2-tuple(v_1109)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {621}let v_1113: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1112),2-proj-7-tuple(v_1102),3-proj-7-tuple(v_1102),4-proj-7-tuple(v_1102),5-proj-7-tuple(v_1102),6-proj-7-tuple(v_1102),7-proj-7-tuple(v_1102))) in
        {622}let v_1114: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1103),2-proj-3-tuple(v_1103),2-proj-2-tuple(v_1112))) in
        {623}let (hs_1115: handshakestate,re_1116: key,message_d_1117: bitstring) = (if (not-caught-fail(v_1102) && success?(is-true(success?(1-proj-7-tuple(v_1102))))) then (if (not-caught-fail(v_1103) && success?(is-true(success?(1-proj-3-tuple(v_1103))))) then (if (not-caught-fail(v_1112) && success?(is-true(success?(1-proj-2-tuple(v_1112))))) then (if not-caught-fail(v_1113) then (if not-caught-fail(v_1114) then (v_1113,5-proj-7-tuple(v_1102),v_1114) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {624}event SendMsg(me_988,them_987,stage_d,msg_d(me_988,them_987),true);
        {625}insert statestore(me_988,them_987,statepack_e(hs_1115));
        {626}out(pub, message_d_1117)
    ) | (
        {655}get statestore(=me_988,=them_987,statepack_e(hs_1118: handshakestate)) in
        {628}in(pub, message_e_1119: bitstring);
        {629}let v_1120: bitstring = catch-fail(handshakestateunpack(hs_1118)) in
        {630}let v_1121: bitstring = catch-fail(deconcat3(message_e_1119)) in
        {631}let v_1122: bool = catch-fail(true) in
        {632}let v_1123: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1120))) in
        {633}let v_1124: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1123))) in
        {634}let v_1125: aead = catch-fail(decrypt(1-proj-2-tuple(v_1124),2-proj-2-tuple(v_1124),3-proj-3-tuple(v_1123),3-proj-3-tuple(v_1121))) in
        {635}let v_1126: bitstring = catch-fail(aeadunpack(v_1125)) in
        {636}let v_1127: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1123))) in
        {637}let v_1128: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1124))) && success?(1-proj-3-tuple(v_1123))) then (if (not-caught-fail(v_1127) && success?(is-true(success?(1-proj-2-tuple(v_1127))))) then cipherstatepack(1-proj-2-tuple(v_1127),increment_nonce(2-proj-2-tuple(v_1124))) else fail-any) else fail-any)) in
        {638}let v_1129: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1121)) && (success?(3-proj-3-tuple(v_1123)) && success?(1-proj-3-tuple(v_1123)))) then (if (not-caught-fail(v_1124) && success?(is-true(success?(1-proj-2-tuple(v_1124))))) then (if not-caught-fail(v_1125) then (if (not-caught-fail(v_1126) && success?(is-true(success?(1-proj-3-tuple(v_1126))))) then (if not-caught-fail(v_1128) then (v_1128,3-proj-3-tuple(v_1126),1-proj-3-tuple(v_1126)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {639}let v_1130: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1129),2-proj-3-tuple(v_1123),3-proj-3-tuple(v_1123)))) in
        {640}let v_1131: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1121)) && success?(symmetricstatepack(1-proj-3-tuple(v_1129),2-proj-3-tuple(v_1123),3-proj-3-tuple(v_1123)))) then (if (not-caught-fail(v_1130) && success?(is-true(success?(1-proj-3-tuple(v_1130))))) then symmetricstatepack(1-proj-3-tuple(v_1130),2-proj-3-tuple(v_1130),hash(3-proj-3-tuple(v_1130),3-proj-3-tuple(v_1121))) else fail-any) else fail-any)) in
        {641}let v_1132: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1121)) && success?(1-proj-7-tuple(v_1120))) then (if (not-caught-fail(v_1123) && success?(is-true(success?(1-proj-3-tuple(v_1123))))) then (if (not-caught-fail(v_1129) && success?(is-true(success?(1-proj-3-tuple(v_1129))))) then (if not-caught-fail(v_1131) then (v_1131,2-proj-3-tuple(v_1129),3-proj-3-tuple(v_1129)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {642}let v_1133: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1132),2-proj-7-tuple(v_1120),3-proj-7-tuple(v_1120),4-proj-7-tuple(v_1120),5-proj-7-tuple(v_1120),6-proj-7-tuple(v_1120),7-proj-7-tuple(v_1120))) in
        {643}let v_1134: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1132))) in
        {644}let v_1135: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1134),zero)) in
        {645}let v_1136: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1134),zero)) in
        {646}let v_1137: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1134),zero)) in
        {647}let v_1138: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1134)) then (if not-caught-fail(v_1135) then (if not-caught-fail(v_1136) then (if not-caught-fail(v_1137) then (v_1135,v_1136,v_1137) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {648}let v_1139: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1138)) then cipherstatepack(1-proj-3-tuple(v_1138),minnonce) else fail-any)) in
        {649}let v_1140: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1138)) then cipherstatepack(2-proj-3-tuple(v_1138),minnonce) else fail-any)) in
        {650}let v_1141: bitstring = catch-fail((if success?(1-proj-3-tuple(v_1132)) then (if (not-caught-fail(v_1134) && success?(is-true(success?(1-proj-3-tuple(v_1134))))) then (if (not-caught-fail(v_1138) && success?(is-true(success?(1-proj-3-tuple(v_1138))))) then (if not-caught-fail(v_1139) then (if not-caught-fail(v_1140) then (1-proj-3-tuple(v_1132),v_1139,v_1140) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {651}let (hs_1142: handshakestate,re_1143: key,plaintext_e_1144: bitstring,valid_1145: bool,cs1_1146: cipherstate,cs2_1147: cipherstate) = (if (not-caught-fail(v_1120) && success?(is-true(success?(1-proj-7-tuple(v_1120))))) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-3-tuple(v_1121))))) then (if not-caught-fail(v_1122) then (if (not-caught-fail(v_1132) && success?(is-true(success?(1-proj-3-tuple(v_1132))))) then (if (v_1122 && 3-proj-3-tuple(v_1132)) then (if not-caught-fail(v_1133) then (if (not-caught-fail(v_1141) && success?(is-true(success?(1-proj-3-tuple(v_1141))))) then (v_1133,getpublickey(3-proj-7-tuple(v_1120)),2-proj-3-tuple(v_1132),true,2-proj-3-tuple(v_1141),3-proj-3-tuple(v_1141)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {652}event RecvMsg(me_988,them_987,stage_e,plaintext_e_1144,valid_1145);
        {653}insert statestore(me_988,them_987,statepack_f(hs_1142));
        {654}event RecvEnd(valid_1145)
    ) | (
        {656}event LeakS(phase0,me_988);
        {657}out(pub, key_s(me_988))
    ) | (
        {658}phase 1;
        {659}event LeakS(phase1,me_988);
        {660}out(pub, key_s(me_988))
    )
)

-- Query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1228,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,c_1228,stage_a,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1228,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,c_1228,stage_b,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1228,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,c_1228,stage_c,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1228,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,c_1228,stage_d,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,c_1228,stage_e,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,c_1228,stage_e,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_e,m,true)) ==> event(SendMsg(alice,bob,stage_e,m,true)) || event(LeakS(phase0,alice)); not attacker_p1(msg_e(alice,bob)); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_e(alice,bob)) ==> event(LeakS(phase0,bob))
Completing...
200 rules inserted. The rule base contains 200 rules. 165 rules in the queue.
400 rules inserted. The rule base contains 396 rules. 106 rules in the queue.
600 rules inserted. The rule base contains 588 rules. 155 rules in the queue.
800 rules inserted. The rule base contains 784 rules. 431 rules in the queue.
1000 rules inserted. The rule base contains 973 rules. 360 rules in the queue.
1200 rules inserted. The rule base contains 1128 rules. 338 rules in the queue.
1400 rules inserted. The rule base contains 1328 rules. 496 rules in the queue.
1600 rules inserted. The rule base contains 1525 rules. 623 rules in the queue.
1800 rules inserted. The rule base contains 1724 rules. 788 rules in the queue.
2000 rules inserted. The rule base contains 1924 rules. 906 rules in the queue.
2200 rules inserted. The rule base contains 2045 rules. 850 rules in the queue.
2400 rules inserted. The rule base contains 2164 rules. 790 rules in the queue.
2600 rules inserted. The rule base contains 2294 rules. 751 rules in the queue.
2800 rules inserted. The rule base contains 2424 rules. 709 rules in the queue.
3000 rules inserted. The rule base contains 2593 rules. 762 rules in the queue.
3200 rules inserted. The rule base contains 2775 rules. 795 rules in the queue.
3400 rules inserted. The rule base contains 2969 rules. 920 rules in the queue.
3600 rules inserted. The rule base contains 3154 rules. 977 rules in the queue.
3800 rules inserted. The rule base contains 3316 rules. 1004 rules in the queue.
4000 rules inserted. The rule base contains 3486 rules. 1016 rules in the queue.
4200 rules inserted. The rule base contains 3676 rules. 1057 rules in the queue.
4400 rules inserted. The rule base contains 3863 rules. 1090 rules in the queue.
4600 rules inserted. The rule base contains 4006 rules. 1128 rules in the queue.
4800 rules inserted. The rule base contains 4089 rules. 1146 rules in the queue.
5000 rules inserted. The rule base contains 4145 rules. 1158 rules in the queue.
5200 rules inserted. The rule base contains 4248 rules. 1179 rules in the queue.
5400 rules inserted. The rule base contains 4323 rules. 1193 rules in the queue.
5600 rules inserted. The rule base contains 4430 rules. 1289 rules in the queue.
5800 rules inserted. The rule base contains 4595 rules. 1293 rules in the queue.
6000 rules inserted. The rule base contains 4730 rules. 1279 rules in the queue.
6200 rules inserted. The rule base contains 4879 rules. 1268 rules in the queue.
6400 rules inserted. The rule base contains 5043 rules. 1265 rules in the queue.
6600 rules inserted. The rule base contains 5183 rules. 1250 rules in the queue.
6800 rules inserted. The rule base contains 5212 rules. 1245 rules in the queue.
7000 rules inserted. The rule base contains 5372 rules. 1268 rules in the queue.
7200 rules inserted. The rule base contains 5494 rules. 1314 rules in the queue.
7400 rules inserted. The rule base contains 5641 rules. 1304 rules in the queue.
7600 rules inserted. The rule base contains 5797 rules. 1294 rules in the queue.
7800 rules inserted. The rule base contains 5937 rules. 1275 rules in the queue.
8000 rules inserted. The rule base contains 6000 rules. 1283 rules in the queue.
8200 rules inserted. The rule base contains 6116 rules. 1322 rules in the queue.
8400 rules inserted. The rule base contains 6287 rules. 1809 rules in the queue.
8600 rules inserted. The rule base contains 6432 rules. 1811 rules in the queue.
8800 rules inserted. The rule base contains 6557 rules. 1818 rules in the queue.
9000 rules inserted. The rule base contains 6690 rules. 1828 rules in the queue.
9200 rules inserted. The rule base contains 6717 rules. 1829 rules in the queue.
9400 rules inserted. The rule base contains 6838 rules. 1819 rules in the queue.
9600 rules inserted. The rule base contains 7014 rules. 1979 rules in the queue.
9800 rules inserted. The rule base contains 7176 rules. 2323 rules in the queue.
10000 rules inserted. The rule base contains 7348 rules. 2506 rules in the queue.
10200 rules inserted. The rule base contains 7511 rules. 2802 rules in the queue.
10400 rules inserted. The rule base contains 7625 rules. 2779 rules in the queue.
10600 rules inserted. The rule base contains 7738 rules. 2752 rules in the queue.
10800 rules inserted. The rule base contains 7844 rules. 2713 rules in the queue.
11000 rules inserted. The rule base contains 7925 rules. 2707 rules in the queue.
11200 rules inserted. The rule base contains 8092 rules. 2730 rules in the queue.
11400 rules inserted. The rule base contains 8286 rules. 2665 rules in the queue.
11600 rules inserted. The rule base contains 8479 rules. 2589 rules in the queue.
11800 rules inserted. The rule base contains 8671 rules. 2509 rules in the queue.
12000 rules inserted. The rule base contains 8850 rules. 2457 rules in the queue.
12200 rules inserted. The rule base contains 9001 rules. 2473 rules in the queue.
12400 rules inserted. The rule base contains 9195 rules. 2411 rules in the queue.
12600 rules inserted. The rule base contains 9386 rules. 2317 rules in the queue.
12800 rules inserted. The rule base contains 9578 rules. 2234 rules in the queue.
13000 rules inserted. The rule base contains 9750 rules. 2225 rules in the queue.
13200 rules inserted. The rule base contains 9893 rules. 2232 rules in the queue.
13400 rules inserted. The rule base contains 10044 rules. 2241 rules in the queue.
13600 rules inserted. The rule base contains 10185 rules. 2207 rules in the queue.
13800 rules inserted. The rule base contains 10348 rules. 2193 rules in the queue.
14000 rules inserted. The rule base contains 10528 rules. 2200 rules in the queue.
14200 rules inserted. The rule base contains 10728 rules. 2216 rules in the queue.
14400 rules inserted. The rule base contains 10918 rules. 2240 rules in the queue.
14600 rules inserted. The rule base contains 11063 rules. 2213 rules in the queue.
14800 rules inserted. The rule base contains 11263 rules. 2227 rules in the queue.
15000 rules inserted. The rule base contains 11463 rules. 2244 rules in the queue.
15200 rules inserted. The rule base contains 11645 rules. 2241 rules in the queue.
15400 rules inserted. The rule base contains 11803 rules. 2236 rules in the queue.
15600 rules inserted. The rule base contains 11960 rules. 2243 rules in the queue.
15800 rules inserted. The rule base contains 12055 rules. 2250 rules in the queue.
16000 rules inserted. The rule base contains 12094 rules. 2327 rules in the queue.
16200 rules inserted. The rule base contains 12240 rules. 2343 rules in the queue.
16400 rules inserted. The rule base contains 12429 rules. 2357 rules in the queue.
16600 rules inserted. The rule base contains 12560 rules. 2381 rules in the queue.
16800 rules inserted. The rule base contains 12617 rules. 2467 rules in the queue.
17000 rules inserted. The rule base contains 12769 rules. 2481 rules in the queue.
17200 rules inserted. The rule base contains 12943 rules. 2504 rules in the queue.
17400 rules inserted. The rule base contains 13070 rules. 2539 rules in the queue.
17600 rules inserted. The rule base contains 13171 rules. 2546 rules in the queue.
17800 rules inserted. The rule base contains 13262 rules. 2587 rules in the queue.
18000 rules inserted. The rule base contains 13389 rules. 2582 rules in the queue.
18200 rules inserted. The rule base contains 13503 rules. 2534 rules in the queue.
18400 rules inserted. The rule base contains 13576 rules. 2557 rules in the queue.
18600 rules inserted. The rule base contains 13687 rules. 2566 rules in the queue.
18800 rules inserted. The rule base contains 13775 rules. 2561 rules in the queue.
19000 rules inserted. The rule base contains 13890 rules. 2537 rules in the queue.
19200 rules inserted. The rule base contains 13957 rules. 2528 rules in the queue.
19400 rules inserted. The rule base contains 14096 rules. 2537 rules in the queue.
19600 rules inserted. The rule base contains 14148 rules. 2542 rules in the queue.
19800 rules inserted. The rule base contains 14266 rules. 2528 rules in the queue.
20000 rules inserted. The rule base contains 14406 rules. 2520 rules in the queue.
20200 rules inserted. The rule base contains 14549 rules. 2524 rules in the queue.
20400 rules inserted. The rule base contains 14713 rules. 2749 rules in the queue.
20600 rules inserted. The rule base contains 14812 rules. 2770 rules in the queue.
20800 rules inserted. The rule base contains 14918 rules. 2779 rules in the queue.
21000 rules inserted. The rule base contains 15118 rules. 2783 rules in the queue.
21200 rules inserted. The rule base contains 15311 rules. 2784 rules in the queue.
21400 rules inserted. The rule base contains 15480 rules. 2798 rules in the queue.
21600 rules inserted. The rule base contains 15540 rules. 2813 rules in the queue.
21800 rules inserted. The rule base contains 15740 rules. 2818 rules in the queue.
22000 rules inserted. The rule base contains 15940 rules. 2819 rules in the queue.
22200 rules inserted. The rule base contains 16102 rules. 2836 rules in the queue.
22400 rules inserted. The rule base contains 16234 rules. 2868 rules in the queue.
22600 rules inserted. The rule base contains 16352 rules. 2886 rules in the queue.
22800 rules inserted. The rule base contains 16516 rules. 3077 rules in the queue.
23000 rules inserted. The rule base contains 16671 rules. 3229 rules in the queue.
23200 rules inserted. The rule base contains 16811 rules. 3230 rules in the queue.
23400 rules inserted. The rule base contains 16997 rules. 3225 rules in the queue.
23600 rules inserted. The rule base contains 17197 rules. 3220 rules in the queue.
23800 rules inserted. The rule base contains 17397 rules. 3218 rules in the queue.
24000 rules inserted. The rule base contains 17578 rules. 3241 rules in the queue.
24200 rules inserted. The rule base contains 17705 rules. 3244 rules in the queue.
24400 rules inserted. The rule base contains 17897 rules. 3233 rules in the queue.
24600 rules inserted. The rule base contains 18097 rules. 3234 rules in the queue.
24800 rules inserted. The rule base contains 18284 rules. 3228 rules in the queue.
25000 rules inserted. The rule base contains 18410 rules. 3253 rules in the queue.
25200 rules inserted. The rule base contains 18535 rules. 3257 rules in the queue.
25400 rules inserted. The rule base contains 18639 rules. 3250 rules in the queue.
25600 rules inserted. The rule base contains 18791 rules. 3203 rules in the queue.
25800 rules inserted. The rule base contains 18966 rules. 3102 rules in the queue.
26000 rules inserted. The rule base contains 19137 rules. 3013 rules in the queue.
26200 rules inserted. The rule base contains 19295 rules. 2991 rules in the queue.
26400 rules inserted. The rule base contains 19466 rules. 2996 rules in the queue.
26600 rules inserted. The rule base contains 19548 rules. 3010 rules in the queue.
26800 rules inserted. The rule base contains 19748 rules. 3032 rules in the queue.
27000 rules inserted. The rule base contains 19948 rules. 3064 rules in the queue.
27200 rules inserted. The rule base contains 20120 rules. 3085 rules in the queue.
27400 rules inserted. The rule base contains 20202 rules. 3085 rules in the queue.
27600 rules inserted. The rule base contains 20346 rules. 3108 rules in the queue.
27800 rules inserted. The rule base contains 20546 rules. 3142 rules in the queue.
28000 rules inserted. The rule base contains 20726 rules. 3163 rules in the queue.
28200 rules inserted. The rule base contains 20840 rules. 3169 rules in the queue.
28400 rules inserted. The rule base contains 20989 rules. 3176 rules in the queue.
28600 rules inserted. The rule base contains 21105 rules. 3202 rules in the queue.
28800 rules inserted. The rule base contains 21282 rules. 3251 rules in the queue.
29000 rules inserted. The rule base contains 21482 rules. 3309 rules in the queue.
29200 rules inserted. The rule base contains 21571 rules. 3324 rules in the queue.
29400 rules inserted. The rule base contains 21699 rules. 3323 rules in the queue.
29600 rules inserted. The rule base contains 21810 rules. 3353 rules in the queue.
29800 rules inserted. The rule base contains 22010 rules. 3361 rules in the queue.
30000 rules inserted. The rule base contains 22210 rules. 3380 rules in the queue.
30200 rules inserted. The rule base contains 22373 rules. 3403 rules in the queue.
30400 rules inserted. The rule base contains 22499 rules. 3406 rules in the queue.
30600 rules inserted. The rule base contains 22598 rules. 3435 rules in the queue.
30800 rules inserted. The rule base contains 22798 rules. 3448 rules in the queue.
31000 rules inserted. The rule base contains 22998 rules. 3466 rules in the queue.
31200 rules inserted. The rule base contains 23163 rules. 3472 rules in the queue.
31400 rules inserted. The rule base contains 23250 rules. 3468 rules in the queue.
31600 rules inserted. The rule base contains 23290 rules. 3459 rules in the queue.
31800 rules inserted. The rule base contains 23322 rules. 3451 rules in the queue.
32000 rules inserted. The rule base contains 23476 rules. 3488 rules in the queue.
32200 rules inserted. The rule base contains 23660 rules. 3534 rules in the queue.
32400 rules inserted. The rule base contains 23795 rules. 3562 rules in the queue.
32600 rules inserted. The rule base contains 23921 rules. 3566 rules in the queue.
32800 rules inserted. The rule base contains 23869 rules. 3727 rules in the queue.
33000 rules inserted. The rule base contains 24059 rules. 3751 rules in the queue.
33200 rules inserted. The rule base contains 24231 rules. 3773 rules in the queue.
33400 rules inserted. The rule base contains 24376 rules. 3780 rules in the queue.
33600 rules inserted. The rule base contains 24530 rules. 3786 rules in the queue.
33800 rules inserted. The rule base contains 24617 rules. 3797 rules in the queue.
34000 rules inserted. The rule base contains 24614 rules. 3974 rules in the queue.
34200 rules inserted. The rule base contains 24786 rules. 4003 rules in the queue.
34400 rules inserted. The rule base contains 24966 rules. 4008 rules in the queue.
34600 rules inserted. The rule base contains 25104 rules. 4029 rules in the queue.
34800 rules inserted. The rule base contains 25213 rules. 4062 rules in the queue.
35000 rules inserted. The rule base contains 25296 rules. 4084 rules in the queue.
35200 rules inserted. The rule base contains 25368 rules. 4120 rules in the queue.
35400 rules inserted. The rule base contains 25458 rules. 4147 rules in the queue.
35600 rules inserted. The rule base contains 25541 rules. 4173 rules in the queue.
35800 rules inserted. The rule base contains 25608 rules. 4189 rules in the queue.
36000 rules inserted. The rule base contains 25712 rules. 4190 rules in the queue.
36200 rules inserted. The rule base contains 25841 rules. 4193 rules in the queue.
36400 rules inserted. The rule base contains 25917 rules. 4132 rules in the queue.
36600 rules inserted. The rule base contains 26027 rules. 4063 rules in the queue.
36800 rules inserted. The rule base contains 26191 rules. 4026 rules in the queue.
37000 rules inserted. The rule base contains 26322 rules. 4019 rules in the queue.
37200 rules inserted. The rule base contains 26454 rules. 4005 rules in the queue.
37400 rules inserted. The rule base contains 26586 rules. 3991 rules in the queue.
37600 rules inserted. The rule base contains 26636 rules. 3972 rules in the queue.
37800 rules inserted. The rule base contains 26707 rules. 3888 rules in the queue.
38000 rules inserted. The rule base contains 26855 rules. 3868 rules in the queue.
38200 rules inserted. The rule base contains 27019 rules. 3840 rules in the queue.
38400 rules inserted. The rule base contains 27148 rules. 3806 rules in the queue.
38600 rules inserted. The rule base contains 27246 rules. 3806 rules in the queue.
38800 rules inserted. The rule base contains 27343 rules. 3795 rules in the queue.
39000 rules inserted. The rule base contains 27418 rules. 3798 rules in the queue.
39200 rules inserted. The rule base contains 27486 rules. 3802 rules in the queue.
39400 rules inserted. The rule base contains 27613 rules. 3780 rules in the queue.
39600 rules inserted. The rule base contains 27733 rules. 3756 rules in the queue.
39800 rules inserted. The rule base contains 27842 rules. 3712 rules in the queue.
40000 rules inserted. The rule base contains 27978 rules. 3708 rules in the queue.
40200 rules inserted. The rule base contains 28062 rules. 3694 rules in the queue.
40400 rules inserted. The rule base contains 28094 rules. 3667 rules in the queue.
40600 rules inserted. The rule base contains 28268 rules. 3641 rules in the queue.
40800 rules inserted. The rule base contains 28384 rules. 3563 rules in the queue.
41000 rules inserted. The rule base contains 28517 rules. 3552 rules in the queue.
41200 rules inserted. The rule base contains 28618 rules. 3528 rules in the queue.
41400 rules inserted. The rule base contains 28601 rules. 3525 rules in the queue.
41600 rules inserted. The rule base contains 28783 rules. 3499 rules in the queue.
41800 rules inserted. The rule base contains 28953 rules. 3431 rules in the queue.
42000 rules inserted. The rule base contains 29027 rules. 3399 rules in the queue.
42200 rules inserted. The rule base contains 29184 rules. 3362 rules in the queue.
42400 rules inserted. The rule base contains 29339 rules. 3345 rules in the queue.
42600 rules inserted. The rule base contains 29473 rules. 3310 rules in the queue.
42800 rules inserted. The rule base contains 29597 rules. 3294 rules in the queue.
43000 rules inserted. The rule base contains 29716 rules. 3302 rules in the queue.
43200 rules inserted. The rule base contains 29844 rules. 3315 rules in the queue.
43400 rules inserted. The rule base contains 29971 rules. 3312 rules in the queue.
43600 rules inserted. The rule base contains 30081 rules. 3273 rules in the queue.
43800 rules inserted. The rule base contains 30218 rules. 3292 rules in the queue.
44000 rules inserted. The rule base contains 30157 rules. 3229 rules in the queue.
44200 rules inserted. The rule base contains 30355 rules. 3201 rules in the queue.
44400 rules inserted. The rule base contains 30489 rules. 3195 rules in the queue.
44600 rules inserted. The rule base contains 30582 rules. 3170 rules in the queue.
44800 rules inserted. The rule base contains 30478 rules. 3139 rules in the queue.
45000 rules inserted. The rule base contains 30676 rules. 3120 rules in the queue.
45200 rules inserted. The rule base contains 30873 rules. 3086 rules in the queue.
45400 rules inserted. The rule base contains 30965 rules. 3028 rules in the queue.
45600 rules inserted. The rule base contains 31121 rules. 2980 rules in the queue.
45800 rules inserted. The rule base contains 31215 rules. 2908 rules in the queue.
46000 rules inserted. The rule base contains 31361 rules. 2870 rules in the queue.
46200 rules inserted. The rule base contains 31553 rules. 2896 rules in the queue.
46400 rules inserted. The rule base contains 31745 rules. 2920 rules in the queue.
46600 rules inserted. The rule base contains 31873 rules. 2914 rules in the queue.
46800 rules inserted. The rule base contains 31963 rules. 2891 rules in the queue.
47000 rules inserted. The rule base contains 31596 rules. 2774 rules in the queue.
47200 rules inserted. The rule base contains 31750 rules. 2758 rules in the queue.
47400 rules inserted. The rule base contains 31788 rules. 2731 rules in the queue.
47600 rules inserted. The rule base contains 31875 rules. 2695 rules in the queue.
47800 rules inserted. The rule base contains 31496 rules. 2566 rules in the queue.
48000 rules inserted. The rule base contains 31619 rules. 2540 rules in the queue.
48200 rules inserted. The rule base contains 31679 rules. 2543 rules in the queue.
48400 rules inserted. The rule base contains 31787 rules. 2550 rules in the queue.
48600 rules inserted. The rule base contains 31874 rules. 2544 rules in the queue.
48800 rules inserted. The rule base contains 32059 rules. 2531 rules in the queue.
49000 rules inserted. The rule base contains 32234 rules. 2514 rules in the queue.
49200 rules inserted. The rule base contains 32379 rules. 2510 rules in the queue.
49400 rules inserted. The rule base contains 32477 rules. 2513 rules in the queue.
49600 rules inserted. The rule base contains 30985 rules. 2492 rules in the queue.
49800 rules inserted. The rule base contains 31185 rules. 2513 rules in the queue.
50000 rules inserted. The rule base contains 31283 rules. 2483 rules in the queue.
50200 rules inserted. The rule base contains 29752 rules. 2454 rules in the queue.
50400 rules inserted. The rule base contains 29946 rules. 2470 rules in the queue.
50600 rules inserted. The rule base contains 30034 rules. 2471 rules in the queue.
50800 rules inserted. The rule base contains 30160 rules. 2504 rules in the queue.
51000 rules inserted. The rule base contains 30229 rules. 2538 rules in the queue.
51200 rules inserted. The rule base contains 30412 rules. 2560 rules in the queue.
51400 rules inserted. The rule base contains 30592 rules. 2580 rules in the queue.
51600 rules inserted. The rule base contains 30726 rules. 2555 rules in the queue.
51800 rules inserted. The rule base contains 30827 rules. 2544 rules in the queue.
52000 rules inserted. The rule base contains 30903 rules. 2588 rules in the queue.
52200 rules inserted. The rule base contains 31054 rules. 2725 rules in the queue.
52400 rules inserted. The rule base contains 31132 rules. 2716 rules in the queue.
52600 rules inserted. The rule base contains 31182 rules. 2732 rules in the queue.
52800 rules inserted. The rule base contains 31328 rules. 2868 rules in the queue.
53000 rules inserted. The rule base contains 31420 rules. 2854 rules in the queue.
