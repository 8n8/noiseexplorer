File "N.noise.passive.pv", line 213, characters 7-8:
Warning: identifier ck rebound.
File "N.noise.passive.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "N.noise.passive.pv", line 223, characters 7-8:
Warning: identifier cs rebound.
File "N.noise.passive.pv", line 223, character 36:
Warning: identifier h rebound.
File "N.noise.passive.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "N.noise.passive.pv", line 233, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 238, characters 7-8:
Warning: identifier cs rebound.
File "N.noise.passive.pv", line 239, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 253, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 258, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 264, character 6:
Warning: identifier e rebound.
File "N.noise.passive.pv", line 265, characters 6-7:
Warning: identifier ne rebound.
File "N.noise.passive.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 269, characters 7-8:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 269, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "N.noise.passive.pv", line 270, characters 6-7:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 279, characters 6-7:
Warning: identifier re rebound.
File "N.noise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 285, characters 7-8:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 353, characters 8-9:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 264, character 6:
Warning: identifier e rebound.
File "N.noise.passive.pv", line 265, characters 6-7:
Warning: identifier ne rebound.
File "N.noise.passive.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 269, characters 7-8:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 269, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "N.noise.passive.pv", line 270, characters 6-7:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 213, characters 7-8:
Warning: identifier ck rebound.
File "N.noise.passive.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "N.noise.passive.pv", line 233, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 253, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 381, characters 8-9:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 279, characters 6-7:
Warning: identifier re rebound.
File "N.noise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 285, characters 7-8:
Warning: identifier hs rebound.
File "N.noise.passive.pv", line 213, characters 7-8:
Warning: identifier ck rebound.
File "N.noise.passive.pv", line 238, characters 7-8:
Warning: identifier cs rebound.
File "N.noise.passive.pv", line 239, characters 6-7:
Warning: identifier ss rebound.
File "N.noise.passive.pv", line 258, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_333: keypair = keypairpack(empty,empty) in
    (
        {5}let e_334: keypair = keypairpack(empty,empty) in
        {6}let v_335: key = catch-fail(dhexp(key_s(bob),g)) in
        {7}let rs_336: key = getpublickey((if not-caught-fail(v_335) then keypairpack(v_335,key_s(bob)) else fail-any)) in
        {8}let re_337: key = empty in
        {9}let v_338: bitstring = catch-fail(hash(somename,empty)) in
        {10}let v_339: key = catch-fail(v_338) in
        {11}let v_340: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {12}let v_341: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_338) then (if not-caught-fail(v_339) then (if not-caught-fail(v_340) then symmetricstatepack(v_340,v_339,v_338) else fail-any) else fail-any) else fail-any))) in
        {13}let v_342: symmetricstate = catch-fail((if success?((if not-caught-fail(v_338) then (if not-caught-fail(v_339) then (if not-caught-fail(v_340) then symmetricstatepack(v_340,v_339,v_338) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_341) && success?(is-true(success?(1-proj-3-tuple(v_341))))) then symmetricstatepack(1-proj-3-tuple(v_341),2-proj-3-tuple(v_341),hash(3-proj-3-tuple(v_341),empty)) else fail-any) else fail-any)) in
        {14}let v_343: bitstring = catch-fail(symmetricstateunpack(v_342)) in
        {15}let v_344: symmetricstate = catch-fail((if (not-caught-fail(v_343) && success?(is-true(success?(1-proj-3-tuple(v_343))))) then symmetricstatepack(1-proj-3-tuple(v_343),2-proj-3-tuple(v_343),hash(3-proj-3-tuple(v_343),rs_336)) else fail-any)) in
        {16}let hs: handshakestate = (if not-caught-fail(v_342) then (if not-caught-fail(v_344) then handshakestatepack(v_344,s_333,e_334,rs_336,re_337,empty,true) else fail-any) else fail-any) in
        {17}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {54}get statestore(=alice,=bob,=sid,statepack_a(hs_345: handshakestate)) in
        {18}let v_346: bitstring = catch-fail(handshakestateunpack(hs_345)) in
        {19}let v_347: bitstring = catch-fail((empty,empty,empty)) in
        {20}let v_348: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {21}let v_349: keypair = catch-fail((if not-caught-fail(v_348) then keypairpack(v_348,key_e(alice,bob,sid)) else fail-any)) in
        {22}let v_350: bitstring = catch-fail(getpublickey(v_349)) in
        {23}let v_351: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_346))) in
        {24}let v_352: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_346)) then (if (not-caught-fail(v_351) && success?(is-true(success?(1-proj-3-tuple(v_351))))) then symmetricstatepack(1-proj-3-tuple(v_351),2-proj-3-tuple(v_351),hash(3-proj-3-tuple(v_351),v_350)) else fail-any) else fail-any)) in
        {25}let v_353: bitstring = catch-fail(keypairunpack(v_349)) in
        {26}let v_354: bitstring = catch-fail(symmetricstateunpack(v_352)) in
        {27}let v_355: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_354),(if success?(4-proj-7-tuple(v_346)) then (if (not-caught-fail(v_353) && success?(is-true(success?(1-proj-2-tuple(v_353))))) then dhexp(2-proj-2-tuple(v_353),4-proj-7-tuple(v_346)) else fail-any) else fail-any))) in
        {28}let v_356: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_354),(if success?(4-proj-7-tuple(v_346)) then (if (not-caught-fail(v_353) && success?(is-true(success?(1-proj-2-tuple(v_353))))) then dhexp(2-proj-2-tuple(v_353),4-proj-7-tuple(v_346)) else fail-any) else fail-any))) in
        {29}let v_357: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_354),(if success?(4-proj-7-tuple(v_346)) then (if (not-caught-fail(v_353) && success?(is-true(success?(1-proj-2-tuple(v_353))))) then dhexp(2-proj-2-tuple(v_353),4-proj-7-tuple(v_346)) else fail-any) else fail-any))) in
        {30}let v_358: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_346)) then (if (not-caught-fail(v_353) && success?(is-true(success?(1-proj-2-tuple(v_353))))) then dhexp(2-proj-2-tuple(v_353),4-proj-7-tuple(v_346)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_354))) then (if not-caught-fail(v_355) then (if not-caught-fail(v_356) then (if not-caught-fail(v_357) then (v_355,v_356,v_357) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {31}let v_359: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_346)) then (if (not-caught-fail(v_353) && success?(is-true(success?(1-proj-2-tuple(v_353))))) then dhexp(2-proj-2-tuple(v_353),4-proj-7-tuple(v_346)) else fail-any) else fail-any)) then (if (not-caught-fail(v_354) && success?(is-true(success?(1-proj-3-tuple(v_354))))) then (if (not-caught-fail(v_358) && success?(is-true(success?(1-proj-3-tuple(v_358))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_358)) then cipherstatepack(2-proj-3-tuple(v_358),minnonce) else fail-any),1-proj-3-tuple(v_358),3-proj-3-tuple(v_354)) else fail-any) else fail-any) else fail-any)) in
        {32}let v_360: bitstring = catch-fail(symmetricstateunpack(v_359)) in
        {33}let v_361: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_360))) in
        {34}let v_362: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_361),2-proj-2-tuple(v_361),3-proj-3-tuple(v_360),msg_a(alice,bob,sid))) in
        {35}let v_363: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_360))) in
        {36}let v_364: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_361))) && success?(1-proj-3-tuple(v_360))) then (if (not-caught-fail(v_363) && success?(is-true(success?(1-proj-2-tuple(v_363))))) then cipherstatepack(1-proj-2-tuple(v_363),increment_nonce(2-proj-2-tuple(v_361))) else fail-any) else fail-any)) in
        {37}let v_365: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_360)) && success?(1-proj-3-tuple(v_360))) then (if (not-caught-fail(v_361) && success?(is-true(success?(1-proj-2-tuple(v_361))))) then (if not-caught-fail(v_362) then (if not-caught-fail(v_364) then (v_364,v_362) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {38}let v_366: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_365),2-proj-3-tuple(v_360),3-proj-3-tuple(v_360)))) in
        {39}let v_367: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_365)) && success?(symmetricstatepack(1-proj-2-tuple(v_365),2-proj-3-tuple(v_360),3-proj-3-tuple(v_360)))) then (if (not-caught-fail(v_366) && success?(is-true(success?(1-proj-3-tuple(v_366))))) then symmetricstatepack(1-proj-3-tuple(v_366),2-proj-3-tuple(v_366),hash(3-proj-3-tuple(v_366),2-proj-2-tuple(v_365))) else fail-any) else fail-any)) in
        {40}let v_368: bitstring = catch-fail((if (not-caught-fail(v_360) && success?(is-true(success?(1-proj-3-tuple(v_360))))) then (if (not-caught-fail(v_365) && success?(is-true(success?(1-proj-2-tuple(v_365))))) then (if not-caught-fail(v_367) then (v_367,2-proj-2-tuple(v_365)) else fail-any) else fail-any) else fail-any)) in
        {41}let v_369: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_368),2-proj-7-tuple(v_346),v_349,4-proj-7-tuple(v_346),5-proj-7-tuple(v_346),6-proj-7-tuple(v_346),7-proj-7-tuple(v_346))) in
        {42}let v_370: bitstring = catch-fail(concat3(v_350,2-proj-3-tuple(v_347),2-proj-2-tuple(v_368))) in
        {43}let v_371: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_368))) in
        {44}let v_372: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_371),zero)) in
        {45}let v_373: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_371),zero)) in
        {46}let v_374: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_371),zero)) in
        {47}let v_375: bitstring = catch-fail((if success?(2-proj-3-tuple(v_371)) then (if not-caught-fail(v_372) then (if not-caught-fail(v_373) then (if not-caught-fail(v_374) then (v_372,v_373,v_374) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {48}let v_376: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_375)) then cipherstatepack(1-proj-3-tuple(v_375),minnonce) else fail-any)) in
        {49}let v_377: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_375)) then cipherstatepack(2-proj-3-tuple(v_375),minnonce) else fail-any)) in
        {50}let v_378: bitstring = catch-fail((if success?(1-proj-2-tuple(v_368)) then (if (not-caught-fail(v_371) && success?(is-true(success?(1-proj-3-tuple(v_371))))) then (if (not-caught-fail(v_375) && success?(is-true(success?(1-proj-3-tuple(v_375))))) then (if not-caught-fail(v_376) then (if not-caught-fail(v_377) then (1-proj-2-tuple(v_368),v_376,v_377) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {51}let (hs_379: handshakestate,message_a: bitstring,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_346) && success?(is-true(success?(1-proj-7-tuple(v_346))))) then (if (not-caught-fail(v_347) && success?(is-true(success?(1-proj-3-tuple(v_347))))) then (if not-caught-fail(v_349) then (if not-caught-fail(v_350) then (if not-caught-fail(v_352) then (if not-caught-fail(v_359) then (if (not-caught-fail(v_368) && success?(is-true(success?(1-proj-2-tuple(v_368))))) then (if not-caught-fail(v_369) then (if not-caught-fail(v_370) then (if (not-caught-fail(v_378) && success?(is-true(success?(1-proj-3-tuple(v_378))))) then (v_369,v_370,2-proj-3-tuple(v_378),3-proj-3-tuple(v_378)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {52}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {53}out(pub, message_a)
    ) | (
        {55}event LeakS(phase0,alice);
        {56}out(pub, key_s(alice))
    ) | (
        {57}phase 1;
        {58}event LeakS(phase1,alice);
        {59}out(pub, key_s(alice))
    )
) | (
    {60}let s_380: keypair = keypairpack(empty,empty) in
    (
        {61}let e_381: keypair = keypairpack(empty,empty) in
        {62}let v_382: key = catch-fail(dhexp(key_s(charlie),g)) in
        {63}let rs_383: key = getpublickey((if not-caught-fail(v_382) then keypairpack(v_382,key_s(charlie)) else fail-any)) in
        {64}let re_384: key = empty in
        {65}let v_385: bitstring = catch-fail(hash(somename,empty)) in
        {66}let v_386: key = catch-fail(v_385) in
        {67}let v_387: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {68}let v_388: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_385) then (if not-caught-fail(v_386) then (if not-caught-fail(v_387) then symmetricstatepack(v_387,v_386,v_385) else fail-any) else fail-any) else fail-any))) in
        {69}let v_389: symmetricstate = catch-fail((if success?((if not-caught-fail(v_385) then (if not-caught-fail(v_386) then (if not-caught-fail(v_387) then symmetricstatepack(v_387,v_386,v_385) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_388) && success?(is-true(success?(1-proj-3-tuple(v_388))))) then symmetricstatepack(1-proj-3-tuple(v_388),2-proj-3-tuple(v_388),hash(3-proj-3-tuple(v_388),empty)) else fail-any) else fail-any)) in
        {70}let v_390: bitstring = catch-fail(symmetricstateunpack(v_389)) in
        {71}let v_391: symmetricstate = catch-fail((if (not-caught-fail(v_390) && success?(is-true(success?(1-proj-3-tuple(v_390))))) then symmetricstatepack(1-proj-3-tuple(v_390),2-proj-3-tuple(v_390),hash(3-proj-3-tuple(v_390),rs_383)) else fail-any)) in
        {72}let hs_392: handshakestate = (if not-caught-fail(v_389) then (if not-caught-fail(v_391) then handshakestatepack(v_391,s_380,e_381,rs_383,re_384,empty,true) else fail-any) else fail-any) in
        {73}insert statestore(alice,charlie,sid,statepack_a(hs_392))
    ) | (
        {110}get statestore(=alice,=charlie,=sid,statepack_a(hs_393: handshakestate)) in
        {74}let v_394: bitstring = catch-fail(handshakestateunpack(hs_393)) in
        {75}let v_395: bitstring = catch-fail((empty,empty,empty)) in
        {76}let v_396: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {77}let v_397: keypair = catch-fail((if not-caught-fail(v_396) then keypairpack(v_396,key_e(alice,charlie,sid)) else fail-any)) in
        {78}let v_398: bitstring = catch-fail(getpublickey(v_397)) in
        {79}let v_399: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_394))) in
        {80}let v_400: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_394)) then (if (not-caught-fail(v_399) && success?(is-true(success?(1-proj-3-tuple(v_399))))) then symmetricstatepack(1-proj-3-tuple(v_399),2-proj-3-tuple(v_399),hash(3-proj-3-tuple(v_399),v_398)) else fail-any) else fail-any)) in
        {81}let v_401: bitstring = catch-fail(keypairunpack(v_397)) in
        {82}let v_402: bitstring = catch-fail(symmetricstateunpack(v_400)) in
        {83}let v_403: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_402),(if success?(4-proj-7-tuple(v_394)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-2-tuple(v_401))))) then dhexp(2-proj-2-tuple(v_401),4-proj-7-tuple(v_394)) else fail-any) else fail-any))) in
        {84}let v_404: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_402),(if success?(4-proj-7-tuple(v_394)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-2-tuple(v_401))))) then dhexp(2-proj-2-tuple(v_401),4-proj-7-tuple(v_394)) else fail-any) else fail-any))) in
        {85}let v_405: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_402),(if success?(4-proj-7-tuple(v_394)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-2-tuple(v_401))))) then dhexp(2-proj-2-tuple(v_401),4-proj-7-tuple(v_394)) else fail-any) else fail-any))) in
        {86}let v_406: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_394)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-2-tuple(v_401))))) then dhexp(2-proj-2-tuple(v_401),4-proj-7-tuple(v_394)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_402))) then (if not-caught-fail(v_403) then (if not-caught-fail(v_404) then (if not-caught-fail(v_405) then (v_403,v_404,v_405) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {87}let v_407: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_394)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-2-tuple(v_401))))) then dhexp(2-proj-2-tuple(v_401),4-proj-7-tuple(v_394)) else fail-any) else fail-any)) then (if (not-caught-fail(v_402) && success?(is-true(success?(1-proj-3-tuple(v_402))))) then (if (not-caught-fail(v_406) && success?(is-true(success?(1-proj-3-tuple(v_406))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_406)) then cipherstatepack(2-proj-3-tuple(v_406),minnonce) else fail-any),1-proj-3-tuple(v_406),3-proj-3-tuple(v_402)) else fail-any) else fail-any) else fail-any)) in
        {88}let v_408: bitstring = catch-fail(symmetricstateunpack(v_407)) in
        {89}let v_409: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_408))) in
        {90}let v_410: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_409),2-proj-2-tuple(v_409),3-proj-3-tuple(v_408),msg_a(alice,charlie,sid))) in
        {91}let v_411: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_408))) in
        {92}let v_412: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_409))) && success?(1-proj-3-tuple(v_408))) then (if (not-caught-fail(v_411) && success?(is-true(success?(1-proj-2-tuple(v_411))))) then cipherstatepack(1-proj-2-tuple(v_411),increment_nonce(2-proj-2-tuple(v_409))) else fail-any) else fail-any)) in
        {93}let v_413: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_408)) && success?(1-proj-3-tuple(v_408))) then (if (not-caught-fail(v_409) && success?(is-true(success?(1-proj-2-tuple(v_409))))) then (if not-caught-fail(v_410) then (if not-caught-fail(v_412) then (v_412,v_410) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {94}let v_414: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_413),2-proj-3-tuple(v_408),3-proj-3-tuple(v_408)))) in
        {95}let v_415: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_413)) && success?(symmetricstatepack(1-proj-2-tuple(v_413),2-proj-3-tuple(v_408),3-proj-3-tuple(v_408)))) then (if (not-caught-fail(v_414) && success?(is-true(success?(1-proj-3-tuple(v_414))))) then symmetricstatepack(1-proj-3-tuple(v_414),2-proj-3-tuple(v_414),hash(3-proj-3-tuple(v_414),2-proj-2-tuple(v_413))) else fail-any) else fail-any)) in
        {96}let v_416: bitstring = catch-fail((if (not-caught-fail(v_408) && success?(is-true(success?(1-proj-3-tuple(v_408))))) then (if (not-caught-fail(v_413) && success?(is-true(success?(1-proj-2-tuple(v_413))))) then (if not-caught-fail(v_415) then (v_415,2-proj-2-tuple(v_413)) else fail-any) else fail-any) else fail-any)) in
        {97}let v_417: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_416),2-proj-7-tuple(v_394),v_397,4-proj-7-tuple(v_394),5-proj-7-tuple(v_394),6-proj-7-tuple(v_394),7-proj-7-tuple(v_394))) in
        {98}let v_418: bitstring = catch-fail(concat3(v_398,2-proj-3-tuple(v_395),2-proj-2-tuple(v_416))) in
        {99}let v_419: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_416))) in
        {100}let v_420: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_419),zero)) in
        {101}let v_421: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_419),zero)) in
        {102}let v_422: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_419),zero)) in
        {103}let v_423: bitstring = catch-fail((if success?(2-proj-3-tuple(v_419)) then (if not-caught-fail(v_420) then (if not-caught-fail(v_421) then (if not-caught-fail(v_422) then (v_420,v_421,v_422) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {104}let v_424: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_423)) then cipherstatepack(1-proj-3-tuple(v_423),minnonce) else fail-any)) in
        {105}let v_425: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_423)) then cipherstatepack(2-proj-3-tuple(v_423),minnonce) else fail-any)) in
        {106}let v_426: bitstring = catch-fail((if success?(1-proj-2-tuple(v_416)) then (if (not-caught-fail(v_419) && success?(is-true(success?(1-proj-3-tuple(v_419))))) then (if (not-caught-fail(v_423) && success?(is-true(success?(1-proj-3-tuple(v_423))))) then (if not-caught-fail(v_424) then (if not-caught-fail(v_425) then (1-proj-2-tuple(v_416),v_424,v_425) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let (hs_427: handshakestate,message_a_428: bitstring,cs1_429: cipherstate,cs2_430: cipherstate) = (if (not-caught-fail(v_394) && success?(is-true(success?(1-proj-7-tuple(v_394))))) then (if (not-caught-fail(v_395) && success?(is-true(success?(1-proj-3-tuple(v_395))))) then (if not-caught-fail(v_397) then (if not-caught-fail(v_398) then (if not-caught-fail(v_400) then (if not-caught-fail(v_407) then (if (not-caught-fail(v_416) && success?(is-true(success?(1-proj-2-tuple(v_416))))) then (if not-caught-fail(v_417) then (if not-caught-fail(v_418) then (if (not-caught-fail(v_426) && success?(is-true(success?(1-proj-3-tuple(v_426))))) then (v_417,v_418,2-proj-3-tuple(v_426),3-proj-3-tuple(v_426)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {108}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {109}out(pub, message_a_428)
    ) | (
        {111}event LeakS(phase0,alice);
        {112}out(pub, key_s(alice))
    ) | (
        {113}phase 1;
        {114}event LeakS(phase1,alice);
        {115}out(pub, key_s(alice))
    )
) | (
    {116}let v_431: key = catch-fail(dhexp(key_s(bob),g)) in
    {117}let s_432: keypair = (if not-caught-fail(v_431) then keypairpack(v_431,key_s(bob)) else fail-any) in
    {118}out(pub, getpublickey(s_432));
    (
        {119}let e_433: keypair = keypairpack(empty,empty) in
        {120}let rs_434: key = empty in
        {121}let re_435: key = empty in
        {122}let v_436: bitstring = catch-fail(hash(somename,empty)) in
        {123}let v_437: key = catch-fail(v_436) in
        {124}let v_438: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {125}let v_439: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_436) then (if not-caught-fail(v_437) then (if not-caught-fail(v_438) then symmetricstatepack(v_438,v_437,v_436) else fail-any) else fail-any) else fail-any))) in
        {126}let v_440: symmetricstate = catch-fail((if success?((if not-caught-fail(v_436) then (if not-caught-fail(v_437) then (if not-caught-fail(v_438) then symmetricstatepack(v_438,v_437,v_436) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-3-tuple(v_439))))) then symmetricstatepack(1-proj-3-tuple(v_439),2-proj-3-tuple(v_439),hash(3-proj-3-tuple(v_439),empty)) else fail-any) else fail-any)) in
        {127}let v_441: bitstring = catch-fail(symmetricstateunpack(v_440)) in
        {128}let v_442: symmetricstate = catch-fail((if success?(getpublickey(s_432)) then (if (not-caught-fail(v_441) && success?(is-true(success?(1-proj-3-tuple(v_441))))) then symmetricstatepack(1-proj-3-tuple(v_441),2-proj-3-tuple(v_441),hash(3-proj-3-tuple(v_441),getpublickey(s_432))) else fail-any) else fail-any)) in
        {129}let hs_443: handshakestate = (if not-caught-fail(v_440) then (if not-caught-fail(v_442) then handshakestatepack(v_442,s_432,e_433,rs_434,re_435,empty,false) else fail-any) else fail-any) in
        {130}insert statestore(bob,alice,sid,statepack_a(hs_443))
    ) | (
        {167}get statestore(=bob,=alice,=sid,statepack_a(hs_444: handshakestate)) in
        {131}in(pub, message_a_445: bitstring);
        {132}let v_446: bitstring = catch-fail(handshakestateunpack(hs_444)) in
        {133}let v_447: bitstring = catch-fail(deconcat3(message_a_445)) in
        {134}let v_448: bool = catch-fail(true) in
        {135}let v_449: key = catch-fail(1-proj-3-tuple(v_447)) in
        {136}let v_450: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_446))) in
        {137}let v_451: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_446)) then (if (not-caught-fail(v_450) && success?(is-true(success?(1-proj-3-tuple(v_450))))) then symmetricstatepack(1-proj-3-tuple(v_450),2-proj-3-tuple(v_450),hash(3-proj-3-tuple(v_450),v_449)) else fail-any) else fail-any)) in
        {138}let v_452: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_446))) in
        {139}let v_453: bitstring = catch-fail(symmetricstateunpack(v_451)) in
        {140}let v_454: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_453),(if success?(2-proj-7-tuple(v_446)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-2-tuple(v_452))))) then dhexp(2-proj-2-tuple(v_452),v_449) else fail-any) else fail-any))) in
        {141}let v_455: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_453),(if success?(2-proj-7-tuple(v_446)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-2-tuple(v_452))))) then dhexp(2-proj-2-tuple(v_452),v_449) else fail-any) else fail-any))) in
        {142}let v_456: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_453),(if success?(2-proj-7-tuple(v_446)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-2-tuple(v_452))))) then dhexp(2-proj-2-tuple(v_452),v_449) else fail-any) else fail-any))) in
        {143}let v_457: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_446)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-2-tuple(v_452))))) then dhexp(2-proj-2-tuple(v_452),v_449) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_453))) then (if not-caught-fail(v_454) then (if not-caught-fail(v_455) then (if not-caught-fail(v_456) then (v_454,v_455,v_456) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {144}let v_458: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_446)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-2-tuple(v_452))))) then dhexp(2-proj-2-tuple(v_452),v_449) else fail-any) else fail-any)) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-3-tuple(v_453))))) then (if (not-caught-fail(v_457) && success?(is-true(success?(1-proj-3-tuple(v_457))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_457)) then cipherstatepack(2-proj-3-tuple(v_457),minnonce) else fail-any),1-proj-3-tuple(v_457),3-proj-3-tuple(v_453)) else fail-any) else fail-any) else fail-any)) in
        {145}let v_459: bitstring = catch-fail(symmetricstateunpack(v_458)) in
        {146}let v_460: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_459))) in
        {147}let v_461: aead = catch-fail(decrypt(1-proj-2-tuple(v_460),2-proj-2-tuple(v_460),3-proj-3-tuple(v_459),3-proj-3-tuple(v_447))) in
        {148}let v_462: bitstring = catch-fail(aeadunpack(v_461)) in
        {149}let v_463: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_459))) in
        {150}let v_464: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_460))) && success?(1-proj-3-tuple(v_459))) then (if (not-caught-fail(v_463) && success?(is-true(success?(1-proj-2-tuple(v_463))))) then cipherstatepack(1-proj-2-tuple(v_463),increment_nonce(2-proj-2-tuple(v_460))) else fail-any) else fail-any)) in
        {151}let v_465: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_447)) && (success?(3-proj-3-tuple(v_459)) && success?(1-proj-3-tuple(v_459)))) then (if (not-caught-fail(v_460) && success?(is-true(success?(1-proj-2-tuple(v_460))))) then (if not-caught-fail(v_461) then (if (not-caught-fail(v_462) && success?(is-true(success?(1-proj-3-tuple(v_462))))) then (if not-caught-fail(v_464) then (v_464,3-proj-3-tuple(v_462),1-proj-3-tuple(v_462)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {152}let v_466: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_465),2-proj-3-tuple(v_459),3-proj-3-tuple(v_459)))) in
        {153}let v_467: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_447)) && success?(symmetricstatepack(1-proj-3-tuple(v_465),2-proj-3-tuple(v_459),3-proj-3-tuple(v_459)))) then (if (not-caught-fail(v_466) && success?(is-true(success?(1-proj-3-tuple(v_466))))) then symmetricstatepack(1-proj-3-tuple(v_466),2-proj-3-tuple(v_466),hash(3-proj-3-tuple(v_466),3-proj-3-tuple(v_447))) else fail-any) else fail-any)) in
        {154}let v_468: bitstring = catch-fail((if success?(3-proj-3-tuple(v_447)) then (if (not-caught-fail(v_459) && success?(is-true(success?(1-proj-3-tuple(v_459))))) then (if (not-caught-fail(v_465) && success?(is-true(success?(1-proj-3-tuple(v_465))))) then (if not-caught-fail(v_467) then (v_467,2-proj-3-tuple(v_465),3-proj-3-tuple(v_465)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {155}let v_469: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_468),2-proj-7-tuple(v_446),3-proj-7-tuple(v_446),4-proj-7-tuple(v_446),v_449,6-proj-7-tuple(v_446),7-proj-7-tuple(v_446))) in
        {156}let v_470: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_468))) in
        {157}let v_471: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_470),zero)) in
        {158}let v_472: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_470),zero)) in
        {159}let v_473: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_470),zero)) in
        {160}let v_474: bitstring = catch-fail((if success?(2-proj-3-tuple(v_470)) then (if not-caught-fail(v_471) then (if not-caught-fail(v_472) then (if not-caught-fail(v_473) then (v_471,v_472,v_473) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {161}let v_475: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_474)) then cipherstatepack(1-proj-3-tuple(v_474),minnonce) else fail-any)) in
        {162}let v_476: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_474)) then cipherstatepack(2-proj-3-tuple(v_474),minnonce) else fail-any)) in
        {163}let v_477: bitstring = catch-fail((if success?(1-proj-3-tuple(v_468)) then (if (not-caught-fail(v_470) && success?(is-true(success?(1-proj-3-tuple(v_470))))) then (if (not-caught-fail(v_474) && success?(is-true(success?(1-proj-3-tuple(v_474))))) then (if not-caught-fail(v_475) then (if not-caught-fail(v_476) then (1-proj-3-tuple(v_468),v_475,v_476) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {164}let (hs_478: handshakestate,plaintext_a: bitstring,valid: bool,cs1_479: cipherstate,cs2_480: cipherstate) = (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-7-tuple(v_446))))) then (if (not-caught-fail(v_447) && success?(is-true(success?(1-proj-3-tuple(v_447))))) then (if not-caught-fail(v_448) then (if not-caught-fail(v_449) then (if not-caught-fail(v_451) then (if not-caught-fail(v_458) then (if (not-caught-fail(v_468) && success?(is-true(success?(1-proj-3-tuple(v_468))))) then (if (v_448 && 3-proj-3-tuple(v_468)) then (if not-caught-fail(v_469) then (if (not-caught-fail(v_477) && success?(is-true(success?(1-proj-3-tuple(v_477))))) then (v_469,2-proj-3-tuple(v_468),true,2-proj-3-tuple(v_477),3-proj-3-tuple(v_477)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {165}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {166}event RecvEnd(valid)
    ) | (
        {168}event LeakS(phase0,bob);
        {169}out(pub, key_s(bob))
    ) | (
        {170}phase 1;
        {171}event LeakS(phase1,bob);
        {172}out(pub, key_s(bob))
    )
) | (
    {173}let v_481: key = catch-fail(dhexp(key_s(bob),g)) in
    {174}let s_482: keypair = (if not-caught-fail(v_481) then keypairpack(v_481,key_s(bob)) else fail-any) in
    {175}out(pub, getpublickey(s_482));
    (
        {176}let e_483: keypair = keypairpack(empty,empty) in
        {177}let rs_484: key = empty in
        {178}let re_485: key = empty in
        {179}let v_486: bitstring = catch-fail(hash(somename,empty)) in
        {180}let v_487: key = catch-fail(v_486) in
        {181}let v_488: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {182}let v_489: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_486) then (if not-caught-fail(v_487) then (if not-caught-fail(v_488) then symmetricstatepack(v_488,v_487,v_486) else fail-any) else fail-any) else fail-any))) in
        {183}let v_490: symmetricstate = catch-fail((if success?((if not-caught-fail(v_486) then (if not-caught-fail(v_487) then (if not-caught-fail(v_488) then symmetricstatepack(v_488,v_487,v_486) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_489) && success?(is-true(success?(1-proj-3-tuple(v_489))))) then symmetricstatepack(1-proj-3-tuple(v_489),2-proj-3-tuple(v_489),hash(3-proj-3-tuple(v_489),empty)) else fail-any) else fail-any)) in
        {184}let v_491: bitstring = catch-fail(symmetricstateunpack(v_490)) in
        {185}let v_492: symmetricstate = catch-fail((if success?(getpublickey(s_482)) then (if (not-caught-fail(v_491) && success?(is-true(success?(1-proj-3-tuple(v_491))))) then symmetricstatepack(1-proj-3-tuple(v_491),2-proj-3-tuple(v_491),hash(3-proj-3-tuple(v_491),getpublickey(s_482))) else fail-any) else fail-any)) in
        {186}let hs_493: handshakestate = (if not-caught-fail(v_490) then (if not-caught-fail(v_492) then handshakestatepack(v_492,s_482,e_483,rs_484,re_485,empty,false) else fail-any) else fail-any) in
        {187}insert statestore(bob,charlie,sid,statepack_a(hs_493))
    ) | (
        {224}get statestore(=bob,=charlie,=sid,statepack_a(hs_494: handshakestate)) in
        {188}in(pub, message_a_495: bitstring);
        {189}let v_496: bitstring = catch-fail(handshakestateunpack(hs_494)) in
        {190}let v_497: bitstring = catch-fail(deconcat3(message_a_495)) in
        {191}let v_498: bool = catch-fail(true) in
        {192}let v_499: key = catch-fail(1-proj-3-tuple(v_497)) in
        {193}let v_500: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_496))) in
        {194}let v_501: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_496)) then (if (not-caught-fail(v_500) && success?(is-true(success?(1-proj-3-tuple(v_500))))) then symmetricstatepack(1-proj-3-tuple(v_500),2-proj-3-tuple(v_500),hash(3-proj-3-tuple(v_500),v_499)) else fail-any) else fail-any)) in
        {195}let v_502: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_496))) in
        {196}let v_503: bitstring = catch-fail(symmetricstateunpack(v_501)) in
        {197}let v_504: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_503),(if success?(2-proj-7-tuple(v_496)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-2-tuple(v_502))))) then dhexp(2-proj-2-tuple(v_502),v_499) else fail-any) else fail-any))) in
        {198}let v_505: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_503),(if success?(2-proj-7-tuple(v_496)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-2-tuple(v_502))))) then dhexp(2-proj-2-tuple(v_502),v_499) else fail-any) else fail-any))) in
        {199}let v_506: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_503),(if success?(2-proj-7-tuple(v_496)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-2-tuple(v_502))))) then dhexp(2-proj-2-tuple(v_502),v_499) else fail-any) else fail-any))) in
        {200}let v_507: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_496)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-2-tuple(v_502))))) then dhexp(2-proj-2-tuple(v_502),v_499) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_503))) then (if not-caught-fail(v_504) then (if not-caught-fail(v_505) then (if not-caught-fail(v_506) then (v_504,v_505,v_506) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {201}let v_508: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_496)) then (if (not-caught-fail(v_502) && success?(is-true(success?(1-proj-2-tuple(v_502))))) then dhexp(2-proj-2-tuple(v_502),v_499) else fail-any) else fail-any)) then (if (not-caught-fail(v_503) && success?(is-true(success?(1-proj-3-tuple(v_503))))) then (if (not-caught-fail(v_507) && success?(is-true(success?(1-proj-3-tuple(v_507))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_507)) then cipherstatepack(2-proj-3-tuple(v_507),minnonce) else fail-any),1-proj-3-tuple(v_507),3-proj-3-tuple(v_503)) else fail-any) else fail-any) else fail-any)) in
        {202}let v_509: bitstring = catch-fail(symmetricstateunpack(v_508)) in
        {203}let v_510: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_509))) in
        {204}let v_511: aead = catch-fail(decrypt(1-proj-2-tuple(v_510),2-proj-2-tuple(v_510),3-proj-3-tuple(v_509),3-proj-3-tuple(v_497))) in
        {205}let v_512: bitstring = catch-fail(aeadunpack(v_511)) in
        {206}let v_513: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_509))) in
        {207}let v_514: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_510))) && success?(1-proj-3-tuple(v_509))) then (if (not-caught-fail(v_513) && success?(is-true(success?(1-proj-2-tuple(v_513))))) then cipherstatepack(1-proj-2-tuple(v_513),increment_nonce(2-proj-2-tuple(v_510))) else fail-any) else fail-any)) in
        {208}let v_515: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_497)) && (success?(3-proj-3-tuple(v_509)) && success?(1-proj-3-tuple(v_509)))) then (if (not-caught-fail(v_510) && success?(is-true(success?(1-proj-2-tuple(v_510))))) then (if not-caught-fail(v_511) then (if (not-caught-fail(v_512) && success?(is-true(success?(1-proj-3-tuple(v_512))))) then (if not-caught-fail(v_514) then (v_514,3-proj-3-tuple(v_512),1-proj-3-tuple(v_512)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {209}let v_516: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_515),2-proj-3-tuple(v_509),3-proj-3-tuple(v_509)))) in
        {210}let v_517: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_497)) && success?(symmetricstatepack(1-proj-3-tuple(v_515),2-proj-3-tuple(v_509),3-proj-3-tuple(v_509)))) then (if (not-caught-fail(v_516) && success?(is-true(success?(1-proj-3-tuple(v_516))))) then symmetricstatepack(1-proj-3-tuple(v_516),2-proj-3-tuple(v_516),hash(3-proj-3-tuple(v_516),3-proj-3-tuple(v_497))) else fail-any) else fail-any)) in
        {211}let v_518: bitstring = catch-fail((if success?(3-proj-3-tuple(v_497)) then (if (not-caught-fail(v_509) && success?(is-true(success?(1-proj-3-tuple(v_509))))) then (if (not-caught-fail(v_515) && success?(is-true(success?(1-proj-3-tuple(v_515))))) then (if not-caught-fail(v_517) then (v_517,2-proj-3-tuple(v_515),3-proj-3-tuple(v_515)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {212}let v_519: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_518),2-proj-7-tuple(v_496),3-proj-7-tuple(v_496),4-proj-7-tuple(v_496),v_499,6-proj-7-tuple(v_496),7-proj-7-tuple(v_496))) in
        {213}let v_520: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_518))) in
        {214}let v_521: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_520),zero)) in
        {215}let v_522: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_520),zero)) in
        {216}let v_523: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_520),zero)) in
        {217}let v_524: bitstring = catch-fail((if success?(2-proj-3-tuple(v_520)) then (if not-caught-fail(v_521) then (if not-caught-fail(v_522) then (if not-caught-fail(v_523) then (v_521,v_522,v_523) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {218}let v_525: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_524)) then cipherstatepack(1-proj-3-tuple(v_524),minnonce) else fail-any)) in
        {219}let v_526: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_524)) then cipherstatepack(2-proj-3-tuple(v_524),minnonce) else fail-any)) in
        {220}let v_527: bitstring = catch-fail((if success?(1-proj-3-tuple(v_518)) then (if (not-caught-fail(v_520) && success?(is-true(success?(1-proj-3-tuple(v_520))))) then (if (not-caught-fail(v_524) && success?(is-true(success?(1-proj-3-tuple(v_524))))) then (if not-caught-fail(v_525) then (if not-caught-fail(v_526) then (1-proj-3-tuple(v_518),v_525,v_526) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {221}let (hs_528: handshakestate,plaintext_a_529: bitstring,valid_530: bool,cs1_531: cipherstate,cs2_532: cipherstate) = (if (not-caught-fail(v_496) && success?(is-true(success?(1-proj-7-tuple(v_496))))) then (if (not-caught-fail(v_497) && success?(is-true(success?(1-proj-3-tuple(v_497))))) then (if not-caught-fail(v_498) then (if not-caught-fail(v_499) then (if not-caught-fail(v_501) then (if not-caught-fail(v_508) then (if (not-caught-fail(v_518) && success?(is-true(success?(1-proj-3-tuple(v_518))))) then (if (v_498 && 3-proj-3-tuple(v_518)) then (if not-caught-fail(v_519) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-3-tuple(v_527))))) then (v_519,2-proj-3-tuple(v_518),true,2-proj-3-tuple(v_527),3-proj-3-tuple(v_527)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {222}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_529);
        {223}event RecvEnd(valid_530)
    ) | (
        {225}event LeakS(phase0,bob);
        {226}out(pub, key_s(bob))
    ) | (
        {227}phase 1;
        {228}event LeakS(phase1,bob);
        {229}out(pub, key_s(bob))
    )
)

