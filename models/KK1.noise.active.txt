File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 271, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 272, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 272, character 36:
Warning: identifier h rebound.
File "KK1.noise.active.pv", line 281, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 287, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 302, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 303, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 308, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 309, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 315, character 6:
Warning: identifier e rebound.
File "KK1.noise.active.pv", line 316, characters 6-7:
Warning: identifier ne rebound.
File "KK1.noise.active.pv", line 317, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 319, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 319, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK1.noise.active.pv", line 320, characters 6-7:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 327, character 6:
Warning: identifier e rebound.
File "KK1.noise.active.pv", line 328, characters 6-7:
Warning: identifier ne rebound.
File "KK1.noise.active.pv", line 329, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 331, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 332, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 333, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 334, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 334, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK1.noise.active.pv", line 335, characters 6-7:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 344, characters 6-7:
Warning: identifier re rebound.
File "KK1.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 347, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 349, characters 7-8:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 357, characters 6-7:
Warning: identifier re rebound.
File "KK1.noise.active.pv", line 358, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 361, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 362, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 363, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 365, characters 7-8:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 461, characters 8-9:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 357, characters 6-7:
Warning: identifier re rebound.
File "KK1.noise.active.pv", line 358, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 361, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 362, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 363, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 365, characters 7-8:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 287, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 453, characters 8-9:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 315, character 6:
Warning: identifier e rebound.
File "KK1.noise.active.pv", line 316, characters 6-7:
Warning: identifier ne rebound.
File "KK1.noise.active.pv", line 317, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 319, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 319, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK1.noise.active.pv", line 320, characters 6-7:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 281, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 302, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 303, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 496, characters 8-9:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 327, character 6:
Warning: identifier e rebound.
File "KK1.noise.active.pv", line 328, characters 6-7:
Warning: identifier ne rebound.
File "KK1.noise.active.pv", line 329, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 331, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 332, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 333, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 334, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 334, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "KK1.noise.active.pv", line 335, characters 6-7:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 262, characters 7-8:
Warning: identifier ck rebound.
File "KK1.noise.active.pv", line 281, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 489, characters 8-9:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 344, characters 6-7:
Warning: identifier re rebound.
File "KK1.noise.active.pv", line 345, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 347, characters 7-8:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 349, characters 7-8:
Warning: identifier hs rebound.
File "KK1.noise.active.pv", line 287, characters 7-8:
Warning: identifier cs rebound.
File "KK1.noise.active.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 308, characters 6-7:
Warning: identifier ss rebound.
File "KK1.noise.active.pv", line 309, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}!
(
    {2}let v_396: key = catch-fail(dhexp(key_s(alice),g)) in
    {3}let s_397: keypair = (if not-caught-fail(v_396) then keypairpack(v_396,key_s(alice)) else fail-any) in
    {4}out(pub, getpublickey(s_397));
    (
        {5}let e_398: keypair = keypairpack(empty,empty) in
        {6}let v_399: key = catch-fail(dhexp(key_s(bob),g)) in
        {7}let rs_400: key = getpublickey((if not-caught-fail(v_399) then keypairpack(v_399,key_s(bob)) else fail-any)) in
        {8}let re_401: key = empty in
        {9}let v_402: bitstring = catch-fail(hash(somename,empty)) in
        {10}let v_403: key = catch-fail(v_402) in
        {11}let v_404: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {12}let v_405: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_402) then (if not-caught-fail(v_403) then (if not-caught-fail(v_404) then symmetricstatepack(v_404,v_403,v_402) else fail-any) else fail-any) else fail-any))) in
        {13}let v_406: symmetricstate = catch-fail((if success?((if not-caught-fail(v_402) then (if not-caught-fail(v_403) then (if not-caught-fail(v_404) then symmetricstatepack(v_404,v_403,v_402) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_405) && success?(is-true(success?(1-proj-3-tuple(v_405))))) then symmetricstatepack(1-proj-3-tuple(v_405),2-proj-3-tuple(v_405),hash(3-proj-3-tuple(v_405),empty)) else fail-any) else fail-any)) in
        {14}let v_407: bitstring = catch-fail(symmetricstateunpack(v_406)) in
        {15}let v_408: symmetricstate = catch-fail((if success?(getpublickey(s_397)) then (if (not-caught-fail(v_407) && success?(is-true(success?(1-proj-3-tuple(v_407))))) then symmetricstatepack(1-proj-3-tuple(v_407),2-proj-3-tuple(v_407),hash(3-proj-3-tuple(v_407),getpublickey(s_397))) else fail-any) else fail-any)) in
        {16}let v_409: bitstring = catch-fail(symmetricstateunpack(v_408)) in
        {17}let v_410: symmetricstate = catch-fail((if (not-caught-fail(v_409) && success?(is-true(success?(1-proj-3-tuple(v_409))))) then symmetricstatepack(1-proj-3-tuple(v_409),2-proj-3-tuple(v_409),hash(3-proj-3-tuple(v_409),rs_400)) else fail-any)) in
        {18}let hs: handshakestate = (if not-caught-fail(v_406) then (if not-caught-fail(v_408) then (if not-caught-fail(v_410) then handshakestatepack(v_410,s_397,e_398,rs_400,re_401,empty,true) else fail-any) else fail-any) else fail-any) in
        {19}insert statestore(alice,bob,statepack_a(hs))
    ) | (
        {42}get statestore(=alice,=bob,statepack_a(hs_411: handshakestate)) in
        {20}let v_412: bitstring = catch-fail(handshakestateunpack(hs_411)) in
        {21}let v_413: bitstring = catch-fail((empty,empty,empty)) in
        {22}let v_414: key = catch-fail(dhexp(key_e(alice,bob),g)) in
        {23}let v_415: keypair = catch-fail((if not-caught-fail(v_414) then keypairpack(v_414,key_e(alice,bob)) else fail-any)) in
        {24}let v_416: bitstring = catch-fail(getpublickey(v_415)) in
        {25}let v_417: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_412))) in
        {26}let v_418: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_412)) then (if (not-caught-fail(v_417) && success?(is-true(success?(1-proj-3-tuple(v_417))))) then symmetricstatepack(1-proj-3-tuple(v_417),2-proj-3-tuple(v_417),hash(3-proj-3-tuple(v_417),v_416)) else fail-any) else fail-any)) in
        {27}let v_419: bitstring = catch-fail(symmetricstateunpack(v_418)) in
        {28}let v_420: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_419))) in
        {29}let v_421: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_420),2-proj-2-tuple(v_420),3-proj-3-tuple(v_419),msg_a(alice,bob))) in
        {30}let v_422: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_419))) in
        {31}let v_423: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_420))) && success?(1-proj-3-tuple(v_419))) then (if (not-caught-fail(v_422) && success?(is-true(success?(1-proj-2-tuple(v_422))))) then cipherstatepack(1-proj-2-tuple(v_422),increment_nonce(2-proj-2-tuple(v_420))) else fail-any) else fail-any)) in
        {32}let v_424: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_419)) && success?(1-proj-3-tuple(v_419))) then (if (not-caught-fail(v_420) && success?(is-true(success?(1-proj-2-tuple(v_420))))) then (if not-caught-fail(v_421) then (if not-caught-fail(v_423) then (v_423,v_421) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {33}let v_425: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_424),2-proj-3-tuple(v_419),3-proj-3-tuple(v_419)))) in
        {34}let v_426: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_424)) && success?(symmetricstatepack(1-proj-2-tuple(v_424),2-proj-3-tuple(v_419),3-proj-3-tuple(v_419)))) then (if (not-caught-fail(v_425) && success?(is-true(success?(1-proj-3-tuple(v_425))))) then symmetricstatepack(1-proj-3-tuple(v_425),2-proj-3-tuple(v_425),hash(3-proj-3-tuple(v_425),2-proj-2-tuple(v_424))) else fail-any) else fail-any)) in
        {35}let v_427: bitstring = catch-fail((if (not-caught-fail(v_419) && success?(is-true(success?(1-proj-3-tuple(v_419))))) then (if (not-caught-fail(v_424) && success?(is-true(success?(1-proj-2-tuple(v_424))))) then (if not-caught-fail(v_426) then (v_426,2-proj-2-tuple(v_424)) else fail-any) else fail-any) else fail-any)) in
        {36}let v_428: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_427),2-proj-7-tuple(v_412),v_415,4-proj-7-tuple(v_412),5-proj-7-tuple(v_412),6-proj-7-tuple(v_412),7-proj-7-tuple(v_412))) in
        {37}let v_429: bitstring = catch-fail(concat3(v_416,2-proj-3-tuple(v_413),2-proj-2-tuple(v_427))) in
        {38}let (hs_430: handshakestate,re_431: key,message_a: bitstring) = (if (not-caught-fail(v_412) && success?(is-true(success?(1-proj-7-tuple(v_412))))) then (if (not-caught-fail(v_413) && success?(is-true(success?(1-proj-3-tuple(v_413))))) then (if not-caught-fail(v_415) then (if not-caught-fail(v_416) then (if not-caught-fail(v_418) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then (if not-caught-fail(v_428) then (if not-caught-fail(v_429) then (v_428,5-proj-7-tuple(v_412),v_429) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {39}event SendMsg(alice,bob,stage_a,msg_a(alice,bob),true);
        {40}insert statestore(alice,bob,statepack_b(hs_430));
        {41}out(pub, message_a)
    ) | (
        {94}get statestore(=alice,=bob,statepack_b(hs_432: handshakestate)) in
        {43}in(pub, message_b: bitstring);
        {44}let v_433: bitstring = catch-fail(handshakestateunpack(hs_432)) in
        {45}let v_434: bitstring = catch-fail(deconcat3(message_b)) in
        {46}let v_435: bool = catch-fail(true) in
        {47}let v_436: key = catch-fail(1-proj-3-tuple(v_434)) in
        {48}let v_437: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_433))) in
        {49}let v_438: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_433)) then (if (not-caught-fail(v_437) && success?(is-true(success?(1-proj-3-tuple(v_437))))) then symmetricstatepack(1-proj-3-tuple(v_437),2-proj-3-tuple(v_437),hash(3-proj-3-tuple(v_437),v_436)) else fail-any) else fail-any)) in
        {50}let v_439: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_433))) in
        {51}let v_440: bitstring = catch-fail(symmetricstateunpack(v_438)) in
        {52}let v_441: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_440),(if success?(3-proj-7-tuple(v_433)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-2-tuple(v_439))))) then dhexp(2-proj-2-tuple(v_439),v_436) else fail-any) else fail-any))) in
        {53}let v_442: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_440),(if success?(3-proj-7-tuple(v_433)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-2-tuple(v_439))))) then dhexp(2-proj-2-tuple(v_439),v_436) else fail-any) else fail-any))) in
        {54}let v_443: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_440),(if success?(3-proj-7-tuple(v_433)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-2-tuple(v_439))))) then dhexp(2-proj-2-tuple(v_439),v_436) else fail-any) else fail-any))) in
        {55}let v_444: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_433)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-2-tuple(v_439))))) then dhexp(2-proj-2-tuple(v_439),v_436) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_440))) then (if not-caught-fail(v_441) then (if not-caught-fail(v_442) then (if not-caught-fail(v_443) then (v_441,v_442,v_443) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {56}let v_445: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_433)) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-2-tuple(v_439))))) then dhexp(2-proj-2-tuple(v_439),v_436) else fail-any) else fail-any)) then (if (not-caught-fail(v_440) && success?(is-true(success?(1-proj-3-tuple(v_440))))) then (if (not-caught-fail(v_444) && success?(is-true(success?(1-proj-3-tuple(v_444))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_444)) then cipherstatepack(2-proj-3-tuple(v_444),minnonce) else fail-any),1-proj-3-tuple(v_444),3-proj-3-tuple(v_440)) else fail-any) else fail-any) else fail-any)) in
        {57}let v_446: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_433))) in
        {58}let v_447: bitstring = catch-fail(symmetricstateunpack(v_445)) in
        {59}let v_448: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_447),(if success?(2-proj-7-tuple(v_433)) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then dhexp(2-proj-2-tuple(v_446),v_436) else fail-any) else fail-any))) in
        {60}let v_449: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_447),(if success?(2-proj-7-tuple(v_433)) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then dhexp(2-proj-2-tuple(v_446),v_436) else fail-any) else fail-any))) in
        {61}let v_450: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_447),(if success?(2-proj-7-tuple(v_433)) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then dhexp(2-proj-2-tuple(v_446),v_436) else fail-any) else fail-any))) in
        {62}let v_451: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_433)) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then dhexp(2-proj-2-tuple(v_446),v_436) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_447))) then (if not-caught-fail(v_448) then (if not-caught-fail(v_449) then (if not-caught-fail(v_450) then (v_448,v_449,v_450) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {63}let v_452: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_433)) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then dhexp(2-proj-2-tuple(v_446),v_436) else fail-any) else fail-any)) then (if (not-caught-fail(v_447) && success?(is-true(success?(1-proj-3-tuple(v_447))))) then (if (not-caught-fail(v_451) && success?(is-true(success?(1-proj-3-tuple(v_451))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_451)) then cipherstatepack(2-proj-3-tuple(v_451),minnonce) else fail-any),1-proj-3-tuple(v_451),3-proj-3-tuple(v_447)) else fail-any) else fail-any) else fail-any)) in
        {64}let v_453: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_433))) in
        {65}let v_454: bitstring = catch-fail(symmetricstateunpack(v_452)) in
        {66}let v_455: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_454),(if (success?(4-proj-7-tuple(v_433)) && success?(3-proj-7-tuple(v_433))) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-2-tuple(v_453))))) then dhexp(2-proj-2-tuple(v_453),4-proj-7-tuple(v_433)) else fail-any) else fail-any))) in
        {67}let v_456: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_454),(if (success?(4-proj-7-tuple(v_433)) && success?(3-proj-7-tuple(v_433))) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-2-tuple(v_453))))) then dhexp(2-proj-2-tuple(v_453),4-proj-7-tuple(v_433)) else fail-any) else fail-any))) in
        {68}let v_457: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_454),(if (success?(4-proj-7-tuple(v_433)) && success?(3-proj-7-tuple(v_433))) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-2-tuple(v_453))))) then dhexp(2-proj-2-tuple(v_453),4-proj-7-tuple(v_433)) else fail-any) else fail-any))) in
        {69}let v_458: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_433)) && success?(3-proj-7-tuple(v_433))) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-2-tuple(v_453))))) then dhexp(2-proj-2-tuple(v_453),4-proj-7-tuple(v_433)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_454))) then (if not-caught-fail(v_455) then (if not-caught-fail(v_456) then (if not-caught-fail(v_457) then (v_455,v_456,v_457) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {70}let v_459: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_433)) && success?(3-proj-7-tuple(v_433))) then (if (not-caught-fail(v_453) && success?(is-true(success?(1-proj-2-tuple(v_453))))) then dhexp(2-proj-2-tuple(v_453),4-proj-7-tuple(v_433)) else fail-any) else fail-any)) then (if (not-caught-fail(v_454) && success?(is-true(success?(1-proj-3-tuple(v_454))))) then (if (not-caught-fail(v_458) && success?(is-true(success?(1-proj-3-tuple(v_458))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_458)) then cipherstatepack(2-proj-3-tuple(v_458),minnonce) else fail-any),1-proj-3-tuple(v_458),3-proj-3-tuple(v_454)) else fail-any) else fail-any) else fail-any)) in
        {71}let v_460: bitstring = catch-fail(symmetricstateunpack(v_459)) in
        {72}let v_461: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_460))) in
        {73}let v_462: aead = catch-fail(decrypt(1-proj-2-tuple(v_461),2-proj-2-tuple(v_461),3-proj-3-tuple(v_460),3-proj-3-tuple(v_434))) in
        {74}let v_463: bitstring = catch-fail(aeadunpack(v_462)) in
        {75}let v_464: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_460))) in
        {76}let v_465: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_461))) && success?(1-proj-3-tuple(v_460))) then (if (not-caught-fail(v_464) && success?(is-true(success?(1-proj-2-tuple(v_464))))) then cipherstatepack(1-proj-2-tuple(v_464),increment_nonce(2-proj-2-tuple(v_461))) else fail-any) else fail-any)) in
        {77}let v_466: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_434)) && (success?(3-proj-3-tuple(v_460)) && success?(1-proj-3-tuple(v_460)))) then (if (not-caught-fail(v_461) && success?(is-true(success?(1-proj-2-tuple(v_461))))) then (if not-caught-fail(v_462) then (if (not-caught-fail(v_463) && success?(is-true(success?(1-proj-3-tuple(v_463))))) then (if not-caught-fail(v_465) then (v_465,3-proj-3-tuple(v_463),1-proj-3-tuple(v_463)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {78}let v_467: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_466),2-proj-3-tuple(v_460),3-proj-3-tuple(v_460)))) in
        {79}let v_468: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_434)) && success?(symmetricstatepack(1-proj-3-tuple(v_466),2-proj-3-tuple(v_460),3-proj-3-tuple(v_460)))) then (if (not-caught-fail(v_467) && success?(is-true(success?(1-proj-3-tuple(v_467))))) then symmetricstatepack(1-proj-3-tuple(v_467),2-proj-3-tuple(v_467),hash(3-proj-3-tuple(v_467),3-proj-3-tuple(v_434))) else fail-any) else fail-any)) in
        {80}let v_469: bitstring = catch-fail((if success?(3-proj-3-tuple(v_434)) then (if (not-caught-fail(v_460) && success?(is-true(success?(1-proj-3-tuple(v_460))))) then (if (not-caught-fail(v_466) && success?(is-true(success?(1-proj-3-tuple(v_466))))) then (if not-caught-fail(v_468) then (v_468,2-proj-3-tuple(v_466),3-proj-3-tuple(v_466)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {81}let v_470: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_469),2-proj-7-tuple(v_433),3-proj-7-tuple(v_433),4-proj-7-tuple(v_433),v_436,6-proj-7-tuple(v_433),7-proj-7-tuple(v_433))) in
        {82}let v_471: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_469))) in
        {83}let v_472: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_471),zero)) in
        {84}let v_473: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_471),zero)) in
        {85}let v_474: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_471),zero)) in
        {86}let v_475: bitstring = catch-fail((if success?(2-proj-3-tuple(v_471)) then (if not-caught-fail(v_472) then (if not-caught-fail(v_473) then (if not-caught-fail(v_474) then (v_472,v_473,v_474) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {87}let v_476: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_475)) then cipherstatepack(1-proj-3-tuple(v_475),minnonce) else fail-any)) in
        {88}let v_477: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_475)) then cipherstatepack(2-proj-3-tuple(v_475),minnonce) else fail-any)) in
        {89}let v_478: bitstring = catch-fail((if success?(1-proj-3-tuple(v_469)) then (if (not-caught-fail(v_471) && success?(is-true(success?(1-proj-3-tuple(v_471))))) then (if (not-caught-fail(v_475) && success?(is-true(success?(1-proj-3-tuple(v_475))))) then (if not-caught-fail(v_476) then (if not-caught-fail(v_477) then (1-proj-3-tuple(v_469),v_476,v_477) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {90}let (hs_479: handshakestate,re_480: key,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_433) && success?(is-true(success?(1-proj-7-tuple(v_433))))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-3-tuple(v_434))))) then (if not-caught-fail(v_435) then (if not-caught-fail(v_436) then (if not-caught-fail(v_438) then (if not-caught-fail(v_445) then (if not-caught-fail(v_452) then (if not-caught-fail(v_459) then (if (not-caught-fail(v_469) && success?(is-true(success?(1-proj-3-tuple(v_469))))) then (if (v_435 && 3-proj-3-tuple(v_469)) then (if not-caught-fail(v_470) then (if (not-caught-fail(v_478) && success?(is-true(success?(1-proj-3-tuple(v_478))))) then (v_470,getpublickey(3-proj-7-tuple(v_433)),2-proj-3-tuple(v_469),true,2-proj-3-tuple(v_478),3-proj-3-tuple(v_478)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {91}event RecvMsg(alice,bob,stage_b,plaintext_b,valid);
        {92}insert statestore(alice,bob,statepack_c(hs_479));
        {93}event RecvEnd(valid)
    ) | (
        {95}event LeakS(phase0,alice);
        {96}out(pub, key_s(alice))
    ) | (
        {97}phase 1;
        {98}event LeakS(phase1,alice);
        {99}out(pub, key_s(alice))
    )
) | (
    {100}let v_481: key = catch-fail(dhexp(key_s(alice),g)) in
    {101}let s_482: keypair = (if not-caught-fail(v_481) then keypairpack(v_481,key_s(alice)) else fail-any) in
    {102}out(pub, getpublickey(s_482));
    (
        {103}let e_483: keypair = keypairpack(empty,empty) in
        {104}let v_484: key = catch-fail(dhexp(key_s(charlie),g)) in
        {105}let rs_485: key = getpublickey((if not-caught-fail(v_484) then keypairpack(v_484,key_s(charlie)) else fail-any)) in
        {106}let re_486: key = empty in
        {107}let v_487: bitstring = catch-fail(hash(somename,empty)) in
        {108}let v_488: key = catch-fail(v_487) in
        {109}let v_489: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {110}let v_490: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_487) then (if not-caught-fail(v_488) then (if not-caught-fail(v_489) then symmetricstatepack(v_489,v_488,v_487) else fail-any) else fail-any) else fail-any))) in
        {111}let v_491: symmetricstate = catch-fail((if success?((if not-caught-fail(v_487) then (if not-caught-fail(v_488) then (if not-caught-fail(v_489) then symmetricstatepack(v_489,v_488,v_487) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_490) && success?(is-true(success?(1-proj-3-tuple(v_490))))) then symmetricstatepack(1-proj-3-tuple(v_490),2-proj-3-tuple(v_490),hash(3-proj-3-tuple(v_490),empty)) else fail-any) else fail-any)) in
        {112}let v_492: bitstring = catch-fail(symmetricstateunpack(v_491)) in
        {113}let v_493: symmetricstate = catch-fail((if success?(getpublickey(s_482)) then (if (not-caught-fail(v_492) && success?(is-true(success?(1-proj-3-tuple(v_492))))) then symmetricstatepack(1-proj-3-tuple(v_492),2-proj-3-tuple(v_492),hash(3-proj-3-tuple(v_492),getpublickey(s_482))) else fail-any) else fail-any)) in
        {114}let v_494: bitstring = catch-fail(symmetricstateunpack(v_493)) in
        {115}let v_495: symmetricstate = catch-fail((if (not-caught-fail(v_494) && success?(is-true(success?(1-proj-3-tuple(v_494))))) then symmetricstatepack(1-proj-3-tuple(v_494),2-proj-3-tuple(v_494),hash(3-proj-3-tuple(v_494),rs_485)) else fail-any)) in
        {116}let hs_496: handshakestate = (if not-caught-fail(v_491) then (if not-caught-fail(v_493) then (if not-caught-fail(v_495) then handshakestatepack(v_495,s_482,e_483,rs_485,re_486,empty,true) else fail-any) else fail-any) else fail-any) in
        {117}insert statestore(alice,charlie,statepack_a(hs_496))
    ) | (
        {140}get statestore(=alice,=charlie,statepack_a(hs_497: handshakestate)) in
        {118}let v_498: bitstring = catch-fail(handshakestateunpack(hs_497)) in
        {119}let v_499: bitstring = catch-fail((empty,empty,empty)) in
        {120}let v_500: key = catch-fail(dhexp(key_e(alice,charlie),g)) in
        {121}let v_501: keypair = catch-fail((if not-caught-fail(v_500) then keypairpack(v_500,key_e(alice,charlie)) else fail-any)) in
        {122}let v_502: bitstring = catch-fail(getpublickey(v_501)) in
        {123}let v_503: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_498))) in
        {124}let v_504: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_498)) then (if (not-caught-fail(v_503) && success?(is-true(success?(1-proj-3-tuple(v_503))))) then symmetricstatepack(1-proj-3-tuple(v_503),2-proj-3-tuple(v_503),hash(3-proj-3-tuple(v_503),v_502)) else fail-any) else fail-any)) in
        {125}let v_505: bitstring = catch-fail(symmetricstateunpack(v_504)) in
        {126}let v_506: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_505))) in
        {127}let v_507: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_506),2-proj-2-tuple(v_506),3-proj-3-tuple(v_505),msg_a(alice,charlie))) in
        {128}let v_508: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_505))) in
        {129}let v_509: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_506))) && success?(1-proj-3-tuple(v_505))) then (if (not-caught-fail(v_508) && success?(is-true(success?(1-proj-2-tuple(v_508))))) then cipherstatepack(1-proj-2-tuple(v_508),increment_nonce(2-proj-2-tuple(v_506))) else fail-any) else fail-any)) in
        {130}let v_510: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_505)) && success?(1-proj-3-tuple(v_505))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then (if not-caught-fail(v_507) then (if not-caught-fail(v_509) then (v_509,v_507) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {131}let v_511: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_510),2-proj-3-tuple(v_505),3-proj-3-tuple(v_505)))) in
        {132}let v_512: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_510)) && success?(symmetricstatepack(1-proj-2-tuple(v_510),2-proj-3-tuple(v_505),3-proj-3-tuple(v_505)))) then (if (not-caught-fail(v_511) && success?(is-true(success?(1-proj-3-tuple(v_511))))) then symmetricstatepack(1-proj-3-tuple(v_511),2-proj-3-tuple(v_511),hash(3-proj-3-tuple(v_511),2-proj-2-tuple(v_510))) else fail-any) else fail-any)) in
        {133}let v_513: bitstring = catch-fail((if (not-caught-fail(v_505) && success?(is-true(success?(1-proj-3-tuple(v_505))))) then (if (not-caught-fail(v_510) && success?(is-true(success?(1-proj-2-tuple(v_510))))) then (if not-caught-fail(v_512) then (v_512,2-proj-2-tuple(v_510)) else fail-any) else fail-any) else fail-any)) in
        {134}let v_514: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_513),2-proj-7-tuple(v_498),v_501,4-proj-7-tuple(v_498),5-proj-7-tuple(v_498),6-proj-7-tuple(v_498),7-proj-7-tuple(v_498))) in
        {135}let v_515: bitstring = catch-fail(concat3(v_502,2-proj-3-tuple(v_499),2-proj-2-tuple(v_513))) in
        {136}let (hs_516: handshakestate,re_517: key,message_a_518: bitstring) = (if (not-caught-fail(v_498) && success?(is-true(success?(1-proj-7-tuple(v_498))))) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-3-tuple(v_499))))) then (if not-caught-fail(v_501) then (if not-caught-fail(v_502) then (if not-caught-fail(v_504) then (if (not-caught-fail(v_513) && success?(is-true(success?(1-proj-2-tuple(v_513))))) then (if not-caught-fail(v_514) then (if not-caught-fail(v_515) then (v_514,5-proj-7-tuple(v_498),v_515) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {137}event SendMsg(alice,charlie,stage_a,msg_a(alice,charlie),true);
        {138}insert statestore(alice,charlie,statepack_b(hs_516));
        {139}out(pub, message_a_518)
    ) | (
        {192}get statestore(=alice,=charlie,statepack_b(hs_519: handshakestate)) in
        {141}in(pub, message_b_520: bitstring);
        {142}let v_521: bitstring = catch-fail(handshakestateunpack(hs_519)) in
        {143}let v_522: bitstring = catch-fail(deconcat3(message_b_520)) in
        {144}let v_523: bool = catch-fail(true) in
        {145}let v_524: key = catch-fail(1-proj-3-tuple(v_522)) in
        {146}let v_525: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_521))) in
        {147}let v_526: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_521)) then (if (not-caught-fail(v_525) && success?(is-true(success?(1-proj-3-tuple(v_525))))) then symmetricstatepack(1-proj-3-tuple(v_525),2-proj-3-tuple(v_525),hash(3-proj-3-tuple(v_525),v_524)) else fail-any) else fail-any)) in
        {148}let v_527: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_521))) in
        {149}let v_528: bitstring = catch-fail(symmetricstateunpack(v_526)) in
        {150}let v_529: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_528),(if success?(3-proj-7-tuple(v_521)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-2-tuple(v_527))))) then dhexp(2-proj-2-tuple(v_527),v_524) else fail-any) else fail-any))) in
        {151}let v_530: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_528),(if success?(3-proj-7-tuple(v_521)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-2-tuple(v_527))))) then dhexp(2-proj-2-tuple(v_527),v_524) else fail-any) else fail-any))) in
        {152}let v_531: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_528),(if success?(3-proj-7-tuple(v_521)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-2-tuple(v_527))))) then dhexp(2-proj-2-tuple(v_527),v_524) else fail-any) else fail-any))) in
        {153}let v_532: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_521)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-2-tuple(v_527))))) then dhexp(2-proj-2-tuple(v_527),v_524) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_528))) then (if not-caught-fail(v_529) then (if not-caught-fail(v_530) then (if not-caught-fail(v_531) then (v_529,v_530,v_531) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {154}let v_533: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_521)) then (if (not-caught-fail(v_527) && success?(is-true(success?(1-proj-2-tuple(v_527))))) then dhexp(2-proj-2-tuple(v_527),v_524) else fail-any) else fail-any)) then (if (not-caught-fail(v_528) && success?(is-true(success?(1-proj-3-tuple(v_528))))) then (if (not-caught-fail(v_532) && success?(is-true(success?(1-proj-3-tuple(v_532))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_532)) then cipherstatepack(2-proj-3-tuple(v_532),minnonce) else fail-any),1-proj-3-tuple(v_532),3-proj-3-tuple(v_528)) else fail-any) else fail-any) else fail-any)) in
        {155}let v_534: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_521))) in
        {156}let v_535: bitstring = catch-fail(symmetricstateunpack(v_533)) in
        {157}let v_536: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_535),(if success?(2-proj-7-tuple(v_521)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then dhexp(2-proj-2-tuple(v_534),v_524) else fail-any) else fail-any))) in
        {158}let v_537: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_535),(if success?(2-proj-7-tuple(v_521)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then dhexp(2-proj-2-tuple(v_534),v_524) else fail-any) else fail-any))) in
        {159}let v_538: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_535),(if success?(2-proj-7-tuple(v_521)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then dhexp(2-proj-2-tuple(v_534),v_524) else fail-any) else fail-any))) in
        {160}let v_539: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_521)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then dhexp(2-proj-2-tuple(v_534),v_524) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_535))) then (if not-caught-fail(v_536) then (if not-caught-fail(v_537) then (if not-caught-fail(v_538) then (v_536,v_537,v_538) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {161}let v_540: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_521)) then (if (not-caught-fail(v_534) && success?(is-true(success?(1-proj-2-tuple(v_534))))) then dhexp(2-proj-2-tuple(v_534),v_524) else fail-any) else fail-any)) then (if (not-caught-fail(v_535) && success?(is-true(success?(1-proj-3-tuple(v_535))))) then (if (not-caught-fail(v_539) && success?(is-true(success?(1-proj-3-tuple(v_539))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_539)) then cipherstatepack(2-proj-3-tuple(v_539),minnonce) else fail-any),1-proj-3-tuple(v_539),3-proj-3-tuple(v_535)) else fail-any) else fail-any) else fail-any)) in
        {162}let v_541: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_521))) in
        {163}let v_542: bitstring = catch-fail(symmetricstateunpack(v_540)) in
        {164}let v_543: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_542),(if (success?(4-proj-7-tuple(v_521)) && success?(3-proj-7-tuple(v_521))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-2-tuple(v_541))))) then dhexp(2-proj-2-tuple(v_541),4-proj-7-tuple(v_521)) else fail-any) else fail-any))) in
        {165}let v_544: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_542),(if (success?(4-proj-7-tuple(v_521)) && success?(3-proj-7-tuple(v_521))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-2-tuple(v_541))))) then dhexp(2-proj-2-tuple(v_541),4-proj-7-tuple(v_521)) else fail-any) else fail-any))) in
        {166}let v_545: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_542),(if (success?(4-proj-7-tuple(v_521)) && success?(3-proj-7-tuple(v_521))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-2-tuple(v_541))))) then dhexp(2-proj-2-tuple(v_541),4-proj-7-tuple(v_521)) else fail-any) else fail-any))) in
        {167}let v_546: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_521)) && success?(3-proj-7-tuple(v_521))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-2-tuple(v_541))))) then dhexp(2-proj-2-tuple(v_541),4-proj-7-tuple(v_521)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_542))) then (if not-caught-fail(v_543) then (if not-caught-fail(v_544) then (if not-caught-fail(v_545) then (v_543,v_544,v_545) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {168}let v_547: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_521)) && success?(3-proj-7-tuple(v_521))) then (if (not-caught-fail(v_541) && success?(is-true(success?(1-proj-2-tuple(v_541))))) then dhexp(2-proj-2-tuple(v_541),4-proj-7-tuple(v_521)) else fail-any) else fail-any)) then (if (not-caught-fail(v_542) && success?(is-true(success?(1-proj-3-tuple(v_542))))) then (if (not-caught-fail(v_546) && success?(is-true(success?(1-proj-3-tuple(v_546))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_546)) then cipherstatepack(2-proj-3-tuple(v_546),minnonce) else fail-any),1-proj-3-tuple(v_546),3-proj-3-tuple(v_542)) else fail-any) else fail-any) else fail-any)) in
        {169}let v_548: bitstring = catch-fail(symmetricstateunpack(v_547)) in
        {170}let v_549: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_548))) in
        {171}let v_550: aead = catch-fail(decrypt(1-proj-2-tuple(v_549),2-proj-2-tuple(v_549),3-proj-3-tuple(v_548),3-proj-3-tuple(v_522))) in
        {172}let v_551: bitstring = catch-fail(aeadunpack(v_550)) in
        {173}let v_552: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_548))) in
        {174}let v_553: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_549))) && success?(1-proj-3-tuple(v_548))) then (if (not-caught-fail(v_552) && success?(is-true(success?(1-proj-2-tuple(v_552))))) then cipherstatepack(1-proj-2-tuple(v_552),increment_nonce(2-proj-2-tuple(v_549))) else fail-any) else fail-any)) in
        {175}let v_554: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_522)) && (success?(3-proj-3-tuple(v_548)) && success?(1-proj-3-tuple(v_548)))) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-2-tuple(v_549))))) then (if not-caught-fail(v_550) then (if (not-caught-fail(v_551) && success?(is-true(success?(1-proj-3-tuple(v_551))))) then (if not-caught-fail(v_553) then (v_553,3-proj-3-tuple(v_551),1-proj-3-tuple(v_551)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {176}let v_555: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_554),2-proj-3-tuple(v_548),3-proj-3-tuple(v_548)))) in
        {177}let v_556: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_522)) && success?(symmetricstatepack(1-proj-3-tuple(v_554),2-proj-3-tuple(v_548),3-proj-3-tuple(v_548)))) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-3-tuple(v_555))))) then symmetricstatepack(1-proj-3-tuple(v_555),2-proj-3-tuple(v_555),hash(3-proj-3-tuple(v_555),3-proj-3-tuple(v_522))) else fail-any) else fail-any)) in
        {178}let v_557: bitstring = catch-fail((if success?(3-proj-3-tuple(v_522)) then (if (not-caught-fail(v_548) && success?(is-true(success?(1-proj-3-tuple(v_548))))) then (if (not-caught-fail(v_554) && success?(is-true(success?(1-proj-3-tuple(v_554))))) then (if not-caught-fail(v_556) then (v_556,2-proj-3-tuple(v_554),3-proj-3-tuple(v_554)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {179}let v_558: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_557),2-proj-7-tuple(v_521),3-proj-7-tuple(v_521),4-proj-7-tuple(v_521),v_524,6-proj-7-tuple(v_521),7-proj-7-tuple(v_521))) in
        {180}let v_559: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_557))) in
        {181}let v_560: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_559),zero)) in
        {182}let v_561: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_559),zero)) in
        {183}let v_562: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_559),zero)) in
        {184}let v_563: bitstring = catch-fail((if success?(2-proj-3-tuple(v_559)) then (if not-caught-fail(v_560) then (if not-caught-fail(v_561) then (if not-caught-fail(v_562) then (v_560,v_561,v_562) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {185}let v_564: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_563)) then cipherstatepack(1-proj-3-tuple(v_563),minnonce) else fail-any)) in
        {186}let v_565: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_563)) then cipherstatepack(2-proj-3-tuple(v_563),minnonce) else fail-any)) in
        {187}let v_566: bitstring = catch-fail((if success?(1-proj-3-tuple(v_557)) then (if (not-caught-fail(v_559) && success?(is-true(success?(1-proj-3-tuple(v_559))))) then (if (not-caught-fail(v_563) && success?(is-true(success?(1-proj-3-tuple(v_563))))) then (if not-caught-fail(v_564) then (if not-caught-fail(v_565) then (1-proj-3-tuple(v_557),v_564,v_565) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {188}let (hs_567: handshakestate,re_568: key,plaintext_b_569: bitstring,valid_570: bool,cs1_571: cipherstate,cs2_572: cipherstate) = (if (not-caught-fail(v_521) && success?(is-true(success?(1-proj-7-tuple(v_521))))) then (if (not-caught-fail(v_522) && success?(is-true(success?(1-proj-3-tuple(v_522))))) then (if not-caught-fail(v_523) then (if not-caught-fail(v_524) then (if not-caught-fail(v_526) then (if not-caught-fail(v_533) then (if not-caught-fail(v_540) then (if not-caught-fail(v_547) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-3-tuple(v_557))))) then (if (v_523 && 3-proj-3-tuple(v_557)) then (if not-caught-fail(v_558) then (if (not-caught-fail(v_566) && success?(is-true(success?(1-proj-3-tuple(v_566))))) then (v_558,getpublickey(3-proj-7-tuple(v_521)),2-proj-3-tuple(v_557),true,2-proj-3-tuple(v_566),3-proj-3-tuple(v_566)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {189}event RecvMsg(alice,charlie,stage_b,plaintext_b_569,valid_570);
        {190}insert statestore(alice,charlie,statepack_c(hs_567));
        {191}event RecvEnd(valid_570)
    ) | (
        {193}event LeakS(phase0,alice);
        {194}out(pub, key_s(alice))
    ) | (
        {195}phase 1;
        {196}event LeakS(phase1,alice);
        {197}out(pub, key_s(alice))
    )
) | (
    {198}let v_573: key = catch-fail(dhexp(key_s(bob),g)) in
    {199}let s_574: keypair = (if not-caught-fail(v_573) then keypairpack(v_573,key_s(bob)) else fail-any) in
    {200}out(pub, getpublickey(s_574));
    (
        {201}let e_575: keypair = keypairpack(empty,empty) in
        {202}let v_576: key = catch-fail(dhexp(key_s(alice),g)) in
        {203}let rs_577: key = getpublickey((if not-caught-fail(v_576) then keypairpack(v_576,key_s(alice)) else fail-any)) in
        {204}let re_578: key = empty in
        {205}let v_579: bitstring = catch-fail(hash(somename,empty)) in
        {206}let v_580: key = catch-fail(v_579) in
        {207}let v_581: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {208}let v_582: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (if not-caught-fail(v_581) then symmetricstatepack(v_581,v_580,v_579) else fail-any) else fail-any) else fail-any))) in
        {209}let v_583: symmetricstate = catch-fail((if success?((if not-caught-fail(v_579) then (if not-caught-fail(v_580) then (if not-caught-fail(v_581) then symmetricstatepack(v_581,v_580,v_579) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_582) && success?(is-true(success?(1-proj-3-tuple(v_582))))) then symmetricstatepack(1-proj-3-tuple(v_582),2-proj-3-tuple(v_582),hash(3-proj-3-tuple(v_582),empty)) else fail-any) else fail-any)) in
        {210}let v_584: bitstring = catch-fail(symmetricstateunpack(v_583)) in
        {211}let v_585: symmetricstate = catch-fail((if (not-caught-fail(v_584) && success?(is-true(success?(1-proj-3-tuple(v_584))))) then symmetricstatepack(1-proj-3-tuple(v_584),2-proj-3-tuple(v_584),hash(3-proj-3-tuple(v_584),rs_577)) else fail-any)) in
        {212}let v_586: bitstring = catch-fail(symmetricstateunpack(v_585)) in
        {213}let v_587: symmetricstate = catch-fail((if success?(getpublickey(s_574)) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then symmetricstatepack(1-proj-3-tuple(v_586),2-proj-3-tuple(v_586),hash(3-proj-3-tuple(v_586),getpublickey(s_574))) else fail-any) else fail-any)) in
        {214}let hs_588: handshakestate = (if not-caught-fail(v_583) then (if not-caught-fail(v_585) then (if not-caught-fail(v_587) then handshakestatepack(v_587,s_574,e_575,rs_577,re_578,empty,false) else fail-any) else fail-any) else fail-any) in
        {215}insert statestore(bob,alice,statepack_a(hs_588))
    ) | (
        {237}get statestore(=bob,=alice,statepack_a(hs_589: handshakestate)) in
        {216}in(pub, message_a_590: bitstring);
        {217}let v_591: bitstring = catch-fail(handshakestateunpack(hs_589)) in
        {218}let v_592: bitstring = catch-fail(deconcat3(message_a_590)) in
        {219}let v_593: bool = catch-fail(true) in
        {220}let v_594: key = catch-fail(1-proj-3-tuple(v_592)) in
        {221}let v_595: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_591))) in
        {222}let v_596: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_591)) then (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-3-tuple(v_595))))) then symmetricstatepack(1-proj-3-tuple(v_595),2-proj-3-tuple(v_595),hash(3-proj-3-tuple(v_595),v_594)) else fail-any) else fail-any)) in
        {223}let v_597: bitstring = catch-fail(symmetricstateunpack(v_596)) in
        {224}let v_598: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_597))) in
        {225}let v_599: aead = catch-fail(decrypt(1-proj-2-tuple(v_598),2-proj-2-tuple(v_598),3-proj-3-tuple(v_597),3-proj-3-tuple(v_592))) in
        {226}let v_600: bitstring = catch-fail(aeadunpack(v_599)) in
        {227}let v_601: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_597))) in
        {228}let v_602: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_598))) && success?(1-proj-3-tuple(v_597))) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-2-tuple(v_601))))) then cipherstatepack(1-proj-2-tuple(v_601),increment_nonce(2-proj-2-tuple(v_598))) else fail-any) else fail-any)) in
        {229}let v_603: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_592)) && (success?(3-proj-3-tuple(v_597)) && success?(1-proj-3-tuple(v_597)))) then (if (not-caught-fail(v_598) && success?(is-true(success?(1-proj-2-tuple(v_598))))) then (if not-caught-fail(v_599) then (if (not-caught-fail(v_600) && success?(is-true(success?(1-proj-3-tuple(v_600))))) then (if not-caught-fail(v_602) then (v_602,3-proj-3-tuple(v_600),1-proj-3-tuple(v_600)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {230}let v_604: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_603),2-proj-3-tuple(v_597),3-proj-3-tuple(v_597)))) in
        {231}let v_605: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_592)) && success?(symmetricstatepack(1-proj-3-tuple(v_603),2-proj-3-tuple(v_597),3-proj-3-tuple(v_597)))) then (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-3-tuple(v_604))))) then symmetricstatepack(1-proj-3-tuple(v_604),2-proj-3-tuple(v_604),hash(3-proj-3-tuple(v_604),3-proj-3-tuple(v_592))) else fail-any) else fail-any)) in
        {232}let v_606: bitstring = catch-fail((if success?(3-proj-3-tuple(v_592)) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then (if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-3-tuple(v_603))))) then (if not-caught-fail(v_605) then (v_605,2-proj-3-tuple(v_603),3-proj-3-tuple(v_603)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {233}let v_607: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_606),2-proj-7-tuple(v_591),3-proj-7-tuple(v_591),4-proj-7-tuple(v_591),v_594,6-proj-7-tuple(v_591),7-proj-7-tuple(v_591))) in
        {234}let (hs_608: handshakestate,re_609: key,plaintext_a: bitstring,valid_610: bool) = (if (not-caught-fail(v_591) && success?(is-true(success?(1-proj-7-tuple(v_591))))) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-3-tuple(v_592))))) then (if not-caught-fail(v_593) then (if not-caught-fail(v_594) then (if not-caught-fail(v_596) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-3-tuple(v_606))))) then (if (v_593 && 3-proj-3-tuple(v_606)) then (if not-caught-fail(v_607) then (v_607,getpublickey(3-proj-7-tuple(v_591)),2-proj-3-tuple(v_606),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {235}event RecvMsg(bob,alice,stage_a,plaintext_a,valid_610);
        {236}insert statestore(bob,alice,statepack_b(hs_608))
    ) | (
        {289}get statestore(=bob,=alice,statepack_b(hs_611: handshakestate)) in
        {238}let v_612: bitstring = catch-fail(handshakestateunpack(hs_611)) in
        {239}let v_613: bitstring = catch-fail((empty,empty,empty)) in
        {240}let v_614: key = catch-fail(dhexp(key_e(bob,alice),g)) in
        {241}let v_615: keypair = catch-fail((if not-caught-fail(v_614) then keypairpack(v_614,key_e(bob,alice)) else fail-any)) in
        {242}let v_616: bitstring = catch-fail(getpublickey(v_615)) in
        {243}let v_617: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_612))) in
        {244}let v_618: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_612)) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-3-tuple(v_617))))) then symmetricstatepack(1-proj-3-tuple(v_617),2-proj-3-tuple(v_617),hash(3-proj-3-tuple(v_617),v_616)) else fail-any) else fail-any)) in
        {245}let v_619: bitstring = catch-fail(keypairunpack(v_615)) in
        {246}let v_620: bitstring = catch-fail(symmetricstateunpack(v_618)) in
        {247}let v_621: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_620),(if success?(5-proj-7-tuple(v_612)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then dhexp(2-proj-2-tuple(v_619),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {248}let v_622: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_620),(if success?(5-proj-7-tuple(v_612)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then dhexp(2-proj-2-tuple(v_619),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {249}let v_623: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_620),(if success?(5-proj-7-tuple(v_612)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then dhexp(2-proj-2-tuple(v_619),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {250}let v_624: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_612)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then dhexp(2-proj-2-tuple(v_619),5-proj-7-tuple(v_612)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_620))) then (if not-caught-fail(v_621) then (if not-caught-fail(v_622) then (if not-caught-fail(v_623) then (v_621,v_622,v_623) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {251}let v_625: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_612)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then dhexp(2-proj-2-tuple(v_619),5-proj-7-tuple(v_612)) else fail-any) else fail-any)) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-3-tuple(v_624))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_624)) then cipherstatepack(2-proj-3-tuple(v_624),minnonce) else fail-any),1-proj-3-tuple(v_624),3-proj-3-tuple(v_620)) else fail-any) else fail-any) else fail-any)) in
        {252}let v_626: bitstring = catch-fail(keypairunpack(v_615)) in
        {253}let v_627: bitstring = catch-fail(symmetricstateunpack(v_625)) in
        {254}let v_628: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_627),(if success?(4-proj-7-tuple(v_612)) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-2-tuple(v_626))))) then dhexp(2-proj-2-tuple(v_626),4-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {255}let v_629: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_627),(if success?(4-proj-7-tuple(v_612)) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-2-tuple(v_626))))) then dhexp(2-proj-2-tuple(v_626),4-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {256}let v_630: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_627),(if success?(4-proj-7-tuple(v_612)) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-2-tuple(v_626))))) then dhexp(2-proj-2-tuple(v_626),4-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {257}let v_631: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_612)) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-2-tuple(v_626))))) then dhexp(2-proj-2-tuple(v_626),4-proj-7-tuple(v_612)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_627))) then (if not-caught-fail(v_628) then (if not-caught-fail(v_629) then (if not-caught-fail(v_630) then (v_628,v_629,v_630) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {258}let v_632: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_612)) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-2-tuple(v_626))))) then dhexp(2-proj-2-tuple(v_626),4-proj-7-tuple(v_612)) else fail-any) else fail-any)) then (if (not-caught-fail(v_627) && success?(is-true(success?(1-proj-3-tuple(v_627))))) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_631)) then cipherstatepack(2-proj-3-tuple(v_631),minnonce) else fail-any),1-proj-3-tuple(v_631),3-proj-3-tuple(v_627)) else fail-any) else fail-any) else fail-any)) in
        {259}let v_633: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_612))) in
        {260}let v_634: bitstring = catch-fail(symmetricstateunpack(v_632)) in
        {261}let v_635: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_634),(if (success?(5-proj-7-tuple(v_612)) && success?(2-proj-7-tuple(v_612))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then dhexp(2-proj-2-tuple(v_633),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {262}let v_636: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_634),(if (success?(5-proj-7-tuple(v_612)) && success?(2-proj-7-tuple(v_612))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then dhexp(2-proj-2-tuple(v_633),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {263}let v_637: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_634),(if (success?(5-proj-7-tuple(v_612)) && success?(2-proj-7-tuple(v_612))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then dhexp(2-proj-2-tuple(v_633),5-proj-7-tuple(v_612)) else fail-any) else fail-any))) in
        {264}let v_638: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_612)) && success?(2-proj-7-tuple(v_612))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then dhexp(2-proj-2-tuple(v_633),5-proj-7-tuple(v_612)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_634))) then (if not-caught-fail(v_635) then (if not-caught-fail(v_636) then (if not-caught-fail(v_637) then (v_635,v_636,v_637) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {265}let v_639: symmetricstate = catch-fail((if success?((if (success?(5-proj-7-tuple(v_612)) && success?(2-proj-7-tuple(v_612))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then dhexp(2-proj-2-tuple(v_633),5-proj-7-tuple(v_612)) else fail-any) else fail-any)) then (if (not-caught-fail(v_634) && success?(is-true(success?(1-proj-3-tuple(v_634))))) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-3-tuple(v_638))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_638)) then cipherstatepack(2-proj-3-tuple(v_638),minnonce) else fail-any),1-proj-3-tuple(v_638),3-proj-3-tuple(v_634)) else fail-any) else fail-any) else fail-any)) in
        {266}let v_640: bitstring = catch-fail(symmetricstateunpack(v_639)) in
        {267}let v_641: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_640))) in
        {268}let v_642: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_641),2-proj-2-tuple(v_641),3-proj-3-tuple(v_640),msg_b(bob,alice))) in
        {269}let v_643: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_640))) in
        {270}let v_644: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_641))) && success?(1-proj-3-tuple(v_640))) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-2-tuple(v_643))))) then cipherstatepack(1-proj-2-tuple(v_643),increment_nonce(2-proj-2-tuple(v_641))) else fail-any) else fail-any)) in
        {271}let v_645: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_640)) && success?(1-proj-3-tuple(v_640))) then (if (not-caught-fail(v_641) && success?(is-true(success?(1-proj-2-tuple(v_641))))) then (if not-caught-fail(v_642) then (if not-caught-fail(v_644) then (v_644,v_642) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {272}let v_646: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_645),2-proj-3-tuple(v_640),3-proj-3-tuple(v_640)))) in
        {273}let v_647: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_645)) && success?(symmetricstatepack(1-proj-2-tuple(v_645),2-proj-3-tuple(v_640),3-proj-3-tuple(v_640)))) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-3-tuple(v_646))))) then symmetricstatepack(1-proj-3-tuple(v_646),2-proj-3-tuple(v_646),hash(3-proj-3-tuple(v_646),2-proj-2-tuple(v_645))) else fail-any) else fail-any)) in
        {274}let v_648: bitstring = catch-fail((if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-3-tuple(v_640))))) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-2-tuple(v_645))))) then (if not-caught-fail(v_647) then (v_647,2-proj-2-tuple(v_645)) else fail-any) else fail-any) else fail-any)) in
        {275}let v_649: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_648),2-proj-7-tuple(v_612),v_615,4-proj-7-tuple(v_612),5-proj-7-tuple(v_612),6-proj-7-tuple(v_612),7-proj-7-tuple(v_612))) in
        {276}let v_650: bitstring = catch-fail(concat3(v_616,2-proj-3-tuple(v_613),2-proj-2-tuple(v_648))) in
        {277}let v_651: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_648))) in
        {278}let v_652: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_651),zero)) in
        {279}let v_653: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_651),zero)) in
        {280}let v_654: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_651),zero)) in
        {281}let v_655: bitstring = catch-fail((if success?(2-proj-3-tuple(v_651)) then (if not-caught-fail(v_652) then (if not-caught-fail(v_653) then (if not-caught-fail(v_654) then (v_652,v_653,v_654) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {282}let v_656: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_655)) then cipherstatepack(1-proj-3-tuple(v_655),minnonce) else fail-any)) in
        {283}let v_657: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_655)) then cipherstatepack(2-proj-3-tuple(v_655),minnonce) else fail-any)) in
        {284}let v_658: bitstring = catch-fail((if success?(1-proj-2-tuple(v_648)) then (if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-3-tuple(v_651))))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-3-tuple(v_655))))) then (if not-caught-fail(v_656) then (if not-caught-fail(v_657) then (1-proj-2-tuple(v_648),v_656,v_657) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {285}let (hs_659: handshakestate,re_660: key,message_b_661: bitstring,cs1_662: cipherstate,cs2_663: cipherstate) = (if (not-caught-fail(v_612) && success?(is-true(success?(1-proj-7-tuple(v_612))))) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-3-tuple(v_613))))) then (if not-caught-fail(v_615) then (if not-caught-fail(v_616) then (if not-caught-fail(v_618) then (if not-caught-fail(v_625) then (if not-caught-fail(v_632) then (if not-caught-fail(v_639) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then (if not-caught-fail(v_649) then (if not-caught-fail(v_650) then (if (not-caught-fail(v_658) && success?(is-true(success?(1-proj-3-tuple(v_658))))) then (v_649,5-proj-7-tuple(v_612),v_650,2-proj-3-tuple(v_658),3-proj-3-tuple(v_658)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {286}event SendMsg(bob,alice,stage_b,msg_b(bob,alice),true);
        {287}insert statestore(bob,alice,statepack_c(hs_659));
        {288}out(pub, message_b_661)
    ) | (
        {290}event LeakS(phase0,bob);
        {291}out(pub, key_s(bob))
    ) | (
        {292}phase 1;
        {293}event LeakS(phase1,bob);
        {294}out(pub, key_s(bob))
    )
) | (
    {295}let v_664: key = catch-fail(dhexp(key_s(bob),g)) in
    {296}let s_665: keypair = (if not-caught-fail(v_664) then keypairpack(v_664,key_s(bob)) else fail-any) in
    {297}out(pub, getpublickey(s_665));
    (
        {298}let e_666: keypair = keypairpack(empty,empty) in
        {299}let v_667: key = catch-fail(dhexp(key_s(charlie),g)) in
        {300}let rs_668: key = getpublickey((if not-caught-fail(v_667) then keypairpack(v_667,key_s(charlie)) else fail-any)) in
        {301}let re_669: key = empty in
        {302}let v_670: bitstring = catch-fail(hash(somename,empty)) in
        {303}let v_671: key = catch-fail(v_670) in
        {304}let v_672: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {305}let v_673: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_670) then (if not-caught-fail(v_671) then (if not-caught-fail(v_672) then symmetricstatepack(v_672,v_671,v_670) else fail-any) else fail-any) else fail-any))) in
        {306}let v_674: symmetricstate = catch-fail((if success?((if not-caught-fail(v_670) then (if not-caught-fail(v_671) then (if not-caught-fail(v_672) then symmetricstatepack(v_672,v_671,v_670) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-3-tuple(v_673))))) then symmetricstatepack(1-proj-3-tuple(v_673),2-proj-3-tuple(v_673),hash(3-proj-3-tuple(v_673),empty)) else fail-any) else fail-any)) in
        {307}let v_675: bitstring = catch-fail(symmetricstateunpack(v_674)) in
        {308}let v_676: symmetricstate = catch-fail((if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-3-tuple(v_675))))) then symmetricstatepack(1-proj-3-tuple(v_675),2-proj-3-tuple(v_675),hash(3-proj-3-tuple(v_675),rs_668)) else fail-any)) in
        {309}let v_677: bitstring = catch-fail(symmetricstateunpack(v_676)) in
        {310}let v_678: symmetricstate = catch-fail((if success?(getpublickey(s_665)) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-3-tuple(v_677))))) then symmetricstatepack(1-proj-3-tuple(v_677),2-proj-3-tuple(v_677),hash(3-proj-3-tuple(v_677),getpublickey(s_665))) else fail-any) else fail-any)) in
        {311}let hs_679: handshakestate = (if not-caught-fail(v_674) then (if not-caught-fail(v_676) then (if not-caught-fail(v_678) then handshakestatepack(v_678,s_665,e_666,rs_668,re_669,empty,false) else fail-any) else fail-any) else fail-any) in
        {312}insert statestore(bob,charlie,statepack_a(hs_679))
    ) | (
        {334}get statestore(=bob,=charlie,statepack_a(hs_680: handshakestate)) in
        {313}in(pub, message_a_681: bitstring);
        {314}let v_682: bitstring = catch-fail(handshakestateunpack(hs_680)) in
        {315}let v_683: bitstring = catch-fail(deconcat3(message_a_681)) in
        {316}let v_684: bool = catch-fail(true) in
        {317}let v_685: key = catch-fail(1-proj-3-tuple(v_683)) in
        {318}let v_686: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_682))) in
        {319}let v_687: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_682)) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then symmetricstatepack(1-proj-3-tuple(v_686),2-proj-3-tuple(v_686),hash(3-proj-3-tuple(v_686),v_685)) else fail-any) else fail-any)) in
        {320}let v_688: bitstring = catch-fail(symmetricstateunpack(v_687)) in
        {321}let v_689: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_688))) in
        {322}let v_690: aead = catch-fail(decrypt(1-proj-2-tuple(v_689),2-proj-2-tuple(v_689),3-proj-3-tuple(v_688),3-proj-3-tuple(v_683))) in
        {323}let v_691: bitstring = catch-fail(aeadunpack(v_690)) in
        {324}let v_692: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_688))) in
        {325}let v_693: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_689))) && success?(1-proj-3-tuple(v_688))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then cipherstatepack(1-proj-2-tuple(v_692),increment_nonce(2-proj-2-tuple(v_689))) else fail-any) else fail-any)) in
        {326}let v_694: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_683)) && (success?(3-proj-3-tuple(v_688)) && success?(1-proj-3-tuple(v_688)))) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-2-tuple(v_689))))) then (if not-caught-fail(v_690) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-3-tuple(v_691))))) then (if not-caught-fail(v_693) then (v_693,3-proj-3-tuple(v_691),1-proj-3-tuple(v_691)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {327}let v_695: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_694),2-proj-3-tuple(v_688),3-proj-3-tuple(v_688)))) in
        {328}let v_696: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_683)) && success?(symmetricstatepack(1-proj-3-tuple(v_694),2-proj-3-tuple(v_688),3-proj-3-tuple(v_688)))) then (if (not-caught-fail(v_695) && success?(is-true(success?(1-proj-3-tuple(v_695))))) then symmetricstatepack(1-proj-3-tuple(v_695),2-proj-3-tuple(v_695),hash(3-proj-3-tuple(v_695),3-proj-3-tuple(v_683))) else fail-any) else fail-any)) in
        {329}let v_697: bitstring = catch-fail((if success?(3-proj-3-tuple(v_683)) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-3-tuple(v_688))))) then (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-3-tuple(v_694))))) then (if not-caught-fail(v_696) then (v_696,2-proj-3-tuple(v_694),3-proj-3-tuple(v_694)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {330}let v_698: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_697),2-proj-7-tuple(v_682),3-proj-7-tuple(v_682),4-proj-7-tuple(v_682),v_685,6-proj-7-tuple(v_682),7-proj-7-tuple(v_682))) in
        {331}let (hs_699: handshakestate,re_700: key,plaintext_a_701: bitstring,valid_702: bool) = (if (not-caught-fail(v_682) && success?(is-true(success?(1-proj-7-tuple(v_682))))) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-3-tuple(v_683))))) then (if not-caught-fail(v_684) then (if not-caught-fail(v_685) then (if not-caught-fail(v_687) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then (if (v_684 && 3-proj-3-tuple(v_697)) then (if not-caught-fail(v_698) then (v_698,getpublickey(3-proj-7-tuple(v_682)),2-proj-3-tuple(v_697),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {332}event RecvMsg(bob,charlie,stage_a,plaintext_a_701,valid_702);
        {333}insert statestore(bob,charlie,statepack_b(hs_699))
    ) | (
        {386}get statestore(=bob,=charlie,statepack_b(hs_703: handshakestate)) in
        {335}let v_704: bitstring = catch-fail(handshakestateunpack(hs_703)) in
        {336}let v_705: bitstring = catch-fail((empty,empty,empty)) in
        {337}let v_706: key = catch-fail(dhexp(key_e(bob,charlie),g)) in
        {338}let v_707: keypair = catch-fail((if not-caught-fail(v_706) then keypairpack(v_706,key_e(bob,charlie)) else fail-any)) in
        {339}let v_708: bitstring = catch-fail(getpublickey(v_707)) in
        {340}let v_709: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_704))) in
        {341}let v_710: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_704)) then (if (not-caught-fail(v_709) && success?(is-true(success?(1-proj-3-tuple(v_709))))) then symmetricstatepack(1-proj-3-tuple(v_709),2-proj-3-tuple(v_709),hash(3-proj-3-tuple(v_709),v_708)) else fail-any) else fail-any)) in
        {342}let v_711: bitstring = catch-fail(keypairunpack(v_707)) in
        {343}let v_712: bitstring = catch-fail(symmetricstateunpack(v_710)) in
        {344}let v_713: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_712),(if success?(5-proj-7-tuple(v_704)) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then dhexp(2-proj-2-tuple(v_711),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {345}let v_714: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_712),(if success?(5-proj-7-tuple(v_704)) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then dhexp(2-proj-2-tuple(v_711),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {346}let v_715: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_712),(if success?(5-proj-7-tuple(v_704)) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then dhexp(2-proj-2-tuple(v_711),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {347}let v_716: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_704)) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then dhexp(2-proj-2-tuple(v_711),5-proj-7-tuple(v_704)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_712))) then (if not-caught-fail(v_713) then (if not-caught-fail(v_714) then (if not-caught-fail(v_715) then (v_713,v_714,v_715) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {348}let v_717: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_704)) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-2-tuple(v_711))))) then dhexp(2-proj-2-tuple(v_711),5-proj-7-tuple(v_704)) else fail-any) else fail-any)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-3-tuple(v_712))))) then (if (not-caught-fail(v_716) && success?(is-true(success?(1-proj-3-tuple(v_716))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_716)) then cipherstatepack(2-proj-3-tuple(v_716),minnonce) else fail-any),1-proj-3-tuple(v_716),3-proj-3-tuple(v_712)) else fail-any) else fail-any) else fail-any)) in
        {349}let v_718: bitstring = catch-fail(keypairunpack(v_707)) in
        {350}let v_719: bitstring = catch-fail(symmetricstateunpack(v_717)) in
        {351}let v_720: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_719),(if success?(4-proj-7-tuple(v_704)) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then dhexp(2-proj-2-tuple(v_718),4-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {352}let v_721: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_719),(if success?(4-proj-7-tuple(v_704)) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then dhexp(2-proj-2-tuple(v_718),4-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {353}let v_722: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_719),(if success?(4-proj-7-tuple(v_704)) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then dhexp(2-proj-2-tuple(v_718),4-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {354}let v_723: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_704)) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then dhexp(2-proj-2-tuple(v_718),4-proj-7-tuple(v_704)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_719))) then (if not-caught-fail(v_720) then (if not-caught-fail(v_721) then (if not-caught-fail(v_722) then (v_720,v_721,v_722) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {355}let v_724: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_704)) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then dhexp(2-proj-2-tuple(v_718),4-proj-7-tuple(v_704)) else fail-any) else fail-any)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-3-tuple(v_719))))) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_723)) then cipherstatepack(2-proj-3-tuple(v_723),minnonce) else fail-any),1-proj-3-tuple(v_723),3-proj-3-tuple(v_719)) else fail-any) else fail-any) else fail-any)) in
        {356}let v_725: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_704))) in
        {357}let v_726: bitstring = catch-fail(symmetricstateunpack(v_724)) in
        {358}let v_727: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_726),(if (success?(5-proj-7-tuple(v_704)) && success?(2-proj-7-tuple(v_704))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {359}let v_728: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_726),(if (success?(5-proj-7-tuple(v_704)) && success?(2-proj-7-tuple(v_704))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {360}let v_729: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_726),(if (success?(5-proj-7-tuple(v_704)) && success?(2-proj-7-tuple(v_704))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),5-proj-7-tuple(v_704)) else fail-any) else fail-any))) in
        {361}let v_730: bitstring = catch-fail((if (success?((if (success?(5-proj-7-tuple(v_704)) && success?(2-proj-7-tuple(v_704))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),5-proj-7-tuple(v_704)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_726))) then (if not-caught-fail(v_727) then (if not-caught-fail(v_728) then (if not-caught-fail(v_729) then (v_727,v_728,v_729) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {362}let v_731: symmetricstate = catch-fail((if success?((if (success?(5-proj-7-tuple(v_704)) && success?(2-proj-7-tuple(v_704))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then dhexp(2-proj-2-tuple(v_725),5-proj-7-tuple(v_704)) else fail-any) else fail-any)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-3-tuple(v_726))))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-3-tuple(v_730))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_730)) then cipherstatepack(2-proj-3-tuple(v_730),minnonce) else fail-any),1-proj-3-tuple(v_730),3-proj-3-tuple(v_726)) else fail-any) else fail-any) else fail-any)) in
        {363}let v_732: bitstring = catch-fail(symmetricstateunpack(v_731)) in
        {364}let v_733: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_732))) in
        {365}let v_734: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_733),2-proj-2-tuple(v_733),3-proj-3-tuple(v_732),msg_b(bob,charlie))) in
        {366}let v_735: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_732))) in
        {367}let v_736: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_733))) && success?(1-proj-3-tuple(v_732))) then (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-2-tuple(v_735))))) then cipherstatepack(1-proj-2-tuple(v_735),increment_nonce(2-proj-2-tuple(v_733))) else fail-any) else fail-any)) in
        {368}let v_737: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_732)) && success?(1-proj-3-tuple(v_732))) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-2-tuple(v_733))))) then (if not-caught-fail(v_734) then (if not-caught-fail(v_736) then (v_736,v_734) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {369}let v_738: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_737),2-proj-3-tuple(v_732),3-proj-3-tuple(v_732)))) in
        {370}let v_739: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_737)) && success?(symmetricstatepack(1-proj-2-tuple(v_737),2-proj-3-tuple(v_732),3-proj-3-tuple(v_732)))) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-3-tuple(v_738))))) then symmetricstatepack(1-proj-3-tuple(v_738),2-proj-3-tuple(v_738),hash(3-proj-3-tuple(v_738),2-proj-2-tuple(v_737))) else fail-any) else fail-any)) in
        {371}let v_740: bitstring = catch-fail((if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-3-tuple(v_732))))) then (if (not-caught-fail(v_737) && success?(is-true(success?(1-proj-2-tuple(v_737))))) then (if not-caught-fail(v_739) then (v_739,2-proj-2-tuple(v_737)) else fail-any) else fail-any) else fail-any)) in
        {372}let v_741: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_740),2-proj-7-tuple(v_704),v_707,4-proj-7-tuple(v_704),5-proj-7-tuple(v_704),6-proj-7-tuple(v_704),7-proj-7-tuple(v_704))) in
        {373}let v_742: bitstring = catch-fail(concat3(v_708,2-proj-3-tuple(v_705),2-proj-2-tuple(v_740))) in
        {374}let v_743: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_740))) in
        {375}let v_744: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_743),zero)) in
        {376}let v_745: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_743),zero)) in
        {377}let v_746: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_743),zero)) in
        {378}let v_747: bitstring = catch-fail((if success?(2-proj-3-tuple(v_743)) then (if not-caught-fail(v_744) then (if not-caught-fail(v_745) then (if not-caught-fail(v_746) then (v_744,v_745,v_746) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {379}let v_748: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_747)) then cipherstatepack(1-proj-3-tuple(v_747),minnonce) else fail-any)) in
        {380}let v_749: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_747)) then cipherstatepack(2-proj-3-tuple(v_747),minnonce) else fail-any)) in
        {381}let v_750: bitstring = catch-fail((if success?(1-proj-2-tuple(v_740)) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then (if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-3-tuple(v_747))))) then (if not-caught-fail(v_748) then (if not-caught-fail(v_749) then (1-proj-2-tuple(v_740),v_748,v_749) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {382}let (hs_751: handshakestate,re_752: key,message_b_753: bitstring,cs1_754: cipherstate,cs2_755: cipherstate) = (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-7-tuple(v_704))))) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then (if not-caught-fail(v_707) then (if not-caught-fail(v_708) then (if not-caught-fail(v_710) then (if not-caught-fail(v_717) then (if not-caught-fail(v_724) then (if not-caught-fail(v_731) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-2-tuple(v_740))))) then (if not-caught-fail(v_741) then (if not-caught-fail(v_742) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then (v_741,5-proj-7-tuple(v_704),v_742,2-proj-3-tuple(v_750),3-proj-3-tuple(v_750)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {383}event SendMsg(bob,charlie,stage_b,msg_b(bob,charlie),true);
        {384}insert statestore(bob,charlie,statepack_c(hs_751));
        {385}out(pub, message_b_753)
    ) | (
        {387}event LeakS(phase0,bob);
        {388}out(pub, key_s(bob))
    ) | (
        {389}phase 1;
        {390}event LeakS(phase1,bob);
        {391}out(pub, key_s(bob))
    )
) | (
    {392}out(pub, (key_s(charlie),key_e(charlie,alice),key_e(charlie,bob)))
)

