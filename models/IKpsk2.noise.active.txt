File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "IKpsk2.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 278, character 6:
Warning: identifier s rebound.
File "IKpsk2.noise.active.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 279, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IKpsk2.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "IKpsk2.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 292, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 295, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 296, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 296, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 297, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 313, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 313, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 314, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 322, characters 6-7:
Warning: identifier re rebound.
File "IKpsk2.noise.active.pv", line 323, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 325, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 326, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 326, characters 48-53:
Warning: identifier valid1 rebound.
File "IKpsk2.noise.active.pv", line 327, characters 6-7:
Warning: identifier rs rebound.
File "IKpsk2.noise.active.pv", line 328, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 329, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 331, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 339, characters 6-7:
Warning: identifier re rebound.
File "IKpsk2.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 343, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 344, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 345, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 347, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 356, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 358, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 366, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 368, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 515, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 517, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 366, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 368, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 507, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 508, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 305, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 306, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 500, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 339, characters 6-7:
Warning: identifier re rebound.
File "IKpsk2.noise.active.pv", line 340, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 343, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 344, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 345, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 347, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 492, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "IKpsk2.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 278, character 6:
Warning: identifier s rebound.
File "IKpsk2.noise.active.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 279, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IKpsk2.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 568, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 569, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 313, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 313, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 314, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 559, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 561, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 356, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 358, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 552, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "IKpsk2.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 292, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 295, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 296, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 296, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.active.pv", line 297, characters 6-7:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 545, characters 8-9:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 322, characters 6-7:
Warning: identifier re rebound.
File "IKpsk2.noise.active.pv", line 323, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 325, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 326, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 326, characters 48-53:
Warning: identifier valid1 rebound.
File "IKpsk2.noise.active.pv", line 327, characters 6-7:
Warning: identifier rs rebound.
File "IKpsk2.noise.active.pv", line 328, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 329, characters 7-8:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 331, characters 7-8:
Warning: identifier hs rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IKpsk2.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IKpsk2.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IKpsk2.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}out(pub, key_psk(alice,charlie));
{3}out(pub, key_psk(charlie,bob));
{4}!
{5}new sid: sessionid;
(
    {6}let s_581: keypair = keypairpack(empty,empty) in
    {7}out(pub, getpublickey(s_581));
    (
        {8}let e_582: keypair = keypairpack(empty,empty) in
        {9}let v_583: key = catch-fail(dhexp(key_s(bob),g)) in
        {10}let rs_584: key = getpublickey((if not-caught-fail(v_583) then keypairpack(v_583,key_s(bob)) else fail-any)) in
        {11}let re_585: key = empty in
        {12}let v_586: bitstring = catch-fail(hash(somename,empty)) in
        {13}let v_587: key = catch-fail(v_586) in
        {14}let v_588: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {15}let v_589: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_586) then (if not-caught-fail(v_587) then (if not-caught-fail(v_588) then symmetricstatepack(v_588,v_587,v_586) else fail-any) else fail-any) else fail-any))) in
        {16}let v_590: symmetricstate = catch-fail((if success?((if not-caught-fail(v_586) then (if not-caught-fail(v_587) then (if not-caught-fail(v_588) then symmetricstatepack(v_588,v_587,v_586) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-3-tuple(v_589))))) then symmetricstatepack(1-proj-3-tuple(v_589),2-proj-3-tuple(v_589),hash(3-proj-3-tuple(v_589),empty)) else fail-any) else fail-any)) in
        {17}let v_591: bitstring = catch-fail(symmetricstateunpack(v_590)) in
        {18}let v_592: symmetricstate = catch-fail((if (not-caught-fail(v_591) && success?(is-true(success?(1-proj-3-tuple(v_591))))) then symmetricstatepack(1-proj-3-tuple(v_591),2-proj-3-tuple(v_591),hash(3-proj-3-tuple(v_591),rs_584)) else fail-any)) in
        {19}let hs: handshakestate = (if not-caught-fail(v_590) then (if not-caught-fail(v_592) then handshakestatepack(v_592,s_581,e_582,rs_584,re_585,key_psk(alice,bob),true) else fail-any) else fail-any) in
        {20}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {74}get statestore(=alice,=bob,=sid,statepack_a(hs_593: handshakestate)) in
        {21}let v_594: bitstring = catch-fail(handshakestateunpack(hs_593)) in
        {22}let v_595: bitstring = catch-fail((empty,empty,empty)) in
        {23}let v_596: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {24}let v_597: keypair = catch-fail((if not-caught-fail(v_596) then keypairpack(v_596,key_e(alice,bob,sid)) else fail-any)) in
        {25}let v_598: bitstring = catch-fail(getpublickey(v_597)) in
        {26}let v_599: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_594))) in
        {27}let v_600: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_594)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-3-tuple(v_599))))) then symmetricstatepack(1-proj-3-tuple(v_599),2-proj-3-tuple(v_599),hash(3-proj-3-tuple(v_599),v_598)) else fail-any) else fail-any)) in
        {28}let v_601: bitstring = catch-fail(symmetricstateunpack(v_600)) in
        {29}let v_602: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_601),getpublickey(v_597))) in
        {30}let v_603: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_601),getpublickey(v_597))) in
        {31}let v_604: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_601),getpublickey(v_597))) in
        {32}let v_605: bitstring = catch-fail((if (success?(getpublickey(v_597)) && success?(2-proj-3-tuple(v_601))) then (if not-caught-fail(v_602) then (if not-caught-fail(v_603) then (if not-caught-fail(v_604) then (v_602,v_603,v_604) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {33}let v_606: symmetricstate = catch-fail((if success?(getpublickey(v_597)) then (if (not-caught-fail(v_601) && success?(is-true(success?(1-proj-3-tuple(v_601))))) then (if (not-caught-fail(v_605) && success?(is-true(success?(1-proj-3-tuple(v_605))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_605)) then cipherstatepack(2-proj-3-tuple(v_605),minnonce) else fail-any),1-proj-3-tuple(v_605),3-proj-3-tuple(v_601)) else fail-any) else fail-any) else fail-any)) in
        {34}let v_607: bitstring = catch-fail(keypairunpack(v_597)) in
        {35}let v_608: bitstring = catch-fail(symmetricstateunpack(v_606)) in
        {36}let v_609: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_608),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then dhexp(2-proj-2-tuple(v_607),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {37}let v_610: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_608),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then dhexp(2-proj-2-tuple(v_607),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {38}let v_611: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_608),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then dhexp(2-proj-2-tuple(v_607),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {39}let v_612: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then dhexp(2-proj-2-tuple(v_607),4-proj-7-tuple(v_594)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_608))) then (if not-caught-fail(v_609) then (if not-caught-fail(v_610) then (if not-caught-fail(v_611) then (v_609,v_610,v_611) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {40}let v_613: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-2-tuple(v_607))))) then dhexp(2-proj-2-tuple(v_607),4-proj-7-tuple(v_594)) else fail-any) else fail-any)) then (if (not-caught-fail(v_608) && success?(is-true(success?(1-proj-3-tuple(v_608))))) then (if (not-caught-fail(v_612) && success?(is-true(success?(1-proj-3-tuple(v_612))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_612)) then cipherstatepack(2-proj-3-tuple(v_612),minnonce) else fail-any),1-proj-3-tuple(v_612),3-proj-3-tuple(v_608)) else fail-any) else fail-any) else fail-any)) in
        {41}let v_614: key = catch-fail(dhexp(key_s(alice),g)) in
        {42}let v_615: keypair = catch-fail((if not-caught-fail(v_614) then keypairpack(v_614,key_s(alice)) else fail-any)) in
        {43}let v_616: bitstring = catch-fail(symmetricstateunpack(v_613)) in
        {44}let v_617: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_616))) in
        {45}let v_618: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_617),2-proj-2-tuple(v_617),3-proj-3-tuple(v_616),getpublickey(v_615))) in
        {46}let v_619: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_616))) in
        {47}let v_620: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_617))) && success?(1-proj-3-tuple(v_616))) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-2-tuple(v_619))))) then cipherstatepack(1-proj-2-tuple(v_619),increment_nonce(2-proj-2-tuple(v_617))) else fail-any) else fail-any)) in
        {48}let v_621: bitstring = catch-fail((if (success?(getpublickey(v_615)) && (success?(3-proj-3-tuple(v_616)) && success?(1-proj-3-tuple(v_616)))) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then (if not-caught-fail(v_618) then (if not-caught-fail(v_620) then (v_620,v_618) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {49}let v_622: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_621),2-proj-3-tuple(v_616),3-proj-3-tuple(v_616)))) in
        {50}let v_623: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_621)) && success?(symmetricstatepack(1-proj-2-tuple(v_621),2-proj-3-tuple(v_616),3-proj-3-tuple(v_616)))) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-3-tuple(v_622))))) then symmetricstatepack(1-proj-3-tuple(v_622),2-proj-3-tuple(v_622),hash(3-proj-3-tuple(v_622),2-proj-2-tuple(v_621))) else fail-any) else fail-any)) in
        {51}let v_624: bitstring = catch-fail((if success?(getpublickey(v_615)) then (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-3-tuple(v_616))))) then (if (not-caught-fail(v_621) && success?(is-true(success?(1-proj-2-tuple(v_621))))) then (if not-caught-fail(v_623) then (v_623,2-proj-2-tuple(v_621)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {52}let v_625: bitstring = catch-fail(keypairunpack(v_615)) in
        {53}let v_626: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_624))) in
        {54}let v_627: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_626),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then dhexp(2-proj-2-tuple(v_625),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {55}let v_628: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_626),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then dhexp(2-proj-2-tuple(v_625),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {56}let v_629: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_626),(if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then dhexp(2-proj-2-tuple(v_625),4-proj-7-tuple(v_594)) else fail-any) else fail-any))) in
        {57}let v_630: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then dhexp(2-proj-2-tuple(v_625),4-proj-7-tuple(v_594)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_626))) then (if not-caught-fail(v_627) then (if not-caught-fail(v_628) then (if not-caught-fail(v_629) then (v_627,v_628,v_629) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {58}let v_631: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_594)) then (if (not-caught-fail(v_625) && success?(is-true(success?(1-proj-2-tuple(v_625))))) then dhexp(2-proj-2-tuple(v_625),4-proj-7-tuple(v_594)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_624))) then (if (not-caught-fail(v_626) && success?(is-true(success?(1-proj-3-tuple(v_626))))) then (if (not-caught-fail(v_630) && success?(is-true(success?(1-proj-3-tuple(v_630))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_630)) then cipherstatepack(2-proj-3-tuple(v_630),minnonce) else fail-any),1-proj-3-tuple(v_630),3-proj-3-tuple(v_626)) else fail-any) else fail-any) else fail-any)) in
        {59}let v_632: bitstring = catch-fail(symmetricstateunpack(v_631)) in
        {60}let v_633: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_632))) in
        {61}let v_634: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_633),2-proj-2-tuple(v_633),3-proj-3-tuple(v_632),msg_a(alice,bob,sid))) in
        {62}let v_635: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_632))) in
        {63}let v_636: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_633))) && success?(1-proj-3-tuple(v_632))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-2-tuple(v_635))))) then cipherstatepack(1-proj-2-tuple(v_635),increment_nonce(2-proj-2-tuple(v_633))) else fail-any) else fail-any)) in
        {64}let v_637: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_632)) && success?(1-proj-3-tuple(v_632))) then (if (not-caught-fail(v_633) && success?(is-true(success?(1-proj-2-tuple(v_633))))) then (if not-caught-fail(v_634) then (if not-caught-fail(v_636) then (v_636,v_634) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {65}let v_638: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_637),2-proj-3-tuple(v_632),3-proj-3-tuple(v_632)))) in
        {66}let v_639: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_637)) && success?(symmetricstatepack(1-proj-2-tuple(v_637),2-proj-3-tuple(v_632),3-proj-3-tuple(v_632)))) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-3-tuple(v_638))))) then symmetricstatepack(1-proj-3-tuple(v_638),2-proj-3-tuple(v_638),hash(3-proj-3-tuple(v_638),2-proj-2-tuple(v_637))) else fail-any) else fail-any)) in
        {67}let v_640: bitstring = catch-fail((if (not-caught-fail(v_632) && success?(is-true(success?(1-proj-3-tuple(v_632))))) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-2-tuple(v_637))))) then (if not-caught-fail(v_639) then (v_639,2-proj-2-tuple(v_637)) else fail-any) else fail-any) else fail-any)) in
        {68}let v_641: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_640),v_615,v_597,4-proj-7-tuple(v_594),5-proj-7-tuple(v_594),6-proj-7-tuple(v_594),7-proj-7-tuple(v_594))) in
        {69}let v_642: bitstring = catch-fail(concat3(v_598,2-proj-2-tuple(v_624),2-proj-2-tuple(v_640))) in
        {70}let (hs_643: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_594) && success?(is-true(success?(1-proj-7-tuple(v_594))))) then (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-3-tuple(v_595))))) then (if not-caught-fail(v_597) then (if not-caught-fail(v_598) then (if not-caught-fail(v_600) then (if not-caught-fail(v_606) then (if not-caught-fail(v_613) then (if not-caught-fail(v_615) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-2-tuple(v_624))))) then (if not-caught-fail(v_631) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then (if not-caught-fail(v_641) then (if not-caught-fail(v_642) then (v_641,v_642) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {71}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {72}insert statestore(alice,bob,sid,statepack_b(hs_643));
        {73}out(pub, message_a)
    ) | (
        {132}get statestore(=alice,=bob,=sid,statepack_b(hs_644: handshakestate)) in
        {75}in(pub, message_b: bitstring);
        {76}let v_645: bitstring = catch-fail(handshakestateunpack(hs_644)) in
        {77}let v_646: bitstring = catch-fail(deconcat3(message_b)) in
        {78}let v_647: bool = catch-fail(true) in
        {79}let v_648: key = catch-fail(1-proj-3-tuple(v_646)) in
        {80}let v_649: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_645))) in
        {81}let v_650: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_645)) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-3-tuple(v_649))))) then symmetricstatepack(1-proj-3-tuple(v_649),2-proj-3-tuple(v_649),hash(3-proj-3-tuple(v_649),v_648)) else fail-any) else fail-any)) in
        {82}let v_651: bitstring = catch-fail(symmetricstateunpack(v_650)) in
        {83}let v_652: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_651),v_648)) in
        {84}let v_653: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_651),v_648)) in
        {85}let v_654: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_651),v_648)) in
        {86}let v_655: bitstring = catch-fail((if success?(2-proj-3-tuple(v_651)) then (if not-caught-fail(v_652) then (if not-caught-fail(v_653) then (if not-caught-fail(v_654) then (v_652,v_653,v_654) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {87}let v_656: symmetricstate = catch-fail((if (not-caught-fail(v_651) && success?(is-true(success?(1-proj-3-tuple(v_651))))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-3-tuple(v_655))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_655)) then cipherstatepack(2-proj-3-tuple(v_655),minnonce) else fail-any),1-proj-3-tuple(v_655),3-proj-3-tuple(v_651)) else fail-any) else fail-any)) in
        {88}let v_657: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_645))) in
        {89}let v_658: bitstring = catch-fail(symmetricstateunpack(v_656)) in
        {90}let v_659: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_658),(if success?(3-proj-7-tuple(v_645)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then dhexp(2-proj-2-tuple(v_657),v_648) else fail-any) else fail-any))) in
        {91}let v_660: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_658),(if success?(3-proj-7-tuple(v_645)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then dhexp(2-proj-2-tuple(v_657),v_648) else fail-any) else fail-any))) in
        {92}let v_661: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_658),(if success?(3-proj-7-tuple(v_645)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then dhexp(2-proj-2-tuple(v_657),v_648) else fail-any) else fail-any))) in
        {93}let v_662: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_645)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then dhexp(2-proj-2-tuple(v_657),v_648) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_658))) then (if not-caught-fail(v_659) then (if not-caught-fail(v_660) then (if not-caught-fail(v_661) then (v_659,v_660,v_661) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {94}let v_663: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_645)) then (if (not-caught-fail(v_657) && success?(is-true(success?(1-proj-2-tuple(v_657))))) then dhexp(2-proj-2-tuple(v_657),v_648) else fail-any) else fail-any)) then (if (not-caught-fail(v_658) && success?(is-true(success?(1-proj-3-tuple(v_658))))) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-3-tuple(v_662))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_662)) then cipherstatepack(2-proj-3-tuple(v_662),minnonce) else fail-any),1-proj-3-tuple(v_662),3-proj-3-tuple(v_658)) else fail-any) else fail-any) else fail-any)) in
        {95}let v_664: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_645))) in
        {96}let v_665: bitstring = catch-fail(symmetricstateunpack(v_663)) in
        {97}let v_666: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_665),(if success?(2-proj-7-tuple(v_645)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then dhexp(2-proj-2-tuple(v_664),v_648) else fail-any) else fail-any))) in
        {98}let v_667: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_665),(if success?(2-proj-7-tuple(v_645)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then dhexp(2-proj-2-tuple(v_664),v_648) else fail-any) else fail-any))) in
        {99}let v_668: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_665),(if success?(2-proj-7-tuple(v_645)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then dhexp(2-proj-2-tuple(v_664),v_648) else fail-any) else fail-any))) in
        {100}let v_669: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_645)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then dhexp(2-proj-2-tuple(v_664),v_648) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_665))) then (if not-caught-fail(v_666) then (if not-caught-fail(v_667) then (if not-caught-fail(v_668) then (v_666,v_667,v_668) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {101}let v_670: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_645)) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-2-tuple(v_664))))) then dhexp(2-proj-2-tuple(v_664),v_648) else fail-any) else fail-any)) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-3-tuple(v_665))))) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-3-tuple(v_669))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_669)) then cipherstatepack(2-proj-3-tuple(v_669),minnonce) else fail-any),1-proj-3-tuple(v_669),3-proj-3-tuple(v_665)) else fail-any) else fail-any) else fail-any)) in
        {102}let v_671: bitstring = catch-fail(symmetricstateunpack(v_670)) in
        {103}let v_672: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_671),6-proj-7-tuple(v_645))) in
        {104}let v_673: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_671),6-proj-7-tuple(v_645))) in
        {105}let v_674: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_671),6-proj-7-tuple(v_645))) in
        {106}let v_675: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_645)) && success?(2-proj-3-tuple(v_671))) then (if not-caught-fail(v_672) then (if not-caught-fail(v_673) then (if not-caught-fail(v_674) then (v_672,v_673,v_674) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let v_676: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_671),1-proj-3-tuple(v_675),3-proj-3-tuple(v_671)))) in
        {108}let v_677: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_675)) && success?(symmetricstatepack(1-proj-3-tuple(v_671),1-proj-3-tuple(v_675),3-proj-3-tuple(v_671)))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then symmetricstatepack(1-proj-3-tuple(v_676),2-proj-3-tuple(v_676),hash(3-proj-3-tuple(v_676),2-proj-3-tuple(v_675))) else fail-any) else fail-any))) in
        {109}let v_678: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_645)) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-3-tuple(v_671))))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-3-tuple(v_675))))) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-3-tuple(v_677))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_675)) then cipherstatepack(3-proj-3-tuple(v_675),minnonce) else fail-any),1-proj-3-tuple(v_675),3-proj-3-tuple(v_677)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {110}let v_679: bitstring = catch-fail(symmetricstateunpack(v_678)) in
        {111}let v_680: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_679))) in
        {112}let v_681: aead = catch-fail(decrypt(1-proj-2-tuple(v_680),2-proj-2-tuple(v_680),3-proj-3-tuple(v_679),3-proj-3-tuple(v_646))) in
        {113}let v_682: bitstring = catch-fail(aeadunpack(v_681)) in
        {114}let v_683: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_679))) in
        {115}let v_684: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_680))) && success?(1-proj-3-tuple(v_679))) then (if (not-caught-fail(v_683) && success?(is-true(success?(1-proj-2-tuple(v_683))))) then cipherstatepack(1-proj-2-tuple(v_683),increment_nonce(2-proj-2-tuple(v_680))) else fail-any) else fail-any)) in
        {116}let v_685: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_646)) && (success?(3-proj-3-tuple(v_679)) && success?(1-proj-3-tuple(v_679)))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-2-tuple(v_680))))) then (if not-caught-fail(v_681) then (if (not-caught-fail(v_682) && success?(is-true(success?(1-proj-3-tuple(v_682))))) then (if not-caught-fail(v_684) then (v_684,3-proj-3-tuple(v_682),1-proj-3-tuple(v_682)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {117}let v_686: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_685),2-proj-3-tuple(v_679),3-proj-3-tuple(v_679)))) in
        {118}let v_687: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_646)) && success?(symmetricstatepack(1-proj-3-tuple(v_685),2-proj-3-tuple(v_679),3-proj-3-tuple(v_679)))) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then symmetricstatepack(1-proj-3-tuple(v_686),2-proj-3-tuple(v_686),hash(3-proj-3-tuple(v_686),3-proj-3-tuple(v_646))) else fail-any) else fail-any)) in
        {119}let v_688: bitstring = catch-fail((if success?(3-proj-3-tuple(v_646)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-3-tuple(v_679))))) then (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-3-tuple(v_685))))) then (if not-caught-fail(v_687) then (v_687,2-proj-3-tuple(v_685),3-proj-3-tuple(v_685)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {120}let v_689: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_688),2-proj-7-tuple(v_645),3-proj-7-tuple(v_645),4-proj-7-tuple(v_645),v_648,6-proj-7-tuple(v_645),7-proj-7-tuple(v_645))) in
        {121}let v_690: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_688))) in
        {122}let v_691: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_690),zero)) in
        {123}let v_692: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_690),zero)) in
        {124}let v_693: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_690),zero)) in
        {125}let v_694: bitstring = catch-fail((if success?(2-proj-3-tuple(v_690)) then (if not-caught-fail(v_691) then (if not-caught-fail(v_692) then (if not-caught-fail(v_693) then (v_691,v_692,v_693) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {126}let v_695: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_694)) then cipherstatepack(1-proj-3-tuple(v_694),minnonce) else fail-any)) in
        {127}let v_696: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_694)) then cipherstatepack(2-proj-3-tuple(v_694),minnonce) else fail-any)) in
        {128}let v_697: bitstring = catch-fail((if success?(1-proj-3-tuple(v_688)) then (if (not-caught-fail(v_690) && success?(is-true(success?(1-proj-3-tuple(v_690))))) then (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-3-tuple(v_694))))) then (if not-caught-fail(v_695) then (if not-caught-fail(v_696) then (1-proj-3-tuple(v_688),v_695,v_696) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {129}let (hs_698: handshakestate,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-7-tuple(v_645))))) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-3-tuple(v_646))))) then (if not-caught-fail(v_647) then (if not-caught-fail(v_648) then (if not-caught-fail(v_650) then (if not-caught-fail(v_656) then (if not-caught-fail(v_663) then (if not-caught-fail(v_670) then (if not-caught-fail(v_678) then (if (not-caught-fail(v_688) && success?(is-true(success?(1-proj-3-tuple(v_688))))) then (if (v_647 && 3-proj-3-tuple(v_688)) then (if not-caught-fail(v_689) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then (v_689,2-proj-3-tuple(v_688),true,2-proj-3-tuple(v_697),3-proj-3-tuple(v_697)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {130}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {131}insert statestore(alice,bob,sid,statepack_c(hs_698,cs1,cs2))
    ) | (
        {133}!
        {152}get statestore(=alice,=bob,=sid,statepack_c(hs_699: handshakestate,cs1_700: cipherstate,cs2_701: cipherstate)) in
        {134}let hs_702: handshakestate = handshakestatesetcs(hs_699,cs1_700) in
        {135}let v_703: bitstring = catch-fail(handshakestateunpack(hs_702)) in
        {136}let v_704: bitstring = catch-fail((empty,empty,empty)) in
        {137}let v_705: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_703))) in
        {138}let v_706: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {139}let v_707: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_706),2-proj-2-tuple(v_706),3-proj-3-tuple(v_705),msg_c(alice,bob,sid))) in
        {140}let v_708: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_705))) in
        {141}let v_709: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_706))) && success?(1-proj-3-tuple(v_705))) then (if (not-caught-fail(v_708) && success?(is-true(success?(1-proj-2-tuple(v_708))))) then cipherstatepack(1-proj-2-tuple(v_708),increment_nonce(2-proj-2-tuple(v_706))) else fail-any) else fail-any)) in
        {142}let v_710: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_705)) && success?(1-proj-3-tuple(v_705))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-2-tuple(v_706))))) then (if not-caught-fail(v_707) then (if not-caught-fail(v_709) then (v_709,v_707) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {143}let v_711: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_710),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) in
        {144}let v_712: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_710)) && success?(symmetricstatepack(1-proj-2-tuple(v_710),2-proj-3-tuple(v_705),3-proj-3-tuple(v_705)))) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-3-tuple(v_711))))) then symmetricstatepack(1-proj-3-tuple(v_711),2-proj-3-tuple(v_711),hash(3-proj-3-tuple(v_711),2-proj-2-tuple(v_710))) else fail-any) else fail-any)) in
        {145}let v_713: bitstring = catch-fail((if success?(1-proj-7-tuple(v_703)) then (if (not-caught-fail(v_705) && success?(is-true(success?(1-proj-3-tuple(v_705))))) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then (if not-caught-fail(v_712) then (v_712,2-proj-2-tuple(v_710)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {146}let v_714: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_713),2-proj-7-tuple(v_703),3-proj-7-tuple(v_703),4-proj-7-tuple(v_703),5-proj-7-tuple(v_703),6-proj-7-tuple(v_703),7-proj-7-tuple(v_703))) in
        {147}let v_715: bitstring = catch-fail(concat3(1-proj-3-tuple(v_704),2-proj-3-tuple(v_704),2-proj-2-tuple(v_713))) in
        {148}let (hs_716: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_703) && success?(is-true(success?(1-proj-7-tuple(v_703))))) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then (if (not-caught-fail(v_713) && success?(is-true(success?(1-proj-2-tuple(v_713))))) then (if not-caught-fail(v_714) then (if not-caught-fail(v_715) then (v_714,v_715) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {149}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {150}insert statestore(alice,bob,sid,statepack_d(hs_716,handshakestategetcs(hs_716),cs2_701));
        {151}out(pub, message_c)
    ) | (
        {153}!
        {173}get statestore(=alice,=bob,=sid,statepack_d(hs_717: handshakestate,cs1_718: cipherstate,cs2_719: cipherstate)) in
        {154}let hs_720: handshakestate = handshakestatesetcs(hs_717,cs2_719) in
        {155}in(pub, message_d: bitstring);
        {156}let v_721: bitstring = catch-fail(handshakestateunpack(hs_720)) in
        {157}let v_722: bitstring = catch-fail(deconcat3(message_d)) in
        {158}let v_723: bool = catch-fail(true) in
        {159}let v_724: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_721))) in
        {160}let v_725: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_724))) in
        {161}let v_726: aead = catch-fail(decrypt(1-proj-2-tuple(v_725),2-proj-2-tuple(v_725),3-proj-3-tuple(v_724),3-proj-3-tuple(v_722))) in
        {162}let v_727: bitstring = catch-fail(aeadunpack(v_726)) in
        {163}let v_728: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_724))) in
        {164}let v_729: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_725))) && success?(1-proj-3-tuple(v_724))) then (if (not-caught-fail(v_728) && success?(is-true(success?(1-proj-2-tuple(v_728))))) then cipherstatepack(1-proj-2-tuple(v_728),increment_nonce(2-proj-2-tuple(v_725))) else fail-any) else fail-any)) in
        {165}let v_730: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_722)) && (success?(3-proj-3-tuple(v_724)) && success?(1-proj-3-tuple(v_724)))) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then (if not-caught-fail(v_726) then (if (not-caught-fail(v_727) && success?(is-true(success?(1-proj-3-tuple(v_727))))) then (if not-caught-fail(v_729) then (v_729,3-proj-3-tuple(v_727),1-proj-3-tuple(v_727)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {166}let v_731: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_730),2-proj-3-tuple(v_724),3-proj-3-tuple(v_724)))) in
        {167}let v_732: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_722)) && success?(symmetricstatepack(1-proj-3-tuple(v_730),2-proj-3-tuple(v_724),3-proj-3-tuple(v_724)))) then (if (not-caught-fail(v_731) && success?(is-true(success?(1-proj-3-tuple(v_731))))) then symmetricstatepack(1-proj-3-tuple(v_731),2-proj-3-tuple(v_731),hash(3-proj-3-tuple(v_731),3-proj-3-tuple(v_722))) else fail-any) else fail-any)) in
        {168}let v_733: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_722)) && success?(1-proj-7-tuple(v_721))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-3-tuple(v_724))))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-3-tuple(v_730))))) then (if not-caught-fail(v_732) then (v_732,2-proj-3-tuple(v_730),3-proj-3-tuple(v_730)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {169}let v_734: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_733),2-proj-7-tuple(v_721),3-proj-7-tuple(v_721),4-proj-7-tuple(v_721),5-proj-7-tuple(v_721),6-proj-7-tuple(v_721),7-proj-7-tuple(v_721))) in
        {170}let (hs_735: handshakestate,plaintext_d: bitstring,valid_736: bool) = (if (not-caught-fail(v_721) && success?(is-true(success?(1-proj-7-tuple(v_721))))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-3-tuple(v_722))))) then (if not-caught-fail(v_723) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-3-tuple(v_733))))) then (if (v_723 && 3-proj-3-tuple(v_733)) then (if not-caught-fail(v_734) then (v_734,2-proj-3-tuple(v_733),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {171}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {172}event RecvEnd(valid_736)
    ) | (
        {174}event LeakS(phase0,alice);
        {175}out(pub, key_s(alice))
    ) | (
        {176}phase 1;
        {177}event LeakS(phase1,alice);
        {178}out(pub, key_s(alice))
    )
) | (
    {179}let s_737: keypair = keypairpack(empty,empty) in
    {180}out(pub, getpublickey(s_737));
    (
        {181}let e_738: keypair = keypairpack(empty,empty) in
        {182}let v_739: key = catch-fail(dhexp(key_s(charlie),g)) in
        {183}let rs_740: key = getpublickey((if not-caught-fail(v_739) then keypairpack(v_739,key_s(charlie)) else fail-any)) in
        {184}let re_741: key = empty in
        {185}let v_742: bitstring = catch-fail(hash(somename,empty)) in
        {186}let v_743: key = catch-fail(v_742) in
        {187}let v_744: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {188}let v_745: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_742) then (if not-caught-fail(v_743) then (if not-caught-fail(v_744) then symmetricstatepack(v_744,v_743,v_742) else fail-any) else fail-any) else fail-any))) in
        {189}let v_746: symmetricstate = catch-fail((if success?((if not-caught-fail(v_742) then (if not-caught-fail(v_743) then (if not-caught-fail(v_744) then symmetricstatepack(v_744,v_743,v_742) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-3-tuple(v_745))))) then symmetricstatepack(1-proj-3-tuple(v_745),2-proj-3-tuple(v_745),hash(3-proj-3-tuple(v_745),empty)) else fail-any) else fail-any)) in
        {190}let v_747: bitstring = catch-fail(symmetricstateunpack(v_746)) in
        {191}let v_748: symmetricstate = catch-fail((if (not-caught-fail(v_747) && success?(is-true(success?(1-proj-3-tuple(v_747))))) then symmetricstatepack(1-proj-3-tuple(v_747),2-proj-3-tuple(v_747),hash(3-proj-3-tuple(v_747),rs_740)) else fail-any)) in
        {192}let hs_749: handshakestate = (if not-caught-fail(v_746) then (if not-caught-fail(v_748) then handshakestatepack(v_748,s_737,e_738,rs_740,re_741,key_psk(alice,charlie),true) else fail-any) else fail-any) in
        {193}insert statestore(alice,charlie,sid,statepack_a(hs_749))
    ) | (
        {247}get statestore(=alice,=charlie,=sid,statepack_a(hs_750: handshakestate)) in
        {194}let v_751: bitstring = catch-fail(handshakestateunpack(hs_750)) in
        {195}let v_752: bitstring = catch-fail((empty,empty,empty)) in
        {196}let v_753: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {197}let v_754: keypair = catch-fail((if not-caught-fail(v_753) then keypairpack(v_753,key_e(alice,charlie,sid)) else fail-any)) in
        {198}let v_755: bitstring = catch-fail(getpublickey(v_754)) in
        {199}let v_756: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_751))) in
        {200}let v_757: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_751)) then (if (not-caught-fail(v_756) && success?(is-true(success?(1-proj-3-tuple(v_756))))) then symmetricstatepack(1-proj-3-tuple(v_756),2-proj-3-tuple(v_756),hash(3-proj-3-tuple(v_756),v_755)) else fail-any) else fail-any)) in
        {201}let v_758: bitstring = catch-fail(symmetricstateunpack(v_757)) in
        {202}let v_759: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_758),getpublickey(v_754))) in
        {203}let v_760: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_758),getpublickey(v_754))) in
        {204}let v_761: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_758),getpublickey(v_754))) in
        {205}let v_762: bitstring = catch-fail((if (success?(getpublickey(v_754)) && success?(2-proj-3-tuple(v_758))) then (if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (if not-caught-fail(v_761) then (v_759,v_760,v_761) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {206}let v_763: symmetricstate = catch-fail((if success?(getpublickey(v_754)) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-3-tuple(v_758))))) then (if (not-caught-fail(v_762) && success?(is-true(success?(1-proj-3-tuple(v_762))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_762)) then cipherstatepack(2-proj-3-tuple(v_762),minnonce) else fail-any),1-proj-3-tuple(v_762),3-proj-3-tuple(v_758)) else fail-any) else fail-any) else fail-any)) in
        {207}let v_764: bitstring = catch-fail(keypairunpack(v_754)) in
        {208}let v_765: bitstring = catch-fail(symmetricstateunpack(v_763)) in
        {209}let v_766: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_765),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-2-tuple(v_764))))) then dhexp(2-proj-2-tuple(v_764),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {210}let v_767: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_765),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-2-tuple(v_764))))) then dhexp(2-proj-2-tuple(v_764),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {211}let v_768: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_765),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-2-tuple(v_764))))) then dhexp(2-proj-2-tuple(v_764),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {212}let v_769: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-2-tuple(v_764))))) then dhexp(2-proj-2-tuple(v_764),4-proj-7-tuple(v_751)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_765))) then (if not-caught-fail(v_766) then (if not-caught-fail(v_767) then (if not-caught-fail(v_768) then (v_766,v_767,v_768) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {213}let v_770: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-2-tuple(v_764))))) then dhexp(2-proj-2-tuple(v_764),4-proj-7-tuple(v_751)) else fail-any) else fail-any)) then (if (not-caught-fail(v_765) && success?(is-true(success?(1-proj-3-tuple(v_765))))) then (if (not-caught-fail(v_769) && success?(is-true(success?(1-proj-3-tuple(v_769))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_769)) then cipherstatepack(2-proj-3-tuple(v_769),minnonce) else fail-any),1-proj-3-tuple(v_769),3-proj-3-tuple(v_765)) else fail-any) else fail-any) else fail-any)) in
        {214}let v_771: key = catch-fail(dhexp(key_s(alice),g)) in
        {215}let v_772: keypair = catch-fail((if not-caught-fail(v_771) then keypairpack(v_771,key_s(alice)) else fail-any)) in
        {216}let v_773: bitstring = catch-fail(symmetricstateunpack(v_770)) in
        {217}let v_774: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {218}let v_775: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_774),2-proj-2-tuple(v_774),3-proj-3-tuple(v_773),getpublickey(v_772))) in
        {219}let v_776: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_773))) in
        {220}let v_777: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_774))) && success?(1-proj-3-tuple(v_773))) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-2-tuple(v_776))))) then cipherstatepack(1-proj-2-tuple(v_776),increment_nonce(2-proj-2-tuple(v_774))) else fail-any) else fail-any)) in
        {221}let v_778: bitstring = catch-fail((if (success?(getpublickey(v_772)) && (success?(3-proj-3-tuple(v_773)) && success?(1-proj-3-tuple(v_773)))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-2-tuple(v_774))))) then (if not-caught-fail(v_775) then (if not-caught-fail(v_777) then (v_777,v_775) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {222}let v_779: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_778),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) in
        {223}let v_780: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_778)) && success?(symmetricstatepack(1-proj-2-tuple(v_778),2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)))) then (if (not-caught-fail(v_779) && success?(is-true(success?(1-proj-3-tuple(v_779))))) then symmetricstatepack(1-proj-3-tuple(v_779),2-proj-3-tuple(v_779),hash(3-proj-3-tuple(v_779),2-proj-2-tuple(v_778))) else fail-any) else fail-any)) in
        {224}let v_781: bitstring = catch-fail((if success?(getpublickey(v_772)) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-2-tuple(v_778))))) then (if not-caught-fail(v_780) then (v_780,2-proj-2-tuple(v_778)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {225}let v_782: bitstring = catch-fail(keypairunpack(v_772)) in
        {226}let v_783: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_781))) in
        {227}let v_784: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_783),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-2-tuple(v_782))))) then dhexp(2-proj-2-tuple(v_782),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {228}let v_785: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_783),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-2-tuple(v_782))))) then dhexp(2-proj-2-tuple(v_782),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {229}let v_786: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_783),(if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-2-tuple(v_782))))) then dhexp(2-proj-2-tuple(v_782),4-proj-7-tuple(v_751)) else fail-any) else fail-any))) in
        {230}let v_787: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-2-tuple(v_782))))) then dhexp(2-proj-2-tuple(v_782),4-proj-7-tuple(v_751)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_783))) then (if not-caught-fail(v_784) then (if not-caught-fail(v_785) then (if not-caught-fail(v_786) then (v_784,v_785,v_786) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {231}let v_788: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_751)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-2-tuple(v_782))))) then dhexp(2-proj-2-tuple(v_782),4-proj-7-tuple(v_751)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_781))) then (if (not-caught-fail(v_783) && success?(is-true(success?(1-proj-3-tuple(v_783))))) then (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-3-tuple(v_787))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_787)) then cipherstatepack(2-proj-3-tuple(v_787),minnonce) else fail-any),1-proj-3-tuple(v_787),3-proj-3-tuple(v_783)) else fail-any) else fail-any) else fail-any)) in
        {232}let v_789: bitstring = catch-fail(symmetricstateunpack(v_788)) in
        {233}let v_790: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_789))) in
        {234}let v_791: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_790),2-proj-2-tuple(v_790),3-proj-3-tuple(v_789),msg_a(alice,charlie,sid))) in
        {235}let v_792: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_789))) in
        {236}let v_793: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_790))) && success?(1-proj-3-tuple(v_789))) then (if (not-caught-fail(v_792) && success?(is-true(success?(1-proj-2-tuple(v_792))))) then cipherstatepack(1-proj-2-tuple(v_792),increment_nonce(2-proj-2-tuple(v_790))) else fail-any) else fail-any)) in
        {237}let v_794: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_789)) && success?(1-proj-3-tuple(v_789))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-2-tuple(v_790))))) then (if not-caught-fail(v_791) then (if not-caught-fail(v_793) then (v_793,v_791) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {238}let v_795: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_794),2-proj-3-tuple(v_789),3-proj-3-tuple(v_789)))) in
        {239}let v_796: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_794)) && success?(symmetricstatepack(1-proj-2-tuple(v_794),2-proj-3-tuple(v_789),3-proj-3-tuple(v_789)))) then (if (not-caught-fail(v_795) && success?(is-true(success?(1-proj-3-tuple(v_795))))) then symmetricstatepack(1-proj-3-tuple(v_795),2-proj-3-tuple(v_795),hash(3-proj-3-tuple(v_795),2-proj-2-tuple(v_794))) else fail-any) else fail-any)) in
        {240}let v_797: bitstring = catch-fail((if (not-caught-fail(v_789) && success?(is-true(success?(1-proj-3-tuple(v_789))))) then (if (not-caught-fail(v_794) && success?(is-true(success?(1-proj-2-tuple(v_794))))) then (if not-caught-fail(v_796) then (v_796,2-proj-2-tuple(v_794)) else fail-any) else fail-any) else fail-any)) in
        {241}let v_798: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_797),v_772,v_754,4-proj-7-tuple(v_751),5-proj-7-tuple(v_751),6-proj-7-tuple(v_751),7-proj-7-tuple(v_751))) in
        {242}let v_799: bitstring = catch-fail(concat3(v_755,2-proj-2-tuple(v_781),2-proj-2-tuple(v_797))) in
        {243}let (hs_800: handshakestate,message_a_801: bitstring) = (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-7-tuple(v_751))))) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-3-tuple(v_752))))) then (if not-caught-fail(v_754) then (if not-caught-fail(v_755) then (if not-caught-fail(v_757) then (if not-caught-fail(v_763) then (if not-caught-fail(v_770) then (if not-caught-fail(v_772) then (if (not-caught-fail(v_781) && success?(is-true(success?(1-proj-2-tuple(v_781))))) then (if not-caught-fail(v_788) then (if (not-caught-fail(v_797) && success?(is-true(success?(1-proj-2-tuple(v_797))))) then (if not-caught-fail(v_798) then (if not-caught-fail(v_799) then (v_798,v_799) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {244}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {245}insert statestore(alice,charlie,sid,statepack_b(hs_800));
        {246}out(pub, message_a_801)
    ) | (
        {305}get statestore(=alice,=charlie,=sid,statepack_b(hs_802: handshakestate)) in
        {248}in(pub, message_b_803: bitstring);
        {249}let v_804: bitstring = catch-fail(handshakestateunpack(hs_802)) in
        {250}let v_805: bitstring = catch-fail(deconcat3(message_b_803)) in
        {251}let v_806: bool = catch-fail(true) in
        {252}let v_807: key = catch-fail(1-proj-3-tuple(v_805)) in
        {253}let v_808: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_804))) in
        {254}let v_809: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_804)) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then symmetricstatepack(1-proj-3-tuple(v_808),2-proj-3-tuple(v_808),hash(3-proj-3-tuple(v_808),v_807)) else fail-any) else fail-any)) in
        {255}let v_810: bitstring = catch-fail(symmetricstateunpack(v_809)) in
        {256}let v_811: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_810),v_807)) in
        {257}let v_812: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_810),v_807)) in
        {258}let v_813: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_810),v_807)) in
        {259}let v_814: bitstring = catch-fail((if success?(2-proj-3-tuple(v_810)) then (if not-caught-fail(v_811) then (if not-caught-fail(v_812) then (if not-caught-fail(v_813) then (v_811,v_812,v_813) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {260}let v_815: symmetricstate = catch-fail((if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-3-tuple(v_814))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_814)) then cipherstatepack(2-proj-3-tuple(v_814),minnonce) else fail-any),1-proj-3-tuple(v_814),3-proj-3-tuple(v_810)) else fail-any) else fail-any)) in
        {261}let v_816: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_804))) in
        {262}let v_817: bitstring = catch-fail(symmetricstateunpack(v_815)) in
        {263}let v_818: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_817),(if success?(3-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {264}let v_819: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_817),(if success?(3-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {265}let v_820: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_817),(if success?(3-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {266}let v_821: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_817))) then (if not-caught-fail(v_818) then (if not-caught-fail(v_819) then (if not-caught-fail(v_820) then (v_818,v_819,v_820) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {267}let v_822: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any)) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-3-tuple(v_821))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_821)) then cipherstatepack(2-proj-3-tuple(v_821),minnonce) else fail-any),1-proj-3-tuple(v_821),3-proj-3-tuple(v_817)) else fail-any) else fail-any) else fail-any)) in
        {268}let v_823: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_804))) in
        {269}let v_824: bitstring = catch-fail(symmetricstateunpack(v_822)) in
        {270}let v_825: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_824),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-2-tuple(v_823))))) then dhexp(2-proj-2-tuple(v_823),v_807) else fail-any) else fail-any))) in
        {271}let v_826: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_824),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-2-tuple(v_823))))) then dhexp(2-proj-2-tuple(v_823),v_807) else fail-any) else fail-any))) in
        {272}let v_827: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_824),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-2-tuple(v_823))))) then dhexp(2-proj-2-tuple(v_823),v_807) else fail-any) else fail-any))) in
        {273}let v_828: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-2-tuple(v_823))))) then dhexp(2-proj-2-tuple(v_823),v_807) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_824))) then (if not-caught-fail(v_825) then (if not-caught-fail(v_826) then (if not-caught-fail(v_827) then (v_825,v_826,v_827) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {274}let v_829: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-2-tuple(v_823))))) then dhexp(2-proj-2-tuple(v_823),v_807) else fail-any) else fail-any)) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-3-tuple(v_824))))) then (if (not-caught-fail(v_828) && success?(is-true(success?(1-proj-3-tuple(v_828))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_828)) then cipherstatepack(2-proj-3-tuple(v_828),minnonce) else fail-any),1-proj-3-tuple(v_828),3-proj-3-tuple(v_824)) else fail-any) else fail-any) else fail-any)) in
        {275}let v_830: bitstring = catch-fail(symmetricstateunpack(v_829)) in
        {276}let v_831: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_830),6-proj-7-tuple(v_804))) in
        {277}let v_832: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_830),6-proj-7-tuple(v_804))) in
        {278}let v_833: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_830),6-proj-7-tuple(v_804))) in
        {279}let v_834: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_804)) && success?(2-proj-3-tuple(v_830))) then (if not-caught-fail(v_831) then (if not-caught-fail(v_832) then (if not-caught-fail(v_833) then (v_831,v_832,v_833) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {280}let v_835: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_830),1-proj-3-tuple(v_834),3-proj-3-tuple(v_830)))) in
        {281}let v_836: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_834)) && success?(symmetricstatepack(1-proj-3-tuple(v_830),1-proj-3-tuple(v_834),3-proj-3-tuple(v_830)))) then (if (not-caught-fail(v_835) && success?(is-true(success?(1-proj-3-tuple(v_835))))) then symmetricstatepack(1-proj-3-tuple(v_835),2-proj-3-tuple(v_835),hash(3-proj-3-tuple(v_835),2-proj-3-tuple(v_834))) else fail-any) else fail-any))) in
        {282}let v_837: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_804)) then (if (not-caught-fail(v_830) && success?(is-true(success?(1-proj-3-tuple(v_830))))) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-3-tuple(v_834))))) then (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-3-tuple(v_836))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_834)) then cipherstatepack(3-proj-3-tuple(v_834),minnonce) else fail-any),1-proj-3-tuple(v_834),3-proj-3-tuple(v_836)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {283}let v_838: bitstring = catch-fail(symmetricstateunpack(v_837)) in
        {284}let v_839: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_838))) in
        {285}let v_840: aead = catch-fail(decrypt(1-proj-2-tuple(v_839),2-proj-2-tuple(v_839),3-proj-3-tuple(v_838),3-proj-3-tuple(v_805))) in
        {286}let v_841: bitstring = catch-fail(aeadunpack(v_840)) in
        {287}let v_842: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_838))) in
        {288}let v_843: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_839))) && success?(1-proj-3-tuple(v_838))) then (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-2-tuple(v_842))))) then cipherstatepack(1-proj-2-tuple(v_842),increment_nonce(2-proj-2-tuple(v_839))) else fail-any) else fail-any)) in
        {289}let v_844: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_805)) && (success?(3-proj-3-tuple(v_838)) && success?(1-proj-3-tuple(v_838)))) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-2-tuple(v_839))))) then (if not-caught-fail(v_840) then (if (not-caught-fail(v_841) && success?(is-true(success?(1-proj-3-tuple(v_841))))) then (if not-caught-fail(v_843) then (v_843,3-proj-3-tuple(v_841),1-proj-3-tuple(v_841)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {290}let v_845: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_844),2-proj-3-tuple(v_838),3-proj-3-tuple(v_838)))) in
        {291}let v_846: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_805)) && success?(symmetricstatepack(1-proj-3-tuple(v_844),2-proj-3-tuple(v_838),3-proj-3-tuple(v_838)))) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-3-tuple(v_845))))) then symmetricstatepack(1-proj-3-tuple(v_845),2-proj-3-tuple(v_845),hash(3-proj-3-tuple(v_845),3-proj-3-tuple(v_805))) else fail-any) else fail-any)) in
        {292}let v_847: bitstring = catch-fail((if success?(3-proj-3-tuple(v_805)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-3-tuple(v_838))))) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-3-tuple(v_844))))) then (if not-caught-fail(v_846) then (v_846,2-proj-3-tuple(v_844),3-proj-3-tuple(v_844)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {293}let v_848: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_847),2-proj-7-tuple(v_804),3-proj-7-tuple(v_804),4-proj-7-tuple(v_804),v_807,6-proj-7-tuple(v_804),7-proj-7-tuple(v_804))) in
        {294}let v_849: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_847))) in
        {295}let v_850: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_849),zero)) in
        {296}let v_851: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_849),zero)) in
        {297}let v_852: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_849),zero)) in
        {298}let v_853: bitstring = catch-fail((if success?(2-proj-3-tuple(v_849)) then (if not-caught-fail(v_850) then (if not-caught-fail(v_851) then (if not-caught-fail(v_852) then (v_850,v_851,v_852) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {299}let v_854: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_853)) then cipherstatepack(1-proj-3-tuple(v_853),minnonce) else fail-any)) in
        {300}let v_855: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_853)) then cipherstatepack(2-proj-3-tuple(v_853),minnonce) else fail-any)) in
        {301}let v_856: bitstring = catch-fail((if success?(1-proj-3-tuple(v_847)) then (if (not-caught-fail(v_849) && success?(is-true(success?(1-proj-3-tuple(v_849))))) then (if (not-caught-fail(v_853) && success?(is-true(success?(1-proj-3-tuple(v_853))))) then (if not-caught-fail(v_854) then (if not-caught-fail(v_855) then (1-proj-3-tuple(v_847),v_854,v_855) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {302}let (hs_857: handshakestate,plaintext_b_858: bitstring,valid_859: bool,cs1_860: cipherstate,cs2_861: cipherstate) = (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-7-tuple(v_804))))) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then (if not-caught-fail(v_806) then (if not-caught-fail(v_807) then (if not-caught-fail(v_809) then (if not-caught-fail(v_815) then (if not-caught-fail(v_822) then (if not-caught-fail(v_829) then (if not-caught-fail(v_837) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-3-tuple(v_847))))) then (if (v_806 && 3-proj-3-tuple(v_847)) then (if not-caught-fail(v_848) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-3-tuple(v_856))))) then (v_848,2-proj-3-tuple(v_847),true,2-proj-3-tuple(v_856),3-proj-3-tuple(v_856)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {303}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_858);
        {304}insert statestore(alice,charlie,sid,statepack_c(hs_857,cs1_860,cs2_861))
    ) | (
        {306}!
        {325}get statestore(=alice,=charlie,=sid,statepack_c(hs_862: handshakestate,cs1_863: cipherstate,cs2_864: cipherstate)) in
        {307}let hs_865: handshakestate = handshakestatesetcs(hs_862,cs1_863) in
        {308}let v_866: bitstring = catch-fail(handshakestateunpack(hs_865)) in
        {309}let v_867: bitstring = catch-fail((empty,empty,empty)) in
        {310}let v_868: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_866))) in
        {311}let v_869: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_868))) in
        {312}let v_870: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_869),2-proj-2-tuple(v_869),3-proj-3-tuple(v_868),msg_c(alice,charlie,sid))) in
        {313}let v_871: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_868))) in
        {314}let v_872: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_869))) && success?(1-proj-3-tuple(v_868))) then (if (not-caught-fail(v_871) && success?(is-true(success?(1-proj-2-tuple(v_871))))) then cipherstatepack(1-proj-2-tuple(v_871),increment_nonce(2-proj-2-tuple(v_869))) else fail-any) else fail-any)) in
        {315}let v_873: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_868)) && success?(1-proj-3-tuple(v_868))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-2-tuple(v_869))))) then (if not-caught-fail(v_870) then (if not-caught-fail(v_872) then (v_872,v_870) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {316}let v_874: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_873),2-proj-3-tuple(v_868),3-proj-3-tuple(v_868)))) in
        {317}let v_875: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_873)) && success?(symmetricstatepack(1-proj-2-tuple(v_873),2-proj-3-tuple(v_868),3-proj-3-tuple(v_868)))) then (if (not-caught-fail(v_874) && success?(is-true(success?(1-proj-3-tuple(v_874))))) then symmetricstatepack(1-proj-3-tuple(v_874),2-proj-3-tuple(v_874),hash(3-proj-3-tuple(v_874),2-proj-2-tuple(v_873))) else fail-any) else fail-any)) in
        {318}let v_876: bitstring = catch-fail((if success?(1-proj-7-tuple(v_866)) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-3-tuple(v_868))))) then (if (not-caught-fail(v_873) && success?(is-true(success?(1-proj-2-tuple(v_873))))) then (if not-caught-fail(v_875) then (v_875,2-proj-2-tuple(v_873)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {319}let v_877: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_876),2-proj-7-tuple(v_866),3-proj-7-tuple(v_866),4-proj-7-tuple(v_866),5-proj-7-tuple(v_866),6-proj-7-tuple(v_866),7-proj-7-tuple(v_866))) in
        {320}let v_878: bitstring = catch-fail(concat3(1-proj-3-tuple(v_867),2-proj-3-tuple(v_867),2-proj-2-tuple(v_876))) in
        {321}let (hs_879: handshakestate,message_c_880: bitstring) = (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-7-tuple(v_866))))) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-3-tuple(v_867))))) then (if (not-caught-fail(v_876) && success?(is-true(success?(1-proj-2-tuple(v_876))))) then (if not-caught-fail(v_877) then (if not-caught-fail(v_878) then (v_877,v_878) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {322}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {323}insert statestore(alice,charlie,sid,statepack_d(hs_879,handshakestategetcs(hs_879),cs2_864));
        {324}out(pub, message_c_880)
    ) | (
        {326}!
        {346}get statestore(=alice,=charlie,=sid,statepack_d(hs_881: handshakestate,cs1_882: cipherstate,cs2_883: cipherstate)) in
        {327}let hs_884: handshakestate = handshakestatesetcs(hs_881,cs2_883) in
        {328}in(pub, message_d_885: bitstring);
        {329}let v_886: bitstring = catch-fail(handshakestateunpack(hs_884)) in
        {330}let v_887: bitstring = catch-fail(deconcat3(message_d_885)) in
        {331}let v_888: bool = catch-fail(true) in
        {332}let v_889: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_886))) in
        {333}let v_890: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_889))) in
        {334}let v_891: aead = catch-fail(decrypt(1-proj-2-tuple(v_890),2-proj-2-tuple(v_890),3-proj-3-tuple(v_889),3-proj-3-tuple(v_887))) in
        {335}let v_892: bitstring = catch-fail(aeadunpack(v_891)) in
        {336}let v_893: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_889))) in
        {337}let v_894: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_890))) && success?(1-proj-3-tuple(v_889))) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-2-tuple(v_893))))) then cipherstatepack(1-proj-2-tuple(v_893),increment_nonce(2-proj-2-tuple(v_890))) else fail-any) else fail-any)) in
        {338}let v_895: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_887)) && (success?(3-proj-3-tuple(v_889)) && success?(1-proj-3-tuple(v_889)))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-2-tuple(v_890))))) then (if not-caught-fail(v_891) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if not-caught-fail(v_894) then (v_894,3-proj-3-tuple(v_892),1-proj-3-tuple(v_892)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {339}let v_896: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_895),2-proj-3-tuple(v_889),3-proj-3-tuple(v_889)))) in
        {340}let v_897: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_887)) && success?(symmetricstatepack(1-proj-3-tuple(v_895),2-proj-3-tuple(v_889),3-proj-3-tuple(v_889)))) then (if (not-caught-fail(v_896) && success?(is-true(success?(1-proj-3-tuple(v_896))))) then symmetricstatepack(1-proj-3-tuple(v_896),2-proj-3-tuple(v_896),hash(3-proj-3-tuple(v_896),3-proj-3-tuple(v_887))) else fail-any) else fail-any)) in
        {341}let v_898: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_887)) && success?(1-proj-7-tuple(v_886))) then (if (not-caught-fail(v_889) && success?(is-true(success?(1-proj-3-tuple(v_889))))) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-3-tuple(v_895))))) then (if not-caught-fail(v_897) then (v_897,2-proj-3-tuple(v_895),3-proj-3-tuple(v_895)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {342}let v_899: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_898),2-proj-7-tuple(v_886),3-proj-7-tuple(v_886),4-proj-7-tuple(v_886),5-proj-7-tuple(v_886),6-proj-7-tuple(v_886),7-proj-7-tuple(v_886))) in
        {343}let (hs_900: handshakestate,plaintext_d_901: bitstring,valid_902: bool) = (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-7-tuple(v_886))))) then (if (not-caught-fail(v_887) && success?(is-true(success?(1-proj-3-tuple(v_887))))) then (if not-caught-fail(v_888) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-3-tuple(v_898))))) then (if (v_888 && 3-proj-3-tuple(v_898)) then (if not-caught-fail(v_899) then (v_899,2-proj-3-tuple(v_898),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {344}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_901);
        {345}event RecvEnd(valid_902)
    ) | (
        {347}event LeakS(phase0,alice);
        {348}out(pub, key_s(alice))
    ) | (
        {349}phase 1;
        {350}event LeakS(phase1,alice);
        {351}out(pub, key_s(alice))
    )
) | (
    {352}let v_903: key = catch-fail(dhexp(key_s(bob),g)) in
    {353}let s_904: keypair = (if not-caught-fail(v_903) then keypairpack(v_903,key_s(bob)) else fail-any) in
    {354}out(pub, getpublickey(s_904));
    (
        {355}let e_905: keypair = keypairpack(empty,empty) in
        {356}let rs_906: key = empty in
        {357}let re_907: key = empty in
        {358}let v_908: bitstring = catch-fail(hash(somename,empty)) in
        {359}let v_909: key = catch-fail(v_908) in
        {360}let v_910: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {361}let v_911: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_908) then (if not-caught-fail(v_909) then (if not-caught-fail(v_910) then symmetricstatepack(v_910,v_909,v_908) else fail-any) else fail-any) else fail-any))) in
        {362}let v_912: symmetricstate = catch-fail((if success?((if not-caught-fail(v_908) then (if not-caught-fail(v_909) then (if not-caught-fail(v_910) then symmetricstatepack(v_910,v_909,v_908) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then symmetricstatepack(1-proj-3-tuple(v_911),2-proj-3-tuple(v_911),hash(3-proj-3-tuple(v_911),empty)) else fail-any) else fail-any)) in
        {363}let v_913: bitstring = catch-fail(symmetricstateunpack(v_912)) in
        {364}let v_914: symmetricstate = catch-fail((if success?(getpublickey(s_904)) then (if (not-caught-fail(v_913) && success?(is-true(success?(1-proj-3-tuple(v_913))))) then symmetricstatepack(1-proj-3-tuple(v_913),2-proj-3-tuple(v_913),hash(3-proj-3-tuple(v_913),getpublickey(s_904))) else fail-any) else fail-any)) in
        {365}let hs_915: handshakestate = (if not-caught-fail(v_912) then (if not-caught-fail(v_914) then handshakestatepack(v_914,s_904,e_905,rs_906,re_907,key_psk(alice,bob),false) else fail-any) else fail-any) in
        {366}insert statestore(bob,alice,sid,statepack_a(hs_915))
    ) | (
        {420}get statestore(=bob,=alice,=sid,statepack_a(hs_916: handshakestate)) in
        {367}in(pub, message_a_917: bitstring);
        {368}let v_918: bitstring = catch-fail(handshakestateunpack(hs_916)) in
        {369}let v_919: bitstring = catch-fail(deconcat3(message_a_917)) in
        {370}let v_920: bool = catch-fail(true) in
        {371}let v_921: key = catch-fail(1-proj-3-tuple(v_919)) in
        {372}let v_922: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_918))) in
        {373}let v_923: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_918)) then (if (not-caught-fail(v_922) && success?(is-true(success?(1-proj-3-tuple(v_922))))) then symmetricstatepack(1-proj-3-tuple(v_922),2-proj-3-tuple(v_922),hash(3-proj-3-tuple(v_922),v_921)) else fail-any) else fail-any)) in
        {374}let v_924: bitstring = catch-fail(symmetricstateunpack(v_923)) in
        {375}let v_925: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_924),v_921)) in
        {376}let v_926: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_924),v_921)) in
        {377}let v_927: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_924),v_921)) in
        {378}let v_928: bitstring = catch-fail((if success?(2-proj-3-tuple(v_924)) then (if not-caught-fail(v_925) then (if not-caught-fail(v_926) then (if not-caught-fail(v_927) then (v_925,v_926,v_927) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {379}let v_929: symmetricstate = catch-fail((if (not-caught-fail(v_924) && success?(is-true(success?(1-proj-3-tuple(v_924))))) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_928)) then cipherstatepack(2-proj-3-tuple(v_928),minnonce) else fail-any),1-proj-3-tuple(v_928),3-proj-3-tuple(v_924)) else fail-any) else fail-any)) in
        {380}let v_930: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_918))) in
        {381}let v_931: bitstring = catch-fail(symmetricstateunpack(v_929)) in
        {382}let v_932: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_931),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then dhexp(2-proj-2-tuple(v_930),v_921) else fail-any) else fail-any))) in
        {383}let v_933: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_931),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then dhexp(2-proj-2-tuple(v_930),v_921) else fail-any) else fail-any))) in
        {384}let v_934: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_931),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then dhexp(2-proj-2-tuple(v_930),v_921) else fail-any) else fail-any))) in
        {385}let v_935: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then dhexp(2-proj-2-tuple(v_930),v_921) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_931))) then (if not-caught-fail(v_932) then (if not-caught-fail(v_933) then (if not-caught-fail(v_934) then (v_932,v_933,v_934) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {386}let v_936: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-2-tuple(v_930))))) then dhexp(2-proj-2-tuple(v_930),v_921) else fail-any) else fail-any)) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-3-tuple(v_931))))) then (if (not-caught-fail(v_935) && success?(is-true(success?(1-proj-3-tuple(v_935))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_935)) then cipherstatepack(2-proj-3-tuple(v_935),minnonce) else fail-any),1-proj-3-tuple(v_935),3-proj-3-tuple(v_931)) else fail-any) else fail-any) else fail-any)) in
        {387}let v_937: bitstring = catch-fail(symmetricstateunpack(v_936)) in
        {388}let v_938: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_937))) in
        {389}let v_939: aead = catch-fail(decrypt(1-proj-2-tuple(v_938),2-proj-2-tuple(v_938),3-proj-3-tuple(v_937),2-proj-3-tuple(v_919))) in
        {390}let v_940: bitstring = catch-fail(aeadunpack(v_939)) in
        {391}let v_941: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_937))) in
        {392}let v_942: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_938))) && success?(1-proj-3-tuple(v_937))) then (if (not-caught-fail(v_941) && success?(is-true(success?(1-proj-2-tuple(v_941))))) then cipherstatepack(1-proj-2-tuple(v_941),increment_nonce(2-proj-2-tuple(v_938))) else fail-any) else fail-any)) in
        {393}let v_943: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_919)) && (success?(3-proj-3-tuple(v_937)) && success?(1-proj-3-tuple(v_937)))) then (if (not-caught-fail(v_938) && success?(is-true(success?(1-proj-2-tuple(v_938))))) then (if not-caught-fail(v_939) then (if (not-caught-fail(v_940) && success?(is-true(success?(1-proj-3-tuple(v_940))))) then (if not-caught-fail(v_942) then (v_942,3-proj-3-tuple(v_940),1-proj-3-tuple(v_940)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {394}let v_944: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_943),2-proj-3-tuple(v_937),3-proj-3-tuple(v_937)))) in
        {395}let v_945: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_919)) && success?(symmetricstatepack(1-proj-3-tuple(v_943),2-proj-3-tuple(v_937),3-proj-3-tuple(v_937)))) then (if (not-caught-fail(v_944) && success?(is-true(success?(1-proj-3-tuple(v_944))))) then symmetricstatepack(1-proj-3-tuple(v_944),2-proj-3-tuple(v_944),hash(3-proj-3-tuple(v_944),2-proj-3-tuple(v_919))) else fail-any) else fail-any)) in
        {396}let v_946: bitstring = catch-fail((if success?(2-proj-3-tuple(v_919)) then (if (not-caught-fail(v_937) && success?(is-true(success?(1-proj-3-tuple(v_937))))) then (if (not-caught-fail(v_943) && success?(is-true(success?(1-proj-3-tuple(v_943))))) then (if not-caught-fail(v_945) then (v_945,2-proj-3-tuple(v_943),3-proj-3-tuple(v_943)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {397}let v_947: key = catch-fail(2-proj-3-tuple(v_946)) in
        {398}let v_948: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_918))) in
        {399}let v_949: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_946))) in
        {400}let v_950: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_949),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then dhexp(2-proj-2-tuple(v_948),v_947) else fail-any) else fail-any))) in
        {401}let v_951: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_949),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then dhexp(2-proj-2-tuple(v_948),v_947) else fail-any) else fail-any))) in
        {402}let v_952: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_949),(if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then dhexp(2-proj-2-tuple(v_948),v_947) else fail-any) else fail-any))) in
        {403}let v_953: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then dhexp(2-proj-2-tuple(v_948),v_947) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_949))) then (if not-caught-fail(v_950) then (if not-caught-fail(v_951) then (if not-caught-fail(v_952) then (v_950,v_951,v_952) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {404}let v_954: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_918)) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-2-tuple(v_948))))) then dhexp(2-proj-2-tuple(v_948),v_947) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_946))) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-3-tuple(v_949))))) then (if (not-caught-fail(v_953) && success?(is-true(success?(1-proj-3-tuple(v_953))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_953)) then cipherstatepack(2-proj-3-tuple(v_953),minnonce) else fail-any),1-proj-3-tuple(v_953),3-proj-3-tuple(v_949)) else fail-any) else fail-any) else fail-any)) in
        {405}let v_955: bitstring = catch-fail(symmetricstateunpack(v_954)) in
        {406}let v_956: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_955))) in
        {407}let v_957: aead = catch-fail(decrypt(1-proj-2-tuple(v_956),2-proj-2-tuple(v_956),3-proj-3-tuple(v_955),3-proj-3-tuple(v_919))) in
        {408}let v_958: bitstring = catch-fail(aeadunpack(v_957)) in
        {409}let v_959: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_955))) in
        {410}let v_960: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_956))) && success?(1-proj-3-tuple(v_955))) then (if (not-caught-fail(v_959) && success?(is-true(success?(1-proj-2-tuple(v_959))))) then cipherstatepack(1-proj-2-tuple(v_959),increment_nonce(2-proj-2-tuple(v_956))) else fail-any) else fail-any)) in
        {411}let v_961: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_919)) && (success?(3-proj-3-tuple(v_955)) && success?(1-proj-3-tuple(v_955)))) then (if (not-caught-fail(v_956) && success?(is-true(success?(1-proj-2-tuple(v_956))))) then (if not-caught-fail(v_957) then (if (not-caught-fail(v_958) && success?(is-true(success?(1-proj-3-tuple(v_958))))) then (if not-caught-fail(v_960) then (v_960,3-proj-3-tuple(v_958),1-proj-3-tuple(v_958)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {412}let v_962: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_961),2-proj-3-tuple(v_955),3-proj-3-tuple(v_955)))) in
        {413}let v_963: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_919)) && success?(symmetricstatepack(1-proj-3-tuple(v_961),2-proj-3-tuple(v_955),3-proj-3-tuple(v_955)))) then (if (not-caught-fail(v_962) && success?(is-true(success?(1-proj-3-tuple(v_962))))) then symmetricstatepack(1-proj-3-tuple(v_962),2-proj-3-tuple(v_962),hash(3-proj-3-tuple(v_962),3-proj-3-tuple(v_919))) else fail-any) else fail-any)) in
        {414}let v_964: bitstring = catch-fail((if success?(3-proj-3-tuple(v_919)) then (if (not-caught-fail(v_955) && success?(is-true(success?(1-proj-3-tuple(v_955))))) then (if (not-caught-fail(v_961) && success?(is-true(success?(1-proj-3-tuple(v_961))))) then (if not-caught-fail(v_963) then (v_963,2-proj-3-tuple(v_961),3-proj-3-tuple(v_961)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {415}let v_965: key = catch-fail(dhexp(key_s(alice),g)) in
        {416}let v_966: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_964),2-proj-7-tuple(v_918),3-proj-7-tuple(v_918),v_947,v_921,6-proj-7-tuple(v_918),7-proj-7-tuple(v_918))) in
        {417}let (hs_967: handshakestate,plaintext_a: bitstring,valid_968: bool) = (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-7-tuple(v_918))))) then (if (not-caught-fail(v_919) && success?(is-true(success?(1-proj-3-tuple(v_919))))) then (if not-caught-fail(v_920) then (if not-caught-fail(v_921) then (if not-caught-fail(v_923) then (if not-caught-fail(v_929) then (if not-caught-fail(v_936) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-3-tuple(v_946))))) then (if not-caught-fail(v_947) then (if not-caught-fail(v_954) then (if (not-caught-fail(v_964) && success?(is-true(success?(1-proj-3-tuple(v_964))))) then (if ((3-proj-3-tuple(v_946) && 3-proj-3-tuple(v_964)) && (v_947 = getpublickey((if not-caught-fail(v_965) then keypairpack(v_965,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_966) then (v_966,2-proj-3-tuple(v_964),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {418}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {419}insert statestore(bob,alice,sid,statepack_b(hs_967))
    ) | (
        {479}get statestore(=bob,=alice,=sid,statepack_b(hs_969: handshakestate)) in
        {421}let v_970: bitstring = catch-fail(handshakestateunpack(hs_969)) in
        {422}let v_971: bitstring = catch-fail((empty,empty,empty)) in
        {423}let v_972: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {424}let v_973: keypair = catch-fail((if not-caught-fail(v_972) then keypairpack(v_972,key_e(bob,alice,sid)) else fail-any)) in
        {425}let v_974: bitstring = catch-fail(getpublickey(v_973)) in
        {426}let v_975: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_970))) in
        {427}let v_976: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_970)) then (if (not-caught-fail(v_975) && success?(is-true(success?(1-proj-3-tuple(v_975))))) then symmetricstatepack(1-proj-3-tuple(v_975),2-proj-3-tuple(v_975),hash(3-proj-3-tuple(v_975),v_974)) else fail-any) else fail-any)) in
        {428}let v_977: bitstring = catch-fail(symmetricstateunpack(v_976)) in
        {429}let v_978: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_977),getpublickey(v_973))) in
        {430}let v_979: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_977),getpublickey(v_973))) in
        {431}let v_980: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_977),getpublickey(v_973))) in
        {432}let v_981: bitstring = catch-fail((if (success?(getpublickey(v_973)) && success?(2-proj-3-tuple(v_977))) then (if not-caught-fail(v_978) then (if not-caught-fail(v_979) then (if not-caught-fail(v_980) then (v_978,v_979,v_980) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {433}let v_982: symmetricstate = catch-fail((if success?(getpublickey(v_973)) then (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-3-tuple(v_977))))) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_981)) then cipherstatepack(2-proj-3-tuple(v_981),minnonce) else fail-any),1-proj-3-tuple(v_981),3-proj-3-tuple(v_977)) else fail-any) else fail-any) else fail-any)) in
        {434}let v_983: bitstring = catch-fail(keypairunpack(v_973)) in
        {435}let v_984: bitstring = catch-fail(symmetricstateunpack(v_982)) in
        {436}let v_985: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_984),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {437}let v_986: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_984),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {438}let v_987: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_984),(if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),5-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {439}let v_988: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),5-proj-7-tuple(v_970)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_984))) then (if not-caught-fail(v_985) then (if not-caught-fail(v_986) then (if not-caught-fail(v_987) then (v_985,v_986,v_987) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {440}let v_989: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_970)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),5-proj-7-tuple(v_970)) else fail-any) else fail-any)) then (if (not-caught-fail(v_984) && success?(is-true(success?(1-proj-3-tuple(v_984))))) then (if (not-caught-fail(v_988) && success?(is-true(success?(1-proj-3-tuple(v_988))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_988)) then cipherstatepack(2-proj-3-tuple(v_988),minnonce) else fail-any),1-proj-3-tuple(v_988),3-proj-3-tuple(v_984)) else fail-any) else fail-any) else fail-any)) in
        {441}let v_990: bitstring = catch-fail(keypairunpack(v_973)) in
        {442}let v_991: bitstring = catch-fail(symmetricstateunpack(v_989)) in
        {443}let v_992: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_991),(if success?(4-proj-7-tuple(v_970)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then dhexp(2-proj-2-tuple(v_990),4-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {444}let v_993: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_991),(if success?(4-proj-7-tuple(v_970)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then dhexp(2-proj-2-tuple(v_990),4-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {445}let v_994: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_991),(if success?(4-proj-7-tuple(v_970)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then dhexp(2-proj-2-tuple(v_990),4-proj-7-tuple(v_970)) else fail-any) else fail-any))) in
        {446}let v_995: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_970)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then dhexp(2-proj-2-tuple(v_990),4-proj-7-tuple(v_970)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_991))) then (if not-caught-fail(v_992) then (if not-caught-fail(v_993) then (if not-caught-fail(v_994) then (v_992,v_993,v_994) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {447}let v_996: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_970)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-2-tuple(v_990))))) then dhexp(2-proj-2-tuple(v_990),4-proj-7-tuple(v_970)) else fail-any) else fail-any)) then (if (not-caught-fail(v_991) && success?(is-true(success?(1-proj-3-tuple(v_991))))) then (if (not-caught-fail(v_995) && success?(is-true(success?(1-proj-3-tuple(v_995))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_995)) then cipherstatepack(2-proj-3-tuple(v_995),minnonce) else fail-any),1-proj-3-tuple(v_995),3-proj-3-tuple(v_991)) else fail-any) else fail-any) else fail-any)) in
        {448}let v_997: bitstring = catch-fail(symmetricstateunpack(v_996)) in
        {449}let v_998: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_997),6-proj-7-tuple(v_970))) in
        {450}let v_999: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_997),6-proj-7-tuple(v_970))) in
        {451}let v_1000: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_997),6-proj-7-tuple(v_970))) in
        {452}let v_1001: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_970)) && success?(2-proj-3-tuple(v_997))) then (if not-caught-fail(v_998) then (if not-caught-fail(v_999) then (if not-caught-fail(v_1000) then (v_998,v_999,v_1000) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {453}let v_1002: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_997),1-proj-3-tuple(v_1001),3-proj-3-tuple(v_997)))) in
        {454}let v_1003: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_1001)) && success?(symmetricstatepack(1-proj-3-tuple(v_997),1-proj-3-tuple(v_1001),3-proj-3-tuple(v_997)))) then (if (not-caught-fail(v_1002) && success?(is-true(success?(1-proj-3-tuple(v_1002))))) then symmetricstatepack(1-proj-3-tuple(v_1002),2-proj-3-tuple(v_1002),hash(3-proj-3-tuple(v_1002),2-proj-3-tuple(v_1001))) else fail-any) else fail-any))) in
        {455}let v_1004: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_970)) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-3-tuple(v_1001))))) then (if (not-caught-fail(v_1003) && success?(is-true(success?(1-proj-3-tuple(v_1003))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_1001)) then cipherstatepack(3-proj-3-tuple(v_1001),minnonce) else fail-any),1-proj-3-tuple(v_1001),3-proj-3-tuple(v_1003)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {456}let v_1005: bitstring = catch-fail(symmetricstateunpack(v_1004)) in
        {457}let v_1006: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1005))) in
        {458}let v_1007: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1006),2-proj-2-tuple(v_1006),3-proj-3-tuple(v_1005),msg_b(bob,alice,sid))) in
        {459}let v_1008: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1005))) in
        {460}let v_1009: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1006))) && success?(1-proj-3-tuple(v_1005))) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-2-tuple(v_1008))))) then cipherstatepack(1-proj-2-tuple(v_1008),increment_nonce(2-proj-2-tuple(v_1006))) else fail-any) else fail-any)) in
        {461}let v_1010: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1005)) && success?(1-proj-3-tuple(v_1005))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-2-tuple(v_1006))))) then (if not-caught-fail(v_1007) then (if not-caught-fail(v_1009) then (v_1009,v_1007) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {462}let v_1011: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1010),2-proj-3-tuple(v_1005),3-proj-3-tuple(v_1005)))) in
        {463}let v_1012: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1010)) && success?(symmetricstatepack(1-proj-2-tuple(v_1010),2-proj-3-tuple(v_1005),3-proj-3-tuple(v_1005)))) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-3-tuple(v_1011))))) then symmetricstatepack(1-proj-3-tuple(v_1011),2-proj-3-tuple(v_1011),hash(3-proj-3-tuple(v_1011),2-proj-2-tuple(v_1010))) else fail-any) else fail-any)) in
        {464}let v_1013: bitstring = catch-fail((if (not-caught-fail(v_1005) && success?(is-true(success?(1-proj-3-tuple(v_1005))))) then (if (not-caught-fail(v_1010) && success?(is-true(success?(1-proj-2-tuple(v_1010))))) then (if not-caught-fail(v_1012) then (v_1012,2-proj-2-tuple(v_1010)) else fail-any) else fail-any) else fail-any)) in
        {465}let v_1014: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1013),2-proj-7-tuple(v_970),v_973,4-proj-7-tuple(v_970),5-proj-7-tuple(v_970),6-proj-7-tuple(v_970),7-proj-7-tuple(v_970))) in
        {466}let v_1015: bitstring = catch-fail(concat3(v_974,2-proj-3-tuple(v_971),2-proj-2-tuple(v_1013))) in
        {467}let v_1016: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1013))) in
        {468}let v_1017: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1016),zero)) in
        {469}let v_1018: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1016),zero)) in
        {470}let v_1019: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1016),zero)) in
        {471}let v_1020: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1016)) then (if not-caught-fail(v_1017) then (if not-caught-fail(v_1018) then (if not-caught-fail(v_1019) then (v_1017,v_1018,v_1019) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {472}let v_1021: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1020)) then cipherstatepack(1-proj-3-tuple(v_1020),minnonce) else fail-any)) in
        {473}let v_1022: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1020)) then cipherstatepack(2-proj-3-tuple(v_1020),minnonce) else fail-any)) in
        {474}let v_1023: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1013)) then (if (not-caught-fail(v_1016) && success?(is-true(success?(1-proj-3-tuple(v_1016))))) then (if (not-caught-fail(v_1020) && success?(is-true(success?(1-proj-3-tuple(v_1020))))) then (if not-caught-fail(v_1021) then (if not-caught-fail(v_1022) then (1-proj-2-tuple(v_1013),v_1021,v_1022) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {475}let (hs_1024: handshakestate,message_b_1025: bitstring,cs1_1026: cipherstate,cs2_1027: cipherstate) = (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-7-tuple(v_970))))) then (if (not-caught-fail(v_971) && success?(is-true(success?(1-proj-3-tuple(v_971))))) then (if not-caught-fail(v_973) then (if not-caught-fail(v_974) then (if not-caught-fail(v_976) then (if not-caught-fail(v_982) then (if not-caught-fail(v_989) then (if not-caught-fail(v_996) then (if not-caught-fail(v_1004) then (if (not-caught-fail(v_1013) && success?(is-true(success?(1-proj-2-tuple(v_1013))))) then (if not-caught-fail(v_1014) then (if not-caught-fail(v_1015) then (if (not-caught-fail(v_1023) && success?(is-true(success?(1-proj-3-tuple(v_1023))))) then (v_1014,v_1015,2-proj-3-tuple(v_1023),3-proj-3-tuple(v_1023)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {476}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {477}insert statestore(bob,alice,sid,statepack_c(hs_1024,cs1_1026,cs2_1027));
        {478}out(pub, message_b_1025)
    ) | (
        {480}!
        {500}get statestore(=bob,=alice,=sid,statepack_c(hs_1028: handshakestate,cs1_1029: cipherstate,cs2_1030: cipherstate)) in
        {481}let hs_1031: handshakestate = handshakestatesetcs(hs_1028,cs1_1029) in
        {482}in(pub, message_c_1032: bitstring);
        {483}let v_1033: bitstring = catch-fail(handshakestateunpack(hs_1031)) in
        {484}let v_1034: bitstring = catch-fail(deconcat3(message_c_1032)) in
        {485}let v_1035: bool = catch-fail(true) in
        {486}let v_1036: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1033))) in
        {487}let v_1037: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1036))) in
        {488}let v_1038: aead = catch-fail(decrypt(1-proj-2-tuple(v_1037),2-proj-2-tuple(v_1037),3-proj-3-tuple(v_1036),3-proj-3-tuple(v_1034))) in
        {489}let v_1039: bitstring = catch-fail(aeadunpack(v_1038)) in
        {490}let v_1040: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1036))) in
        {491}let v_1041: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1037))) && success?(1-proj-3-tuple(v_1036))) then (if (not-caught-fail(v_1040) && success?(is-true(success?(1-proj-2-tuple(v_1040))))) then cipherstatepack(1-proj-2-tuple(v_1040),increment_nonce(2-proj-2-tuple(v_1037))) else fail-any) else fail-any)) in
        {492}let v_1042: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1034)) && (success?(3-proj-3-tuple(v_1036)) && success?(1-proj-3-tuple(v_1036)))) then (if (not-caught-fail(v_1037) && success?(is-true(success?(1-proj-2-tuple(v_1037))))) then (if not-caught-fail(v_1038) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then (if not-caught-fail(v_1041) then (v_1041,3-proj-3-tuple(v_1039),1-proj-3-tuple(v_1039)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {493}let v_1043: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1042),2-proj-3-tuple(v_1036),3-proj-3-tuple(v_1036)))) in
        {494}let v_1044: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1034)) && success?(symmetricstatepack(1-proj-3-tuple(v_1042),2-proj-3-tuple(v_1036),3-proj-3-tuple(v_1036)))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-3-tuple(v_1043))))) then symmetricstatepack(1-proj-3-tuple(v_1043),2-proj-3-tuple(v_1043),hash(3-proj-3-tuple(v_1043),3-proj-3-tuple(v_1034))) else fail-any) else fail-any)) in
        {495}let v_1045: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1034)) && success?(1-proj-7-tuple(v_1033))) then (if (not-caught-fail(v_1036) && success?(is-true(success?(1-proj-3-tuple(v_1036))))) then (if (not-caught-fail(v_1042) && success?(is-true(success?(1-proj-3-tuple(v_1042))))) then (if not-caught-fail(v_1044) then (v_1044,2-proj-3-tuple(v_1042),3-proj-3-tuple(v_1042)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {496}let v_1046: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1045),2-proj-7-tuple(v_1033),3-proj-7-tuple(v_1033),4-proj-7-tuple(v_1033),5-proj-7-tuple(v_1033),6-proj-7-tuple(v_1033),7-proj-7-tuple(v_1033))) in
        {497}let (hs_1047: handshakestate,plaintext_c: bitstring,valid_1048: bool) = (if (not-caught-fail(v_1033) && success?(is-true(success?(1-proj-7-tuple(v_1033))))) then (if (not-caught-fail(v_1034) && success?(is-true(success?(1-proj-3-tuple(v_1034))))) then (if not-caught-fail(v_1035) then (if (not-caught-fail(v_1045) && success?(is-true(success?(1-proj-3-tuple(v_1045))))) then (if (v_1035 && 3-proj-3-tuple(v_1045)) then (if not-caught-fail(v_1046) then (v_1046,2-proj-3-tuple(v_1045),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {498}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {499}insert statestore(bob,alice,sid,statepack_d(hs_1047,handshakestategetcs(hs_1047),cs2_1030))
    ) | (
        {501}!
        {519}get statestore(=bob,=alice,=sid,statepack_d(hs_1049: handshakestate,cs1_1050: cipherstate,cs2_1051: cipherstate)) in
        {502}let hs_1052: handshakestate = handshakestatesetcs(hs_1049,cs2_1051) in
        {503}let v_1053: bitstring = catch-fail(handshakestateunpack(hs_1052)) in
        {504}let v_1054: bitstring = catch-fail((empty,empty,empty)) in
        {505}let v_1055: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1053))) in
        {506}let v_1056: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1055))) in
        {507}let v_1057: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1056),2-proj-2-tuple(v_1056),3-proj-3-tuple(v_1055),msg_d(bob,alice,sid))) in
        {508}let v_1058: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1055))) in
        {509}let v_1059: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1056))) && success?(1-proj-3-tuple(v_1055))) then (if (not-caught-fail(v_1058) && success?(is-true(success?(1-proj-2-tuple(v_1058))))) then cipherstatepack(1-proj-2-tuple(v_1058),increment_nonce(2-proj-2-tuple(v_1056))) else fail-any) else fail-any)) in
        {510}let v_1060: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1055)) && success?(1-proj-3-tuple(v_1055))) then (if (not-caught-fail(v_1056) && success?(is-true(success?(1-proj-2-tuple(v_1056))))) then (if not-caught-fail(v_1057) then (if not-caught-fail(v_1059) then (v_1059,v_1057) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {511}let v_1061: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1060),2-proj-3-tuple(v_1055),3-proj-3-tuple(v_1055)))) in
        {512}let v_1062: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1060)) && success?(symmetricstatepack(1-proj-2-tuple(v_1060),2-proj-3-tuple(v_1055),3-proj-3-tuple(v_1055)))) then (if (not-caught-fail(v_1061) && success?(is-true(success?(1-proj-3-tuple(v_1061))))) then symmetricstatepack(1-proj-3-tuple(v_1061),2-proj-3-tuple(v_1061),hash(3-proj-3-tuple(v_1061),2-proj-2-tuple(v_1060))) else fail-any) else fail-any)) in
        {513}let v_1063: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1053)) then (if (not-caught-fail(v_1055) && success?(is-true(success?(1-proj-3-tuple(v_1055))))) then (if (not-caught-fail(v_1060) && success?(is-true(success?(1-proj-2-tuple(v_1060))))) then (if not-caught-fail(v_1062) then (v_1062,2-proj-2-tuple(v_1060)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {514}let v_1064: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1063),2-proj-7-tuple(v_1053),3-proj-7-tuple(v_1053),4-proj-7-tuple(v_1053),5-proj-7-tuple(v_1053),6-proj-7-tuple(v_1053),7-proj-7-tuple(v_1053))) in
        {515}let v_1065: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1054),2-proj-3-tuple(v_1054),2-proj-2-tuple(v_1063))) in
        {516}let (hs_1066: handshakestate,message_d_1067: bitstring) = (if (not-caught-fail(v_1053) && success?(is-true(success?(1-proj-7-tuple(v_1053))))) then (if (not-caught-fail(v_1054) && success?(is-true(success?(1-proj-3-tuple(v_1054))))) then (if (not-caught-fail(v_1063) && success?(is-true(success?(1-proj-2-tuple(v_1063))))) then (if not-caught-fail(v_1064) then (if not-caught-fail(v_1065) then (v_1064,v_1065) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {517}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice,sid));
        {518}out(pub, message_d_1067)
    ) | (
        {520}event LeakS(phase0,bob);
        {521}out(pub, key_s(bob))
    ) | (
        {522}phase 1;
        {523}event LeakS(phase1,bob);
        {524}out(pub, key_s(bob))
    )
) | (
    {525}let v_1068: key = catch-fail(dhexp(key_s(bob),g)) in
    {526}let s_1069: keypair = (if not-caught-fail(v_1068) then keypairpack(v_1068,key_s(bob)) else fail-any) in
    {527}out(pub, getpublickey(s_1069));
    (
        {528}let e_1070: keypair = keypairpack(empty,empty) in
        {529}let rs_1071: key = empty in
        {530}let re_1072: key = empty in
        {531}let v_1073: bitstring = catch-fail(hash(somename,empty)) in
        {532}let v_1074: key = catch-fail(v_1073) in
        {533}let v_1075: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {534}let v_1076: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_1073) then (if not-caught-fail(v_1074) then (if not-caught-fail(v_1075) then symmetricstatepack(v_1075,v_1074,v_1073) else fail-any) else fail-any) else fail-any))) in
        {535}let v_1077: symmetricstate = catch-fail((if success?((if not-caught-fail(v_1073) then (if not-caught-fail(v_1074) then (if not-caught-fail(v_1075) then symmetricstatepack(v_1075,v_1074,v_1073) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_1076) && success?(is-true(success?(1-proj-3-tuple(v_1076))))) then symmetricstatepack(1-proj-3-tuple(v_1076),2-proj-3-tuple(v_1076),hash(3-proj-3-tuple(v_1076),empty)) else fail-any) else fail-any)) in
        {536}let v_1078: bitstring = catch-fail(symmetricstateunpack(v_1077)) in
        {537}let v_1079: symmetricstate = catch-fail((if success?(getpublickey(s_1069)) then (if (not-caught-fail(v_1078) && success?(is-true(success?(1-proj-3-tuple(v_1078))))) then symmetricstatepack(1-proj-3-tuple(v_1078),2-proj-3-tuple(v_1078),hash(3-proj-3-tuple(v_1078),getpublickey(s_1069))) else fail-any) else fail-any)) in
        {538}let hs_1080: handshakestate = (if not-caught-fail(v_1077) then (if not-caught-fail(v_1079) then handshakestatepack(v_1079,s_1069,e_1070,rs_1071,re_1072,key_psk(charlie,bob),false) else fail-any) else fail-any) in
        {539}insert statestore(bob,charlie,sid,statepack_a(hs_1080))
    ) | (
        {593}get statestore(=bob,=charlie,=sid,statepack_a(hs_1081: handshakestate)) in
        {540}in(pub, message_a_1082: bitstring);
        {541}let v_1083: bitstring = catch-fail(handshakestateunpack(hs_1081)) in
        {542}let v_1084: bitstring = catch-fail(deconcat3(message_a_1082)) in
        {543}let v_1085: bool = catch-fail(true) in
        {544}let v_1086: key = catch-fail(1-proj-3-tuple(v_1084)) in
        {545}let v_1087: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1083))) in
        {546}let v_1088: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1087) && success?(is-true(success?(1-proj-3-tuple(v_1087))))) then symmetricstatepack(1-proj-3-tuple(v_1087),2-proj-3-tuple(v_1087),hash(3-proj-3-tuple(v_1087),v_1086)) else fail-any) else fail-any)) in
        {547}let v_1089: bitstring = catch-fail(symmetricstateunpack(v_1088)) in
        {548}let v_1090: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1089),v_1086)) in
        {549}let v_1091: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1089),v_1086)) in
        {550}let v_1092: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1089),v_1086)) in
        {551}let v_1093: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1089)) then (if not-caught-fail(v_1090) then (if not-caught-fail(v_1091) then (if not-caught-fail(v_1092) then (v_1090,v_1091,v_1092) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {552}let v_1094: symmetricstate = catch-fail((if (not-caught-fail(v_1089) && success?(is-true(success?(1-proj-3-tuple(v_1089))))) then (if (not-caught-fail(v_1093) && success?(is-true(success?(1-proj-3-tuple(v_1093))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1093)) then cipherstatepack(2-proj-3-tuple(v_1093),minnonce) else fail-any),1-proj-3-tuple(v_1093),3-proj-3-tuple(v_1089)) else fail-any) else fail-any)) in
        {553}let v_1095: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_1083))) in
        {554}let v_1096: bitstring = catch-fail(symmetricstateunpack(v_1094)) in
        {555}let v_1097: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1096),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then dhexp(2-proj-2-tuple(v_1095),v_1086) else fail-any) else fail-any))) in
        {556}let v_1098: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1096),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then dhexp(2-proj-2-tuple(v_1095),v_1086) else fail-any) else fail-any))) in
        {557}let v_1099: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1096),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then dhexp(2-proj-2-tuple(v_1095),v_1086) else fail-any) else fail-any))) in
        {558}let v_1100: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then dhexp(2-proj-2-tuple(v_1095),v_1086) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1096))) then (if not-caught-fail(v_1097) then (if not-caught-fail(v_1098) then (if not-caught-fail(v_1099) then (v_1097,v_1098,v_1099) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {559}let v_1101: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-2-tuple(v_1095))))) then dhexp(2-proj-2-tuple(v_1095),v_1086) else fail-any) else fail-any)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-3-tuple(v_1096))))) then (if (not-caught-fail(v_1100) && success?(is-true(success?(1-proj-3-tuple(v_1100))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1100)) then cipherstatepack(2-proj-3-tuple(v_1100),minnonce) else fail-any),1-proj-3-tuple(v_1100),3-proj-3-tuple(v_1096)) else fail-any) else fail-any) else fail-any)) in
        {560}let v_1102: bitstring = catch-fail(symmetricstateunpack(v_1101)) in
        {561}let v_1103: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1102))) in
        {562}let v_1104: aead = catch-fail(decrypt(1-proj-2-tuple(v_1103),2-proj-2-tuple(v_1103),3-proj-3-tuple(v_1102),2-proj-3-tuple(v_1084))) in
        {563}let v_1105: bitstring = catch-fail(aeadunpack(v_1104)) in
        {564}let v_1106: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1102))) in
        {565}let v_1107: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1103))) && success?(1-proj-3-tuple(v_1102))) then (if (not-caught-fail(v_1106) && success?(is-true(success?(1-proj-2-tuple(v_1106))))) then cipherstatepack(1-proj-2-tuple(v_1106),increment_nonce(2-proj-2-tuple(v_1103))) else fail-any) else fail-any)) in
        {566}let v_1108: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_1084)) && (success?(3-proj-3-tuple(v_1102)) && success?(1-proj-3-tuple(v_1102)))) then (if (not-caught-fail(v_1103) && success?(is-true(success?(1-proj-2-tuple(v_1103))))) then (if not-caught-fail(v_1104) then (if (not-caught-fail(v_1105) && success?(is-true(success?(1-proj-3-tuple(v_1105))))) then (if not-caught-fail(v_1107) then (v_1107,3-proj-3-tuple(v_1105),1-proj-3-tuple(v_1105)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {567}let v_1109: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1108),2-proj-3-tuple(v_1102),3-proj-3-tuple(v_1102)))) in
        {568}let v_1110: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_1084)) && success?(symmetricstatepack(1-proj-3-tuple(v_1108),2-proj-3-tuple(v_1102),3-proj-3-tuple(v_1102)))) then (if (not-caught-fail(v_1109) && success?(is-true(success?(1-proj-3-tuple(v_1109))))) then symmetricstatepack(1-proj-3-tuple(v_1109),2-proj-3-tuple(v_1109),hash(3-proj-3-tuple(v_1109),2-proj-3-tuple(v_1084))) else fail-any) else fail-any)) in
        {569}let v_1111: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1084)) then (if (not-caught-fail(v_1102) && success?(is-true(success?(1-proj-3-tuple(v_1102))))) then (if (not-caught-fail(v_1108) && success?(is-true(success?(1-proj-3-tuple(v_1108))))) then (if not-caught-fail(v_1110) then (v_1110,2-proj-3-tuple(v_1108),3-proj-3-tuple(v_1108)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {570}let v_1112: key = catch-fail(2-proj-3-tuple(v_1111)) in
        {571}let v_1113: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_1083))) in
        {572}let v_1114: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_1111))) in
        {573}let v_1115: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1114),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then dhexp(2-proj-2-tuple(v_1113),v_1112) else fail-any) else fail-any))) in
        {574}let v_1116: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1114),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then dhexp(2-proj-2-tuple(v_1113),v_1112) else fail-any) else fail-any))) in
        {575}let v_1117: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1114),(if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then dhexp(2-proj-2-tuple(v_1113),v_1112) else fail-any) else fail-any))) in
        {576}let v_1118: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then dhexp(2-proj-2-tuple(v_1113),v_1112) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1114))) then (if not-caught-fail(v_1115) then (if not-caught-fail(v_1116) then (if not-caught-fail(v_1117) then (v_1115,v_1116,v_1117) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {577}let v_1119: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_1083)) then (if (not-caught-fail(v_1113) && success?(is-true(success?(1-proj-2-tuple(v_1113))))) then dhexp(2-proj-2-tuple(v_1113),v_1112) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_1111))) then (if (not-caught-fail(v_1114) && success?(is-true(success?(1-proj-3-tuple(v_1114))))) then (if (not-caught-fail(v_1118) && success?(is-true(success?(1-proj-3-tuple(v_1118))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1118)) then cipherstatepack(2-proj-3-tuple(v_1118),minnonce) else fail-any),1-proj-3-tuple(v_1118),3-proj-3-tuple(v_1114)) else fail-any) else fail-any) else fail-any)) in
        {578}let v_1120: bitstring = catch-fail(symmetricstateunpack(v_1119)) in
        {579}let v_1121: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1120))) in
        {580}let v_1122: aead = catch-fail(decrypt(1-proj-2-tuple(v_1121),2-proj-2-tuple(v_1121),3-proj-3-tuple(v_1120),3-proj-3-tuple(v_1084))) in
        {581}let v_1123: bitstring = catch-fail(aeadunpack(v_1122)) in
        {582}let v_1124: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1120))) in
        {583}let v_1125: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1121))) && success?(1-proj-3-tuple(v_1120))) then (if (not-caught-fail(v_1124) && success?(is-true(success?(1-proj-2-tuple(v_1124))))) then cipherstatepack(1-proj-2-tuple(v_1124),increment_nonce(2-proj-2-tuple(v_1121))) else fail-any) else fail-any)) in
        {584}let v_1126: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1084)) && (success?(3-proj-3-tuple(v_1120)) && success?(1-proj-3-tuple(v_1120)))) then (if (not-caught-fail(v_1121) && success?(is-true(success?(1-proj-2-tuple(v_1121))))) then (if not-caught-fail(v_1122) then (if (not-caught-fail(v_1123) && success?(is-true(success?(1-proj-3-tuple(v_1123))))) then (if not-caught-fail(v_1125) then (v_1125,3-proj-3-tuple(v_1123),1-proj-3-tuple(v_1123)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {585}let v_1127: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1126),2-proj-3-tuple(v_1120),3-proj-3-tuple(v_1120)))) in
        {586}let v_1128: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1084)) && success?(symmetricstatepack(1-proj-3-tuple(v_1126),2-proj-3-tuple(v_1120),3-proj-3-tuple(v_1120)))) then (if (not-caught-fail(v_1127) && success?(is-true(success?(1-proj-3-tuple(v_1127))))) then symmetricstatepack(1-proj-3-tuple(v_1127),2-proj-3-tuple(v_1127),hash(3-proj-3-tuple(v_1127),3-proj-3-tuple(v_1084))) else fail-any) else fail-any)) in
        {587}let v_1129: bitstring = catch-fail((if success?(3-proj-3-tuple(v_1084)) then (if (not-caught-fail(v_1120) && success?(is-true(success?(1-proj-3-tuple(v_1120))))) then (if (not-caught-fail(v_1126) && success?(is-true(success?(1-proj-3-tuple(v_1126))))) then (if not-caught-fail(v_1128) then (v_1128,2-proj-3-tuple(v_1126),3-proj-3-tuple(v_1126)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {588}let v_1130: key = catch-fail(dhexp(key_s(charlie),g)) in
        {589}let v_1131: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1129),2-proj-7-tuple(v_1083),3-proj-7-tuple(v_1083),v_1112,v_1086,6-proj-7-tuple(v_1083),7-proj-7-tuple(v_1083))) in
        {590}let (hs_1132: handshakestate,plaintext_a_1133: bitstring,valid_1134: bool) = (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-7-tuple(v_1083))))) then (if (not-caught-fail(v_1084) && success?(is-true(success?(1-proj-3-tuple(v_1084))))) then (if not-caught-fail(v_1085) then (if not-caught-fail(v_1086) then (if not-caught-fail(v_1088) then (if not-caught-fail(v_1094) then (if not-caught-fail(v_1101) then (if (not-caught-fail(v_1111) && success?(is-true(success?(1-proj-3-tuple(v_1111))))) then (if not-caught-fail(v_1112) then (if not-caught-fail(v_1119) then (if (not-caught-fail(v_1129) && success?(is-true(success?(1-proj-3-tuple(v_1129))))) then (if ((3-proj-3-tuple(v_1111) && 3-proj-3-tuple(v_1129)) && (v_1112 = getpublickey((if not-caught-fail(v_1130) then keypairpack(v_1130,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1131) then (v_1131,2-proj-3-tuple(v_1129),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {591}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_1133);
        {592}insert statestore(bob,charlie,sid,statepack_b(hs_1132))
    ) | (
        {652}get statestore(=bob,=charlie,=sid,statepack_b(hs_1135: handshakestate)) in
        {594}let v_1136: bitstring = catch-fail(handshakestateunpack(hs_1135)) in
        {595}let v_1137: bitstring = catch-fail((empty,empty,empty)) in
        {596}let v_1138: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {597}let v_1139: keypair = catch-fail((if not-caught-fail(v_1138) then keypairpack(v_1138,key_e(bob,charlie,sid)) else fail-any)) in
        {598}let v_1140: bitstring = catch-fail(getpublickey(v_1139)) in
        {599}let v_1141: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1136))) in
        {600}let v_1142: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1141) && success?(is-true(success?(1-proj-3-tuple(v_1141))))) then symmetricstatepack(1-proj-3-tuple(v_1141),2-proj-3-tuple(v_1141),hash(3-proj-3-tuple(v_1141),v_1140)) else fail-any) else fail-any)) in
        {601}let v_1143: bitstring = catch-fail(symmetricstateunpack(v_1142)) in
        {602}let v_1144: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1143),getpublickey(v_1139))) in
        {603}let v_1145: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1143),getpublickey(v_1139))) in
        {604}let v_1146: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1143),getpublickey(v_1139))) in
        {605}let v_1147: bitstring = catch-fail((if (success?(getpublickey(v_1139)) && success?(2-proj-3-tuple(v_1143))) then (if not-caught-fail(v_1144) then (if not-caught-fail(v_1145) then (if not-caught-fail(v_1146) then (v_1144,v_1145,v_1146) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {606}let v_1148: symmetricstate = catch-fail((if success?(getpublickey(v_1139)) then (if (not-caught-fail(v_1143) && success?(is-true(success?(1-proj-3-tuple(v_1143))))) then (if (not-caught-fail(v_1147) && success?(is-true(success?(1-proj-3-tuple(v_1147))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1147)) then cipherstatepack(2-proj-3-tuple(v_1147),minnonce) else fail-any),1-proj-3-tuple(v_1147),3-proj-3-tuple(v_1143)) else fail-any) else fail-any) else fail-any)) in
        {607}let v_1149: bitstring = catch-fail(keypairunpack(v_1139)) in
        {608}let v_1150: bitstring = catch-fail(symmetricstateunpack(v_1148)) in
        {609}let v_1151: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1150),(if success?(5-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1149) && success?(is-true(success?(1-proj-2-tuple(v_1149))))) then dhexp(2-proj-2-tuple(v_1149),5-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {610}let v_1152: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1150),(if success?(5-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1149) && success?(is-true(success?(1-proj-2-tuple(v_1149))))) then dhexp(2-proj-2-tuple(v_1149),5-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {611}let v_1153: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1150),(if success?(5-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1149) && success?(is-true(success?(1-proj-2-tuple(v_1149))))) then dhexp(2-proj-2-tuple(v_1149),5-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {612}let v_1154: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1149) && success?(is-true(success?(1-proj-2-tuple(v_1149))))) then dhexp(2-proj-2-tuple(v_1149),5-proj-7-tuple(v_1136)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1150))) then (if not-caught-fail(v_1151) then (if not-caught-fail(v_1152) then (if not-caught-fail(v_1153) then (v_1151,v_1152,v_1153) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {613}let v_1155: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1149) && success?(is-true(success?(1-proj-2-tuple(v_1149))))) then dhexp(2-proj-2-tuple(v_1149),5-proj-7-tuple(v_1136)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1150) && success?(is-true(success?(1-proj-3-tuple(v_1150))))) then (if (not-caught-fail(v_1154) && success?(is-true(success?(1-proj-3-tuple(v_1154))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1154)) then cipherstatepack(2-proj-3-tuple(v_1154),minnonce) else fail-any),1-proj-3-tuple(v_1154),3-proj-3-tuple(v_1150)) else fail-any) else fail-any) else fail-any)) in
        {614}let v_1156: bitstring = catch-fail(keypairunpack(v_1139)) in
        {615}let v_1157: bitstring = catch-fail(symmetricstateunpack(v_1155)) in
        {616}let v_1158: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1157),(if success?(4-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1156) && success?(is-true(success?(1-proj-2-tuple(v_1156))))) then dhexp(2-proj-2-tuple(v_1156),4-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {617}let v_1159: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1157),(if success?(4-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1156) && success?(is-true(success?(1-proj-2-tuple(v_1156))))) then dhexp(2-proj-2-tuple(v_1156),4-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {618}let v_1160: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1157),(if success?(4-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1156) && success?(is-true(success?(1-proj-2-tuple(v_1156))))) then dhexp(2-proj-2-tuple(v_1156),4-proj-7-tuple(v_1136)) else fail-any) else fail-any))) in
        {619}let v_1161: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1156) && success?(is-true(success?(1-proj-2-tuple(v_1156))))) then dhexp(2-proj-2-tuple(v_1156),4-proj-7-tuple(v_1136)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1157))) then (if not-caught-fail(v_1158) then (if not-caught-fail(v_1159) then (if not-caught-fail(v_1160) then (v_1158,v_1159,v_1160) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {620}let v_1162: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1156) && success?(is-true(success?(1-proj-2-tuple(v_1156))))) then dhexp(2-proj-2-tuple(v_1156),4-proj-7-tuple(v_1136)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1157) && success?(is-true(success?(1-proj-3-tuple(v_1157))))) then (if (not-caught-fail(v_1161) && success?(is-true(success?(1-proj-3-tuple(v_1161))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1161)) then cipherstatepack(2-proj-3-tuple(v_1161),minnonce) else fail-any),1-proj-3-tuple(v_1161),3-proj-3-tuple(v_1157)) else fail-any) else fail-any) else fail-any)) in
        {621}let v_1163: bitstring = catch-fail(symmetricstateunpack(v_1162)) in
        {622}let v_1164: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1163),6-proj-7-tuple(v_1136))) in
        {623}let v_1165: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1163),6-proj-7-tuple(v_1136))) in
        {624}let v_1166: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1163),6-proj-7-tuple(v_1136))) in
        {625}let v_1167: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_1136)) && success?(2-proj-3-tuple(v_1163))) then (if not-caught-fail(v_1164) then (if not-caught-fail(v_1165) then (if not-caught-fail(v_1166) then (v_1164,v_1165,v_1166) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {626}let v_1168: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1163),1-proj-3-tuple(v_1167),3-proj-3-tuple(v_1163)))) in
        {627}let v_1169: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_1167)) && success?(symmetricstatepack(1-proj-3-tuple(v_1163),1-proj-3-tuple(v_1167),3-proj-3-tuple(v_1163)))) then (if (not-caught-fail(v_1168) && success?(is-true(success?(1-proj-3-tuple(v_1168))))) then symmetricstatepack(1-proj-3-tuple(v_1168),2-proj-3-tuple(v_1168),hash(3-proj-3-tuple(v_1168),2-proj-3-tuple(v_1167))) else fail-any) else fail-any))) in
        {628}let v_1170: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_1136)) then (if (not-caught-fail(v_1163) && success?(is-true(success?(1-proj-3-tuple(v_1163))))) then (if (not-caught-fail(v_1167) && success?(is-true(success?(1-proj-3-tuple(v_1167))))) then (if (not-caught-fail(v_1169) && success?(is-true(success?(1-proj-3-tuple(v_1169))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_1167)) then cipherstatepack(3-proj-3-tuple(v_1167),minnonce) else fail-any),1-proj-3-tuple(v_1167),3-proj-3-tuple(v_1169)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {629}let v_1171: bitstring = catch-fail(symmetricstateunpack(v_1170)) in
        {630}let v_1172: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1171))) in
        {631}let v_1173: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1172),2-proj-2-tuple(v_1172),3-proj-3-tuple(v_1171),msg_b(bob,charlie,sid))) in
        {632}let v_1174: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1171))) in
        {633}let v_1175: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1172))) && success?(1-proj-3-tuple(v_1171))) then (if (not-caught-fail(v_1174) && success?(is-true(success?(1-proj-2-tuple(v_1174))))) then cipherstatepack(1-proj-2-tuple(v_1174),increment_nonce(2-proj-2-tuple(v_1172))) else fail-any) else fail-any)) in
        {634}let v_1176: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1171)) && success?(1-proj-3-tuple(v_1171))) then (if (not-caught-fail(v_1172) && success?(is-true(success?(1-proj-2-tuple(v_1172))))) then (if not-caught-fail(v_1173) then (if not-caught-fail(v_1175) then (v_1175,v_1173) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {635}let v_1177: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1176),2-proj-3-tuple(v_1171),3-proj-3-tuple(v_1171)))) in
        {636}let v_1178: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1176)) && success?(symmetricstatepack(1-proj-2-tuple(v_1176),2-proj-3-tuple(v_1171),3-proj-3-tuple(v_1171)))) then (if (not-caught-fail(v_1177) && success?(is-true(success?(1-proj-3-tuple(v_1177))))) then symmetricstatepack(1-proj-3-tuple(v_1177),2-proj-3-tuple(v_1177),hash(3-proj-3-tuple(v_1177),2-proj-2-tuple(v_1176))) else fail-any) else fail-any)) in
        {637}let v_1179: bitstring = catch-fail((if (not-caught-fail(v_1171) && success?(is-true(success?(1-proj-3-tuple(v_1171))))) then (if (not-caught-fail(v_1176) && success?(is-true(success?(1-proj-2-tuple(v_1176))))) then (if not-caught-fail(v_1178) then (v_1178,2-proj-2-tuple(v_1176)) else fail-any) else fail-any) else fail-any)) in
        {638}let v_1180: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1179),2-proj-7-tuple(v_1136),v_1139,4-proj-7-tuple(v_1136),5-proj-7-tuple(v_1136),6-proj-7-tuple(v_1136),7-proj-7-tuple(v_1136))) in
        {639}let v_1181: bitstring = catch-fail(concat3(v_1140,2-proj-3-tuple(v_1137),2-proj-2-tuple(v_1179))) in
        {640}let v_1182: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1179))) in
        {641}let v_1183: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1182),zero)) in
        {642}let v_1184: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1182),zero)) in
        {643}let v_1185: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1182),zero)) in
        {644}let v_1186: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1182)) then (if not-caught-fail(v_1183) then (if not-caught-fail(v_1184) then (if not-caught-fail(v_1185) then (v_1183,v_1184,v_1185) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {645}let v_1187: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1186)) then cipherstatepack(1-proj-3-tuple(v_1186),minnonce) else fail-any)) in
        {646}let v_1188: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1186)) then cipherstatepack(2-proj-3-tuple(v_1186),minnonce) else fail-any)) in
        {647}let v_1189: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1179)) then (if (not-caught-fail(v_1182) && success?(is-true(success?(1-proj-3-tuple(v_1182))))) then (if (not-caught-fail(v_1186) && success?(is-true(success?(1-proj-3-tuple(v_1186))))) then (if not-caught-fail(v_1187) then (if not-caught-fail(v_1188) then (1-proj-2-tuple(v_1179),v_1187,v_1188) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {648}let (hs_1190: handshakestate,message_b_1191: bitstring,cs1_1192: cipherstate,cs2_1193: cipherstate) = (if (not-caught-fail(v_1136) && success?(is-true(success?(1-proj-7-tuple(v_1136))))) then (if (not-caught-fail(v_1137) && success?(is-true(success?(1-proj-3-tuple(v_1137))))) then (if not-caught-fail(v_1139) then (if not-caught-fail(v_1140) then (if not-caught-fail(v_1142) then (if not-caught-fail(v_1148) then (if not-caught-fail(v_1155) then (if not-caught-fail(v_1162) then (if not-caught-fail(v_1170) then (if (not-caught-fail(v_1179) && success?(is-true(success?(1-proj-2-tuple(v_1179))))) then (if not-caught-fail(v_1180) then (if not-caught-fail(v_1181) then (if (not-caught-fail(v_1189) && success?(is-true(success?(1-proj-3-tuple(v_1189))))) then (v_1180,v_1181,2-proj-3-tuple(v_1189),3-proj-3-tuple(v_1189)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {649}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {650}insert statestore(bob,charlie,sid,statepack_c(hs_1190,cs1_1192,cs2_1193));
        {651}out(pub, message_b_1191)
    ) | (
        {653}!
        {673}get statestore(=bob,=charlie,=sid,statepack_c(hs_1194: handshakestate,cs1_1195: cipherstate,cs2_1196: cipherstate)) in
        {654}let hs_1197: handshakestate = handshakestatesetcs(hs_1194,cs1_1195) in
        {655}in(pub, message_c_1198: bitstring);
        {656}let v_1199: bitstring = catch-fail(handshakestateunpack(hs_1197)) in
        {657}let v_1200: bitstring = catch-fail(deconcat3(message_c_1198)) in
        {658}let v_1201: bool = catch-fail(true) in
        {659}let v_1202: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1199))) in
        {660}let v_1203: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1202))) in
        {661}let v_1204: aead = catch-fail(decrypt(1-proj-2-tuple(v_1203),2-proj-2-tuple(v_1203),3-proj-3-tuple(v_1202),3-proj-3-tuple(v_1200))) in
        {662}let v_1205: bitstring = catch-fail(aeadunpack(v_1204)) in
        {663}let v_1206: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1202))) in
        {664}let v_1207: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1203))) && success?(1-proj-3-tuple(v_1202))) then (if (not-caught-fail(v_1206) && success?(is-true(success?(1-proj-2-tuple(v_1206))))) then cipherstatepack(1-proj-2-tuple(v_1206),increment_nonce(2-proj-2-tuple(v_1203))) else fail-any) else fail-any)) in
        {665}let v_1208: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1200)) && (success?(3-proj-3-tuple(v_1202)) && success?(1-proj-3-tuple(v_1202)))) then (if (not-caught-fail(v_1203) && success?(is-true(success?(1-proj-2-tuple(v_1203))))) then (if not-caught-fail(v_1204) then (if (not-caught-fail(v_1205) && success?(is-true(success?(1-proj-3-tuple(v_1205))))) then (if not-caught-fail(v_1207) then (v_1207,3-proj-3-tuple(v_1205),1-proj-3-tuple(v_1205)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {666}let v_1209: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1208),2-proj-3-tuple(v_1202),3-proj-3-tuple(v_1202)))) in
        {667}let v_1210: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1200)) && success?(symmetricstatepack(1-proj-3-tuple(v_1208),2-proj-3-tuple(v_1202),3-proj-3-tuple(v_1202)))) then (if (not-caught-fail(v_1209) && success?(is-true(success?(1-proj-3-tuple(v_1209))))) then symmetricstatepack(1-proj-3-tuple(v_1209),2-proj-3-tuple(v_1209),hash(3-proj-3-tuple(v_1209),3-proj-3-tuple(v_1200))) else fail-any) else fail-any)) in
        {668}let v_1211: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1200)) && success?(1-proj-7-tuple(v_1199))) then (if (not-caught-fail(v_1202) && success?(is-true(success?(1-proj-3-tuple(v_1202))))) then (if (not-caught-fail(v_1208) && success?(is-true(success?(1-proj-3-tuple(v_1208))))) then (if not-caught-fail(v_1210) then (v_1210,2-proj-3-tuple(v_1208),3-proj-3-tuple(v_1208)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {669}let v_1212: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1211),2-proj-7-tuple(v_1199),3-proj-7-tuple(v_1199),4-proj-7-tuple(v_1199),5-proj-7-tuple(v_1199),6-proj-7-tuple(v_1199),7-proj-7-tuple(v_1199))) in
        {670}let (hs_1213: handshakestate,plaintext_c_1214: bitstring,valid_1215: bool) = (if (not-caught-fail(v_1199) && success?(is-true(success?(1-proj-7-tuple(v_1199))))) then (if (not-caught-fail(v_1200) && success?(is-true(success?(1-proj-3-tuple(v_1200))))) then (if not-caught-fail(v_1201) then (if (not-caught-fail(v_1211) && success?(is-true(success?(1-proj-3-tuple(v_1211))))) then (if (v_1201 && 3-proj-3-tuple(v_1211)) then (if not-caught-fail(v_1212) then (v_1212,2-proj-3-tuple(v_1211),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {671}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1214);
        {672}insert statestore(bob,charlie,sid,statepack_d(hs_1213,handshakestategetcs(hs_1213),cs2_1196))
    ) | (
        {674}!
        {692}get statestore(=bob,=charlie,=sid,statepack_d(hs_1216: handshakestate,cs1_1217: cipherstate,cs2_1218: cipherstate)) in
        {675}let hs_1219: handshakestate = handshakestatesetcs(hs_1216,cs2_1218) in
        {676}let v_1220: bitstring = catch-fail(handshakestateunpack(hs_1219)) in
        {677}let v_1221: bitstring = catch-fail((empty,empty,empty)) in
        {678}let v_1222: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1220))) in
        {679}let v_1223: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1222))) in
        {680}let v_1224: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1223),2-proj-2-tuple(v_1223),3-proj-3-tuple(v_1222),msg_d(bob,charlie,sid))) in
        {681}let v_1225: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1222))) in
        {682}let v_1226: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1223))) && success?(1-proj-3-tuple(v_1222))) then (if (not-caught-fail(v_1225) && success?(is-true(success?(1-proj-2-tuple(v_1225))))) then cipherstatepack(1-proj-2-tuple(v_1225),increment_nonce(2-proj-2-tuple(v_1223))) else fail-any) else fail-any)) in
        {683}let v_1227: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1222)) && success?(1-proj-3-tuple(v_1222))) then (if (not-caught-fail(v_1223) && success?(is-true(success?(1-proj-2-tuple(v_1223))))) then (if not-caught-fail(v_1224) then (if not-caught-fail(v_1226) then (v_1226,v_1224) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {684}let v_1228: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1227),2-proj-3-tuple(v_1222),3-proj-3-tuple(v_1222)))) in
        {685}let v_1229: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1227)) && success?(symmetricstatepack(1-proj-2-tuple(v_1227),2-proj-3-tuple(v_1222),3-proj-3-tuple(v_1222)))) then (if (not-caught-fail(v_1228) && success?(is-true(success?(1-proj-3-tuple(v_1228))))) then symmetricstatepack(1-proj-3-tuple(v_1228),2-proj-3-tuple(v_1228),hash(3-proj-3-tuple(v_1228),2-proj-2-tuple(v_1227))) else fail-any) else fail-any)) in
        {686}let v_1230: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1220)) then (if (not-caught-fail(v_1222) && success?(is-true(success?(1-proj-3-tuple(v_1222))))) then (if (not-caught-fail(v_1227) && success?(is-true(success?(1-proj-2-tuple(v_1227))))) then (if not-caught-fail(v_1229) then (v_1229,2-proj-2-tuple(v_1227)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {687}let v_1231: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1230),2-proj-7-tuple(v_1220),3-proj-7-tuple(v_1220),4-proj-7-tuple(v_1220),5-proj-7-tuple(v_1220),6-proj-7-tuple(v_1220),7-proj-7-tuple(v_1220))) in
        {688}let v_1232: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1221),2-proj-3-tuple(v_1221),2-proj-2-tuple(v_1230))) in
        {689}let (hs_1233: handshakestate,message_d_1234: bitstring) = (if (not-caught-fail(v_1220) && success?(is-true(success?(1-proj-7-tuple(v_1220))))) then (if (not-caught-fail(v_1221) && success?(is-true(success?(1-proj-3-tuple(v_1221))))) then (if (not-caught-fail(v_1230) && success?(is-true(success?(1-proj-2-tuple(v_1230))))) then (if not-caught-fail(v_1231) then (if not-caught-fail(v_1232) then (v_1231,v_1232) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {690}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie,sid));
        {691}out(pub, message_d_1234)
    ) | (
        {693}event LeakS(phase0,bob);
        {694}out(pub, key_s(bob))
    ) | (
        {695}phase 1;
        {696}event LeakS(phase1,bob);
        {697}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1337,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1337,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1337,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1337,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1337,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1337,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1337,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1337,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 177 rules in the queue.
400 rules inserted. The rule base contains 394 rules. 140 rules in the queue.
600 rules inserted. The rule base contains 567 rules. 141 rules in the queue.
800 rules inserted. The rule base contains 766 rules. 344 rules in the queue.
1000 rules inserted. The rule base contains 966 rules. 633 rules in the queue.
1200 rules inserted. The rule base contains 1150 rules. 635 rules in the queue.
1400 rules inserted. The rule base contains 1320 rules. 566 rules in the queue.
1600 rules inserted. The rule base contains 1489 rules. 495 rules in the queue.
1800 rules inserted. The rule base contains 1677 rules. 474 rules in the queue.
2000 rules inserted. The rule base contains 1865 rules. 592 rules in the queue.
2200 rules inserted. The rule base contains 1997 rules. 806 rules in the queue.
2400 rules inserted. The rule base contains 2197 rules. 873 rules in the queue.
2600 rules inserted. The rule base contains 2397 rules. 957 rules in the queue.
2800 rules inserted. The rule base contains 2597 rules. 1007 rules in the queue.
3000 rules inserted. The rule base contains 2797 rules. 1017 rules in the queue.
3200 rules inserted. The rule base contains 2955 rules. 1035 rules in the queue.
3400 rules inserted. The rule base contains 3100 rules. 1055 rules in the queue.
3600 rules inserted. The rule base contains 3243 rules. 1078 rules in the queue.
3800 rules inserted. The rule base contains 3405 rules. 1090 rules in the queue.
4000 rules inserted. The rule base contains 3605 rules. 1100 rules in the queue.
4200 rules inserted. The rule base contains 3786 rules. 1110 rules in the queue.
4400 rules inserted. The rule base contains 3986 rules. 1124 rules in the queue.
4600 rules inserted. The rule base contains 4186 rules. 1141 rules in the queue.
4800 rules inserted. The rule base contains 4386 rules. 1159 rules in the queue.
5000 rules inserted. The rule base contains 4439 rules. 1115 rules in the queue.
5200 rules inserted. The rule base contains 4570 rules. 1114 rules in the queue.
5400 rules inserted. The rule base contains 4740 rules. 1145 rules in the queue.
5600 rules inserted. The rule base contains 4913 rules. 1165 rules in the queue.
5800 rules inserted. The rule base contains 5088 rules. 1194 rules in the queue.
6000 rules inserted. The rule base contains 5251 rules. 1213 rules in the queue.
6200 rules inserted. The rule base contains 5413 rules. 1240 rules in the queue.
6400 rules inserted. The rule base contains 5505 rules. 1227 rules in the queue.
6600 rules inserted. The rule base contains 5588 rules. 1205 rules in the queue.
6800 rules inserted. The rule base contains 5680 rules. 1185 rules in the queue.
7000 rules inserted. The rule base contains 5757 rules. 1174 rules in the queue.
7200 rules inserted. The rule base contains 5893 rules. 1173 rules in the queue.
7400 rules inserted. The rule base contains 6004 rules. 1199 rules in the queue.
7600 rules inserted. The rule base contains 6123 rules. 1226 rules in the queue.
7800 rules inserted. The rule base contains 6249 rules. 1254 rules in the queue.
8000 rules inserted. The rule base contains 6380 rules. 1274 rules in the queue.
8200 rules inserted. The rule base contains 6537 rules. 1280 rules in the queue.
8400 rules inserted. The rule base contains 6666 rules. 1338 rules in the queue.
8600 rules inserted. The rule base contains 6810 rules. 1371 rules in the queue.
8800 rules inserted. The rule base contains 6960 rules. 1384 rules in the queue.
9000 rules inserted. The rule base contains 7109 rules. 1390 rules in the queue.
9200 rules inserted. The rule base contains 7262 rules. 1396 rules in the queue.
9400 rules inserted. The rule base contains 7420 rules. 1404 rules in the queue.
9600 rules inserted. The rule base contains 7481 rules. 1420 rules in the queue.
9800 rules inserted. The rule base contains 7607 rules. 1420 rules in the queue.
10000 rules inserted. The rule base contains 7738 rules. 1415 rules in the queue.
10200 rules inserted. The rule base contains 7863 rules. 1407 rules in the queue.
10400 rules inserted. The rule base contains 7994 rules. 1400 rules in the queue.
10600 rules inserted. The rule base contains 8138 rules. 1396 rules in the queue.
10800 rules inserted. The rule base contains 8312 rules. 1403 rules in the queue.
11000 rules inserted. The rule base contains 8372 rules. 1397 rules in the queue.
11200 rules inserted. The rule base contains 8530 rules. 1470 rules in the queue.
11400 rules inserted. The rule base contains 8686 rules. 1480 rules in the queue.
11600 rules inserted. The rule base contains 8855 rules. 1503 rules in the queue.
11800 rules inserted. The rule base contains 9023 rules. 1522 rules in the queue.
12000 rules inserted. The rule base contains 9107 rules. 1542 rules in the queue.
12200 rules inserted. The rule base contains 9199 rules. 1559 rules in the queue.
12400 rules inserted. The rule base contains 9299 rules. 1577 rules in the queue.
12600 rules inserted. The rule base contains 9404 rules. 1601 rules in the queue.
12800 rules inserted. The rule base contains 9537 rules. 1641 rules in the queue.
13000 rules inserted. The rule base contains 9655 rules. 1668 rules in the queue.
13200 rules inserted. The rule base contains 9791 rules. 1709 rules in the queue.
13400 rules inserted. The rule base contains 9955 rules. 1734 rules in the queue.
13600 rules inserted. The rule base contains 10057 rules. 1729 rules in the queue.
13800 rules inserted. The rule base contains 10114 rules. 1707 rules in the queue.
14000 rules inserted. The rule base contains 10193 rules. 1674 rules in the queue.
14200 rules inserted. The rule base contains 10299 rules. 1609 rules in the queue.
14400 rules inserted. The rule base contains 10408 rules. 1547 rules in the queue.
14600 rules inserted. The rule base contains 10517 rules. 1492 rules in the queue.
14800 rules inserted. The rule base contains 10653 rules. 1451 rules in the queue.
15000 rules inserted. The rule base contains 10765 rules. 1440 rules in the queue.
15200 rules inserted. The rule base contains 10794 rules. 1430 rules in the queue.
15400 rules inserted. The rule base contains 10893 rules. 1413 rules in the queue.
15600 rules inserted. The rule base contains 11081 rules. 1443 rules in the queue.
15800 rules inserted. The rule base contains 11217 rules. 1426 rules in the queue.
16000 rules inserted. The rule base contains 11416 rules. 1465 rules in the queue.
16200 rules inserted. The rule base contains 11512 rules. 1454 rules in the queue.
16400 rules inserted. The rule base contains 11571 rules. 1458 rules in the queue.
16600 rules inserted. The rule base contains 11700 rules. 1405 rules in the queue.
16800 rules inserted. The rule base contains 11803 rules. 1396 rules in the queue.
17000 rules inserted. The rule base contains 11939 rules. 1376 rules in the queue.
17200 rules inserted. The rule base contains 12074 rules. 1355 rules in the queue.
17400 rules inserted. The rule base contains 12217 rules. 1429 rules in the queue.
17600 rules inserted. The rule base contains 12358 rules. 1615 rules in the queue.
17800 rules inserted. The rule base contains 12488 rules. 1639 rules in the queue.
18000 rules inserted. The rule base contains 12616 rules. 1632 rules in the queue.
18200 rules inserted. The rule base contains 12801 rules. 1632 rules in the queue.
18400 rules inserted. The rule base contains 12974 rules. 1611 rules in the queue.
18600 rules inserted. The rule base contains 13166 rules. 1641 rules in the queue.
18800 rules inserted. The rule base contains 13082 rules. 1704 rules in the queue.
19000 rules inserted. The rule base contains 13258 rules. 1992 rules in the queue.
19200 rules inserted. The rule base contains 13416 rules. 2413 rules in the queue.
19400 rules inserted. The rule base contains 13537 rules. 2460 rules in the queue.
19600 rules inserted. The rule base contains 13643 rules. 2467 rules in the queue.
19800 rules inserted. The rule base contains 13783 rules. 2481 rules in the queue.
20000 rules inserted. The rule base contains 13941 rules. 2489 rules in the queue.
20200 rules inserted. The rule base contains 14052 rules. 2499 rules in the queue.
20400 rules inserted. The rule base contains 14207 rules. 2890 rules in the queue.
20600 rules inserted. The rule base contains 14331 rules. 3119 rules in the queue.
20800 rules inserted. The rule base contains 14512 rules. 3258 rules in the queue.
21000 rules inserted. The rule base contains 14691 rules. 3397 rules in the queue.
21200 rules inserted. The rule base contains 14859 rules. 3565 rules in the queue.
21400 rules inserted. The rule base contains 15047 rules. 3789 rules in the queue.
21600 rules inserted. The rule base contains 15227 rules. 4096 rules in the queue.
21800 rules inserted. The rule base contains 15381 rules. 4287 rules in the queue.
22000 rules inserted. The rule base contains 15414 rules. 4372 rules in the queue.
22200 rules inserted. The rule base contains 15566 rules. 4358 rules in the queue.
22400 rules inserted. The rule base contains 15721 rules. 4339 rules in the queue.
22600 rules inserted. The rule base contains 15786 rules. 4331 rules in the queue.
22800 rules inserted. The rule base contains 15853 rules. 4331 rules in the queue.
23000 rules inserted. The rule base contains 15926 rules. 4323 rules in the queue.
23200 rules inserted. The rule base contains 15984 rules. 4355 rules in the queue.
23400 rules inserted. The rule base contains 16111 rules. 4442 rules in the queue.
23600 rules inserted. The rule base contains 16269 rules. 4437 rules in the queue.
23800 rules inserted. The rule base contains 16443 rules. 4366 rules in the queue.
24000 rules inserted. The rule base contains 16613 rules. 4269 rules in the queue.
24200 rules inserted. The rule base contains 16795 rules. 4342 rules in the queue.
24400 rules inserted. The rule base contains 16995 rules. 4681 rules in the queue.
24600 rules inserted. The rule base contains 17194 rules. 4995 rules in the queue.
24800 rules inserted. The rule base contains 17367 rules. 4921 rules in the queue.
25000 rules inserted. The rule base contains 17541 rules. 4844 rules in the queue.
25200 rules inserted. The rule base contains 17715 rules. 4796 rules in the queue.
25400 rules inserted. The rule base contains 17886 rules. 4930 rules in the queue.
25600 rules inserted. The rule base contains 18071 rules. 5266 rules in the queue.
25800 rules inserted. The rule base contains 18254 rules. 5433 rules in the queue.
26000 rules inserted. The rule base contains 18429 rules. 5496 rules in the queue.
26200 rules inserted. The rule base contains 18349 rules. 5720 rules in the queue.
26400 rules inserted. The rule base contains 18489 rules. 5782 rules in the queue.
26600 rules inserted. The rule base contains 18659 rules. 5841 rules in the queue.
26800 rules inserted. The rule base contains 18814 rules. 5887 rules in the queue.
27000 rules inserted. The rule base contains 18868 rules. 5959 rules in the queue.
27200 rules inserted. The rule base contains 18868 rules. 5959 rules in the queue.
27400 rules inserted. The rule base contains 18868 rules. 5959 rules in the queue.
27600 rules inserted. The rule base contains 18927 rules. 6076 rules in the queue.
27800 rules inserted. The rule base contains 18927 rules. 6076 rules in the queue.
28000 rules inserted. The rule base contains 19051 rules. 6402 rules in the queue.
28200 rules inserted. The rule base contains 19249 rules. 6449 rules in the queue.
28400 rules inserted. The rule base contains 19444 rules. 6479 rules in the queue.
28600 rules inserted. The rule base contains 19617 rules. 6380 rules in the queue.
28800 rules inserted. The rule base contains 19792 rules. 6333 rules in the queue.
29000 rules inserted. The rule base contains 19969 rules. 6300 rules in the queue.
29200 rules inserted. The rule base contains 20144 rules. 6252 rules in the queue.
29400 rules inserted. The rule base contains 20317 rules. 6154 rules in the queue.
29600 rules inserted. The rule base contains 20495 rules. 6129 rules in the queue.
29800 rules inserted. The rule base contains 20687 rules. 6140 rules in the queue.
30000 rules inserted. The rule base contains 20879 rules. 6152 rules in the queue.
30200 rules inserted. The rule base contains 21064 rules. 6398 rules in the queue.
30400 rules inserted. The rule base contains 21242 rules. 6329 rules in the queue.
30600 rules inserted. The rule base contains 21425 rules. 6424 rules in the queue.
30800 rules inserted. The rule base contains 21611 rules. 6580 rules in the queue.
31000 rules inserted. The rule base contains 21787 rules. 6546 rules in the queue.
31200 rules inserted. The rule base contains 21959 rules. 6461 rules in the queue.
31400 rules inserted. The rule base contains 22132 rules. 6465 rules in the queue.
31600 rules inserted. The rule base contains 22303 rules. 6482 rules in the queue.
31800 rules inserted. The rule base contains 22359 rules. 6455 rules in the queue.
32000 rules inserted. The rule base contains 22447 rules. 6468 rules in the queue.
32200 rules inserted. The rule base contains 22635 rules. 6503 rules in the queue.
32400 rules inserted. The rule base contains 22807 rules. 6503 rules in the queue.
32600 rules inserted. The rule base contains 22999 rules. 6512 rules in the queue.
32800 rules inserted. The rule base contains 23082 rules. 6641 rules in the queue.
33000 rules inserted. The rule base contains 23115 rules. 6699 rules in the queue.
33200 rules inserted. The rule base contains 23142 rules. 6784 rules in the queue.
33400 rules inserted. The rule base contains 23247 rules. 6869 rules in the queue.
33600 rules inserted. The rule base contains 23329 rules. 7097 rules in the queue.
33800 rules inserted. The rule base contains 23333 rules. 7103 rules in the queue.
34000 rules inserted. The rule base contains 23455 rules. 7111 rules in the queue.
34200 rules inserted. The rule base contains 23599 rules. 7035 rules in the queue.
34400 rules inserted. The rule base contains 23751 rules. 7022 rules in the queue.
34600 rules inserted. The rule base contains 23927 rules. 7081 rules in the queue.
34800 rules inserted. The rule base contains 24103 rules. 7140 rules in the queue.
35000 rules inserted. The rule base contains 24287 rules. 7156 rules in the queue.
35200 rules inserted. The rule base contains 24471 rules. 7172 rules in the queue.
35400 rules inserted. The rule base contains 24662 rules. 7190 rules in the queue.
35600 rules inserted. The rule base contains 24847 rules. 7199 rules in the queue.
35800 rules inserted. The rule base contains 25039 rules. 7266 rules in the queue.
36000 rules inserted. The rule base contains 25231 rules. 7323 rules in the queue.
36200 rules inserted. The rule base contains 25417 rules. 7263 rules in the queue.
36400 rules inserted. The rule base contains 25557 rules. 7167 rules in the queue.
36600 rules inserted. The rule base contains 25719 rules. 7217 rules in the queue.
36800 rules inserted. The rule base contains 25898 rules. 7183 rules in the queue.
37000 rules inserted. The rule base contains 26071 rules. 7097 rules in the queue.
37200 rules inserted. The rule base contains 26243 rules. 7005 rules in the queue.
37400 rules inserted. The rule base contains 26419 rules. 6935 rules in the queue.
37600 rules inserted. The rule base contains 26618 rules. 6994 rules in the queue.
37800 rules inserted. The rule base contains 26779 rules. 7010 rules in the queue.
38000 rules inserted. The rule base contains 26947 rules. 7075 rules in the queue.
38200 rules inserted. The rule base contains 26989 rules. 7171 rules in the queue.
38400 rules inserted. The rule base contains 26967 rules. 7338 rules in the queue.
38600 rules inserted. The rule base contains 27140 rules. 7354 rules in the queue.
38800 rules inserted. The rule base contains 27296 rules. 7353 rules in the queue.
39000 rules inserted. The rule base contains 27475 rules. 7350 rules in the queue.
39200 rules inserted. The rule base contains 27530 rules. 7335 rules in the queue.
39400 rules inserted. The rule base contains 27542 rules. 7323 rules in the queue.
39600 rules inserted. The rule base contains 27563 rules. 7302 rules in the queue.
39800 rules inserted. The rule base contains 27573 rules. 7268 rules in the queue.
40000 rules inserted. The rule base contains 27619 rules. 7305 rules in the queue.
40200 rules inserted. The rule base contains 27777 rules. 7543 rules in the queue.
40400 rules inserted. The rule base contains 27802 rules. 7562 rules in the queue.
40600 rules inserted. The rule base contains 27821 rules. 7549 rules in the queue.
40800 rules inserted. The rule base contains 27829 rules. 7536 rules in the queue.
41000 rules inserted. The rule base contains 27942 rules. 7555 rules in the queue.
41200 rules inserted. The rule base contains 28058 rules. 7588 rules in the queue.
41400 rules inserted. The rule base contains 28206 rules. 7611 rules in the queue.
41600 rules inserted. The rule base contains 28356 rules. 7642 rules in the queue.
41800 rules inserted. The rule base contains 28542 rules. 7671 rules in the queue.
42000 rules inserted. The rule base contains 28742 rules. 7705 rules in the queue.
42200 rules inserted. The rule base contains 28942 rules. 7747 rules in the queue.
42400 rules inserted. The rule base contains 29142 rules. 7781 rules in the queue.
42600 rules inserted. The rule base contains 29319 rules. 7812 rules in the queue.
42800 rules inserted. The rule base contains 29462 rules. 7846 rules in the queue.
43000 rules inserted. The rule base contains 29606 rules. 7880 rules in the queue.
43200 rules inserted. The rule base contains 29727 rules. 7920 rules in the queue.
43400 rules inserted. The rule base contains 29858 rules. 7953 rules in the queue.
43600 rules inserted. The rule base contains 30034 rules. 8000 rules in the queue.
43800 rules inserted. The rule base contains 30234 rules. 8061 rules in the queue.
44000 rules inserted. The rule base contains 30426 rules. 8121 rules in the queue.
44200 rules inserted. The rule base contains 30610 rules. 8169 rules in the queue.
44400 rules inserted. The rule base contains 30761 rules. 8186 rules in the queue.
44600 rules inserted. The rule base contains 30898 rules. 8175 rules in the queue.
44800 rules inserted. The rule base contains 31049 rules. 8115 rules in the queue.
45000 rules inserted. The rule base contains 31214 rules. 8139 rules in the queue.
45200 rules inserted. The rule base contains 31292 rules. 8177 rules in the queue.
45400 rules inserted. The rule base contains 31284 rules. 8310 rules in the queue.
45600 rules inserted. The rule base contains 31395 rules. 8407 rules in the queue.
45800 rules inserted. The rule base contains 31531 rules. 8365 rules in the queue.
46000 rules inserted. The rule base contains 31671 rules. 8332 rules in the queue.
46200 rules inserted. The rule base contains 31775 rules. 8307 rules in the queue.
46400 rules inserted. The rule base contains 31799 rules. 8275 rules in the queue.
46600 rules inserted. The rule base contains 31817 rules. 8244 rules in the queue.
46800 rules inserted. The rule base contains 31835 rules. 8216 rules in the queue.
47000 rules inserted. The rule base contains 31859 rules. 8186 rules in the queue.
47200 rules inserted. The rule base contains 32033 rules. 8104 rules in the queue.
47400 rules inserted. The rule base contains 32197 rules. 8174 rules in the queue.
47600 rules inserted. The rule base contains 32002 rules. 8403 rules in the queue.
47800 rules inserted. The rule base contains 32022 rules. 8382 rules in the queue.
48000 rules inserted. The rule base contains 32052 rules. 8364 rules in the queue.
48200 rules inserted. The rule base contains 32123 rules. 8346 rules in the queue.
48400 rules inserted. The rule base contains 32261 rules. 8376 rules in the queue.
48600 rules inserted. The rule base contains 32405 rules. 8402 rules in the queue.
48800 rules inserted. The rule base contains 32601 rules. 8404 rules in the queue.
49000 rules inserted. The rule base contains 32801 rules. 8423 rules in the queue.
49200 rules inserted. The rule base contains 32969 rules. 8446 rules in the queue.
49400 rules inserted. The rule base contains 33115 rules. 8458 rules in the queue.
49600 rules inserted. The rule base contains 33253 rules. 8485 rules in the queue.
49800 rules inserted. The rule base contains 33397 rules. 8504 rules in the queue.
50000 rules inserted. The rule base contains 33526 rules. 8532 rules in the queue.
50200 rules inserted. The rule base contains 33693 rules. 8541 rules in the queue.
50400 rules inserted. The rule base contains 33877 rules. 8565 rules in the queue.
50600 rules inserted. The rule base contains 34077 rules. 8583 rules in the queue.
50800 rules inserted. The rule base contains 34261 rules. 8609 rules in the queue.
51000 rules inserted. The rule base contains 34361 rules. 8633 rules in the queue.
51200 rules inserted. The rule base contains 34521 rules. 8669 rules in the queue.
51400 rules inserted. The rule base contains 34673 rules. 8707 rules in the queue.
51600 rules inserted. The rule base contains 34849 rules. 8754 rules in the queue.
51800 rules inserted. The rule base contains 35025 rules. 8801 rules in the queue.
52000 rules inserted. The rule base contains 35186 rules. 8844 rules in the queue.
52200 rules inserted. The rule base contains 35325 rules. 8882 rules in the queue.
52400 rules inserted. The rule base contains 35494 rules. 8962 rules in the queue.
52600 rules inserted. The rule base contains 35640 rules. 9013 rules in the queue.
52800 rules inserted. The rule base contains 35786 rules. 9027 rules in the queue.
53000 rules inserted. The rule base contains 35910 rules. 8997 rules in the queue.
53200 rules inserted. The rule base contains 35892 rules. 9029 rules in the queue.
53400 rules inserted. The rule base contains 35952 rules. 9000 rules in the queue.
53600 rules inserted. The rule base contains 35972 rules. 9089 rules in the queue.
53800 rules inserted. The rule base contains 36132 rules. 9035 rules in the queue.
54000 rules inserted. The rule base contains 36288 rules. 9004 rules in the queue.
54200 rules inserted. The rule base contains 36446 rules. 8953 rules in the queue.
54400 rules inserted. The rule base contains 36604 rules. 8919 rules in the queue.
54600 rules inserted. The rule base contains 36756 rules. 8767 rules in the queue.
54800 rules inserted. The rule base contains 36903 rules. 8620 rules in the queue.
55000 rules inserted. The rule base contains 37065 rules. 8458 rules in the queue.
55200 rules inserted. The rule base contains 37232 rules. 8422 rules in the queue.
55400 rules inserted. The rule base contains 37400 rules. 8390 rules in the queue.
55600 rules inserted. The rule base contains 37533 rules. 8365 rules in the queue.
55800 rules inserted. The rule base contains 37642 rules. 8388 rules in the queue.
56000 rules inserted. The rule base contains 37759 rules. 8312 rules in the queue.
56200 rules inserted. The rule base contains 37871 rules. 8200 rules in the queue.
56400 rules inserted. The rule base contains 38001 rules. 8070 rules in the queue.
56600 rules inserted. The rule base contains 38123 rules. 8077 rules in the queue.
56800 rules inserted. The rule base contains 38229 rules. 8098 rules in the queue.
57000 rules inserted. The rule base contains 38429 rules. 8119 rules in the queue.
57200 rules inserted. The rule base contains 38629 rules. 8137 rules in the queue.
57400 rules inserted. The rule base contains 38829 rules. 8158 rules in the queue.
57600 rules inserted. The rule base contains 39029 rules. 8182 rules in the queue.
57800 rules inserted. The rule base contains 39213 rules. 8215 rules in the queue.
58000 rules inserted. The rule base contains 39398 rules. 8253 rules in the queue.
58200 rules inserted. The rule base contains 39590 rules. 8285 rules in the queue.
58400 rules inserted. The rule base contains 39781 rules. 8313 rules in the queue.
58600 rules inserted. The rule base contains 39965 rules. 8346 rules in the queue.
58800 rules inserted. The rule base contains 40165 rules. 8374 rules in the queue.
59000 rules inserted. The rule base contains 40365 rules. 8398 rules in the queue.
59200 rules inserted. The rule base contains 40565 rules. 8427 rules in the queue.
59400 rules inserted. The rule base contains 40725 rules. 8461 rules in the queue.
59600 rules inserted. The rule base contains 40809 rules. 8483 rules in the queue.
59800 rules inserted. The rule base contains 41009 rules. 8510 rules in the queue.
60000 rules inserted. The rule base contains 41205 rules. 8539 rules in the queue.
60200 rules inserted. The rule base contains 41345 rules. 8578 rules in the queue.
60400 rules inserted. The rule base contains 41483 rules. 8616 rules in the queue.
60600 rules inserted. The rule base contains 41623 rules. 8655 rules in the queue.
60800 rules inserted. The rule base contains 41817 rules. 8688 rules in the queue.
61000 rules inserted. The rule base contains 42017 rules. 8720 rules in the queue.
61200 rules inserted. The rule base contains 42169 rules. 8731 rules in the queue.
61400 rules inserted. The rule base contains 42328 rules. 8733 rules in the queue.
61600 rules inserted. The rule base contains 42474 rules. 8761 rules in the queue.
61800 rules inserted. The rule base contains 42669 rules. 8799 rules in the queue.
62000 rules inserted. The rule base contains 42714 rules. 8817 rules in the queue.
62200 rules inserted. The rule base contains 42787 rules. 8769 rules in the queue.
62400 rules inserted. The rule base contains 42881 rules. 8767 rules in the queue.
62600 rules inserted. The rule base contains 42989 rules. 8683 rules in the queue.
