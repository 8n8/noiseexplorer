File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 232, character 36:
Warning: identifier h rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "IK.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "IK.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 278, character 6:
Warning: identifier s rebound.
File "IK.noise.active.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 279, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "IK.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "IK.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 295, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 295, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 296, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 304, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 304, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 305, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 313, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 321, characters 6-7:
Warning: identifier re rebound.
File "IK.noise.active.pv", line 322, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 325, characters 48-53:
Warning: identifier valid1 rebound.
File "IK.noise.active.pv", line 326, characters 6-7:
Warning: identifier rs rebound.
File "IK.noise.active.pv", line 327, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 328, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 330, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 338, characters 6-7:
Warning: identifier re rebound.
File "IK.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 354, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 356, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 513, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 515, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 366, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 505, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 506, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 304, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 304, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 305, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 498, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 338, characters 6-7:
Warning: identifier re rebound.
File "IK.noise.active.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 345, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 490, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 273, character 6:
Warning: identifier e rebound.
File "IK.noise.active.pv", line 274, characters 6-7:
Warning: identifier ne rebound.
File "IK.noise.active.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 278, character 6:
Warning: identifier s rebound.
File "IK.noise.active.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 279, characters 26-36:
Warning: identifier ciphertext1 rebound.
File "IK.noise.active.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 281, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 566, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 567, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 312, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 313, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 557, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 559, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 354, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 356, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 550, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 289, character 6:
Warning: identifier e rebound.
File "IK.noise.active.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "IK.noise.active.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 295, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 295, characters 26-36:
Warning: identifier ciphertext2 rebound.
File "IK.noise.active.pv", line 296, characters 6-7:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 241, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 242, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 543, characters 8-9:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 321, characters 6-7:
Warning: identifier re rebound.
File "IK.noise.active.pv", line 322, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 325, characters 48-53:
Warning: identifier valid1 rebound.
File "IK.noise.active.pv", line 326, characters 6-7:
Warning: identifier rs rebound.
File "IK.noise.active.pv", line 327, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 328, characters 7-8:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 330, characters 7-8:
Warning: identifier hs rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "IK.noise.active.pv", line 247, characters 7-8:
Warning: identifier cs rebound.
File "IK.noise.active.pv", line 248, characters 6-7:
Warning: identifier ss rebound.
File "IK.noise.active.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Completing equations...
Completed equations:
dhexp(b_76,dhexp(a_75,g)) = dhexp(a_75,dhexp(b_76,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let s_535: keypair = keypairpack(empty,empty) in
    {5}out(pub, getpublickey(s_535));
    (
        {6}let e_536: keypair = keypairpack(empty,empty) in
        {7}let v_537: key = catch-fail(dhexp(key_s(bob),g)) in
        {8}let rs_538: key = getpublickey((if not-caught-fail(v_537) then keypairpack(v_537,key_s(bob)) else fail-any)) in
        {9}let re_539: key = empty in
        {10}let v_540: bitstring = catch-fail(hash(somename,empty)) in
        {11}let v_541: key = catch-fail(v_540) in
        {12}let v_542: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {13}let v_543: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_540) then (if not-caught-fail(v_541) then (if not-caught-fail(v_542) then symmetricstatepack(v_542,v_541,v_540) else fail-any) else fail-any) else fail-any))) in
        {14}let v_544: symmetricstate = catch-fail((if success?((if not-caught-fail(v_540) then (if not-caught-fail(v_541) then (if not-caught-fail(v_542) then symmetricstatepack(v_542,v_541,v_540) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_543) && success?(is-true(success?(1-proj-3-tuple(v_543))))) then symmetricstatepack(1-proj-3-tuple(v_543),2-proj-3-tuple(v_543),hash(3-proj-3-tuple(v_543),empty)) else fail-any) else fail-any)) in
        {15}let v_545: bitstring = catch-fail(symmetricstateunpack(v_544)) in
        {16}let v_546: symmetricstate = catch-fail((if (not-caught-fail(v_545) && success?(is-true(success?(1-proj-3-tuple(v_545))))) then symmetricstatepack(1-proj-3-tuple(v_545),2-proj-3-tuple(v_545),hash(3-proj-3-tuple(v_545),rs_538)) else fail-any)) in
        {17}let hs: handshakestate = (if not-caught-fail(v_544) then (if not-caught-fail(v_546) then handshakestatepack(v_546,s_535,e_536,rs_538,re_539,empty,true) else fail-any) else fail-any) in
        {18}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {66}get statestore(=alice,=bob,=sid,statepack_a(hs_547: handshakestate)) in
        {19}let v_548: bitstring = catch-fail(handshakestateunpack(hs_547)) in
        {20}let v_549: bitstring = catch-fail((empty,empty,empty)) in
        {21}let v_550: key = catch-fail(dhexp(key_e(alice,bob,sid),g)) in
        {22}let v_551: keypair = catch-fail((if not-caught-fail(v_550) then keypairpack(v_550,key_e(alice,bob,sid)) else fail-any)) in
        {23}let v_552: bitstring = catch-fail(getpublickey(v_551)) in
        {24}let v_553: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_548))) in
        {25}let v_554: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_548)) then (if (not-caught-fail(v_553) && success?(is-true(success?(1-proj-3-tuple(v_553))))) then symmetricstatepack(1-proj-3-tuple(v_553),2-proj-3-tuple(v_553),hash(3-proj-3-tuple(v_553),v_552)) else fail-any) else fail-any)) in
        {26}let v_555: bitstring = catch-fail(keypairunpack(v_551)) in
        {27}let v_556: bitstring = catch-fail(symmetricstateunpack(v_554)) in
        {28}let v_557: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_556),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then dhexp(2-proj-2-tuple(v_555),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {29}let v_558: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_556),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then dhexp(2-proj-2-tuple(v_555),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {30}let v_559: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_556),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then dhexp(2-proj-2-tuple(v_555),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {31}let v_560: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then dhexp(2-proj-2-tuple(v_555),4-proj-7-tuple(v_548)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_556))) then (if not-caught-fail(v_557) then (if not-caught-fail(v_558) then (if not-caught-fail(v_559) then (v_557,v_558,v_559) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {32}let v_561: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-2-tuple(v_555))))) then dhexp(2-proj-2-tuple(v_555),4-proj-7-tuple(v_548)) else fail-any) else fail-any)) then (if (not-caught-fail(v_556) && success?(is-true(success?(1-proj-3-tuple(v_556))))) then (if (not-caught-fail(v_560) && success?(is-true(success?(1-proj-3-tuple(v_560))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_560)) then cipherstatepack(2-proj-3-tuple(v_560),minnonce) else fail-any),1-proj-3-tuple(v_560),3-proj-3-tuple(v_556)) else fail-any) else fail-any) else fail-any)) in
        {33}let v_562: key = catch-fail(dhexp(key_s(alice),g)) in
        {34}let v_563: keypair = catch-fail((if not-caught-fail(v_562) then keypairpack(v_562,key_s(alice)) else fail-any)) in
        {35}let v_564: bitstring = catch-fail(symmetricstateunpack(v_561)) in
        {36}let v_565: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_564))) in
        {37}let v_566: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_565),2-proj-2-tuple(v_565),3-proj-3-tuple(v_564),getpublickey(v_563))) in
        {38}let v_567: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_564))) in
        {39}let v_568: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_565))) && success?(1-proj-3-tuple(v_564))) then (if (not-caught-fail(v_567) && success?(is-true(success?(1-proj-2-tuple(v_567))))) then cipherstatepack(1-proj-2-tuple(v_567),increment_nonce(2-proj-2-tuple(v_565))) else fail-any) else fail-any)) in
        {40}let v_569: bitstring = catch-fail((if (success?(getpublickey(v_563)) && (success?(3-proj-3-tuple(v_564)) && success?(1-proj-3-tuple(v_564)))) then (if (not-caught-fail(v_565) && success?(is-true(success?(1-proj-2-tuple(v_565))))) then (if not-caught-fail(v_566) then (if not-caught-fail(v_568) then (v_568,v_566) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {41}let v_570: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_569),2-proj-3-tuple(v_564),3-proj-3-tuple(v_564)))) in
        {42}let v_571: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_569)) && success?(symmetricstatepack(1-proj-2-tuple(v_569),2-proj-3-tuple(v_564),3-proj-3-tuple(v_564)))) then (if (not-caught-fail(v_570) && success?(is-true(success?(1-proj-3-tuple(v_570))))) then symmetricstatepack(1-proj-3-tuple(v_570),2-proj-3-tuple(v_570),hash(3-proj-3-tuple(v_570),2-proj-2-tuple(v_569))) else fail-any) else fail-any)) in
        {43}let v_572: bitstring = catch-fail((if success?(getpublickey(v_563)) then (if (not-caught-fail(v_564) && success?(is-true(success?(1-proj-3-tuple(v_564))))) then (if (not-caught-fail(v_569) && success?(is-true(success?(1-proj-2-tuple(v_569))))) then (if not-caught-fail(v_571) then (v_571,2-proj-2-tuple(v_569)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {44}let v_573: bitstring = catch-fail(keypairunpack(v_563)) in
        {45}let v_574: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_572))) in
        {46}let v_575: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_574),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then dhexp(2-proj-2-tuple(v_573),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {47}let v_576: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_574),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then dhexp(2-proj-2-tuple(v_573),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {48}let v_577: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_574),(if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then dhexp(2-proj-2-tuple(v_573),4-proj-7-tuple(v_548)) else fail-any) else fail-any))) in
        {49}let v_578: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then dhexp(2-proj-2-tuple(v_573),4-proj-7-tuple(v_548)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_574))) then (if not-caught-fail(v_575) then (if not-caught-fail(v_576) then (if not-caught-fail(v_577) then (v_575,v_576,v_577) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {50}let v_579: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_548)) then (if (not-caught-fail(v_573) && success?(is-true(success?(1-proj-2-tuple(v_573))))) then dhexp(2-proj-2-tuple(v_573),4-proj-7-tuple(v_548)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_572))) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-3-tuple(v_574))))) then (if (not-caught-fail(v_578) && success?(is-true(success?(1-proj-3-tuple(v_578))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_578)) then cipherstatepack(2-proj-3-tuple(v_578),minnonce) else fail-any),1-proj-3-tuple(v_578),3-proj-3-tuple(v_574)) else fail-any) else fail-any) else fail-any)) in
        {51}let v_580: bitstring = catch-fail(symmetricstateunpack(v_579)) in
        {52}let v_581: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_580))) in
        {53}let v_582: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_581),2-proj-2-tuple(v_581),3-proj-3-tuple(v_580),msg_a(alice,bob,sid))) in
        {54}let v_583: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_580))) in
        {55}let v_584: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_581))) && success?(1-proj-3-tuple(v_580))) then (if (not-caught-fail(v_583) && success?(is-true(success?(1-proj-2-tuple(v_583))))) then cipherstatepack(1-proj-2-tuple(v_583),increment_nonce(2-proj-2-tuple(v_581))) else fail-any) else fail-any)) in
        {56}let v_585: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_580)) && success?(1-proj-3-tuple(v_580))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then (if not-caught-fail(v_582) then (if not-caught-fail(v_584) then (v_584,v_582) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {57}let v_586: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_585),2-proj-3-tuple(v_580),3-proj-3-tuple(v_580)))) in
        {58}let v_587: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_585)) && success?(symmetricstatepack(1-proj-2-tuple(v_585),2-proj-3-tuple(v_580),3-proj-3-tuple(v_580)))) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then symmetricstatepack(1-proj-3-tuple(v_586),2-proj-3-tuple(v_586),hash(3-proj-3-tuple(v_586),2-proj-2-tuple(v_585))) else fail-any) else fail-any)) in
        {59}let v_588: bitstring = catch-fail((if (not-caught-fail(v_580) && success?(is-true(success?(1-proj-3-tuple(v_580))))) then (if (not-caught-fail(v_585) && success?(is-true(success?(1-proj-2-tuple(v_585))))) then (if not-caught-fail(v_587) then (v_587,2-proj-2-tuple(v_585)) else fail-any) else fail-any) else fail-any)) in
        {60}let v_589: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_588),v_563,v_551,4-proj-7-tuple(v_548),5-proj-7-tuple(v_548),6-proj-7-tuple(v_548),7-proj-7-tuple(v_548))) in
        {61}let v_590: bitstring = catch-fail(concat3(v_552,2-proj-2-tuple(v_572),2-proj-2-tuple(v_588))) in
        {62}let (hs_591: handshakestate,message_a: bitstring) = (if (not-caught-fail(v_548) && success?(is-true(success?(1-proj-7-tuple(v_548))))) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-3-tuple(v_549))))) then (if not-caught-fail(v_551) then (if not-caught-fail(v_552) then (if not-caught-fail(v_554) then (if not-caught-fail(v_561) then (if not-caught-fail(v_563) then (if (not-caught-fail(v_572) && success?(is-true(success?(1-proj-2-tuple(v_572))))) then (if not-caught-fail(v_579) then (if (not-caught-fail(v_588) && success?(is-true(success?(1-proj-2-tuple(v_588))))) then (if not-caught-fail(v_589) then (if not-caught-fail(v_590) then (v_589,v_590) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {63}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {64}insert statestore(alice,bob,sid,statepack_b(hs_591));
        {65}out(pub, message_a)
    ) | (
        {110}get statestore(=alice,=bob,=sid,statepack_b(hs_592: handshakestate)) in
        {67}in(pub, message_b: bitstring);
        {68}let v_593: bitstring = catch-fail(handshakestateunpack(hs_592)) in
        {69}let v_594: bitstring = catch-fail(deconcat3(message_b)) in
        {70}let v_595: bool = catch-fail(true) in
        {71}let v_596: key = catch-fail(1-proj-3-tuple(v_594)) in
        {72}let v_597: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_593))) in
        {73}let v_598: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_593)) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then symmetricstatepack(1-proj-3-tuple(v_597),2-proj-3-tuple(v_597),hash(3-proj-3-tuple(v_597),v_596)) else fail-any) else fail-any)) in
        {74}let v_599: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_593))) in
        {75}let v_600: bitstring = catch-fail(symmetricstateunpack(v_598)) in
        {76}let v_601: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_600),(if success?(3-proj-7-tuple(v_593)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then dhexp(2-proj-2-tuple(v_599),v_596) else fail-any) else fail-any))) in
        {77}let v_602: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_600),(if success?(3-proj-7-tuple(v_593)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then dhexp(2-proj-2-tuple(v_599),v_596) else fail-any) else fail-any))) in
        {78}let v_603: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_600),(if success?(3-proj-7-tuple(v_593)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then dhexp(2-proj-2-tuple(v_599),v_596) else fail-any) else fail-any))) in
        {79}let v_604: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_593)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then dhexp(2-proj-2-tuple(v_599),v_596) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_600))) then (if not-caught-fail(v_601) then (if not-caught-fail(v_602) then (if not-caught-fail(v_603) then (v_601,v_602,v_603) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {80}let v_605: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_593)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-2-tuple(v_599))))) then dhexp(2-proj-2-tuple(v_599),v_596) else fail-any) else fail-any)) then (if (not-caught-fail(v_600) && success?(is-true(success?(1-proj-3-tuple(v_600))))) then (if (not-caught-fail(v_604) && success?(is-true(success?(1-proj-3-tuple(v_604))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_604)) then cipherstatepack(2-proj-3-tuple(v_604),minnonce) else fail-any),1-proj-3-tuple(v_604),3-proj-3-tuple(v_600)) else fail-any) else fail-any) else fail-any)) in
        {81}let v_606: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_593))) in
        {82}let v_607: bitstring = catch-fail(symmetricstateunpack(v_605)) in
        {83}let v_608: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_607),(if success?(2-proj-7-tuple(v_593)) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then dhexp(2-proj-2-tuple(v_606),v_596) else fail-any) else fail-any))) in
        {84}let v_609: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_607),(if success?(2-proj-7-tuple(v_593)) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then dhexp(2-proj-2-tuple(v_606),v_596) else fail-any) else fail-any))) in
        {85}let v_610: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_607),(if success?(2-proj-7-tuple(v_593)) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then dhexp(2-proj-2-tuple(v_606),v_596) else fail-any) else fail-any))) in
        {86}let v_611: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_593)) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then dhexp(2-proj-2-tuple(v_606),v_596) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_607))) then (if not-caught-fail(v_608) then (if not-caught-fail(v_609) then (if not-caught-fail(v_610) then (v_608,v_609,v_610) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {87}let v_612: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_593)) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-2-tuple(v_606))))) then dhexp(2-proj-2-tuple(v_606),v_596) else fail-any) else fail-any)) then (if (not-caught-fail(v_607) && success?(is-true(success?(1-proj-3-tuple(v_607))))) then (if (not-caught-fail(v_611) && success?(is-true(success?(1-proj-3-tuple(v_611))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_611)) then cipherstatepack(2-proj-3-tuple(v_611),minnonce) else fail-any),1-proj-3-tuple(v_611),3-proj-3-tuple(v_607)) else fail-any) else fail-any) else fail-any)) in
        {88}let v_613: bitstring = catch-fail(symmetricstateunpack(v_612)) in
        {89}let v_614: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_613))) in
        {90}let v_615: aead = catch-fail(decrypt(1-proj-2-tuple(v_614),2-proj-2-tuple(v_614),3-proj-3-tuple(v_613),3-proj-3-tuple(v_594))) in
        {91}let v_616: bitstring = catch-fail(aeadunpack(v_615)) in
        {92}let v_617: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_613))) in
        {93}let v_618: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_614))) && success?(1-proj-3-tuple(v_613))) then (if (not-caught-fail(v_617) && success?(is-true(success?(1-proj-2-tuple(v_617))))) then cipherstatepack(1-proj-2-tuple(v_617),increment_nonce(2-proj-2-tuple(v_614))) else fail-any) else fail-any)) in
        {94}let v_619: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_594)) && (success?(3-proj-3-tuple(v_613)) && success?(1-proj-3-tuple(v_613)))) then (if (not-caught-fail(v_614) && success?(is-true(success?(1-proj-2-tuple(v_614))))) then (if not-caught-fail(v_615) then (if (not-caught-fail(v_616) && success?(is-true(success?(1-proj-3-tuple(v_616))))) then (if not-caught-fail(v_618) then (v_618,3-proj-3-tuple(v_616),1-proj-3-tuple(v_616)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {95}let v_620: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_619),2-proj-3-tuple(v_613),3-proj-3-tuple(v_613)))) in
        {96}let v_621: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_594)) && success?(symmetricstatepack(1-proj-3-tuple(v_619),2-proj-3-tuple(v_613),3-proj-3-tuple(v_613)))) then (if (not-caught-fail(v_620) && success?(is-true(success?(1-proj-3-tuple(v_620))))) then symmetricstatepack(1-proj-3-tuple(v_620),2-proj-3-tuple(v_620),hash(3-proj-3-tuple(v_620),3-proj-3-tuple(v_594))) else fail-any) else fail-any)) in
        {97}let v_622: bitstring = catch-fail((if success?(3-proj-3-tuple(v_594)) then (if (not-caught-fail(v_613) && success?(is-true(success?(1-proj-3-tuple(v_613))))) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-3-tuple(v_619))))) then (if not-caught-fail(v_621) then (v_621,2-proj-3-tuple(v_619),3-proj-3-tuple(v_619)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {98}let v_623: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_622),2-proj-7-tuple(v_593),3-proj-7-tuple(v_593),4-proj-7-tuple(v_593),v_596,6-proj-7-tuple(v_593),7-proj-7-tuple(v_593))) in
        {99}let v_624: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_622))) in
        {100}let v_625: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_624),zero)) in
        {101}let v_626: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_624),zero)) in
        {102}let v_627: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_624),zero)) in
        {103}let v_628: bitstring = catch-fail((if success?(2-proj-3-tuple(v_624)) then (if not-caught-fail(v_625) then (if not-caught-fail(v_626) then (if not-caught-fail(v_627) then (v_625,v_626,v_627) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {104}let v_629: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_628)) then cipherstatepack(1-proj-3-tuple(v_628),minnonce) else fail-any)) in
        {105}let v_630: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_628)) then cipherstatepack(2-proj-3-tuple(v_628),minnonce) else fail-any)) in
        {106}let v_631: bitstring = catch-fail((if success?(1-proj-3-tuple(v_622)) then (if (not-caught-fail(v_624) && success?(is-true(success?(1-proj-3-tuple(v_624))))) then (if (not-caught-fail(v_628) && success?(is-true(success?(1-proj-3-tuple(v_628))))) then (if not-caught-fail(v_629) then (if not-caught-fail(v_630) then (1-proj-3-tuple(v_622),v_629,v_630) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let (hs_632: handshakestate,plaintext_b: bitstring,valid: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_593) && success?(is-true(success?(1-proj-7-tuple(v_593))))) then (if (not-caught-fail(v_594) && success?(is-true(success?(1-proj-3-tuple(v_594))))) then (if not-caught-fail(v_595) then (if not-caught-fail(v_596) then (if not-caught-fail(v_598) then (if not-caught-fail(v_605) then (if not-caught-fail(v_612) then (if (not-caught-fail(v_622) && success?(is-true(success?(1-proj-3-tuple(v_622))))) then (if (v_595 && 3-proj-3-tuple(v_622)) then (if not-caught-fail(v_623) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then (v_623,2-proj-3-tuple(v_622),true,2-proj-3-tuple(v_631),3-proj-3-tuple(v_631)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {108}event RecvMsg(alice,bob,stagepack_b(sid),plaintext_b);
        {109}insert statestore(alice,bob,sid,statepack_c(hs_632,cs1,cs2))
    ) | (
        {111}!
        {130}get statestore(=alice,=bob,=sid,statepack_c(hs_633: handshakestate,cs1_634: cipherstate,cs2_635: cipherstate)) in
        {112}let hs_636: handshakestate = handshakestatesetcs(hs_633,cs1_634) in
        {113}let v_637: bitstring = catch-fail(handshakestateunpack(hs_636)) in
        {114}let v_638: bitstring = catch-fail((empty,empty,empty)) in
        {115}let v_639: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_637))) in
        {116}let v_640: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_639))) in
        {117}let v_641: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_640),2-proj-2-tuple(v_640),3-proj-3-tuple(v_639),msg_c(alice,bob,sid))) in
        {118}let v_642: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_639))) in
        {119}let v_643: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_640))) && success?(1-proj-3-tuple(v_639))) then (if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-2-tuple(v_642))))) then cipherstatepack(1-proj-2-tuple(v_642),increment_nonce(2-proj-2-tuple(v_640))) else fail-any) else fail-any)) in
        {120}let v_644: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_639)) && success?(1-proj-3-tuple(v_639))) then (if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-2-tuple(v_640))))) then (if not-caught-fail(v_641) then (if not-caught-fail(v_643) then (v_643,v_641) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {121}let v_645: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_644),2-proj-3-tuple(v_639),3-proj-3-tuple(v_639)))) in
        {122}let v_646: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_644)) && success?(symmetricstatepack(1-proj-2-tuple(v_644),2-proj-3-tuple(v_639),3-proj-3-tuple(v_639)))) then (if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then symmetricstatepack(1-proj-3-tuple(v_645),2-proj-3-tuple(v_645),hash(3-proj-3-tuple(v_645),2-proj-2-tuple(v_644))) else fail-any) else fail-any)) in
        {123}let v_647: bitstring = catch-fail((if success?(1-proj-7-tuple(v_637)) then (if (not-caught-fail(v_639) && success?(is-true(success?(1-proj-3-tuple(v_639))))) then (if (not-caught-fail(v_644) && success?(is-true(success?(1-proj-2-tuple(v_644))))) then (if not-caught-fail(v_646) then (v_646,2-proj-2-tuple(v_644)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {124}let v_648: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_647),2-proj-7-tuple(v_637),3-proj-7-tuple(v_637),4-proj-7-tuple(v_637),5-proj-7-tuple(v_637),6-proj-7-tuple(v_637),7-proj-7-tuple(v_637))) in
        {125}let v_649: bitstring = catch-fail(concat3(1-proj-3-tuple(v_638),2-proj-3-tuple(v_638),2-proj-2-tuple(v_647))) in
        {126}let (hs_650: handshakestate,message_c: bitstring) = (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-7-tuple(v_637))))) then (if (not-caught-fail(v_638) && success?(is-true(success?(1-proj-3-tuple(v_638))))) then (if (not-caught-fail(v_647) && success?(is-true(success?(1-proj-2-tuple(v_647))))) then (if not-caught-fail(v_648) then (if not-caught-fail(v_649) then (v_648,v_649) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {127}event SendMsg(alice,bob,stagepack_c(sid),msg_c(alice,bob,sid));
        {128}insert statestore(alice,bob,sid,statepack_d(hs_650,handshakestategetcs(hs_650),cs2_635));
        {129}out(pub, message_c)
    ) | (
        {131}!
        {151}get statestore(=alice,=bob,=sid,statepack_d(hs_651: handshakestate,cs1_652: cipherstate,cs2_653: cipherstate)) in
        {132}let hs_654: handshakestate = handshakestatesetcs(hs_651,cs2_653) in
        {133}in(pub, message_d: bitstring);
        {134}let v_655: bitstring = catch-fail(handshakestateunpack(hs_654)) in
        {135}let v_656: bitstring = catch-fail(deconcat3(message_d)) in
        {136}let v_657: bool = catch-fail(true) in
        {137}let v_658: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_655))) in
        {138}let v_659: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_658))) in
        {139}let v_660: aead = catch-fail(decrypt(1-proj-2-tuple(v_659),2-proj-2-tuple(v_659),3-proj-3-tuple(v_658),3-proj-3-tuple(v_656))) in
        {140}let v_661: bitstring = catch-fail(aeadunpack(v_660)) in
        {141}let v_662: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_658))) in
        {142}let v_663: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_659))) && success?(1-proj-3-tuple(v_658))) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-2-tuple(v_662))))) then cipherstatepack(1-proj-2-tuple(v_662),increment_nonce(2-proj-2-tuple(v_659))) else fail-any) else fail-any)) in
        {143}let v_664: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_656)) && (success?(3-proj-3-tuple(v_658)) && success?(1-proj-3-tuple(v_658)))) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-2-tuple(v_659))))) then (if not-caught-fail(v_660) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-3-tuple(v_661))))) then (if not-caught-fail(v_663) then (v_663,3-proj-3-tuple(v_661),1-proj-3-tuple(v_661)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {144}let v_665: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_664),2-proj-3-tuple(v_658),3-proj-3-tuple(v_658)))) in
        {145}let v_666: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_656)) && success?(symmetricstatepack(1-proj-3-tuple(v_664),2-proj-3-tuple(v_658),3-proj-3-tuple(v_658)))) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-3-tuple(v_665))))) then symmetricstatepack(1-proj-3-tuple(v_665),2-proj-3-tuple(v_665),hash(3-proj-3-tuple(v_665),3-proj-3-tuple(v_656))) else fail-any) else fail-any)) in
        {146}let v_667: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_656)) && success?(1-proj-7-tuple(v_655))) then (if (not-caught-fail(v_658) && success?(is-true(success?(1-proj-3-tuple(v_658))))) then (if (not-caught-fail(v_664) && success?(is-true(success?(1-proj-3-tuple(v_664))))) then (if not-caught-fail(v_666) then (v_666,2-proj-3-tuple(v_664),3-proj-3-tuple(v_664)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {147}let v_668: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_667),2-proj-7-tuple(v_655),3-proj-7-tuple(v_655),4-proj-7-tuple(v_655),5-proj-7-tuple(v_655),6-proj-7-tuple(v_655),7-proj-7-tuple(v_655))) in
        {148}let (hs_669: handshakestate,plaintext_d: bitstring,valid_670: bool) = (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-7-tuple(v_655))))) then (if (not-caught-fail(v_656) && success?(is-true(success?(1-proj-3-tuple(v_656))))) then (if not-caught-fail(v_657) then (if (not-caught-fail(v_667) && success?(is-true(success?(1-proj-3-tuple(v_667))))) then (if (v_657 && 3-proj-3-tuple(v_667)) then (if not-caught-fail(v_668) then (v_668,2-proj-3-tuple(v_667),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {149}event RecvMsg(alice,bob,stagepack_d(sid),plaintext_d);
        {150}event RecvEnd(valid_670)
    ) | (
        {152}event LeakS(phase0,alice);
        {153}out(pub, key_s(alice))
    ) | (
        {154}phase 1;
        {155}event LeakS(phase1,alice);
        {156}out(pub, key_s(alice))
    )
) | (
    {157}let s_671: keypair = keypairpack(empty,empty) in
    {158}out(pub, getpublickey(s_671));
    (
        {159}let e_672: keypair = keypairpack(empty,empty) in
        {160}let v_673: key = catch-fail(dhexp(key_s(charlie),g)) in
        {161}let rs_674: key = getpublickey((if not-caught-fail(v_673) then keypairpack(v_673,key_s(charlie)) else fail-any)) in
        {162}let re_675: key = empty in
        {163}let v_676: bitstring = catch-fail(hash(somename,empty)) in
        {164}let v_677: key = catch-fail(v_676) in
        {165}let v_678: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {166}let v_679: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_676) then (if not-caught-fail(v_677) then (if not-caught-fail(v_678) then symmetricstatepack(v_678,v_677,v_676) else fail-any) else fail-any) else fail-any))) in
        {167}let v_680: symmetricstate = catch-fail((if success?((if not-caught-fail(v_676) then (if not-caught-fail(v_677) then (if not-caught-fail(v_678) then symmetricstatepack(v_678,v_677,v_676) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-3-tuple(v_679))))) then symmetricstatepack(1-proj-3-tuple(v_679),2-proj-3-tuple(v_679),hash(3-proj-3-tuple(v_679),empty)) else fail-any) else fail-any)) in
        {168}let v_681: bitstring = catch-fail(symmetricstateunpack(v_680)) in
        {169}let v_682: symmetricstate = catch-fail((if (not-caught-fail(v_681) && success?(is-true(success?(1-proj-3-tuple(v_681))))) then symmetricstatepack(1-proj-3-tuple(v_681),2-proj-3-tuple(v_681),hash(3-proj-3-tuple(v_681),rs_674)) else fail-any)) in
        {170}let hs_683: handshakestate = (if not-caught-fail(v_680) then (if not-caught-fail(v_682) then handshakestatepack(v_682,s_671,e_672,rs_674,re_675,empty,true) else fail-any) else fail-any) in
        {171}insert statestore(alice,charlie,sid,statepack_a(hs_683))
    ) | (
        {219}get statestore(=alice,=charlie,=sid,statepack_a(hs_684: handshakestate)) in
        {172}let v_685: bitstring = catch-fail(handshakestateunpack(hs_684)) in
        {173}let v_686: bitstring = catch-fail((empty,empty,empty)) in
        {174}let v_687: key = catch-fail(dhexp(key_e(alice,charlie,sid),g)) in
        {175}let v_688: keypair = catch-fail((if not-caught-fail(v_687) then keypairpack(v_687,key_e(alice,charlie,sid)) else fail-any)) in
        {176}let v_689: bitstring = catch-fail(getpublickey(v_688)) in
        {177}let v_690: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_685))) in
        {178}let v_691: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_685)) then (if (not-caught-fail(v_690) && success?(is-true(success?(1-proj-3-tuple(v_690))))) then symmetricstatepack(1-proj-3-tuple(v_690),2-proj-3-tuple(v_690),hash(3-proj-3-tuple(v_690),v_689)) else fail-any) else fail-any)) in
        {179}let v_692: bitstring = catch-fail(keypairunpack(v_688)) in
        {180}let v_693: bitstring = catch-fail(symmetricstateunpack(v_691)) in
        {181}let v_694: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_693),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {182}let v_695: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_693),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {183}let v_696: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_693),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {184}let v_697: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),4-proj-7-tuple(v_685)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_693))) then (if not-caught-fail(v_694) then (if not-caught-fail(v_695) then (if not-caught-fail(v_696) then (v_694,v_695,v_696) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {185}let v_698: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-2-tuple(v_692))))) then dhexp(2-proj-2-tuple(v_692),4-proj-7-tuple(v_685)) else fail-any) else fail-any)) then (if (not-caught-fail(v_693) && success?(is-true(success?(1-proj-3-tuple(v_693))))) then (if (not-caught-fail(v_697) && success?(is-true(success?(1-proj-3-tuple(v_697))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_697)) then cipherstatepack(2-proj-3-tuple(v_697),minnonce) else fail-any),1-proj-3-tuple(v_697),3-proj-3-tuple(v_693)) else fail-any) else fail-any) else fail-any)) in
        {186}let v_699: key = catch-fail(dhexp(key_s(alice),g)) in
        {187}let v_700: keypair = catch-fail((if not-caught-fail(v_699) then keypairpack(v_699,key_s(alice)) else fail-any)) in
        {188}let v_701: bitstring = catch-fail(symmetricstateunpack(v_698)) in
        {189}let v_702: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_701))) in
        {190}let v_703: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_702),2-proj-2-tuple(v_702),3-proj-3-tuple(v_701),getpublickey(v_700))) in
        {191}let v_704: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_701))) in
        {192}let v_705: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_702))) && success?(1-proj-3-tuple(v_701))) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-2-tuple(v_704))))) then cipherstatepack(1-proj-2-tuple(v_704),increment_nonce(2-proj-2-tuple(v_702))) else fail-any) else fail-any)) in
        {193}let v_706: bitstring = catch-fail((if (success?(getpublickey(v_700)) && (success?(3-proj-3-tuple(v_701)) && success?(1-proj-3-tuple(v_701)))) then (if (not-caught-fail(v_702) && success?(is-true(success?(1-proj-2-tuple(v_702))))) then (if not-caught-fail(v_703) then (if not-caught-fail(v_705) then (v_705,v_703) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {194}let v_707: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_706),2-proj-3-tuple(v_701),3-proj-3-tuple(v_701)))) in
        {195}let v_708: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_706)) && success?(symmetricstatepack(1-proj-2-tuple(v_706),2-proj-3-tuple(v_701),3-proj-3-tuple(v_701)))) then (if (not-caught-fail(v_707) && success?(is-true(success?(1-proj-3-tuple(v_707))))) then symmetricstatepack(1-proj-3-tuple(v_707),2-proj-3-tuple(v_707),hash(3-proj-3-tuple(v_707),2-proj-2-tuple(v_706))) else fail-any) else fail-any)) in
        {196}let v_709: bitstring = catch-fail((if success?(getpublickey(v_700)) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-2-tuple(v_706))))) then (if not-caught-fail(v_708) then (v_708,2-proj-2-tuple(v_706)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {197}let v_710: bitstring = catch-fail(keypairunpack(v_700)) in
        {198}let v_711: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_709))) in
        {199}let v_712: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_711),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then dhexp(2-proj-2-tuple(v_710),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {200}let v_713: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_711),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then dhexp(2-proj-2-tuple(v_710),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {201}let v_714: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_711),(if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then dhexp(2-proj-2-tuple(v_710),4-proj-7-tuple(v_685)) else fail-any) else fail-any))) in
        {202}let v_715: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then dhexp(2-proj-2-tuple(v_710),4-proj-7-tuple(v_685)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_711))) then (if not-caught-fail(v_712) then (if not-caught-fail(v_713) then (if not-caught-fail(v_714) then (v_712,v_713,v_714) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {203}let v_716: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_685)) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-2-tuple(v_710))))) then dhexp(2-proj-2-tuple(v_710),4-proj-7-tuple(v_685)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_709))) then (if (not-caught-fail(v_711) && success?(is-true(success?(1-proj-3-tuple(v_711))))) then (if (not-caught-fail(v_715) && success?(is-true(success?(1-proj-3-tuple(v_715))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_715)) then cipherstatepack(2-proj-3-tuple(v_715),minnonce) else fail-any),1-proj-3-tuple(v_715),3-proj-3-tuple(v_711)) else fail-any) else fail-any) else fail-any)) in
        {204}let v_717: bitstring = catch-fail(symmetricstateunpack(v_716)) in
        {205}let v_718: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_717))) in
        {206}let v_719: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_718),2-proj-2-tuple(v_718),3-proj-3-tuple(v_717),msg_a(alice,charlie,sid))) in
        {207}let v_720: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_717))) in
        {208}let v_721: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_718))) && success?(1-proj-3-tuple(v_717))) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-2-tuple(v_720))))) then cipherstatepack(1-proj-2-tuple(v_720),increment_nonce(2-proj-2-tuple(v_718))) else fail-any) else fail-any)) in
        {209}let v_722: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_717)) && success?(1-proj-3-tuple(v_717))) then (if (not-caught-fail(v_718) && success?(is-true(success?(1-proj-2-tuple(v_718))))) then (if not-caught-fail(v_719) then (if not-caught-fail(v_721) then (v_721,v_719) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {210}let v_723: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_722),2-proj-3-tuple(v_717),3-proj-3-tuple(v_717)))) in
        {211}let v_724: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_722)) && success?(symmetricstatepack(1-proj-2-tuple(v_722),2-proj-3-tuple(v_717),3-proj-3-tuple(v_717)))) then (if (not-caught-fail(v_723) && success?(is-true(success?(1-proj-3-tuple(v_723))))) then symmetricstatepack(1-proj-3-tuple(v_723),2-proj-3-tuple(v_723),hash(3-proj-3-tuple(v_723),2-proj-2-tuple(v_722))) else fail-any) else fail-any)) in
        {212}let v_725: bitstring = catch-fail((if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then (if (not-caught-fail(v_722) && success?(is-true(success?(1-proj-2-tuple(v_722))))) then (if not-caught-fail(v_724) then (v_724,2-proj-2-tuple(v_722)) else fail-any) else fail-any) else fail-any)) in
        {213}let v_726: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_725),v_700,v_688,4-proj-7-tuple(v_685),5-proj-7-tuple(v_685),6-proj-7-tuple(v_685),7-proj-7-tuple(v_685))) in
        {214}let v_727: bitstring = catch-fail(concat3(v_689,2-proj-2-tuple(v_709),2-proj-2-tuple(v_725))) in
        {215}let (hs_728: handshakestate,message_a_729: bitstring) = (if (not-caught-fail(v_685) && success?(is-true(success?(1-proj-7-tuple(v_685))))) then (if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then (if not-caught-fail(v_688) then (if not-caught-fail(v_689) then (if not-caught-fail(v_691) then (if not-caught-fail(v_698) then (if not-caught-fail(v_700) then (if (not-caught-fail(v_709) && success?(is-true(success?(1-proj-2-tuple(v_709))))) then (if not-caught-fail(v_716) then (if (not-caught-fail(v_725) && success?(is-true(success?(1-proj-2-tuple(v_725))))) then (if not-caught-fail(v_726) then (if not-caught-fail(v_727) then (v_726,v_727) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {216}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {217}insert statestore(alice,charlie,sid,statepack_b(hs_728));
        {218}out(pub, message_a_729)
    ) | (
        {263}get statestore(=alice,=charlie,=sid,statepack_b(hs_730: handshakestate)) in
        {220}in(pub, message_b_731: bitstring);
        {221}let v_732: bitstring = catch-fail(handshakestateunpack(hs_730)) in
        {222}let v_733: bitstring = catch-fail(deconcat3(message_b_731)) in
        {223}let v_734: bool = catch-fail(true) in
        {224}let v_735: key = catch-fail(1-proj-3-tuple(v_733)) in
        {225}let v_736: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_732))) in
        {226}let v_737: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_732)) then (if (not-caught-fail(v_736) && success?(is-true(success?(1-proj-3-tuple(v_736))))) then symmetricstatepack(1-proj-3-tuple(v_736),2-proj-3-tuple(v_736),hash(3-proj-3-tuple(v_736),v_735)) else fail-any) else fail-any)) in
        {227}let v_738: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_732))) in
        {228}let v_739: bitstring = catch-fail(symmetricstateunpack(v_737)) in
        {229}let v_740: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_739),(if success?(3-proj-7-tuple(v_732)) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then dhexp(2-proj-2-tuple(v_738),v_735) else fail-any) else fail-any))) in
        {230}let v_741: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_739),(if success?(3-proj-7-tuple(v_732)) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then dhexp(2-proj-2-tuple(v_738),v_735) else fail-any) else fail-any))) in
        {231}let v_742: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_739),(if success?(3-proj-7-tuple(v_732)) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then dhexp(2-proj-2-tuple(v_738),v_735) else fail-any) else fail-any))) in
        {232}let v_743: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_732)) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then dhexp(2-proj-2-tuple(v_738),v_735) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_739))) then (if not-caught-fail(v_740) then (if not-caught-fail(v_741) then (if not-caught-fail(v_742) then (v_740,v_741,v_742) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {233}let v_744: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_732)) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then dhexp(2-proj-2-tuple(v_738),v_735) else fail-any) else fail-any)) then (if (not-caught-fail(v_739) && success?(is-true(success?(1-proj-3-tuple(v_739))))) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_743)) then cipherstatepack(2-proj-3-tuple(v_743),minnonce) else fail-any),1-proj-3-tuple(v_743),3-proj-3-tuple(v_739)) else fail-any) else fail-any) else fail-any)) in
        {234}let v_745: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_732))) in
        {235}let v_746: bitstring = catch-fail(symmetricstateunpack(v_744)) in
        {236}let v_747: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_746),(if success?(2-proj-7-tuple(v_732)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then dhexp(2-proj-2-tuple(v_745),v_735) else fail-any) else fail-any))) in
        {237}let v_748: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_746),(if success?(2-proj-7-tuple(v_732)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then dhexp(2-proj-2-tuple(v_745),v_735) else fail-any) else fail-any))) in
        {238}let v_749: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_746),(if success?(2-proj-7-tuple(v_732)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then dhexp(2-proj-2-tuple(v_745),v_735) else fail-any) else fail-any))) in
        {239}let v_750: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_732)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then dhexp(2-proj-2-tuple(v_745),v_735) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_746))) then (if not-caught-fail(v_747) then (if not-caught-fail(v_748) then (if not-caught-fail(v_749) then (v_747,v_748,v_749) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {240}let v_751: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_732)) then (if (not-caught-fail(v_745) && success?(is-true(success?(1-proj-2-tuple(v_745))))) then dhexp(2-proj-2-tuple(v_745),v_735) else fail-any) else fail-any)) then (if (not-caught-fail(v_746) && success?(is-true(success?(1-proj-3-tuple(v_746))))) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_750)) then cipherstatepack(2-proj-3-tuple(v_750),minnonce) else fail-any),1-proj-3-tuple(v_750),3-proj-3-tuple(v_746)) else fail-any) else fail-any) else fail-any)) in
        {241}let v_752: bitstring = catch-fail(symmetricstateunpack(v_751)) in
        {242}let v_753: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_752))) in
        {243}let v_754: aead = catch-fail(decrypt(1-proj-2-tuple(v_753),2-proj-2-tuple(v_753),3-proj-3-tuple(v_752),3-proj-3-tuple(v_733))) in
        {244}let v_755: bitstring = catch-fail(aeadunpack(v_754)) in
        {245}let v_756: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_752))) in
        {246}let v_757: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_753))) && success?(1-proj-3-tuple(v_752))) then (if (not-caught-fail(v_756) && success?(is-true(success?(1-proj-2-tuple(v_756))))) then cipherstatepack(1-proj-2-tuple(v_756),increment_nonce(2-proj-2-tuple(v_753))) else fail-any) else fail-any)) in
        {247}let v_758: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_733)) && (success?(3-proj-3-tuple(v_752)) && success?(1-proj-3-tuple(v_752)))) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-2-tuple(v_753))))) then (if not-caught-fail(v_754) then (if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-3-tuple(v_755))))) then (if not-caught-fail(v_757) then (v_757,3-proj-3-tuple(v_755),1-proj-3-tuple(v_755)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {248}let v_759: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_758),2-proj-3-tuple(v_752),3-proj-3-tuple(v_752)))) in
        {249}let v_760: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_733)) && success?(symmetricstatepack(1-proj-3-tuple(v_758),2-proj-3-tuple(v_752),3-proj-3-tuple(v_752)))) then (if (not-caught-fail(v_759) && success?(is-true(success?(1-proj-3-tuple(v_759))))) then symmetricstatepack(1-proj-3-tuple(v_759),2-proj-3-tuple(v_759),hash(3-proj-3-tuple(v_759),3-proj-3-tuple(v_733))) else fail-any) else fail-any)) in
        {250}let v_761: bitstring = catch-fail((if success?(3-proj-3-tuple(v_733)) then (if (not-caught-fail(v_752) && success?(is-true(success?(1-proj-3-tuple(v_752))))) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-3-tuple(v_758))))) then (if not-caught-fail(v_760) then (v_760,2-proj-3-tuple(v_758),3-proj-3-tuple(v_758)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {251}let v_762: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_761),2-proj-7-tuple(v_732),3-proj-7-tuple(v_732),4-proj-7-tuple(v_732),v_735,6-proj-7-tuple(v_732),7-proj-7-tuple(v_732))) in
        {252}let v_763: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_761))) in
        {253}let v_764: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_763),zero)) in
        {254}let v_765: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_763),zero)) in
        {255}let v_766: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_763),zero)) in
        {256}let v_767: bitstring = catch-fail((if success?(2-proj-3-tuple(v_763)) then (if not-caught-fail(v_764) then (if not-caught-fail(v_765) then (if not-caught-fail(v_766) then (v_764,v_765,v_766) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {257}let v_768: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_767)) then cipherstatepack(1-proj-3-tuple(v_767),minnonce) else fail-any)) in
        {258}let v_769: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_767)) then cipherstatepack(2-proj-3-tuple(v_767),minnonce) else fail-any)) in
        {259}let v_770: bitstring = catch-fail((if success?(1-proj-3-tuple(v_761)) then (if (not-caught-fail(v_763) && success?(is-true(success?(1-proj-3-tuple(v_763))))) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-3-tuple(v_767))))) then (if not-caught-fail(v_768) then (if not-caught-fail(v_769) then (1-proj-3-tuple(v_761),v_768,v_769) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {260}let (hs_771: handshakestate,plaintext_b_772: bitstring,valid_773: bool,cs1_774: cipherstate,cs2_775: cipherstate) = (if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-7-tuple(v_732))))) then (if (not-caught-fail(v_733) && success?(is-true(success?(1-proj-3-tuple(v_733))))) then (if not-caught-fail(v_734) then (if not-caught-fail(v_735) then (if not-caught-fail(v_737) then (if not-caught-fail(v_744) then (if not-caught-fail(v_751) then (if (not-caught-fail(v_761) && success?(is-true(success?(1-proj-3-tuple(v_761))))) then (if (v_734 && 3-proj-3-tuple(v_761)) then (if not-caught-fail(v_762) then (if (not-caught-fail(v_770) && success?(is-true(success?(1-proj-3-tuple(v_770))))) then (v_762,2-proj-3-tuple(v_761),true,2-proj-3-tuple(v_770),3-proj-3-tuple(v_770)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {261}event RecvMsg(alice,charlie,stagepack_b(sid),plaintext_b_772);
        {262}insert statestore(alice,charlie,sid,statepack_c(hs_771,cs1_774,cs2_775))
    ) | (
        {264}!
        {283}get statestore(=alice,=charlie,=sid,statepack_c(hs_776: handshakestate,cs1_777: cipherstate,cs2_778: cipherstate)) in
        {265}let hs_779: handshakestate = handshakestatesetcs(hs_776,cs1_777) in
        {266}let v_780: bitstring = catch-fail(handshakestateunpack(hs_779)) in
        {267}let v_781: bitstring = catch-fail((empty,empty,empty)) in
        {268}let v_782: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_780))) in
        {269}let v_783: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_782))) in
        {270}let v_784: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_783),2-proj-2-tuple(v_783),3-proj-3-tuple(v_782),msg_c(alice,charlie,sid))) in
        {271}let v_785: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_782))) in
        {272}let v_786: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_783))) && success?(1-proj-3-tuple(v_782))) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-2-tuple(v_785))))) then cipherstatepack(1-proj-2-tuple(v_785),increment_nonce(2-proj-2-tuple(v_783))) else fail-any) else fail-any)) in
        {273}let v_787: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_782)) && success?(1-proj-3-tuple(v_782))) then (if (not-caught-fail(v_783) && success?(is-true(success?(1-proj-2-tuple(v_783))))) then (if not-caught-fail(v_784) then (if not-caught-fail(v_786) then (v_786,v_784) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {274}let v_788: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_787),2-proj-3-tuple(v_782),3-proj-3-tuple(v_782)))) in
        {275}let v_789: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_787)) && success?(symmetricstatepack(1-proj-2-tuple(v_787),2-proj-3-tuple(v_782),3-proj-3-tuple(v_782)))) then (if (not-caught-fail(v_788) && success?(is-true(success?(1-proj-3-tuple(v_788))))) then symmetricstatepack(1-proj-3-tuple(v_788),2-proj-3-tuple(v_788),hash(3-proj-3-tuple(v_788),2-proj-2-tuple(v_787))) else fail-any) else fail-any)) in
        {276}let v_790: bitstring = catch-fail((if success?(1-proj-7-tuple(v_780)) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then (if (not-caught-fail(v_787) && success?(is-true(success?(1-proj-2-tuple(v_787))))) then (if not-caught-fail(v_789) then (v_789,2-proj-2-tuple(v_787)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {277}let v_791: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_790),2-proj-7-tuple(v_780),3-proj-7-tuple(v_780),4-proj-7-tuple(v_780),5-proj-7-tuple(v_780),6-proj-7-tuple(v_780),7-proj-7-tuple(v_780))) in
        {278}let v_792: bitstring = catch-fail(concat3(1-proj-3-tuple(v_781),2-proj-3-tuple(v_781),2-proj-2-tuple(v_790))) in
        {279}let (hs_793: handshakestate,message_c_794: bitstring) = (if (not-caught-fail(v_780) && success?(is-true(success?(1-proj-7-tuple(v_780))))) then (if (not-caught-fail(v_781) && success?(is-true(success?(1-proj-3-tuple(v_781))))) then (if (not-caught-fail(v_790) && success?(is-true(success?(1-proj-2-tuple(v_790))))) then (if not-caught-fail(v_791) then (if not-caught-fail(v_792) then (v_791,v_792) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {280}event SendMsg(alice,charlie,stagepack_c(sid),msg_c(alice,charlie,sid));
        {281}insert statestore(alice,charlie,sid,statepack_d(hs_793,handshakestategetcs(hs_793),cs2_778));
        {282}out(pub, message_c_794)
    ) | (
        {284}!
        {304}get statestore(=alice,=charlie,=sid,statepack_d(hs_795: handshakestate,cs1_796: cipherstate,cs2_797: cipherstate)) in
        {285}let hs_798: handshakestate = handshakestatesetcs(hs_795,cs2_797) in
        {286}in(pub, message_d_799: bitstring);
        {287}let v_800: bitstring = catch-fail(handshakestateunpack(hs_798)) in
        {288}let v_801: bitstring = catch-fail(deconcat3(message_d_799)) in
        {289}let v_802: bool = catch-fail(true) in
        {290}let v_803: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_800))) in
        {291}let v_804: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_803))) in
        {292}let v_805: aead = catch-fail(decrypt(1-proj-2-tuple(v_804),2-proj-2-tuple(v_804),3-proj-3-tuple(v_803),3-proj-3-tuple(v_801))) in
        {293}let v_806: bitstring = catch-fail(aeadunpack(v_805)) in
        {294}let v_807: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_803))) in
        {295}let v_808: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_804))) && success?(1-proj-3-tuple(v_803))) then (if (not-caught-fail(v_807) && success?(is-true(success?(1-proj-2-tuple(v_807))))) then cipherstatepack(1-proj-2-tuple(v_807),increment_nonce(2-proj-2-tuple(v_804))) else fail-any) else fail-any)) in
        {296}let v_809: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_801)) && (success?(3-proj-3-tuple(v_803)) && success?(1-proj-3-tuple(v_803)))) then (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-2-tuple(v_804))))) then (if not-caught-fail(v_805) then (if (not-caught-fail(v_806) && success?(is-true(success?(1-proj-3-tuple(v_806))))) then (if not-caught-fail(v_808) then (v_808,3-proj-3-tuple(v_806),1-proj-3-tuple(v_806)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {297}let v_810: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_809),2-proj-3-tuple(v_803),3-proj-3-tuple(v_803)))) in
        {298}let v_811: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_801)) && success?(symmetricstatepack(1-proj-3-tuple(v_809),2-proj-3-tuple(v_803),3-proj-3-tuple(v_803)))) then (if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then symmetricstatepack(1-proj-3-tuple(v_810),2-proj-3-tuple(v_810),hash(3-proj-3-tuple(v_810),3-proj-3-tuple(v_801))) else fail-any) else fail-any)) in
        {299}let v_812: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_801)) && success?(1-proj-7-tuple(v_800))) then (if (not-caught-fail(v_803) && success?(is-true(success?(1-proj-3-tuple(v_803))))) then (if (not-caught-fail(v_809) && success?(is-true(success?(1-proj-3-tuple(v_809))))) then (if not-caught-fail(v_811) then (v_811,2-proj-3-tuple(v_809),3-proj-3-tuple(v_809)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {300}let v_813: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_812),2-proj-7-tuple(v_800),3-proj-7-tuple(v_800),4-proj-7-tuple(v_800),5-proj-7-tuple(v_800),6-proj-7-tuple(v_800),7-proj-7-tuple(v_800))) in
        {301}let (hs_814: handshakestate,plaintext_d_815: bitstring,valid_816: bool) = (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-7-tuple(v_800))))) then (if (not-caught-fail(v_801) && success?(is-true(success?(1-proj-3-tuple(v_801))))) then (if not-caught-fail(v_802) then (if (not-caught-fail(v_812) && success?(is-true(success?(1-proj-3-tuple(v_812))))) then (if (v_802 && 3-proj-3-tuple(v_812)) then (if not-caught-fail(v_813) then (v_813,2-proj-3-tuple(v_812),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {302}event RecvMsg(alice,charlie,stagepack_d(sid),plaintext_d_815);
        {303}event RecvEnd(valid_816)
    ) | (
        {305}event LeakS(phase0,alice);
        {306}out(pub, key_s(alice))
    ) | (
        {307}phase 1;
        {308}event LeakS(phase1,alice);
        {309}out(pub, key_s(alice))
    )
) | (
    {310}let v_817: key = catch-fail(dhexp(key_s(bob),g)) in
    {311}let s_818: keypair = (if not-caught-fail(v_817) then keypairpack(v_817,key_s(bob)) else fail-any) in
    {312}out(pub, getpublickey(s_818));
    (
        {313}let e_819: keypair = keypairpack(empty,empty) in
        {314}let rs_820: key = empty in
        {315}let re_821: key = empty in
        {316}let v_822: bitstring = catch-fail(hash(somename,empty)) in
        {317}let v_823: key = catch-fail(v_822) in
        {318}let v_824: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {319}let v_825: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_822) then (if not-caught-fail(v_823) then (if not-caught-fail(v_824) then symmetricstatepack(v_824,v_823,v_822) else fail-any) else fail-any) else fail-any))) in
        {320}let v_826: symmetricstate = catch-fail((if success?((if not-caught-fail(v_822) then (if not-caught-fail(v_823) then (if not-caught-fail(v_824) then symmetricstatepack(v_824,v_823,v_822) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_825) && success?(is-true(success?(1-proj-3-tuple(v_825))))) then symmetricstatepack(1-proj-3-tuple(v_825),2-proj-3-tuple(v_825),hash(3-proj-3-tuple(v_825),empty)) else fail-any) else fail-any)) in
        {321}let v_827: bitstring = catch-fail(symmetricstateunpack(v_826)) in
        {322}let v_828: symmetricstate = catch-fail((if success?(getpublickey(s_818)) then (if (not-caught-fail(v_827) && success?(is-true(success?(1-proj-3-tuple(v_827))))) then symmetricstatepack(1-proj-3-tuple(v_827),2-proj-3-tuple(v_827),hash(3-proj-3-tuple(v_827),getpublickey(s_818))) else fail-any) else fail-any)) in
        {323}let hs_829: handshakestate = (if not-caught-fail(v_826) then (if not-caught-fail(v_828) then handshakestatepack(v_828,s_818,e_819,rs_820,re_821,empty,false) else fail-any) else fail-any) in
        {324}insert statestore(bob,alice,sid,statepack_a(hs_829))
    ) | (
        {372}get statestore(=bob,=alice,=sid,statepack_a(hs_830: handshakestate)) in
        {325}in(pub, message_a_831: bitstring);
        {326}let v_832: bitstring = catch-fail(handshakestateunpack(hs_830)) in
        {327}let v_833: bitstring = catch-fail(deconcat3(message_a_831)) in
        {328}let v_834: bool = catch-fail(true) in
        {329}let v_835: key = catch-fail(1-proj-3-tuple(v_833)) in
        {330}let v_836: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_832))) in
        {331}let v_837: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_832)) then (if (not-caught-fail(v_836) && success?(is-true(success?(1-proj-3-tuple(v_836))))) then symmetricstatepack(1-proj-3-tuple(v_836),2-proj-3-tuple(v_836),hash(3-proj-3-tuple(v_836),v_835)) else fail-any) else fail-any)) in
        {332}let v_838: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_832))) in
        {333}let v_839: bitstring = catch-fail(symmetricstateunpack(v_837)) in
        {334}let v_840: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_839),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),v_835) else fail-any) else fail-any))) in
        {335}let v_841: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_839),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),v_835) else fail-any) else fail-any))) in
        {336}let v_842: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_839),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),v_835) else fail-any) else fail-any))) in
        {337}let v_843: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),v_835) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_839))) then (if not-caught-fail(v_840) then (if not-caught-fail(v_841) then (if not-caught-fail(v_842) then (v_840,v_841,v_842) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {338}let v_844: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_838) && success?(is-true(success?(1-proj-2-tuple(v_838))))) then dhexp(2-proj-2-tuple(v_838),v_835) else fail-any) else fail-any)) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then (if (not-caught-fail(v_843) && success?(is-true(success?(1-proj-3-tuple(v_843))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_843)) then cipherstatepack(2-proj-3-tuple(v_843),minnonce) else fail-any),1-proj-3-tuple(v_843),3-proj-3-tuple(v_839)) else fail-any) else fail-any) else fail-any)) in
        {339}let v_845: bitstring = catch-fail(symmetricstateunpack(v_844)) in
        {340}let v_846: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_845))) in
        {341}let v_847: aead = catch-fail(decrypt(1-proj-2-tuple(v_846),2-proj-2-tuple(v_846),3-proj-3-tuple(v_845),2-proj-3-tuple(v_833))) in
        {342}let v_848: bitstring = catch-fail(aeadunpack(v_847)) in
        {343}let v_849: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_845))) in
        {344}let v_850: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_846))) && success?(1-proj-3-tuple(v_845))) then (if (not-caught-fail(v_849) && success?(is-true(success?(1-proj-2-tuple(v_849))))) then cipherstatepack(1-proj-2-tuple(v_849),increment_nonce(2-proj-2-tuple(v_846))) else fail-any) else fail-any)) in
        {345}let v_851: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_833)) && (success?(3-proj-3-tuple(v_845)) && success?(1-proj-3-tuple(v_845)))) then (if (not-caught-fail(v_846) && success?(is-true(success?(1-proj-2-tuple(v_846))))) then (if not-caught-fail(v_847) then (if (not-caught-fail(v_848) && success?(is-true(success?(1-proj-3-tuple(v_848))))) then (if not-caught-fail(v_850) then (v_850,3-proj-3-tuple(v_848),1-proj-3-tuple(v_848)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {346}let v_852: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_851),2-proj-3-tuple(v_845),3-proj-3-tuple(v_845)))) in
        {347}let v_853: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_833)) && success?(symmetricstatepack(1-proj-3-tuple(v_851),2-proj-3-tuple(v_845),3-proj-3-tuple(v_845)))) then (if (not-caught-fail(v_852) && success?(is-true(success?(1-proj-3-tuple(v_852))))) then symmetricstatepack(1-proj-3-tuple(v_852),2-proj-3-tuple(v_852),hash(3-proj-3-tuple(v_852),2-proj-3-tuple(v_833))) else fail-any) else fail-any)) in
        {348}let v_854: bitstring = catch-fail((if success?(2-proj-3-tuple(v_833)) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-3-tuple(v_845))))) then (if (not-caught-fail(v_851) && success?(is-true(success?(1-proj-3-tuple(v_851))))) then (if not-caught-fail(v_853) then (v_853,2-proj-3-tuple(v_851),3-proj-3-tuple(v_851)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {349}let v_855: key = catch-fail(2-proj-3-tuple(v_854)) in
        {350}let v_856: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_832))) in
        {351}let v_857: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_854))) in
        {352}let v_858: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_857),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),v_855) else fail-any) else fail-any))) in
        {353}let v_859: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_857),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),v_855) else fail-any) else fail-any))) in
        {354}let v_860: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_857),(if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),v_855) else fail-any) else fail-any))) in
        {355}let v_861: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),v_855) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_857))) then (if not-caught-fail(v_858) then (if not-caught-fail(v_859) then (if not-caught-fail(v_860) then (v_858,v_859,v_860) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {356}let v_862: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_832)) then (if (not-caught-fail(v_856) && success?(is-true(success?(1-proj-2-tuple(v_856))))) then dhexp(2-proj-2-tuple(v_856),v_855) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_854))) then (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-3-tuple(v_857))))) then (if (not-caught-fail(v_861) && success?(is-true(success?(1-proj-3-tuple(v_861))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_861)) then cipherstatepack(2-proj-3-tuple(v_861),minnonce) else fail-any),1-proj-3-tuple(v_861),3-proj-3-tuple(v_857)) else fail-any) else fail-any) else fail-any)) in
        {357}let v_863: bitstring = catch-fail(symmetricstateunpack(v_862)) in
        {358}let v_864: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {359}let v_865: aead = catch-fail(decrypt(1-proj-2-tuple(v_864),2-proj-2-tuple(v_864),3-proj-3-tuple(v_863),3-proj-3-tuple(v_833))) in
        {360}let v_866: bitstring = catch-fail(aeadunpack(v_865)) in
        {361}let v_867: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_863))) in
        {362}let v_868: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_864))) && success?(1-proj-3-tuple(v_863))) then (if (not-caught-fail(v_867) && success?(is-true(success?(1-proj-2-tuple(v_867))))) then cipherstatepack(1-proj-2-tuple(v_867),increment_nonce(2-proj-2-tuple(v_864))) else fail-any) else fail-any)) in
        {363}let v_869: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_833)) && (success?(3-proj-3-tuple(v_863)) && success?(1-proj-3-tuple(v_863)))) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-2-tuple(v_864))))) then (if not-caught-fail(v_865) then (if (not-caught-fail(v_866) && success?(is-true(success?(1-proj-3-tuple(v_866))))) then (if not-caught-fail(v_868) then (v_868,3-proj-3-tuple(v_866),1-proj-3-tuple(v_866)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {364}let v_870: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_869),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) in
        {365}let v_871: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_833)) && success?(symmetricstatepack(1-proj-3-tuple(v_869),2-proj-3-tuple(v_863),3-proj-3-tuple(v_863)))) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-3-tuple(v_870))))) then symmetricstatepack(1-proj-3-tuple(v_870),2-proj-3-tuple(v_870),hash(3-proj-3-tuple(v_870),3-proj-3-tuple(v_833))) else fail-any) else fail-any)) in
        {366}let v_872: bitstring = catch-fail((if success?(3-proj-3-tuple(v_833)) then (if (not-caught-fail(v_863) && success?(is-true(success?(1-proj-3-tuple(v_863))))) then (if (not-caught-fail(v_869) && success?(is-true(success?(1-proj-3-tuple(v_869))))) then (if not-caught-fail(v_871) then (v_871,2-proj-3-tuple(v_869),3-proj-3-tuple(v_869)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {367}let v_873: key = catch-fail(dhexp(key_s(alice),g)) in
        {368}let v_874: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_872),2-proj-7-tuple(v_832),3-proj-7-tuple(v_832),v_855,v_835,6-proj-7-tuple(v_832),7-proj-7-tuple(v_832))) in
        {369}let (hs_875: handshakestate,plaintext_a: bitstring,valid_876: bool) = (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-7-tuple(v_832))))) then (if (not-caught-fail(v_833) && success?(is-true(success?(1-proj-3-tuple(v_833))))) then (if not-caught-fail(v_834) then (if not-caught-fail(v_835) then (if not-caught-fail(v_837) then (if not-caught-fail(v_844) then (if (not-caught-fail(v_854) && success?(is-true(success?(1-proj-3-tuple(v_854))))) then (if not-caught-fail(v_855) then (if not-caught-fail(v_862) then (if (not-caught-fail(v_872) && success?(is-true(success?(1-proj-3-tuple(v_872))))) then (if ((3-proj-3-tuple(v_854) && 3-proj-3-tuple(v_872)) && (v_855 = getpublickey((if not-caught-fail(v_873) then keypairpack(v_873,key_s(alice)) else fail-any)))) then (if not-caught-fail(v_874) then (v_874,2-proj-3-tuple(v_872),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {370}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {371}insert statestore(bob,alice,sid,statepack_b(hs_875))
    ) | (
        {417}get statestore(=bob,=alice,=sid,statepack_b(hs_877: handshakestate)) in
        {373}let v_878: bitstring = catch-fail(handshakestateunpack(hs_877)) in
        {374}let v_879: bitstring = catch-fail((empty,empty,empty)) in
        {375}let v_880: key = catch-fail(dhexp(key_e(bob,alice,sid),g)) in
        {376}let v_881: keypair = catch-fail((if not-caught-fail(v_880) then keypairpack(v_880,key_e(bob,alice,sid)) else fail-any)) in
        {377}let v_882: bitstring = catch-fail(getpublickey(v_881)) in
        {378}let v_883: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_878))) in
        {379}let v_884: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_878)) then (if (not-caught-fail(v_883) && success?(is-true(success?(1-proj-3-tuple(v_883))))) then symmetricstatepack(1-proj-3-tuple(v_883),2-proj-3-tuple(v_883),hash(3-proj-3-tuple(v_883),v_882)) else fail-any) else fail-any)) in
        {380}let v_885: bitstring = catch-fail(keypairunpack(v_881)) in
        {381}let v_886: bitstring = catch-fail(symmetricstateunpack(v_884)) in
        {382}let v_887: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_886),(if success?(5-proj-7-tuple(v_878)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),5-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {383}let v_888: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_886),(if success?(5-proj-7-tuple(v_878)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),5-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {384}let v_889: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_886),(if success?(5-proj-7-tuple(v_878)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),5-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {385}let v_890: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_878)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),5-proj-7-tuple(v_878)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_886))) then (if not-caught-fail(v_887) then (if not-caught-fail(v_888) then (if not-caught-fail(v_889) then (v_887,v_888,v_889) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {386}let v_891: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_878)) then (if (not-caught-fail(v_885) && success?(is-true(success?(1-proj-2-tuple(v_885))))) then dhexp(2-proj-2-tuple(v_885),5-proj-7-tuple(v_878)) else fail-any) else fail-any)) then (if (not-caught-fail(v_886) && success?(is-true(success?(1-proj-3-tuple(v_886))))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-3-tuple(v_890))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_890)) then cipherstatepack(2-proj-3-tuple(v_890),minnonce) else fail-any),1-proj-3-tuple(v_890),3-proj-3-tuple(v_886)) else fail-any) else fail-any) else fail-any)) in
        {387}let v_892: bitstring = catch-fail(keypairunpack(v_881)) in
        {388}let v_893: bitstring = catch-fail(symmetricstateunpack(v_891)) in
        {389}let v_894: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_893),(if success?(4-proj-7-tuple(v_878)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then dhexp(2-proj-2-tuple(v_892),4-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {390}let v_895: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_893),(if success?(4-proj-7-tuple(v_878)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then dhexp(2-proj-2-tuple(v_892),4-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {391}let v_896: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_893),(if success?(4-proj-7-tuple(v_878)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then dhexp(2-proj-2-tuple(v_892),4-proj-7-tuple(v_878)) else fail-any) else fail-any))) in
        {392}let v_897: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_878)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then dhexp(2-proj-2-tuple(v_892),4-proj-7-tuple(v_878)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_893))) then (if not-caught-fail(v_894) then (if not-caught-fail(v_895) then (if not-caught-fail(v_896) then (v_894,v_895,v_896) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {393}let v_898: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_878)) then (if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-2-tuple(v_892))))) then dhexp(2-proj-2-tuple(v_892),4-proj-7-tuple(v_878)) else fail-any) else fail-any)) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-3-tuple(v_893))))) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-3-tuple(v_897))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_897)) then cipherstatepack(2-proj-3-tuple(v_897),minnonce) else fail-any),1-proj-3-tuple(v_897),3-proj-3-tuple(v_893)) else fail-any) else fail-any) else fail-any)) in
        {394}let v_899: bitstring = catch-fail(symmetricstateunpack(v_898)) in
        {395}let v_900: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_899))) in
        {396}let v_901: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_900),2-proj-2-tuple(v_900),3-proj-3-tuple(v_899),msg_b(bob,alice,sid))) in
        {397}let v_902: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_899))) in
        {398}let v_903: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_900))) && success?(1-proj-3-tuple(v_899))) then (if (not-caught-fail(v_902) && success?(is-true(success?(1-proj-2-tuple(v_902))))) then cipherstatepack(1-proj-2-tuple(v_902),increment_nonce(2-proj-2-tuple(v_900))) else fail-any) else fail-any)) in
        {399}let v_904: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_899)) && success?(1-proj-3-tuple(v_899))) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then (if not-caught-fail(v_901) then (if not-caught-fail(v_903) then (v_903,v_901) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {400}let v_905: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_904),2-proj-3-tuple(v_899),3-proj-3-tuple(v_899)))) in
        {401}let v_906: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_904)) && success?(symmetricstatepack(1-proj-2-tuple(v_904),2-proj-3-tuple(v_899),3-proj-3-tuple(v_899)))) then (if (not-caught-fail(v_905) && success?(is-true(success?(1-proj-3-tuple(v_905))))) then symmetricstatepack(1-proj-3-tuple(v_905),2-proj-3-tuple(v_905),hash(3-proj-3-tuple(v_905),2-proj-2-tuple(v_904))) else fail-any) else fail-any)) in
        {402}let v_907: bitstring = catch-fail((if (not-caught-fail(v_899) && success?(is-true(success?(1-proj-3-tuple(v_899))))) then (if (not-caught-fail(v_904) && success?(is-true(success?(1-proj-2-tuple(v_904))))) then (if not-caught-fail(v_906) then (v_906,2-proj-2-tuple(v_904)) else fail-any) else fail-any) else fail-any)) in
        {403}let v_908: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_907),2-proj-7-tuple(v_878),v_881,4-proj-7-tuple(v_878),5-proj-7-tuple(v_878),6-proj-7-tuple(v_878),7-proj-7-tuple(v_878))) in
        {404}let v_909: bitstring = catch-fail(concat3(v_882,2-proj-3-tuple(v_879),2-proj-2-tuple(v_907))) in
        {405}let v_910: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_907))) in
        {406}let v_911: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_910),zero)) in
        {407}let v_912: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_910),zero)) in
        {408}let v_913: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_910),zero)) in
        {409}let v_914: bitstring = catch-fail((if success?(2-proj-3-tuple(v_910)) then (if not-caught-fail(v_911) then (if not-caught-fail(v_912) then (if not-caught-fail(v_913) then (v_911,v_912,v_913) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {410}let v_915: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_914)) then cipherstatepack(1-proj-3-tuple(v_914),minnonce) else fail-any)) in
        {411}let v_916: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_914)) then cipherstatepack(2-proj-3-tuple(v_914),minnonce) else fail-any)) in
        {412}let v_917: bitstring = catch-fail((if success?(1-proj-2-tuple(v_907)) then (if (not-caught-fail(v_910) && success?(is-true(success?(1-proj-3-tuple(v_910))))) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-3-tuple(v_914))))) then (if not-caught-fail(v_915) then (if not-caught-fail(v_916) then (1-proj-2-tuple(v_907),v_915,v_916) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {413}let (hs_918: handshakestate,message_b_919: bitstring,cs1_920: cipherstate,cs2_921: cipherstate) = (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-7-tuple(v_878))))) then (if (not-caught-fail(v_879) && success?(is-true(success?(1-proj-3-tuple(v_879))))) then (if not-caught-fail(v_881) then (if not-caught-fail(v_882) then (if not-caught-fail(v_884) then (if not-caught-fail(v_891) then (if not-caught-fail(v_898) then (if (not-caught-fail(v_907) && success?(is-true(success?(1-proj-2-tuple(v_907))))) then (if not-caught-fail(v_908) then (if not-caught-fail(v_909) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then (v_908,v_909,2-proj-3-tuple(v_917),3-proj-3-tuple(v_917)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {414}event SendMsg(bob,alice,stagepack_b(sid),msg_b(bob,alice,sid));
        {415}insert statestore(bob,alice,sid,statepack_c(hs_918,cs1_920,cs2_921));
        {416}out(pub, message_b_919)
    ) | (
        {418}!
        {438}get statestore(=bob,=alice,=sid,statepack_c(hs_922: handshakestate,cs1_923: cipherstate,cs2_924: cipherstate)) in
        {419}let hs_925: handshakestate = handshakestatesetcs(hs_922,cs1_923) in
        {420}in(pub, message_c_926: bitstring);
        {421}let v_927: bitstring = catch-fail(handshakestateunpack(hs_925)) in
        {422}let v_928: bitstring = catch-fail(deconcat3(message_c_926)) in
        {423}let v_929: bool = catch-fail(true) in
        {424}let v_930: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_927))) in
        {425}let v_931: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_930))) in
        {426}let v_932: aead = catch-fail(decrypt(1-proj-2-tuple(v_931),2-proj-2-tuple(v_931),3-proj-3-tuple(v_930),3-proj-3-tuple(v_928))) in
        {427}let v_933: bitstring = catch-fail(aeadunpack(v_932)) in
        {428}let v_934: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_930))) in
        {429}let v_935: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_931))) && success?(1-proj-3-tuple(v_930))) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-2-tuple(v_934))))) then cipherstatepack(1-proj-2-tuple(v_934),increment_nonce(2-proj-2-tuple(v_931))) else fail-any) else fail-any)) in
        {430}let v_936: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_928)) && (success?(3-proj-3-tuple(v_930)) && success?(1-proj-3-tuple(v_930)))) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then (if not-caught-fail(v_932) then (if (not-caught-fail(v_933) && success?(is-true(success?(1-proj-3-tuple(v_933))))) then (if not-caught-fail(v_935) then (v_935,3-proj-3-tuple(v_933),1-proj-3-tuple(v_933)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {431}let v_937: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_930),3-proj-3-tuple(v_930)))) in
        {432}let v_938: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_928)) && success?(symmetricstatepack(1-proj-3-tuple(v_936),2-proj-3-tuple(v_930),3-proj-3-tuple(v_930)))) then (if (not-caught-fail(v_937) && success?(is-true(success?(1-proj-3-tuple(v_937))))) then symmetricstatepack(1-proj-3-tuple(v_937),2-proj-3-tuple(v_937),hash(3-proj-3-tuple(v_937),3-proj-3-tuple(v_928))) else fail-any) else fail-any)) in
        {433}let v_939: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_928)) && success?(1-proj-7-tuple(v_927))) then (if (not-caught-fail(v_930) && success?(is-true(success?(1-proj-3-tuple(v_930))))) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-3-tuple(v_936))))) then (if not-caught-fail(v_938) then (v_938,2-proj-3-tuple(v_936),3-proj-3-tuple(v_936)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {434}let v_940: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_939),2-proj-7-tuple(v_927),3-proj-7-tuple(v_927),4-proj-7-tuple(v_927),5-proj-7-tuple(v_927),6-proj-7-tuple(v_927),7-proj-7-tuple(v_927))) in
        {435}let (hs_941: handshakestate,plaintext_c: bitstring,valid_942: bool) = (if (not-caught-fail(v_927) && success?(is-true(success?(1-proj-7-tuple(v_927))))) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then (if not-caught-fail(v_929) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-3-tuple(v_939))))) then (if (v_929 && 3-proj-3-tuple(v_939)) then (if not-caught-fail(v_940) then (v_940,2-proj-3-tuple(v_939),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {436}event RecvMsg(bob,alice,stagepack_c(sid),plaintext_c);
        {437}insert statestore(bob,alice,sid,statepack_d(hs_941,handshakestategetcs(hs_941),cs2_924))
    ) | (
        {439}!
        {457}get statestore(=bob,=alice,=sid,statepack_d(hs_943: handshakestate,cs1_944: cipherstate,cs2_945: cipherstate)) in
        {440}let hs_946: handshakestate = handshakestatesetcs(hs_943,cs2_945) in
        {441}let v_947: bitstring = catch-fail(handshakestateunpack(hs_946)) in
        {442}let v_948: bitstring = catch-fail((empty,empty,empty)) in
        {443}let v_949: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_947))) in
        {444}let v_950: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_949))) in
        {445}let v_951: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_950),2-proj-2-tuple(v_950),3-proj-3-tuple(v_949),msg_d(bob,alice,sid))) in
        {446}let v_952: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_949))) in
        {447}let v_953: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_950))) && success?(1-proj-3-tuple(v_949))) then (if (not-caught-fail(v_952) && success?(is-true(success?(1-proj-2-tuple(v_952))))) then cipherstatepack(1-proj-2-tuple(v_952),increment_nonce(2-proj-2-tuple(v_950))) else fail-any) else fail-any)) in
        {448}let v_954: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_949)) && success?(1-proj-3-tuple(v_949))) then (if (not-caught-fail(v_950) && success?(is-true(success?(1-proj-2-tuple(v_950))))) then (if not-caught-fail(v_951) then (if not-caught-fail(v_953) then (v_953,v_951) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {449}let v_955: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_954),2-proj-3-tuple(v_949),3-proj-3-tuple(v_949)))) in
        {450}let v_956: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_954)) && success?(symmetricstatepack(1-proj-2-tuple(v_954),2-proj-3-tuple(v_949),3-proj-3-tuple(v_949)))) then (if (not-caught-fail(v_955) && success?(is-true(success?(1-proj-3-tuple(v_955))))) then symmetricstatepack(1-proj-3-tuple(v_955),2-proj-3-tuple(v_955),hash(3-proj-3-tuple(v_955),2-proj-2-tuple(v_954))) else fail-any) else fail-any)) in
        {451}let v_957: bitstring = catch-fail((if success?(1-proj-7-tuple(v_947)) then (if (not-caught-fail(v_949) && success?(is-true(success?(1-proj-3-tuple(v_949))))) then (if (not-caught-fail(v_954) && success?(is-true(success?(1-proj-2-tuple(v_954))))) then (if not-caught-fail(v_956) then (v_956,2-proj-2-tuple(v_954)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {452}let v_958: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_957),2-proj-7-tuple(v_947),3-proj-7-tuple(v_947),4-proj-7-tuple(v_947),5-proj-7-tuple(v_947),6-proj-7-tuple(v_947),7-proj-7-tuple(v_947))) in
        {453}let v_959: bitstring = catch-fail(concat3(1-proj-3-tuple(v_948),2-proj-3-tuple(v_948),2-proj-2-tuple(v_957))) in
        {454}let (hs_960: handshakestate,message_d_961: bitstring) = (if (not-caught-fail(v_947) && success?(is-true(success?(1-proj-7-tuple(v_947))))) then (if (not-caught-fail(v_948) && success?(is-true(success?(1-proj-3-tuple(v_948))))) then (if (not-caught-fail(v_957) && success?(is-true(success?(1-proj-2-tuple(v_957))))) then (if not-caught-fail(v_958) then (if not-caught-fail(v_959) then (v_958,v_959) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {455}event SendMsg(bob,alice,stagepack_d(sid),msg_d(bob,alice,sid));
        {456}out(pub, message_d_961)
    ) | (
        {458}event LeakS(phase0,bob);
        {459}out(pub, key_s(bob))
    ) | (
        {460}phase 1;
        {461}event LeakS(phase1,bob);
        {462}out(pub, key_s(bob))
    )
) | (
    {463}let v_962: key = catch-fail(dhexp(key_s(bob),g)) in
    {464}let s_963: keypair = (if not-caught-fail(v_962) then keypairpack(v_962,key_s(bob)) else fail-any) in
    {465}out(pub, getpublickey(s_963));
    (
        {466}let e_964: keypair = keypairpack(empty,empty) in
        {467}let rs_965: key = empty in
        {468}let re_966: key = empty in
        {469}let v_967: bitstring = catch-fail(hash(somename,empty)) in
        {470}let v_968: key = catch-fail(v_967) in
        {471}let v_969: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {472}let v_970: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_967) then (if not-caught-fail(v_968) then (if not-caught-fail(v_969) then symmetricstatepack(v_969,v_968,v_967) else fail-any) else fail-any) else fail-any))) in
        {473}let v_971: symmetricstate = catch-fail((if success?((if not-caught-fail(v_967) then (if not-caught-fail(v_968) then (if not-caught-fail(v_969) then symmetricstatepack(v_969,v_968,v_967) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_970) && success?(is-true(success?(1-proj-3-tuple(v_970))))) then symmetricstatepack(1-proj-3-tuple(v_970),2-proj-3-tuple(v_970),hash(3-proj-3-tuple(v_970),empty)) else fail-any) else fail-any)) in
        {474}let v_972: bitstring = catch-fail(symmetricstateunpack(v_971)) in
        {475}let v_973: symmetricstate = catch-fail((if success?(getpublickey(s_963)) then (if (not-caught-fail(v_972) && success?(is-true(success?(1-proj-3-tuple(v_972))))) then symmetricstatepack(1-proj-3-tuple(v_972),2-proj-3-tuple(v_972),hash(3-proj-3-tuple(v_972),getpublickey(s_963))) else fail-any) else fail-any)) in
        {476}let hs_974: handshakestate = (if not-caught-fail(v_971) then (if not-caught-fail(v_973) then handshakestatepack(v_973,s_963,e_964,rs_965,re_966,empty,false) else fail-any) else fail-any) in
        {477}insert statestore(bob,charlie,sid,statepack_a(hs_974))
    ) | (
        {525}get statestore(=bob,=charlie,=sid,statepack_a(hs_975: handshakestate)) in
        {478}in(pub, message_a_976: bitstring);
        {479}let v_977: bitstring = catch-fail(handshakestateunpack(hs_975)) in
        {480}let v_978: bitstring = catch-fail(deconcat3(message_a_976)) in
        {481}let v_979: bool = catch-fail(true) in
        {482}let v_980: key = catch-fail(1-proj-3-tuple(v_978)) in
        {483}let v_981: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_977))) in
        {484}let v_982: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_977)) then (if (not-caught-fail(v_981) && success?(is-true(success?(1-proj-3-tuple(v_981))))) then symmetricstatepack(1-proj-3-tuple(v_981),2-proj-3-tuple(v_981),hash(3-proj-3-tuple(v_981),v_980)) else fail-any) else fail-any)) in
        {485}let v_983: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_977))) in
        {486}let v_984: bitstring = catch-fail(symmetricstateunpack(v_982)) in
        {487}let v_985: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_984),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),v_980) else fail-any) else fail-any))) in
        {488}let v_986: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_984),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),v_980) else fail-any) else fail-any))) in
        {489}let v_987: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_984),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),v_980) else fail-any) else fail-any))) in
        {490}let v_988: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),v_980) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_984))) then (if not-caught-fail(v_985) then (if not-caught-fail(v_986) then (if not-caught-fail(v_987) then (v_985,v_986,v_987) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {491}let v_989: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_983) && success?(is-true(success?(1-proj-2-tuple(v_983))))) then dhexp(2-proj-2-tuple(v_983),v_980) else fail-any) else fail-any)) then (if (not-caught-fail(v_984) && success?(is-true(success?(1-proj-3-tuple(v_984))))) then (if (not-caught-fail(v_988) && success?(is-true(success?(1-proj-3-tuple(v_988))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_988)) then cipherstatepack(2-proj-3-tuple(v_988),minnonce) else fail-any),1-proj-3-tuple(v_988),3-proj-3-tuple(v_984)) else fail-any) else fail-any) else fail-any)) in
        {492}let v_990: bitstring = catch-fail(symmetricstateunpack(v_989)) in
        {493}let v_991: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_990))) in
        {494}let v_992: aead = catch-fail(decrypt(1-proj-2-tuple(v_991),2-proj-2-tuple(v_991),3-proj-3-tuple(v_990),2-proj-3-tuple(v_978))) in
        {495}let v_993: bitstring = catch-fail(aeadunpack(v_992)) in
        {496}let v_994: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_990))) in
        {497}let v_995: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_991))) && success?(1-proj-3-tuple(v_990))) then (if (not-caught-fail(v_994) && success?(is-true(success?(1-proj-2-tuple(v_994))))) then cipherstatepack(1-proj-2-tuple(v_994),increment_nonce(2-proj-2-tuple(v_991))) else fail-any) else fail-any)) in
        {498}let v_996: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_978)) && (success?(3-proj-3-tuple(v_990)) && success?(1-proj-3-tuple(v_990)))) then (if (not-caught-fail(v_991) && success?(is-true(success?(1-proj-2-tuple(v_991))))) then (if not-caught-fail(v_992) then (if (not-caught-fail(v_993) && success?(is-true(success?(1-proj-3-tuple(v_993))))) then (if not-caught-fail(v_995) then (v_995,3-proj-3-tuple(v_993),1-proj-3-tuple(v_993)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {499}let v_997: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_996),2-proj-3-tuple(v_990),3-proj-3-tuple(v_990)))) in
        {500}let v_998: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_978)) && success?(symmetricstatepack(1-proj-3-tuple(v_996),2-proj-3-tuple(v_990),3-proj-3-tuple(v_990)))) then (if (not-caught-fail(v_997) && success?(is-true(success?(1-proj-3-tuple(v_997))))) then symmetricstatepack(1-proj-3-tuple(v_997),2-proj-3-tuple(v_997),hash(3-proj-3-tuple(v_997),2-proj-3-tuple(v_978))) else fail-any) else fail-any)) in
        {501}let v_999: bitstring = catch-fail((if success?(2-proj-3-tuple(v_978)) then (if (not-caught-fail(v_990) && success?(is-true(success?(1-proj-3-tuple(v_990))))) then (if (not-caught-fail(v_996) && success?(is-true(success?(1-proj-3-tuple(v_996))))) then (if not-caught-fail(v_998) then (v_998,2-proj-3-tuple(v_996),3-proj-3-tuple(v_996)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {502}let v_1000: key = catch-fail(2-proj-3-tuple(v_999)) in
        {503}let v_1001: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_977))) in
        {504}let v_1002: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_999))) in
        {505}let v_1003: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1002),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then dhexp(2-proj-2-tuple(v_1001),v_1000) else fail-any) else fail-any))) in
        {506}let v_1004: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1002),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then dhexp(2-proj-2-tuple(v_1001),v_1000) else fail-any) else fail-any))) in
        {507}let v_1005: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1002),(if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then dhexp(2-proj-2-tuple(v_1001),v_1000) else fail-any) else fail-any))) in
        {508}let v_1006: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then dhexp(2-proj-2-tuple(v_1001),v_1000) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1002))) then (if not-caught-fail(v_1003) then (if not-caught-fail(v_1004) then (if not-caught-fail(v_1005) then (v_1003,v_1004,v_1005) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {509}let v_1007: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_977)) then (if (not-caught-fail(v_1001) && success?(is-true(success?(1-proj-2-tuple(v_1001))))) then dhexp(2-proj-2-tuple(v_1001),v_1000) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_999))) then (if (not-caught-fail(v_1002) && success?(is-true(success?(1-proj-3-tuple(v_1002))))) then (if (not-caught-fail(v_1006) && success?(is-true(success?(1-proj-3-tuple(v_1006))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1006)) then cipherstatepack(2-proj-3-tuple(v_1006),minnonce) else fail-any),1-proj-3-tuple(v_1006),3-proj-3-tuple(v_1002)) else fail-any) else fail-any) else fail-any)) in
        {510}let v_1008: bitstring = catch-fail(symmetricstateunpack(v_1007)) in
        {511}let v_1009: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1008))) in
        {512}let v_1010: aead = catch-fail(decrypt(1-proj-2-tuple(v_1009),2-proj-2-tuple(v_1009),3-proj-3-tuple(v_1008),3-proj-3-tuple(v_978))) in
        {513}let v_1011: bitstring = catch-fail(aeadunpack(v_1010)) in
        {514}let v_1012: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1008))) in
        {515}let v_1013: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1009))) && success?(1-proj-3-tuple(v_1008))) then (if (not-caught-fail(v_1012) && success?(is-true(success?(1-proj-2-tuple(v_1012))))) then cipherstatepack(1-proj-2-tuple(v_1012),increment_nonce(2-proj-2-tuple(v_1009))) else fail-any) else fail-any)) in
        {516}let v_1014: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_978)) && (success?(3-proj-3-tuple(v_1008)) && success?(1-proj-3-tuple(v_1008)))) then (if (not-caught-fail(v_1009) && success?(is-true(success?(1-proj-2-tuple(v_1009))))) then (if not-caught-fail(v_1010) then (if (not-caught-fail(v_1011) && success?(is-true(success?(1-proj-3-tuple(v_1011))))) then (if not-caught-fail(v_1013) then (v_1013,3-proj-3-tuple(v_1011),1-proj-3-tuple(v_1011)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {517}let v_1015: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1014),2-proj-3-tuple(v_1008),3-proj-3-tuple(v_1008)))) in
        {518}let v_1016: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_978)) && success?(symmetricstatepack(1-proj-3-tuple(v_1014),2-proj-3-tuple(v_1008),3-proj-3-tuple(v_1008)))) then (if (not-caught-fail(v_1015) && success?(is-true(success?(1-proj-3-tuple(v_1015))))) then symmetricstatepack(1-proj-3-tuple(v_1015),2-proj-3-tuple(v_1015),hash(3-proj-3-tuple(v_1015),3-proj-3-tuple(v_978))) else fail-any) else fail-any)) in
        {519}let v_1017: bitstring = catch-fail((if success?(3-proj-3-tuple(v_978)) then (if (not-caught-fail(v_1008) && success?(is-true(success?(1-proj-3-tuple(v_1008))))) then (if (not-caught-fail(v_1014) && success?(is-true(success?(1-proj-3-tuple(v_1014))))) then (if not-caught-fail(v_1016) then (v_1016,2-proj-3-tuple(v_1014),3-proj-3-tuple(v_1014)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {520}let v_1018: key = catch-fail(dhexp(key_s(charlie),g)) in
        {521}let v_1019: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1017),2-proj-7-tuple(v_977),3-proj-7-tuple(v_977),v_1000,v_980,6-proj-7-tuple(v_977),7-proj-7-tuple(v_977))) in
        {522}let (hs_1020: handshakestate,plaintext_a_1021: bitstring,valid_1022: bool) = (if (not-caught-fail(v_977) && success?(is-true(success?(1-proj-7-tuple(v_977))))) then (if (not-caught-fail(v_978) && success?(is-true(success?(1-proj-3-tuple(v_978))))) then (if not-caught-fail(v_979) then (if not-caught-fail(v_980) then (if not-caught-fail(v_982) then (if not-caught-fail(v_989) then (if (not-caught-fail(v_999) && success?(is-true(success?(1-proj-3-tuple(v_999))))) then (if not-caught-fail(v_1000) then (if not-caught-fail(v_1007) then (if (not-caught-fail(v_1017) && success?(is-true(success?(1-proj-3-tuple(v_1017))))) then (if ((3-proj-3-tuple(v_999) && 3-proj-3-tuple(v_1017)) && (v_1000 = getpublickey((if not-caught-fail(v_1018) then keypairpack(v_1018,key_s(charlie)) else fail-any)))) then (if not-caught-fail(v_1019) then (v_1019,2-proj-3-tuple(v_1017),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {523}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_1021);
        {524}insert statestore(bob,charlie,sid,statepack_b(hs_1020))
    ) | (
        {570}get statestore(=bob,=charlie,=sid,statepack_b(hs_1023: handshakestate)) in
        {526}let v_1024: bitstring = catch-fail(handshakestateunpack(hs_1023)) in
        {527}let v_1025: bitstring = catch-fail((empty,empty,empty)) in
        {528}let v_1026: key = catch-fail(dhexp(key_e(bob,charlie,sid),g)) in
        {529}let v_1027: keypair = catch-fail((if not-caught-fail(v_1026) then keypairpack(v_1026,key_e(bob,charlie,sid)) else fail-any)) in
        {530}let v_1028: bitstring = catch-fail(getpublickey(v_1027)) in
        {531}let v_1029: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1024))) in
        {532}let v_1030: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1029) && success?(is-true(success?(1-proj-3-tuple(v_1029))))) then symmetricstatepack(1-proj-3-tuple(v_1029),2-proj-3-tuple(v_1029),hash(3-proj-3-tuple(v_1029),v_1028)) else fail-any) else fail-any)) in
        {533}let v_1031: bitstring = catch-fail(keypairunpack(v_1027)) in
        {534}let v_1032: bitstring = catch-fail(symmetricstateunpack(v_1030)) in
        {535}let v_1033: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1032),(if success?(5-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-2-tuple(v_1031))))) then dhexp(2-proj-2-tuple(v_1031),5-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {536}let v_1034: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1032),(if success?(5-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-2-tuple(v_1031))))) then dhexp(2-proj-2-tuple(v_1031),5-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {537}let v_1035: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1032),(if success?(5-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-2-tuple(v_1031))))) then dhexp(2-proj-2-tuple(v_1031),5-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {538}let v_1036: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-2-tuple(v_1031))))) then dhexp(2-proj-2-tuple(v_1031),5-proj-7-tuple(v_1024)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1032))) then (if not-caught-fail(v_1033) then (if not-caught-fail(v_1034) then (if not-caught-fail(v_1035) then (v_1033,v_1034,v_1035) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {539}let v_1037: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1031) && success?(is-true(success?(1-proj-2-tuple(v_1031))))) then dhexp(2-proj-2-tuple(v_1031),5-proj-7-tuple(v_1024)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1032) && success?(is-true(success?(1-proj-3-tuple(v_1032))))) then (if (not-caught-fail(v_1036) && success?(is-true(success?(1-proj-3-tuple(v_1036))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1036)) then cipherstatepack(2-proj-3-tuple(v_1036),minnonce) else fail-any),1-proj-3-tuple(v_1036),3-proj-3-tuple(v_1032)) else fail-any) else fail-any) else fail-any)) in
        {540}let v_1038: bitstring = catch-fail(keypairunpack(v_1027)) in
        {541}let v_1039: bitstring = catch-fail(symmetricstateunpack(v_1037)) in
        {542}let v_1040: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1039),(if success?(4-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then dhexp(2-proj-2-tuple(v_1038),4-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {543}let v_1041: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1039),(if success?(4-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then dhexp(2-proj-2-tuple(v_1038),4-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {544}let v_1042: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1039),(if success?(4-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then dhexp(2-proj-2-tuple(v_1038),4-proj-7-tuple(v_1024)) else fail-any) else fail-any))) in
        {545}let v_1043: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then dhexp(2-proj-2-tuple(v_1038),4-proj-7-tuple(v_1024)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_1039))) then (if not-caught-fail(v_1040) then (if not-caught-fail(v_1041) then (if not-caught-fail(v_1042) then (v_1040,v_1041,v_1042) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {546}let v_1044: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_1024)) then (if (not-caught-fail(v_1038) && success?(is-true(success?(1-proj-2-tuple(v_1038))))) then dhexp(2-proj-2-tuple(v_1038),4-proj-7-tuple(v_1024)) else fail-any) else fail-any)) then (if (not-caught-fail(v_1039) && success?(is-true(success?(1-proj-3-tuple(v_1039))))) then (if (not-caught-fail(v_1043) && success?(is-true(success?(1-proj-3-tuple(v_1043))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_1043)) then cipherstatepack(2-proj-3-tuple(v_1043),minnonce) else fail-any),1-proj-3-tuple(v_1043),3-proj-3-tuple(v_1039)) else fail-any) else fail-any) else fail-any)) in
        {547}let v_1045: bitstring = catch-fail(symmetricstateunpack(v_1044)) in
        {548}let v_1046: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1045))) in
        {549}let v_1047: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1046),2-proj-2-tuple(v_1046),3-proj-3-tuple(v_1045),msg_b(bob,charlie,sid))) in
        {550}let v_1048: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1045))) in
        {551}let v_1049: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1046))) && success?(1-proj-3-tuple(v_1045))) then (if (not-caught-fail(v_1048) && success?(is-true(success?(1-proj-2-tuple(v_1048))))) then cipherstatepack(1-proj-2-tuple(v_1048),increment_nonce(2-proj-2-tuple(v_1046))) else fail-any) else fail-any)) in
        {552}let v_1050: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1045)) && success?(1-proj-3-tuple(v_1045))) then (if (not-caught-fail(v_1046) && success?(is-true(success?(1-proj-2-tuple(v_1046))))) then (if not-caught-fail(v_1047) then (if not-caught-fail(v_1049) then (v_1049,v_1047) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {553}let v_1051: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1050),2-proj-3-tuple(v_1045),3-proj-3-tuple(v_1045)))) in
        {554}let v_1052: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1050)) && success?(symmetricstatepack(1-proj-2-tuple(v_1050),2-proj-3-tuple(v_1045),3-proj-3-tuple(v_1045)))) then (if (not-caught-fail(v_1051) && success?(is-true(success?(1-proj-3-tuple(v_1051))))) then symmetricstatepack(1-proj-3-tuple(v_1051),2-proj-3-tuple(v_1051),hash(3-proj-3-tuple(v_1051),2-proj-2-tuple(v_1050))) else fail-any) else fail-any)) in
        {555}let v_1053: bitstring = catch-fail((if (not-caught-fail(v_1045) && success?(is-true(success?(1-proj-3-tuple(v_1045))))) then (if (not-caught-fail(v_1050) && success?(is-true(success?(1-proj-2-tuple(v_1050))))) then (if not-caught-fail(v_1052) then (v_1052,2-proj-2-tuple(v_1050)) else fail-any) else fail-any) else fail-any)) in
        {556}let v_1054: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1053),2-proj-7-tuple(v_1024),v_1027,4-proj-7-tuple(v_1024),5-proj-7-tuple(v_1024),6-proj-7-tuple(v_1024),7-proj-7-tuple(v_1024))) in
        {557}let v_1055: bitstring = catch-fail(concat3(v_1028,2-proj-3-tuple(v_1025),2-proj-2-tuple(v_1053))) in
        {558}let v_1056: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_1053))) in
        {559}let v_1057: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_1056),zero)) in
        {560}let v_1058: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_1056),zero)) in
        {561}let v_1059: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_1056),zero)) in
        {562}let v_1060: bitstring = catch-fail((if success?(2-proj-3-tuple(v_1056)) then (if not-caught-fail(v_1057) then (if not-caught-fail(v_1058) then (if not-caught-fail(v_1059) then (v_1057,v_1058,v_1059) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {563}let v_1061: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_1060)) then cipherstatepack(1-proj-3-tuple(v_1060),minnonce) else fail-any)) in
        {564}let v_1062: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_1060)) then cipherstatepack(2-proj-3-tuple(v_1060),minnonce) else fail-any)) in
        {565}let v_1063: bitstring = catch-fail((if success?(1-proj-2-tuple(v_1053)) then (if (not-caught-fail(v_1056) && success?(is-true(success?(1-proj-3-tuple(v_1056))))) then (if (not-caught-fail(v_1060) && success?(is-true(success?(1-proj-3-tuple(v_1060))))) then (if not-caught-fail(v_1061) then (if not-caught-fail(v_1062) then (1-proj-2-tuple(v_1053),v_1061,v_1062) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {566}let (hs_1064: handshakestate,message_b_1065: bitstring,cs1_1066: cipherstate,cs2_1067: cipherstate) = (if (not-caught-fail(v_1024) && success?(is-true(success?(1-proj-7-tuple(v_1024))))) then (if (not-caught-fail(v_1025) && success?(is-true(success?(1-proj-3-tuple(v_1025))))) then (if not-caught-fail(v_1027) then (if not-caught-fail(v_1028) then (if not-caught-fail(v_1030) then (if not-caught-fail(v_1037) then (if not-caught-fail(v_1044) then (if (not-caught-fail(v_1053) && success?(is-true(success?(1-proj-2-tuple(v_1053))))) then (if not-caught-fail(v_1054) then (if not-caught-fail(v_1055) then (if (not-caught-fail(v_1063) && success?(is-true(success?(1-proj-3-tuple(v_1063))))) then (v_1054,v_1055,2-proj-3-tuple(v_1063),3-proj-3-tuple(v_1063)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {567}event SendMsg(bob,charlie,stagepack_b(sid),msg_b(bob,charlie,sid));
        {568}insert statestore(bob,charlie,sid,statepack_c(hs_1064,cs1_1066,cs2_1067));
        {569}out(pub, message_b_1065)
    ) | (
        {571}!
        {591}get statestore(=bob,=charlie,=sid,statepack_c(hs_1068: handshakestate,cs1_1069: cipherstate,cs2_1070: cipherstate)) in
        {572}let hs_1071: handshakestate = handshakestatesetcs(hs_1068,cs1_1069) in
        {573}in(pub, message_c_1072: bitstring);
        {574}let v_1073: bitstring = catch-fail(handshakestateunpack(hs_1071)) in
        {575}let v_1074: bitstring = catch-fail(deconcat3(message_c_1072)) in
        {576}let v_1075: bool = catch-fail(true) in
        {577}let v_1076: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1073))) in
        {578}let v_1077: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1076))) in
        {579}let v_1078: aead = catch-fail(decrypt(1-proj-2-tuple(v_1077),2-proj-2-tuple(v_1077),3-proj-3-tuple(v_1076),3-proj-3-tuple(v_1074))) in
        {580}let v_1079: bitstring = catch-fail(aeadunpack(v_1078)) in
        {581}let v_1080: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1076))) in
        {582}let v_1081: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1077))) && success?(1-proj-3-tuple(v_1076))) then (if (not-caught-fail(v_1080) && success?(is-true(success?(1-proj-2-tuple(v_1080))))) then cipherstatepack(1-proj-2-tuple(v_1080),increment_nonce(2-proj-2-tuple(v_1077))) else fail-any) else fail-any)) in
        {583}let v_1082: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1074)) && (success?(3-proj-3-tuple(v_1076)) && success?(1-proj-3-tuple(v_1076)))) then (if (not-caught-fail(v_1077) && success?(is-true(success?(1-proj-2-tuple(v_1077))))) then (if not-caught-fail(v_1078) then (if (not-caught-fail(v_1079) && success?(is-true(success?(1-proj-3-tuple(v_1079))))) then (if not-caught-fail(v_1081) then (v_1081,3-proj-3-tuple(v_1079),1-proj-3-tuple(v_1079)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {584}let v_1083: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_1082),2-proj-3-tuple(v_1076),3-proj-3-tuple(v_1076)))) in
        {585}let v_1084: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_1074)) && success?(symmetricstatepack(1-proj-3-tuple(v_1082),2-proj-3-tuple(v_1076),3-proj-3-tuple(v_1076)))) then (if (not-caught-fail(v_1083) && success?(is-true(success?(1-proj-3-tuple(v_1083))))) then symmetricstatepack(1-proj-3-tuple(v_1083),2-proj-3-tuple(v_1083),hash(3-proj-3-tuple(v_1083),3-proj-3-tuple(v_1074))) else fail-any) else fail-any)) in
        {586}let v_1085: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1074)) && success?(1-proj-7-tuple(v_1073))) then (if (not-caught-fail(v_1076) && success?(is-true(success?(1-proj-3-tuple(v_1076))))) then (if (not-caught-fail(v_1082) && success?(is-true(success?(1-proj-3-tuple(v_1082))))) then (if not-caught-fail(v_1084) then (v_1084,2-proj-3-tuple(v_1082),3-proj-3-tuple(v_1082)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {587}let v_1086: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_1085),2-proj-7-tuple(v_1073),3-proj-7-tuple(v_1073),4-proj-7-tuple(v_1073),5-proj-7-tuple(v_1073),6-proj-7-tuple(v_1073),7-proj-7-tuple(v_1073))) in
        {588}let (hs_1087: handshakestate,plaintext_c_1088: bitstring,valid_1089: bool) = (if (not-caught-fail(v_1073) && success?(is-true(success?(1-proj-7-tuple(v_1073))))) then (if (not-caught-fail(v_1074) && success?(is-true(success?(1-proj-3-tuple(v_1074))))) then (if not-caught-fail(v_1075) then (if (not-caught-fail(v_1085) && success?(is-true(success?(1-proj-3-tuple(v_1085))))) then (if (v_1075 && 3-proj-3-tuple(v_1085)) then (if not-caught-fail(v_1086) then (v_1086,2-proj-3-tuple(v_1085),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {589}event RecvMsg(bob,charlie,stagepack_c(sid),plaintext_c_1088);
        {590}insert statestore(bob,charlie,sid,statepack_d(hs_1087,handshakestategetcs(hs_1087),cs2_1070))
    ) | (
        {592}!
        {610}get statestore(=bob,=charlie,=sid,statepack_d(hs_1090: handshakestate,cs1_1091: cipherstate,cs2_1092: cipherstate)) in
        {593}let hs_1093: handshakestate = handshakestatesetcs(hs_1090,cs2_1092) in
        {594}let v_1094: bitstring = catch-fail(handshakestateunpack(hs_1093)) in
        {595}let v_1095: bitstring = catch-fail((empty,empty,empty)) in
        {596}let v_1096: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_1094))) in
        {597}let v_1097: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1096))) in
        {598}let v_1098: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_1097),2-proj-2-tuple(v_1097),3-proj-3-tuple(v_1096),msg_d(bob,charlie,sid))) in
        {599}let v_1099: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_1096))) in
        {600}let v_1100: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_1097))) && success?(1-proj-3-tuple(v_1096))) then (if (not-caught-fail(v_1099) && success?(is-true(success?(1-proj-2-tuple(v_1099))))) then cipherstatepack(1-proj-2-tuple(v_1099),increment_nonce(2-proj-2-tuple(v_1097))) else fail-any) else fail-any)) in
        {601}let v_1101: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_1096)) && success?(1-proj-3-tuple(v_1096))) then (if (not-caught-fail(v_1097) && success?(is-true(success?(1-proj-2-tuple(v_1097))))) then (if not-caught-fail(v_1098) then (if not-caught-fail(v_1100) then (v_1100,v_1098) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {602}let v_1102: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_1101),2-proj-3-tuple(v_1096),3-proj-3-tuple(v_1096)))) in
        {603}let v_1103: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_1101)) && success?(symmetricstatepack(1-proj-2-tuple(v_1101),2-proj-3-tuple(v_1096),3-proj-3-tuple(v_1096)))) then (if (not-caught-fail(v_1102) && success?(is-true(success?(1-proj-3-tuple(v_1102))))) then symmetricstatepack(1-proj-3-tuple(v_1102),2-proj-3-tuple(v_1102),hash(3-proj-3-tuple(v_1102),2-proj-2-tuple(v_1101))) else fail-any) else fail-any)) in
        {604}let v_1104: bitstring = catch-fail((if success?(1-proj-7-tuple(v_1094)) then (if (not-caught-fail(v_1096) && success?(is-true(success?(1-proj-3-tuple(v_1096))))) then (if (not-caught-fail(v_1101) && success?(is-true(success?(1-proj-2-tuple(v_1101))))) then (if not-caught-fail(v_1103) then (v_1103,2-proj-2-tuple(v_1101)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {605}let v_1105: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_1104),2-proj-7-tuple(v_1094),3-proj-7-tuple(v_1094),4-proj-7-tuple(v_1094),5-proj-7-tuple(v_1094),6-proj-7-tuple(v_1094),7-proj-7-tuple(v_1094))) in
        {606}let v_1106: bitstring = catch-fail(concat3(1-proj-3-tuple(v_1095),2-proj-3-tuple(v_1095),2-proj-2-tuple(v_1104))) in
        {607}let (hs_1107: handshakestate,message_d_1108: bitstring) = (if (not-caught-fail(v_1094) && success?(is-true(success?(1-proj-7-tuple(v_1094))))) then (if (not-caught-fail(v_1095) && success?(is-true(success?(1-proj-3-tuple(v_1095))))) then (if (not-caught-fail(v_1104) && success?(is-true(success?(1-proj-2-tuple(v_1104))))) then (if not-caught-fail(v_1105) then (if not-caught-fail(v_1106) then (v_1105,v_1106) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {608}event SendMsg(bob,charlie,stagepack_d(sid),msg_d(bob,charlie,sid));
        {609}out(pub, message_d_1108)
    ) | (
        {611}event LeakS(phase0,bob);
        {612}out(pub, key_s(bob))
    ) | (
        {613}phase 1;
        {614}event LeakS(phase1,bob);
        {615}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1211,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1211,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1211,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1211,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1211,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1211,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1211,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1211,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 191 rules in the queue.
400 rules inserted. The rule base contains 396 rules. 137 rules in the queue.
600 rules inserted. The rule base contains 579 rules. 209 rules in the queue.
800 rules inserted. The rule base contains 768 rules. 675 rules in the queue.
1000 rules inserted. The rule base contains 968 rules. 686 rules in the queue.
1200 rules inserted. The rule base contains 1168 rules. 724 rules in the queue.
1400 rules inserted. The rule base contains 1368 rules. 1131 rules in the queue.
1600 rules inserted. The rule base contains 1568 rules. 1261 rules in the queue.
1800 rules inserted. The rule base contains 1768 rules. 1269 rules in the queue.
2000 rules inserted. The rule base contains 1959 rules. 1231 rules in the queue.
2200 rules inserted. The rule base contains 2141 rules. 1155 rules in the queue.
2400 rules inserted. The rule base contains 2323 rules. 1083 rules in the queue.
2600 rules inserted. The rule base contains 2505 rules. 1007 rules in the queue.
2800 rules inserted. The rule base contains 2606 rules. 944 rules in the queue.
3000 rules inserted. The rule base contains 2628 rules. 918 rules in the queue.
3200 rules inserted. The rule base contains 2767 rules. 955 rules in the queue.
3400 rules inserted. The rule base contains 2963 rules. 1091 rules in the queue.
3600 rules inserted. The rule base contains 3155 rules. 1218 rules in the queue.
3800 rules inserted. The rule base contains 3339 rules. 1206 rules in the queue.
4000 rules inserted. The rule base contains 3539 rules. 1206 rules in the queue.
4200 rules inserted. The rule base contains 3739 rules. 1289 rules in the queue.
4400 rules inserted. The rule base contains 3939 rules. 1370 rules in the queue.
4600 rules inserted. The rule base contains 4139 rules. 1455 rules in the queue.
4800 rules inserted. The rule base contains 4336 rules. 1534 rules in the queue.
5000 rules inserted. The rule base contains 4360 rules. 1525 rules in the queue.
5200 rules inserted. The rule base contains 4443 rules. 1516 rules in the queue.
5400 rules inserted. The rule base contains 4583 rules. 1522 rules in the queue.
5600 rules inserted. The rule base contains 4723 rules. 1520 rules in the queue.
5800 rules inserted. The rule base contains 4860 rules. 1520 rules in the queue.
6000 rules inserted. The rule base contains 5001 rules. 1519 rules in the queue.
6200 rules inserted. The rule base contains 5139 rules. 1520 rules in the queue.
6400 rules inserted. The rule base contains 5325 rules. 1526 rules in the queue.
6600 rules inserted. The rule base contains 5525 rules. 1526 rules in the queue.
6800 rules inserted. The rule base contains 5711 rules. 1535 rules in the queue.
7000 rules inserted. The rule base contains 5906 rules. 1544 rules in the queue.
7200 rules inserted. The rule base contains 6102 rules. 1548 rules in the queue.
7400 rules inserted. The rule base contains 6294 rules. 1554 rules in the queue.
7600 rules inserted. The rule base contains 6486 rules. 1560 rules in the queue.
7800 rules inserted. The rule base contains 6686 rules. 1568 rules in the queue.
8000 rules inserted. The rule base contains 6879 rules. 1573 rules in the queue.
8200 rules inserted. The rule base contains 7033 rules. 1573 rules in the queue.
8400 rules inserted. The rule base contains 7177 rules. 1573 rules in the queue.
8600 rules inserted. The rule base contains 7309 rules. 1560 rules in the queue.
8800 rules inserted. The rule base contains 7444 rules. 1544 rules in the queue.
9000 rules inserted. The rule base contains 7584 rules. 1535 rules in the queue.
9200 rules inserted. The rule base contains 7761 rules. 1548 rules in the queue.
9400 rules inserted. The rule base contains 7947 rules. 1546 rules in the queue.
9600 rules inserted. The rule base contains 8100 rules. 1573 rules in the queue.
9800 rules inserted. The rule base contains 8202 rules. 1609 rules in the queue.
10000 rules inserted. The rule base contains 8312 rules. 1639 rules in the queue.
10200 rules inserted. The rule base contains 8417 rules. 1668 rules in the queue.
10400 rules inserted. The rule base contains 8523 rules. 1705 rules in the queue.
10600 rules inserted. The rule base contains 8641 rules. 1736 rules in the queue.
10800 rules inserted. The rule base contains 8833 rules. 1748 rules in the queue.
11000 rules inserted. The rule base contains 8968 rules. 1800 rules in the queue.
11200 rules inserted. The rule base contains 9105 rules. 1799 rules in the queue.
11400 rules inserted. The rule base contains 9256 rules. 1806 rules in the queue.
11600 rules inserted. The rule base contains 9398 rules. 1792 rules in the queue.
11800 rules inserted. The rule base contains 9542 rules. 1762 rules in the queue.
12000 rules inserted. The rule base contains 9694 rules. 1764 rules in the queue.
12200 rules inserted. The rule base contains 9870 rules. 1775 rules in the queue.
12400 rules inserted. The rule base contains 10039 rules. 1773 rules in the queue.
12600 rules inserted. The rule base contains 10103 rules. 1782 rules in the queue.
12800 rules inserted. The rule base contains 10246 rules. 1783 rules in the queue.
13000 rules inserted. The rule base contains 10400 rules. 1790 rules in the queue.
13200 rules inserted. The rule base contains 10541 rules. 1786 rules in the queue.
13400 rules inserted. The rule base contains 10687 rules. 1777 rules in the queue.
13600 rules inserted. The rule base contains 10837 rules. 1787 rules in the queue.
13800 rules inserted. The rule base contains 11020 rules. 1777 rules in the queue.
14000 rules inserted. The rule base contains 11202 rules. 1761 rules in the queue.
14200 rules inserted. The rule base contains 11248 rules. 1742 rules in the queue.
14400 rules inserted. The rule base contains 11342 rules. 1774 rules in the queue.
14600 rules inserted. The rule base contains 11448 rules. 1752 rules in the queue.
14800 rules inserted. The rule base contains 11539 rules. 1722 rules in the queue.
15000 rules inserted. The rule base contains 11641 rules. 1704 rules in the queue.
15200 rules inserted. The rule base contains 11763 rules. 1732 rules in the queue.
15400 rules inserted. The rule base contains 11872 rules. 1870 rules in the queue.
15600 rules inserted. The rule base contains 11947 rules. 1921 rules in the queue.
15800 rules inserted. The rule base contains 12069 rules. 1902 rules in the queue.
16000 rules inserted. The rule base contains 12163 rules. 1911 rules in the queue.
16200 rules inserted. The rule base contains 12304 rules. 1902 rules in the queue.
16400 rules inserted. The rule base contains 12435 rules. 1888 rules in the queue.
16600 rules inserted. The rule base contains 12572 rules. 1878 rules in the queue.
16800 rules inserted. The rule base contains 12762 rules. 1995 rules in the queue.
17000 rules inserted. The rule base contains 12885 rules. 2066 rules in the queue.
17200 rules inserted. The rule base contains 13005 rules. 2035 rules in the queue.
17400 rules inserted. The rule base contains 13068 rules. 2031 rules in the queue.
17600 rules inserted. The rule base contains 13179 rules. 2004 rules in the queue.
17800 rules inserted. The rule base contains 13275 rules. 1961 rules in the queue.
18000 rules inserted. The rule base contains 13421 rules. 1940 rules in the queue.
18200 rules inserted. The rule base contains 13544 rules. 1908 rules in the queue.
18400 rules inserted. The rule base contains 13648 rules. 1959 rules in the queue.
18600 rules inserted. The rule base contains 13829 rules. 2419 rules in the queue.
18800 rules inserted. The rule base contains 13925 rules. 2650 rules in the queue.
19000 rules inserted. The rule base contains 14069 rules. 3031 rules in the queue.
19200 rules inserted. The rule base contains 14112 rules. 3028 rules in the queue.
19400 rules inserted. The rule base contains 14217 rules. 3004 rules in the queue.
19600 rules inserted. The rule base contains 14337 rules. 2946 rules in the queue.
19800 rules inserted. The rule base contains 14488 rules. 2920 rules in the queue.
20000 rules inserted. The rule base contains 14607 rules. 2952 rules in the queue.
20200 rules inserted. The rule base contains 14607 rules. 2952 rules in the queue.
20400 rules inserted. The rule base contains 14675 rules. 2953 rules in the queue.
20600 rules inserted. The rule base contains 14749 rules. 2944 rules in the queue.
20800 rules inserted. The rule base contains 14822 rules. 2956 rules in the queue.
21000 rules inserted. The rule base contains 14893 rules. 2968 rules in the queue.
21200 rules inserted. The rule base contains 14918 rules. 2961 rules in the queue.
21400 rules inserted. The rule base contains 14989 rules. 3034 rules in the queue.
21600 rules inserted. The rule base contains 15120 rules. 3130 rules in the queue.
21800 rules inserted. The rule base contains 15219 rules. 3187 rules in the queue.
22000 rules inserted. The rule base contains 15312 rules. 3195 rules in the queue.
22200 rules inserted. The rule base contains 15454 rules. 3209 rules in the queue.
22400 rules inserted. The rule base contains 15631 rules. 3210 rules in the queue.
22600 rules inserted. The rule base contains 15819 rules. 3231 rules in the queue.
22800 rules inserted. The rule base contains 15963 rules. 3240 rules in the queue.
23000 rules inserted. The rule base contains 16056 rules. 3363 rules in the queue.
23200 rules inserted. The rule base contains 16146 rules. 3417 rules in the queue.
23400 rules inserted. The rule base contains 16155 rules. 3365 rules in the queue.
23600 rules inserted. The rule base contains 16200 rules. 3371 rules in the queue.
23800 rules inserted. The rule base contains 16208 rules. 3306 rules in the queue.
24000 rules inserted. The rule base contains 16247 rules. 3293 rules in the queue.
24200 rules inserted. The rule base contains 16296 rules. 3378 rules in the queue.
24400 rules inserted. The rule base contains 16333 rules. 3390 rules in the queue.
24600 rules inserted. The rule base contains 16345 rules. 3338 rules in the queue.
24800 rules inserted. The rule base contains 16349 rules. 3266 rules in the queue.
25000 rules inserted. The rule base contains 16434 rules. 3532 rules in the queue.
25200 rules inserted. The rule base contains 16587 rules. 3555 rules in the queue.
25400 rules inserted. The rule base contains 16721 rules. 3566 rules in the queue.
25600 rules inserted. The rule base contains 16904 rules. 3583 rules in the queue.
25800 rules inserted. The rule base contains 17094 rules. 3588 rules in the queue.
26000 rules inserted. The rule base contains 17245 rules. 3586 rules in the queue.
26200 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
26400 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
26600 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
26800 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
27000 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
27200 rules inserted. The rule base contains 17277 rules. 3574 rules in the queue.
27400 rules inserted. The rule base contains 17104 rules. 3549 rules in the queue.
27600 rules inserted. The rule base contains 17104 rules. 3549 rules in the queue.
27800 rules inserted. The rule base contains 17104 rules. 3549 rules in the queue.
28000 rules inserted. The rule base contains 17104 rules. 3549 rules in the queue.
28200 rules inserted. The rule base contains 17239 rules. 3927 rules in the queue.
28400 rules inserted. The rule base contains 17401 rules. 4341 rules in the queue.
28600 rules inserted. The rule base contains 17545 rules. 4863 rules in the queue.
28800 rules inserted. The rule base contains 17727 rules. 4920 rules in the queue.
29000 rules inserted. The rule base contains 17858 rules. 4960 rules in the queue.
29200 rules inserted. The rule base contains 18029 rules. 4989 rules in the queue.
29400 rules inserted. The rule base contains 18210 rules. 5031 rules in the queue.
29600 rules inserted. The rule base contains 18293 rules. 5031 rules in the queue.
29800 rules inserted. The rule base contains 18307 rules. 5005 rules in the queue.
30000 rules inserted. The rule base contains 18323 rules. 4981 rules in the queue.
30200 rules inserted. The rule base contains 18404 rules. 4886 rules in the queue.
30400 rules inserted. The rule base contains 18435 rules. 4845 rules in the queue.
30600 rules inserted. The rule base contains 18489 rules. 4789 rules in the queue.
30800 rules inserted. The rule base contains 18262 rules. 4756 rules in the queue.
31000 rules inserted. The rule base contains 18280 rules. 4723 rules in the queue.
31200 rules inserted. The rule base contains 18301 rules. 4687 rules in the queue.
31400 rules inserted. The rule base contains 18317 rules. 4663 rules in the queue.
31600 rules inserted. The rule base contains 18413 rules. 4705 rules in the queue.
31800 rules inserted. The rule base contains 18600 rules. 4873 rules in the queue.
32000 rules inserted. The rule base contains 18788 rules. 5028 rules in the queue.
32200 rules inserted. The rule base contains 18976 rules. 5175 rules in the queue.
32400 rules inserted. The rule base contains 19156 rules. 5289 rules in the queue.
32600 rules inserted. The rule base contains 19337 rules. 5430 rules in the queue.
32800 rules inserted. The rule base contains 19530 rules. 5727 rules in the queue.
33000 rules inserted. The rule base contains 19722 rules. 5979 rules in the queue.
33200 rules inserted. The rule base contains 19910 rules. 6390 rules in the queue.
33400 rules inserted. The rule base contains 20064 rules. 6773 rules in the queue.
33600 rules inserted. The rule base contains 20207 rules. 6789 rules in the queue.
33800 rules inserted. The rule base contains 20184 rules. 6910 rules in the queue.
34000 rules inserted. The rule base contains 20339 rules. 6891 rules in the queue.
34200 rules inserted. The rule base contains 20503 rules. 6878 rules in the queue.
34400 rules inserted. The rule base contains 20575 rules. 6845 rules in the queue.
34600 rules inserted. The rule base contains 20667 rules. 6753 rules in the queue.
34800 rules inserted. The rule base contains 20784 rules. 6636 rules in the queue.
35000 rules inserted. The rule base contains 20903 rules. 6517 rules in the queue.
35200 rules inserted. The rule base contains 21019 rules. 6401 rules in the queue.
35400 rules inserted. The rule base contains 21103 rules. 6379 rules in the queue.
35600 rules inserted. The rule base contains 21205 rules. 6277 rules in the queue.
35800 rules inserted. The rule base contains 21303 rules. 6179 rules in the queue.
36000 rules inserted. The rule base contains 21434 rules. 6087 rules in the queue.
36200 rules inserted. The rule base contains 21614 rules. 6062 rules in the queue.
36400 rules inserted. The rule base contains 21802 rules. 5980 rules in the queue.
36600 rules inserted. The rule base contains 21982 rules. 5907 rules in the queue.
36800 rules inserted. The rule base contains 22162 rules. 5809 rules in the queue.
37000 rules inserted. The rule base contains 22350 rules. 5725 rules in the queue.
37200 rules inserted. The rule base contains 22534 rules. 5807 rules in the queue.
37400 rules inserted. The rule base contains 22734 rules. 6227 rules in the queue.
37600 rules inserted. The rule base contains 22934 rules. 6662 rules in the queue.
37800 rules inserted. The rule base contains 23134 rules. 7096 rules in the queue.
38000 rules inserted. The rule base contains 23319 rules. 6992 rules in the queue.
38200 rules inserted. The rule base contains 23506 rules. 6986 rules in the queue.
38400 rules inserted. The rule base contains 23690 rules. 6888 rules in the queue.
38600 rules inserted. The rule base contains 23874 rules. 6770 rules in the queue.
38800 rules inserted. The rule base contains 24060 rules. 6762 rules in the queue.
39000 rules inserted. The rule base contains 24241 rules. 6835 rules in the queue.
39200 rules inserted. The rule base contains 24420 rules. 6946 rules in the queue.
39400 rules inserted. The rule base contains 24606 rules. 7267 rules in the queue.
39600 rules inserted. The rule base contains 24801 rules. 7697 rules in the queue.
39800 rules inserted. The rule base contains 24990 rules. 7826 rules in the queue.
40000 rules inserted. The rule base contains 25140 rules. 7914 rules in the queue.
40200 rules inserted. The rule base contains 25282 rules. 8007 rules in the queue.
40400 rules inserted. The rule base contains 25079 rules. 8371 rules in the queue.
40600 rules inserted. The rule base contains 25087 rules. 8468 rules in the queue.
40800 rules inserted. The rule base contains 25243 rules. 8429 rules in the queue.
41000 rules inserted. The rule base contains 25377 rules. 8393 rules in the queue.
41200 rules inserted. The rule base contains 25469 rules. 8340 rules in the queue.
41400 rules inserted. The rule base contains 25524 rules. 8312 rules in the queue.
41600 rules inserted. The rule base contains 25616 rules. 8499 rules in the queue.
41800 rules inserted. The rule base contains 25683 rules. 8423 rules in the queue.
42000 rules inserted. The rule base contains 25815 rules. 8363 rules in the queue.
42200 rules inserted. The rule base contains 26015 rules. 8983 rules in the queue.
42400 rules inserted. The rule base contains 26213 rules. 9005 rules in the queue.
42600 rules inserted. The rule base contains 26413 rules. 9042 rules in the queue.
42800 rules inserted. The rule base contains 26606 rules. 9012 rules in the queue.
43000 rules inserted. The rule base contains 26789 rules. 8895 rules in the queue.
43200 rules inserted. The rule base contains 26975 rules. 8862 rules in the queue.
43400 rules inserted. The rule base contains 27162 rules. 8790 rules in the queue.
43600 rules inserted. The rule base contains 27347 rules. 8695 rules in the queue.
43800 rules inserted. The rule base contains 27533 rules. 8690 rules in the queue.
44000 rules inserted. The rule base contains 27717 rules. 8574 rules in the queue.
44200 rules inserted. The rule base contains 27904 rules. 8568 rules in the queue.
44400 rules inserted. The rule base contains 28089 rules. 8473 rules in the queue.
44600 rules inserted. The rule base contains 28272 rules. 8356 rules in the queue.
44800 rules inserted. The rule base contains 28459 rules. 8353 rules in the queue.
45000 rules inserted. The rule base contains 28659 rules. 8377 rules in the queue.
45200 rules inserted. The rule base contains 28851 rules. 8349 rules in the queue.
45400 rules inserted. The rule base contains 29047 rules. 8333 rules in the queue.
45600 rules inserted. The rule base contains 29243 rules. 8965 rules in the queue.
45800 rules inserted. The rule base contains 29433 rules. 8887 rules in the queue.
46000 rules inserted. The rule base contains 29618 rules. 8798 rules in the queue.
46200 rules inserted. The rule base contains 29803 rules. 8712 rules in the queue.
46400 rules inserted. The rule base contains 29995 rules. 8849 rules in the queue.
46600 rules inserted. The rule base contains 30184 rules. 8978 rules in the queue.
46800 rules inserted. The rule base contains 30375 rules. 9189 rules in the queue.
47000 rules inserted. The rule base contains 30564 rules. 9253 rules in the queue.
47200 rules inserted. The rule base contains 30747 rules. 9144 rules in the queue.
47400 rules inserted. The rule base contains 30933 rules. 9058 rules in the queue.
47600 rules inserted. The rule base contains 31109 rules. 9001 rules in the queue.
47800 rules inserted. The rule base contains 31276 rules. 9050 rules in the queue.
48000 rules inserted. The rule base contains 31435 rules. 9063 rules in the queue.
48200 rules inserted. The rule base contains 31587 rules. 9047 rules in the queue.
48400 rules inserted. The rule base contains 31592 rules. 9173 rules in the queue.
48600 rules inserted. The rule base contains 31618 rules. 9194 rules in the queue.
48800 rules inserted. The rule base contains 31685 rules. 9108 rules in the queue.
49000 rules inserted. The rule base contains 31878 rules. 9327 rules in the queue.
49200 rules inserted. The rule base contains 32050 rules. 9368 rules in the queue.
49400 rules inserted. The rule base contains 32193 rules. 9509 rules in the queue.
49600 rules inserted. The rule base contains 32292 rules. 9411 rules in the queue.
49800 rules inserted. The rule base contains 32394 rules. 9358 rules in the queue.
50000 rules inserted. The rule base contains 32564 rules. 9458 rules in the queue.
50200 rules inserted. The rule base contains 32597 rules. 9643 rules in the queue.
50400 rules inserted. The rule base contains 32748 rules. 9573 rules in the queue.
50600 rules inserted. The rule base contains 32900 rules. 9470 rules in the queue.
50800 rules inserted. The rule base contains 33048 rules. 9405 rules in the queue.
51000 rules inserted. The rule base contains 33172 rules. 9344 rules in the queue.
51200 rules inserted. The rule base contains 33351 rules. 9380 rules in the queue.
51400 rules inserted. The rule base contains 33521 rules. 9394 rules in the queue.
51600 rules inserted. The rule base contains 33703 rules. 9433 rules in the queue.
51800 rules inserted. The rule base contains 33885 rules. 9454 rules in the queue.
52000 rules inserted. The rule base contains 34068 rules. 9407 rules in the queue.
52200 rules inserted. The rule base contains 34265 rules. 9438 rules in the queue.
52400 rules inserted. The rule base contains 34445 rules. 9391 rules in the queue.
52600 rules inserted. The rule base contains 34638 rules. 9347 rules in the queue.
52800 rules inserted. The rule base contains 34825 rules. 9378 rules in the queue.
53000 rules inserted. The rule base contains 35017 rules. 9326 rules in the queue.
53200 rules inserted. The rule base contains 35205 rules. 9360 rules in the queue.
53400 rules inserted. The rule base contains 35393 rules. 9386 rules in the queue.
53600 rules inserted. The rule base contains 35593 rules. 9423 rules in the queue.
53800 rules inserted. The rule base contains 35785 rules. 9381 rules in the queue.
54000 rules inserted. The rule base contains 35970 rules. 9259 rules in the queue.
54200 rules inserted. The rule base contains 36057 rules. 9222 rules in the queue.
54400 rules inserted. The rule base contains 36169 rules. 9122 rules in the queue.
54600 rules inserted. The rule base contains 36345 rules. 9153 rules in the queue.
54800 rules inserted. The rule base contains 36533 rules. 9187 rules in the queue.
55000 rules inserted. The rule base contains 36718 rules. 9088 rules in the queue.
55200 rules inserted. The rule base contains 36902 rules. 8992 rules in the queue.
55400 rules inserted. The rule base contains 37087 rules. 8893 rules in the queue.
55600 rules inserted. The rule base contains 37271 rules. 8797 rules in the queue.
55800 rules inserted. The rule base contains 37457 rules. 8715 rules in the queue.
56000 rules inserted. The rule base contains 37639 rules. 8600 rules in the queue.
56200 rules inserted. The rule base contains 37837 rules. 8621 rules in the queue.
56400 rules inserted. The rule base contains 38024 rules. 8645 rules in the queue.
56600 rules inserted. The rule base contains 38141 rules. 8624 rules in the queue.
56800 rules inserted. The rule base contains 38279 rules. 8609 rules in the queue.
57000 rules inserted. The rule base contains 38395 rules. 8578 rules in the queue.
57200 rules inserted. The rule base contains 38533 rules. 8901 rules in the queue.
57400 rules inserted. The rule base contains 38604 rules. 8844 rules in the queue.
