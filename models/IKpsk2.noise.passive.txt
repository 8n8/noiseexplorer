File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 276, character 7 - line 276, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 277, character 7 - line 277, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 277, character 36 - line 277, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 307, character 6 - line 307, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 312, character 6 - line 312, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 318, character 6 - line 318, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.passive.pv", line 319, character 6 - line 319, character 7:
Warning: identifier ne rebound.
File "IKpsk2.noise.passive.pv", line 320, character 6 - line 320, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 321, character 6 - line 321, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 322, character 6 - line 322, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 323, character 6 - line 323, character 6:
Warning: identifier s rebound.
File "IKpsk2.noise.passive.pv", line 324, character 7 - line 324, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 324, character 26 - line 324, character 36:
Warning: identifier ciphertext1 rebound.
File "IKpsk2.noise.passive.pv", line 325, character 6 - line 325, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 326, character 7 - line 326, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 326, character 26 - line 326, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 327, character 6 - line 327, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 334, character 6 - line 334, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.passive.pv", line 335, character 6 - line 335, character 7:
Warning: identifier ne rebound.
File "IKpsk2.noise.passive.pv", line 336, character 6 - line 336, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 337, character 6 - line 337, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 338, character 6 - line 338, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 339, character 6 - line 339, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 340, character 6 - line 340, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 341, character 7 - line 341, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 341, character 26 - line 341, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 342, character 6 - line 342, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 349, character 7 - line 349, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 349, character 26 - line 349, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 350, character 6 - line 350, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 357, character 7 - line 357, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 357, character 26 - line 357, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 358, character 6 - line 358, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 367, character 6 - line 367, character 7:
Warning: identifier re rebound.
File "IKpsk2.noise.passive.pv", line 368, character 6 - line 368, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 369, character 6 - line 369, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 370, character 6 - line 370, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 371, character 7 - line 371, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 371, character 48 - line 371, character 53:
Warning: identifier valid1 rebound.
File "IKpsk2.noise.passive.pv", line 372, character 6 - line 372, character 7:
Warning: identifier rs rebound.
File "IKpsk2.noise.passive.pv", line 373, character 6 - line 373, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 374, character 7 - line 374, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 376, character 7 - line 376, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 384, character 6 - line 384, character 7:
Warning: identifier re rebound.
File "IKpsk2.noise.passive.pv", line 385, character 6 - line 385, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 386, character 6 - line 386, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 387, character 6 - line 387, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 388, character 6 - line 388, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 389, character 6 - line 389, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 390, character 7 - line 390, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 392, character 7 - line 392, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 400, character 7 - line 400, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 402, character 7 - line 402, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 410, character 7 - line 410, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 412, character 7 - line 412, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 612, character 8 - line 612, character 10:
Warning: identifier hsa rebound.
File "IKpsk2.noise.passive.pv", line 410, character 7 - line 410, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 412, character 7 - line 412, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 604, character 8 - line 604, character 10:
Warning: identifier hsa rebound.
File "IKpsk2.noise.passive.pv", line 349, character 7 - line 349, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 349, character 26 - line 349, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 350, character 6 - line 350, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 597, character 8 - line 597, character 10:
Warning: identifier hsa rebound.
File "IKpsk2.noise.passive.pv", line 384, character 6 - line 384, character 7:
Warning: identifier re rebound.
File "IKpsk2.noise.passive.pv", line 385, character 6 - line 385, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 386, character 6 - line 386, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 387, character 6 - line 387, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 388, character 6 - line 388, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 389, character 6 - line 389, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 390, character 7 - line 390, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 392, character 7 - line 392, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 276, character 7 - line 276, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 277, character 7 - line 277, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 277, character 36 - line 277, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 589, character 8 - line 589, character 10:
Warning: identifier hsa rebound.
File "IKpsk2.noise.passive.pv", line 318, character 6 - line 318, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.passive.pv", line 319, character 6 - line 319, character 7:
Warning: identifier ne rebound.
File "IKpsk2.noise.passive.pv", line 320, character 6 - line 320, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 321, character 6 - line 321, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 322, character 6 - line 322, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 323, character 6 - line 323, character 6:
Warning: identifier s rebound.
File "IKpsk2.noise.passive.pv", line 324, character 7 - line 324, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 324, character 26 - line 324, character 36:
Warning: identifier ciphertext1 rebound.
File "IKpsk2.noise.passive.pv", line 325, character 6 - line 325, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 326, character 7 - line 326, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 326, character 26 - line 326, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 327, character 6 - line 327, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 307, character 6 - line 307, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 662, character 8 - line 662, character 10:
Warning: identifier hsb rebound.
File "IKpsk2.noise.passive.pv", line 357, character 7 - line 357, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 357, character 26 - line 357, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 358, character 6 - line 358, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 655, character 8 - line 655, character 10:
Warning: identifier hsb rebound.
File "IKpsk2.noise.passive.pv", line 400, character 7 - line 400, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 402, character 7 - line 402, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 647, character 8 - line 647, character 10:
Warning: identifier hsb rebound.
File "IKpsk2.noise.passive.pv", line 334, character 6 - line 334, character 6:
Warning: identifier e rebound.
File "IKpsk2.noise.passive.pv", line 335, character 6 - line 335, character 7:
Warning: identifier ne rebound.
File "IKpsk2.noise.passive.pv", line 336, character 6 - line 336, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 337, character 6 - line 337, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 338, character 6 - line 338, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 339, character 6 - line 339, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 340, character 6 - line 340, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 341, character 7 - line 341, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 341, character 26 - line 341, character 36:
Warning: identifier ciphertext2 rebound.
File "IKpsk2.noise.passive.pv", line 342, character 6 - line 342, character 7:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 276, character 7 - line 276, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 277, character 7 - line 277, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 277, character 36 - line 277, character 36:
Warning: identifier h rebound.
File "IKpsk2.noise.passive.pv", line 286, character 7 - line 286, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 287, character 6 - line 287, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 640, character 8 - line 640, character 10:
Warning: identifier hsb rebound.
File "IKpsk2.noise.passive.pv", line 367, character 6 - line 367, character 7:
Warning: identifier re rebound.
File "IKpsk2.noise.passive.pv", line 368, character 6 - line 368, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 369, character 6 - line 369, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 370, character 6 - line 370, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 371, character 7 - line 371, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 371, character 48 - line 371, character 53:
Warning: identifier valid1 rebound.
File "IKpsk2.noise.passive.pv", line 372, character 6 - line 372, character 7:
Warning: identifier rs rebound.
File "IKpsk2.noise.passive.pv", line 373, character 6 - line 373, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 374, character 7 - line 374, character 8:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 376, character 7 - line 376, character 8:
Warning: identifier hs rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 267, character 7 - line 267, character 8:
Warning: identifier ck rebound.
File "IKpsk2.noise.passive.pv", line 292, character 7 - line 292, character 8:
Warning: identifier cs rebound.
File "IKpsk2.noise.passive.pv", line 293, character 6 - line 293, character 7:
Warning: identifier ss rebound.
File "IKpsk2.noise.passive.pv", line 312, character 6 - line 312, character 7:
Warning: identifier ss rebound.
Linear part:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Completing equations...
Completed equations:
dhexp(b_49,dhexp(a_48,g)) = dhexp(a_48,dhexp(b_49,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}!
(
    {2}let s_634: keypair = keypairpack(empty,empty) in
    {3}let v_635: key = catch-fail(dhexp(key_0,g)) in
    {4}out(pub, getpublickey((if not-caught-fail(v_635) then keypairpack(v_635,key_0) else fail-any)));
    (
        {5}let e_636: keypair = keypairpack(empty,empty) in
        {6}let v_637: key = catch-fail(dhexp(key_1,g)) in
        {7}let rs_638: key = getpublickey((if not-caught-fail(v_637) then keypairpack(v_637,key_1) else fail-any)) in
        {8}let re_639: key = empty in
        {9}let v_640: bitstring = catch-fail(hash(somename,empty)) in
        {10}let v_641: key = catch-fail(v_640) in
        {11}let v_642: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {12}let v_643: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_640) then (if not-caught-fail(v_641) then (if not-caught-fail(v_642) then symmetricstatepack(v_642,v_641,v_640) else fail-any) else fail-any) else fail-any))) in
        {13}let v_644: symmetricstate = catch-fail((if success?((if not-caught-fail(v_640) then (if not-caught-fail(v_641) then (if not-caught-fail(v_642) then symmetricstatepack(v_642,v_641,v_640) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_643) && success?(is-true(success?(1-proj-3-tuple(v_643))))) then symmetricstatepack(1-proj-3-tuple(v_643),2-proj-3-tuple(v_643),hash(3-proj-3-tuple(v_643),empty)) else fail-any) else fail-any)) in
        {14}let v_645: bitstring = catch-fail(symmetricstateunpack(v_644)) in
        {15}let v_646: symmetricstate = catch-fail((if (not-caught-fail(v_645) && success?(is-true(success?(1-proj-3-tuple(v_645))))) then symmetricstatepack(1-proj-3-tuple(v_645),2-proj-3-tuple(v_645),hash(3-proj-3-tuple(v_645),rs_638)) else fail-any)) in
        {16}let hsa: handshakestate = (if not-caught-fail(v_644) then (if not-caught-fail(v_646) then handshakestatepack(v_646,s_634,e_636,rs_638,re_639,key_psk,true) else fail-any) else fail-any) in
        {17}insert statestore(alice,statepack_a(hsa))
    ) | (
        {71}get statestore(=alice,statepack_a(hsa_647: handshakestate)) in
        {18}let v_648: bitstring = catch-fail(handshakestateunpack(hsa_647)) in
        {19}let v_649: bitstring = catch-fail((empty,empty,empty)) in
        {20}let v_650: key = catch-fail(dhexp(key_2,g)) in
        {21}let v_651: keypair = catch-fail((if not-caught-fail(v_650) then keypairpack(v_650,key_2) else fail-any)) in
        {22}let v_652: bitstring = catch-fail(getpublickey(v_651)) in
        {23}let v_653: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_648))) in
        {24}let v_654: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_648)) then (if (not-caught-fail(v_653) && success?(is-true(success?(1-proj-3-tuple(v_653))))) then symmetricstatepack(1-proj-3-tuple(v_653),2-proj-3-tuple(v_653),hash(3-proj-3-tuple(v_653),v_652)) else fail-any) else fail-any)) in
        {25}let v_655: bitstring = catch-fail(symmetricstateunpack(v_654)) in
        {26}let v_656: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_655),getpublickey(v_651))) in
        {27}let v_657: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_655),getpublickey(v_651))) in
        {28}let v_658: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_655),getpublickey(v_651))) in
        {29}let v_659: bitstring = catch-fail((if (success?(getpublickey(v_651)) && success?(2-proj-3-tuple(v_655))) then (if not-caught-fail(v_656) then (if not-caught-fail(v_657) then (if not-caught-fail(v_658) then (v_656,v_657,v_658) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {30}let v_660: symmetricstate = catch-fail((if success?(getpublickey(v_651)) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-3-tuple(v_655))))) then (if (not-caught-fail(v_659) && success?(is-true(success?(1-proj-3-tuple(v_659))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_659)) then cipherstatepack(2-proj-3-tuple(v_659),minnonce) else fail-any),1-proj-3-tuple(v_659),3-proj-3-tuple(v_655)) else fail-any) else fail-any) else fail-any)) in
        {31}let v_661: bitstring = catch-fail(keypairunpack(v_651)) in
        {32}let v_662: bitstring = catch-fail(symmetricstateunpack(v_660)) in
        {33}let v_663: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_662),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-2-tuple(v_661))))) then dhexp(2-proj-2-tuple(v_661),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {34}let v_664: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_662),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-2-tuple(v_661))))) then dhexp(2-proj-2-tuple(v_661),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {35}let v_665: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_662),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-2-tuple(v_661))))) then dhexp(2-proj-2-tuple(v_661),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {36}let v_666: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-2-tuple(v_661))))) then dhexp(2-proj-2-tuple(v_661),4-proj-7-tuple(v_648)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_662))) then (if not-caught-fail(v_663) then (if not-caught-fail(v_664) then (if not-caught-fail(v_665) then (v_663,v_664,v_665) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {37}let v_667: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_661) && success?(is-true(success?(1-proj-2-tuple(v_661))))) then dhexp(2-proj-2-tuple(v_661),4-proj-7-tuple(v_648)) else fail-any) else fail-any)) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-3-tuple(v_662))))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-3-tuple(v_666))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_666)) then cipherstatepack(2-proj-3-tuple(v_666),minnonce) else fail-any),1-proj-3-tuple(v_666),3-proj-3-tuple(v_662)) else fail-any) else fail-any) else fail-any)) in
        {38}let v_668: key = catch-fail(dhexp(key_0,g)) in
        {39}let v_669: keypair = catch-fail((if not-caught-fail(v_668) then keypairpack(v_668,key_0) else fail-any)) in
        {40}let v_670: bitstring = catch-fail(symmetricstateunpack(v_667)) in
        {41}let v_671: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {42}let v_672: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_671),2-proj-2-tuple(v_671),3-proj-3-tuple(v_670),getpublickey(v_669))) in
        {43}let v_673: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_670))) in
        {44}let v_674: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_671))) && success?(1-proj-3-tuple(v_670))) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-2-tuple(v_673))))) then cipherstatepack(1-proj-2-tuple(v_673),increment_nonce(2-proj-2-tuple(v_671))) else fail-any) else fail-any)) in
        {45}let v_675: bitstring = catch-fail((if (success?(getpublickey(v_669)) && (success?(3-proj-3-tuple(v_670)) && success?(1-proj-3-tuple(v_670)))) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-2-tuple(v_671))))) then (if not-caught-fail(v_672) then (if not-caught-fail(v_674) then (v_674,v_672) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {46}let v_676: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) in
        {47}let v_677: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_675)) && success?(symmetricstatepack(1-proj-2-tuple(v_675),2-proj-3-tuple(v_670),3-proj-3-tuple(v_670)))) then (if (not-caught-fail(v_676) && success?(is-true(success?(1-proj-3-tuple(v_676))))) then symmetricstatepack(1-proj-3-tuple(v_676),2-proj-3-tuple(v_676),hash(3-proj-3-tuple(v_676),2-proj-2-tuple(v_675))) else fail-any) else fail-any)) in
        {48}let v_678: bitstring = catch-fail((if success?(getpublickey(v_669)) then (if (not-caught-fail(v_670) && success?(is-true(success?(1-proj-3-tuple(v_670))))) then (if (not-caught-fail(v_675) && success?(is-true(success?(1-proj-2-tuple(v_675))))) then (if not-caught-fail(v_677) then (v_677,2-proj-2-tuple(v_675)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {49}let v_679: bitstring = catch-fail(keypairunpack(v_669)) in
        {50}let v_680: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_678))) in
        {51}let v_681: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_680),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-2-tuple(v_679))))) then dhexp(2-proj-2-tuple(v_679),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {52}let v_682: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_680),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-2-tuple(v_679))))) then dhexp(2-proj-2-tuple(v_679),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {53}let v_683: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_680),(if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-2-tuple(v_679))))) then dhexp(2-proj-2-tuple(v_679),4-proj-7-tuple(v_648)) else fail-any) else fail-any))) in
        {54}let v_684: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-2-tuple(v_679))))) then dhexp(2-proj-2-tuple(v_679),4-proj-7-tuple(v_648)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_680))) then (if not-caught-fail(v_681) then (if not-caught-fail(v_682) then (if not-caught-fail(v_683) then (v_681,v_682,v_683) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {55}let v_685: symmetricstate = catch-fail((if (success?((if success?(4-proj-7-tuple(v_648)) then (if (not-caught-fail(v_679) && success?(is-true(success?(1-proj-2-tuple(v_679))))) then dhexp(2-proj-2-tuple(v_679),4-proj-7-tuple(v_648)) else fail-any) else fail-any)) && success?(1-proj-2-tuple(v_678))) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-3-tuple(v_680))))) then (if (not-caught-fail(v_684) && success?(is-true(success?(1-proj-3-tuple(v_684))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_684)) then cipherstatepack(2-proj-3-tuple(v_684),minnonce) else fail-any),1-proj-3-tuple(v_684),3-proj-3-tuple(v_680)) else fail-any) else fail-any) else fail-any)) in
        {56}let v_686: bitstring = catch-fail(symmetricstateunpack(v_685)) in
        {57}let v_687: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_686))) in
        {58}let v_688: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_687),2-proj-2-tuple(v_687),3-proj-3-tuple(v_686),msg_a)) in
        {59}let v_689: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_686))) in
        {60}let v_690: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_687))) && success?(1-proj-3-tuple(v_686))) then (if (not-caught-fail(v_689) && success?(is-true(success?(1-proj-2-tuple(v_689))))) then cipherstatepack(1-proj-2-tuple(v_689),increment_nonce(2-proj-2-tuple(v_687))) else fail-any) else fail-any)) in
        {61}let v_691: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_686)) && success?(1-proj-3-tuple(v_686))) then (if (not-caught-fail(v_687) && success?(is-true(success?(1-proj-2-tuple(v_687))))) then (if not-caught-fail(v_688) then (if not-caught-fail(v_690) then (v_690,v_688) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {62}let v_692: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_691),2-proj-3-tuple(v_686),3-proj-3-tuple(v_686)))) in
        {63}let v_693: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_691)) && success?(symmetricstatepack(1-proj-2-tuple(v_691),2-proj-3-tuple(v_686),3-proj-3-tuple(v_686)))) then (if (not-caught-fail(v_692) && success?(is-true(success?(1-proj-3-tuple(v_692))))) then symmetricstatepack(1-proj-3-tuple(v_692),2-proj-3-tuple(v_692),hash(3-proj-3-tuple(v_692),2-proj-2-tuple(v_691))) else fail-any) else fail-any)) in
        {64}let v_694: bitstring = catch-fail((if (not-caught-fail(v_686) && success?(is-true(success?(1-proj-3-tuple(v_686))))) then (if (not-caught-fail(v_691) && success?(is-true(success?(1-proj-2-tuple(v_691))))) then (if not-caught-fail(v_693) then (v_693,2-proj-2-tuple(v_691)) else fail-any) else fail-any) else fail-any)) in
        {65}let v_695: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_694),v_669,v_651,4-proj-7-tuple(v_648),5-proj-7-tuple(v_648),6-proj-7-tuple(v_648),7-proj-7-tuple(v_648))) in
        {66}let v_696: bitstring = catch-fail(concat3(v_652,2-proj-2-tuple(v_678),2-proj-2-tuple(v_694))) in
        {67}let (hsa_697: handshakestate,re_698: key,message_a: bitstring) = (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-7-tuple(v_648))))) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-3-tuple(v_649))))) then (if not-caught-fail(v_651) then (if not-caught-fail(v_652) then (if not-caught-fail(v_654) then (if not-caught-fail(v_660) then (if not-caught-fail(v_667) then (if not-caught-fail(v_669) then (if (not-caught-fail(v_678) && success?(is-true(success?(1-proj-2-tuple(v_678))))) then (if not-caught-fail(v_685) then (if (not-caught-fail(v_694) && success?(is-true(success?(1-proj-2-tuple(v_694))))) then (if not-caught-fail(v_695) then (if not-caught-fail(v_696) then (v_695,5-proj-7-tuple(v_648),v_696) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {68}event SendMsg(alice,bob,stage_a,msg_a,true);
        {69}insert statestore(alice,statepack_b(hsa_697));
        {70}out(pub, message_a)
    ) | (
        {121}get statestore(=alice,statepack_b(hsa_699: handshakestate)) in
        {72}in(pub, message_b: bitstring);
        {73}let v_700: bitstring = catch-fail(handshakestateunpack(hsa_699)) in
        {74}let v_701: bitstring = catch-fail(deconcat3(message_b)) in
        {75}let v_702: bool = catch-fail(true) in
        {76}let v_703: key = catch-fail(1-proj-3-tuple(v_701)) in
        {77}let v_704: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_700))) in
        {78}let v_705: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_700)) then (if (not-caught-fail(v_704) && success?(is-true(success?(1-proj-3-tuple(v_704))))) then symmetricstatepack(1-proj-3-tuple(v_704),2-proj-3-tuple(v_704),hash(3-proj-3-tuple(v_704),v_703)) else fail-any) else fail-any)) in
        {79}let v_706: bitstring = catch-fail(symmetricstateunpack(v_705)) in
        {80}let v_707: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_706),v_703)) in
        {81}let v_708: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_706),v_703)) in
        {82}let v_709: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_706),v_703)) in
        {83}let v_710: bitstring = catch-fail((if success?(2-proj-3-tuple(v_706)) then (if not-caught-fail(v_707) then (if not-caught-fail(v_708) then (if not-caught-fail(v_709) then (v_707,v_708,v_709) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {84}let v_711: symmetricstate = catch-fail((if (not-caught-fail(v_706) && success?(is-true(success?(1-proj-3-tuple(v_706))))) then (if (not-caught-fail(v_710) && success?(is-true(success?(1-proj-3-tuple(v_710))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_710)) then cipherstatepack(2-proj-3-tuple(v_710),minnonce) else fail-any),1-proj-3-tuple(v_710),3-proj-3-tuple(v_706)) else fail-any) else fail-any)) in
        {85}let v_712: bitstring = catch-fail(keypairunpack(3-proj-7-tuple(v_700))) in
        {86}let v_713: bitstring = catch-fail(symmetricstateunpack(v_711)) in
        {87}let v_714: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_713),(if success?(3-proj-7-tuple(v_700)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-2-tuple(v_712))))) then dhexp(2-proj-2-tuple(v_712),v_703) else fail-any) else fail-any))) in
        {88}let v_715: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_713),(if success?(3-proj-7-tuple(v_700)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-2-tuple(v_712))))) then dhexp(2-proj-2-tuple(v_712),v_703) else fail-any) else fail-any))) in
        {89}let v_716: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_713),(if success?(3-proj-7-tuple(v_700)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-2-tuple(v_712))))) then dhexp(2-proj-2-tuple(v_712),v_703) else fail-any) else fail-any))) in
        {90}let v_717: bitstring = catch-fail((if (success?((if success?(3-proj-7-tuple(v_700)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-2-tuple(v_712))))) then dhexp(2-proj-2-tuple(v_712),v_703) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_713))) then (if not-caught-fail(v_714) then (if not-caught-fail(v_715) then (if not-caught-fail(v_716) then (v_714,v_715,v_716) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {91}let v_718: symmetricstate = catch-fail((if success?((if success?(3-proj-7-tuple(v_700)) then (if (not-caught-fail(v_712) && success?(is-true(success?(1-proj-2-tuple(v_712))))) then dhexp(2-proj-2-tuple(v_712),v_703) else fail-any) else fail-any)) then (if (not-caught-fail(v_713) && success?(is-true(success?(1-proj-3-tuple(v_713))))) then (if (not-caught-fail(v_717) && success?(is-true(success?(1-proj-3-tuple(v_717))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_717)) then cipherstatepack(2-proj-3-tuple(v_717),minnonce) else fail-any),1-proj-3-tuple(v_717),3-proj-3-tuple(v_713)) else fail-any) else fail-any) else fail-any)) in
        {92}let v_719: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_700))) in
        {93}let v_720: bitstring = catch-fail(symmetricstateunpack(v_718)) in
        {94}let v_721: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_720),(if success?(2-proj-7-tuple(v_700)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then dhexp(2-proj-2-tuple(v_719),v_703) else fail-any) else fail-any))) in
        {95}let v_722: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_720),(if success?(2-proj-7-tuple(v_700)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then dhexp(2-proj-2-tuple(v_719),v_703) else fail-any) else fail-any))) in
        {96}let v_723: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_720),(if success?(2-proj-7-tuple(v_700)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then dhexp(2-proj-2-tuple(v_719),v_703) else fail-any) else fail-any))) in
        {97}let v_724: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_700)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then dhexp(2-proj-2-tuple(v_719),v_703) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_720))) then (if not-caught-fail(v_721) then (if not-caught-fail(v_722) then (if not-caught-fail(v_723) then (v_721,v_722,v_723) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {98}let v_725: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_700)) then (if (not-caught-fail(v_719) && success?(is-true(success?(1-proj-2-tuple(v_719))))) then dhexp(2-proj-2-tuple(v_719),v_703) else fail-any) else fail-any)) then (if (not-caught-fail(v_720) && success?(is-true(success?(1-proj-3-tuple(v_720))))) then (if (not-caught-fail(v_724) && success?(is-true(success?(1-proj-3-tuple(v_724))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_724)) then cipherstatepack(2-proj-3-tuple(v_724),minnonce) else fail-any),1-proj-3-tuple(v_724),3-proj-3-tuple(v_720)) else fail-any) else fail-any) else fail-any)) in
        {99}let v_726: bitstring = catch-fail(symmetricstateunpack(v_725)) in
        {100}let v_727: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_726),6-proj-7-tuple(v_700))) in
        {101}let v_728: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_726),6-proj-7-tuple(v_700))) in
        {102}let v_729: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_726),6-proj-7-tuple(v_700))) in
        {103}let v_730: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_700)) && success?(2-proj-3-tuple(v_726))) then (if not-caught-fail(v_727) then (if not-caught-fail(v_728) then (if not-caught-fail(v_729) then (v_727,v_728,v_729) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {104}let v_731: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_726),1-proj-3-tuple(v_730),3-proj-3-tuple(v_726)))) in
        {105}let v_732: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_730)) && success?(symmetricstatepack(1-proj-3-tuple(v_726),1-proj-3-tuple(v_730),3-proj-3-tuple(v_726)))) then (if (not-caught-fail(v_731) && success?(is-true(success?(1-proj-3-tuple(v_731))))) then symmetricstatepack(1-proj-3-tuple(v_731),2-proj-3-tuple(v_731),hash(3-proj-3-tuple(v_731),2-proj-3-tuple(v_730))) else fail-any) else fail-any))) in
        {106}let v_733: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_700)) then (if (not-caught-fail(v_726) && success?(is-true(success?(1-proj-3-tuple(v_726))))) then (if (not-caught-fail(v_730) && success?(is-true(success?(1-proj-3-tuple(v_730))))) then (if (not-caught-fail(v_732) && success?(is-true(success?(1-proj-3-tuple(v_732))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_730)) then cipherstatepack(3-proj-3-tuple(v_730),minnonce) else fail-any),1-proj-3-tuple(v_730),3-proj-3-tuple(v_732)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {107}let v_734: bitstring = catch-fail(symmetricstateunpack(v_733)) in
        {108}let v_735: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_734))) in
        {109}let v_736: aead = catch-fail(decrypt(1-proj-2-tuple(v_735),2-proj-2-tuple(v_735),3-proj-3-tuple(v_734),3-proj-3-tuple(v_701))) in
        {110}let v_737: bitstring = catch-fail(aeadunpack(v_736)) in
        {111}let v_738: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_734))) in
        {112}let v_739: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_735))) && success?(1-proj-3-tuple(v_734))) then (if (not-caught-fail(v_738) && success?(is-true(success?(1-proj-2-tuple(v_738))))) then cipherstatepack(1-proj-2-tuple(v_738),increment_nonce(2-proj-2-tuple(v_735))) else fail-any) else fail-any)) in
        {113}let v_740: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_701)) && (success?(3-proj-3-tuple(v_734)) && success?(1-proj-3-tuple(v_734)))) then (if (not-caught-fail(v_735) && success?(is-true(success?(1-proj-2-tuple(v_735))))) then (if not-caught-fail(v_736) then (if (not-caught-fail(v_737) && success?(is-true(success?(1-proj-3-tuple(v_737))))) then (if not-caught-fail(v_739) then (v_739,3-proj-3-tuple(v_737),1-proj-3-tuple(v_737)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {114}let v_741: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_740),2-proj-3-tuple(v_734),3-proj-3-tuple(v_734)))) in
        {115}let v_742: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_701)) && success?(symmetricstatepack(1-proj-3-tuple(v_740),2-proj-3-tuple(v_734),3-proj-3-tuple(v_734)))) then (if (not-caught-fail(v_741) && success?(is-true(success?(1-proj-3-tuple(v_741))))) then symmetricstatepack(1-proj-3-tuple(v_741),2-proj-3-tuple(v_741),hash(3-proj-3-tuple(v_741),3-proj-3-tuple(v_701))) else fail-any) else fail-any)) in
        {116}let v_743: bitstring = catch-fail((if success?(3-proj-3-tuple(v_701)) then (if (not-caught-fail(v_734) && success?(is-true(success?(1-proj-3-tuple(v_734))))) then (if (not-caught-fail(v_740) && success?(is-true(success?(1-proj-3-tuple(v_740))))) then (if not-caught-fail(v_742) then (v_742,2-proj-3-tuple(v_740),3-proj-3-tuple(v_740)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {117}let v_744: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_743),2-proj-7-tuple(v_700),3-proj-7-tuple(v_700),4-proj-7-tuple(v_700),v_703,6-proj-7-tuple(v_700),7-proj-7-tuple(v_700))) in
        {118}let (hsa_745: handshakestate,re_746: key,plaintext_b: bitstring,valid: bool) = (if (not-caught-fail(v_700) && success?(is-true(success?(1-proj-7-tuple(v_700))))) then (if (not-caught-fail(v_701) && success?(is-true(success?(1-proj-3-tuple(v_701))))) then (if not-caught-fail(v_702) then (if not-caught-fail(v_703) then (if not-caught-fail(v_705) then (if not-caught-fail(v_711) then (if not-caught-fail(v_718) then (if not-caught-fail(v_725) then (if not-caught-fail(v_733) then (if (not-caught-fail(v_743) && success?(is-true(success?(1-proj-3-tuple(v_743))))) then (if (v_702 && 3-proj-3-tuple(v_743)) then (if not-caught-fail(v_744) then (v_744,getpublickey(3-proj-7-tuple(v_700)),2-proj-3-tuple(v_743),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {119}event RecvMsg(alice,bob,stage_b,plaintext_b,valid);
        {120}insert statestore(alice,statepack_c(hsa_745))
    ) | (
        {139}get statestore(=alice,statepack_c(hsa_747: handshakestate)) in
        {122}let v_748: bitstring = catch-fail(handshakestateunpack(hsa_747)) in
        {123}let v_749: bitstring = catch-fail((empty,empty,empty)) in
        {124}let v_750: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_748))) in
        {125}let v_751: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_750))) in
        {126}let v_752: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_751),2-proj-2-tuple(v_751),3-proj-3-tuple(v_750),msg_c)) in
        {127}let v_753: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_750))) in
        {128}let v_754: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_751))) && success?(1-proj-3-tuple(v_750))) then (if (not-caught-fail(v_753) && success?(is-true(success?(1-proj-2-tuple(v_753))))) then cipherstatepack(1-proj-2-tuple(v_753),increment_nonce(2-proj-2-tuple(v_751))) else fail-any) else fail-any)) in
        {129}let v_755: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_750)) && success?(1-proj-3-tuple(v_750))) then (if (not-caught-fail(v_751) && success?(is-true(success?(1-proj-2-tuple(v_751))))) then (if not-caught-fail(v_752) then (if not-caught-fail(v_754) then (v_754,v_752) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {130}let v_756: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_755),2-proj-3-tuple(v_750),3-proj-3-tuple(v_750)))) in
        {131}let v_757: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_755)) && success?(symmetricstatepack(1-proj-2-tuple(v_755),2-proj-3-tuple(v_750),3-proj-3-tuple(v_750)))) then (if (not-caught-fail(v_756) && success?(is-true(success?(1-proj-3-tuple(v_756))))) then symmetricstatepack(1-proj-3-tuple(v_756),2-proj-3-tuple(v_756),hash(3-proj-3-tuple(v_756),2-proj-2-tuple(v_755))) else fail-any) else fail-any)) in
        {132}let v_758: bitstring = catch-fail((if success?(1-proj-7-tuple(v_748)) then (if (not-caught-fail(v_750) && success?(is-true(success?(1-proj-3-tuple(v_750))))) then (if (not-caught-fail(v_755) && success?(is-true(success?(1-proj-2-tuple(v_755))))) then (if not-caught-fail(v_757) then (v_757,2-proj-2-tuple(v_755)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {133}let v_759: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_758),2-proj-7-tuple(v_748),3-proj-7-tuple(v_748),4-proj-7-tuple(v_748),5-proj-7-tuple(v_748),6-proj-7-tuple(v_748),7-proj-7-tuple(v_748))) in
        {134}let v_760: bitstring = catch-fail(concat3(1-proj-3-tuple(v_749),2-proj-3-tuple(v_749),2-proj-2-tuple(v_758))) in
        {135}let (hsa_761: handshakestate,re_762: key,message_c: bitstring) = (if (not-caught-fail(v_748) && success?(is-true(success?(1-proj-7-tuple(v_748))))) then (if (not-caught-fail(v_749) && success?(is-true(success?(1-proj-3-tuple(v_749))))) then (if (not-caught-fail(v_758) && success?(is-true(success?(1-proj-2-tuple(v_758))))) then (if not-caught-fail(v_759) then (if not-caught-fail(v_760) then (v_759,5-proj-7-tuple(v_748),v_760) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {136}event SendMsg(alice,bob,stage_c,msg_c,true);
        {137}insert statestore(alice,statepack_d(hsa_761));
        {138}out(pub, message_c)
    ) | (
        {167}get statestore(=alice,statepack_d(hsa_763: handshakestate)) in
        {140}in(pub, message_d: bitstring);
        {141}let v_764: bitstring = catch-fail(handshakestateunpack(hsa_763)) in
        {142}let v_765: bitstring = catch-fail(deconcat3(message_d)) in
        {143}let v_766: bool = catch-fail(true) in
        {144}let v_767: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_764))) in
        {145}let v_768: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_767))) in
        {146}let v_769: aead = catch-fail(decrypt(1-proj-2-tuple(v_768),2-proj-2-tuple(v_768),3-proj-3-tuple(v_767),3-proj-3-tuple(v_765))) in
        {147}let v_770: bitstring = catch-fail(aeadunpack(v_769)) in
        {148}let v_771: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_767))) in
        {149}let v_772: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_768))) && success?(1-proj-3-tuple(v_767))) then (if (not-caught-fail(v_771) && success?(is-true(success?(1-proj-2-tuple(v_771))))) then cipherstatepack(1-proj-2-tuple(v_771),increment_nonce(2-proj-2-tuple(v_768))) else fail-any) else fail-any)) in
        {150}let v_773: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_765)) && (success?(3-proj-3-tuple(v_767)) && success?(1-proj-3-tuple(v_767)))) then (if (not-caught-fail(v_768) && success?(is-true(success?(1-proj-2-tuple(v_768))))) then (if not-caught-fail(v_769) then (if (not-caught-fail(v_770) && success?(is-true(success?(1-proj-3-tuple(v_770))))) then (if not-caught-fail(v_772) then (v_772,3-proj-3-tuple(v_770),1-proj-3-tuple(v_770)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {151}let v_774: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_773),2-proj-3-tuple(v_767),3-proj-3-tuple(v_767)))) in
        {152}let v_775: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_765)) && success?(symmetricstatepack(1-proj-3-tuple(v_773),2-proj-3-tuple(v_767),3-proj-3-tuple(v_767)))) then (if (not-caught-fail(v_774) && success?(is-true(success?(1-proj-3-tuple(v_774))))) then symmetricstatepack(1-proj-3-tuple(v_774),2-proj-3-tuple(v_774),hash(3-proj-3-tuple(v_774),3-proj-3-tuple(v_765))) else fail-any) else fail-any)) in
        {153}let v_776: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_765)) && success?(1-proj-7-tuple(v_764))) then (if (not-caught-fail(v_767) && success?(is-true(success?(1-proj-3-tuple(v_767))))) then (if (not-caught-fail(v_773) && success?(is-true(success?(1-proj-3-tuple(v_773))))) then (if not-caught-fail(v_775) then (v_775,2-proj-3-tuple(v_773),3-proj-3-tuple(v_773)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {154}let v_777: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_776),2-proj-7-tuple(v_764),3-proj-7-tuple(v_764),4-proj-7-tuple(v_764),5-proj-7-tuple(v_764),6-proj-7-tuple(v_764),7-proj-7-tuple(v_764))) in
        {155}let v_778: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_776))) in
        {156}let v_779: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_778),zero)) in
        {157}let v_780: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_778),zero)) in
        {158}let v_781: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_778),zero)) in
        {159}let v_782: bitstring = catch-fail((if success?(2-proj-3-tuple(v_778)) then (if not-caught-fail(v_779) then (if not-caught-fail(v_780) then (if not-caught-fail(v_781) then (v_779,v_780,v_781) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {160}let v_783: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_782)) then cipherstatepack(1-proj-3-tuple(v_782),minnonce) else fail-any)) in
        {161}let v_784: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_782)) then cipherstatepack(2-proj-3-tuple(v_782),minnonce) else fail-any)) in
        {162}let v_785: bitstring = catch-fail((if success?(1-proj-3-tuple(v_776)) then (if (not-caught-fail(v_778) && success?(is-true(success?(1-proj-3-tuple(v_778))))) then (if (not-caught-fail(v_782) && success?(is-true(success?(1-proj-3-tuple(v_782))))) then (if not-caught-fail(v_783) then (if not-caught-fail(v_784) then (1-proj-3-tuple(v_776),v_783,v_784) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {163}let (hsa_786: handshakestate,re_787: key,plaintext_d: bitstring,valid_788: bool,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_764) && success?(is-true(success?(1-proj-7-tuple(v_764))))) then (if (not-caught-fail(v_765) && success?(is-true(success?(1-proj-3-tuple(v_765))))) then (if not-caught-fail(v_766) then (if (not-caught-fail(v_776) && success?(is-true(success?(1-proj-3-tuple(v_776))))) then (if (v_766 && 3-proj-3-tuple(v_776)) then (if not-caught-fail(v_777) then (if (not-caught-fail(v_785) && success?(is-true(success?(1-proj-3-tuple(v_785))))) then (v_777,getpublickey(3-proj-7-tuple(v_764)),2-proj-3-tuple(v_776),true,2-proj-3-tuple(v_785),3-proj-3-tuple(v_785)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {164}event RecvMsg(alice,bob,stage_d,plaintext_d,valid_788);
        {165}insert statestore(alice,statepack_e(hsa_786));
        {166}event RecvEnd(valid_788)
    ) | (
        {168}event LeakS(phase0,alice);
        {169}out(pub, key_0)
    ) | (
        {170}phase 1;
        {171}event LeakS(phase1,alice);
        {172}out(pub, key_0)
    )
) | (
    {173}let v_789: key = catch-fail(dhexp(key_1,g)) in
    {174}let s_790: keypair = (if not-caught-fail(v_789) then keypairpack(v_789,key_1) else fail-any) in
    {175}let v_791: key = catch-fail(dhexp(key_1,g)) in
    {176}out(pub, getpublickey((if not-caught-fail(v_791) then keypairpack(v_791,key_1) else fail-any)));
    (
        {177}let e_792: keypair = keypairpack(empty,empty) in
        {178}let rs_793: key = empty in
        {179}let re_794: key = empty in
        {180}let v_795: bitstring = catch-fail(hash(somename,empty)) in
        {181}let v_796: key = catch-fail(v_795) in
        {182}let v_797: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {183}let v_798: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_795) then (if not-caught-fail(v_796) then (if not-caught-fail(v_797) then symmetricstatepack(v_797,v_796,v_795) else fail-any) else fail-any) else fail-any))) in
        {184}let v_799: symmetricstate = catch-fail((if success?((if not-caught-fail(v_795) then (if not-caught-fail(v_796) then (if not-caught-fail(v_797) then symmetricstatepack(v_797,v_796,v_795) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_798) && success?(is-true(success?(1-proj-3-tuple(v_798))))) then symmetricstatepack(1-proj-3-tuple(v_798),2-proj-3-tuple(v_798),hash(3-proj-3-tuple(v_798),empty)) else fail-any) else fail-any)) in
        {185}let v_800: bitstring = catch-fail(symmetricstateunpack(v_799)) in
        {186}let v_801: symmetricstate = catch-fail((if success?(getpublickey(s_790)) then (if (not-caught-fail(v_800) && success?(is-true(success?(1-proj-3-tuple(v_800))))) then symmetricstatepack(1-proj-3-tuple(v_800),2-proj-3-tuple(v_800),hash(3-proj-3-tuple(v_800),getpublickey(s_790))) else fail-any) else fail-any)) in
        {187}let hsb: handshakestate = (if not-caught-fail(v_799) then (if not-caught-fail(v_801) then handshakestatepack(v_801,s_790,e_792,rs_793,re_794,key_psk,false) else fail-any) else fail-any) in
        {188}insert statestore(bob,statepack_a(hsb))
    ) | (
        {242}get statestore(=bob,statepack_a(hsb_802: handshakestate)) in
        {189}in(pub, message_a_803: bitstring);
        {190}let v_804: bitstring = catch-fail(handshakestateunpack(hsb_802)) in
        {191}let v_805: bitstring = catch-fail(deconcat3(message_a_803)) in
        {192}let v_806: bool = catch-fail(true) in
        {193}let v_807: key = catch-fail(1-proj-3-tuple(v_805)) in
        {194}let v_808: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_804))) in
        {195}let v_809: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_804)) then (if (not-caught-fail(v_808) && success?(is-true(success?(1-proj-3-tuple(v_808))))) then symmetricstatepack(1-proj-3-tuple(v_808),2-proj-3-tuple(v_808),hash(3-proj-3-tuple(v_808),v_807)) else fail-any) else fail-any)) in
        {196}let v_810: bitstring = catch-fail(symmetricstateunpack(v_809)) in
        {197}let v_811: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_810),v_807)) in
        {198}let v_812: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_810),v_807)) in
        {199}let v_813: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_810),v_807)) in
        {200}let v_814: bitstring = catch-fail((if success?(2-proj-3-tuple(v_810)) then (if not-caught-fail(v_811) then (if not-caught-fail(v_812) then (if not-caught-fail(v_813) then (v_811,v_812,v_813) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {201}let v_815: symmetricstate = catch-fail((if (not-caught-fail(v_810) && success?(is-true(success?(1-proj-3-tuple(v_810))))) then (if (not-caught-fail(v_814) && success?(is-true(success?(1-proj-3-tuple(v_814))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_814)) then cipherstatepack(2-proj-3-tuple(v_814),minnonce) else fail-any),1-proj-3-tuple(v_814),3-proj-3-tuple(v_810)) else fail-any) else fail-any)) in
        {202}let v_816: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_804))) in
        {203}let v_817: bitstring = catch-fail(symmetricstateunpack(v_815)) in
        {204}let v_818: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_817),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {205}let v_819: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_817),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {206}let v_820: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_817),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any))) in
        {207}let v_821: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_817))) then (if not-caught-fail(v_818) then (if not-caught-fail(v_819) then (if not-caught-fail(v_820) then (v_818,v_819,v_820) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {208}let v_822: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_816) && success?(is-true(success?(1-proj-2-tuple(v_816))))) then dhexp(2-proj-2-tuple(v_816),v_807) else fail-any) else fail-any)) then (if (not-caught-fail(v_817) && success?(is-true(success?(1-proj-3-tuple(v_817))))) then (if (not-caught-fail(v_821) && success?(is-true(success?(1-proj-3-tuple(v_821))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_821)) then cipherstatepack(2-proj-3-tuple(v_821),minnonce) else fail-any),1-proj-3-tuple(v_821),3-proj-3-tuple(v_817)) else fail-any) else fail-any) else fail-any)) in
        {209}let v_823: bitstring = catch-fail(symmetricstateunpack(v_822)) in
        {210}let v_824: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_823))) in
        {211}let v_825: aead = catch-fail(decrypt(1-proj-2-tuple(v_824),2-proj-2-tuple(v_824),3-proj-3-tuple(v_823),2-proj-3-tuple(v_805))) in
        {212}let v_826: bitstring = catch-fail(aeadunpack(v_825)) in
        {213}let v_827: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_823))) in
        {214}let v_828: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_824))) && success?(1-proj-3-tuple(v_823))) then (if (not-caught-fail(v_827) && success?(is-true(success?(1-proj-2-tuple(v_827))))) then cipherstatepack(1-proj-2-tuple(v_827),increment_nonce(2-proj-2-tuple(v_824))) else fail-any) else fail-any)) in
        {215}let v_829: bitstring = catch-fail((if (success?(2-proj-3-tuple(v_805)) && (success?(3-proj-3-tuple(v_823)) && success?(1-proj-3-tuple(v_823)))) then (if (not-caught-fail(v_824) && success?(is-true(success?(1-proj-2-tuple(v_824))))) then (if not-caught-fail(v_825) then (if (not-caught-fail(v_826) && success?(is-true(success?(1-proj-3-tuple(v_826))))) then (if not-caught-fail(v_828) then (v_828,3-proj-3-tuple(v_826),1-proj-3-tuple(v_826)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {216}let v_830: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_829),2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)))) in
        {217}let v_831: symmetricstate = catch-fail((if (success?(2-proj-3-tuple(v_805)) && success?(symmetricstatepack(1-proj-3-tuple(v_829),2-proj-3-tuple(v_823),3-proj-3-tuple(v_823)))) then (if (not-caught-fail(v_830) && success?(is-true(success?(1-proj-3-tuple(v_830))))) then symmetricstatepack(1-proj-3-tuple(v_830),2-proj-3-tuple(v_830),hash(3-proj-3-tuple(v_830),2-proj-3-tuple(v_805))) else fail-any) else fail-any)) in
        {218}let v_832: bitstring = catch-fail((if success?(2-proj-3-tuple(v_805)) then (if (not-caught-fail(v_823) && success?(is-true(success?(1-proj-3-tuple(v_823))))) then (if (not-caught-fail(v_829) && success?(is-true(success?(1-proj-3-tuple(v_829))))) then (if not-caught-fail(v_831) then (v_831,2-proj-3-tuple(v_829),3-proj-3-tuple(v_829)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {219}let v_833: key = catch-fail(2-proj-3-tuple(v_832)) in
        {220}let v_834: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_804))) in
        {221}let v_835: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_832))) in
        {222}let v_836: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_835),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then dhexp(2-proj-2-tuple(v_834),v_833) else fail-any) else fail-any))) in
        {223}let v_837: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_835),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then dhexp(2-proj-2-tuple(v_834),v_833) else fail-any) else fail-any))) in
        {224}let v_838: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_835),(if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then dhexp(2-proj-2-tuple(v_834),v_833) else fail-any) else fail-any))) in
        {225}let v_839: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then dhexp(2-proj-2-tuple(v_834),v_833) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_835))) then (if not-caught-fail(v_836) then (if not-caught-fail(v_837) then (if not-caught-fail(v_838) then (v_836,v_837,v_838) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {226}let v_840: symmetricstate = catch-fail((if (success?((if success?(2-proj-7-tuple(v_804)) then (if (not-caught-fail(v_834) && success?(is-true(success?(1-proj-2-tuple(v_834))))) then dhexp(2-proj-2-tuple(v_834),v_833) else fail-any) else fail-any)) && success?(1-proj-3-tuple(v_832))) then (if (not-caught-fail(v_835) && success?(is-true(success?(1-proj-3-tuple(v_835))))) then (if (not-caught-fail(v_839) && success?(is-true(success?(1-proj-3-tuple(v_839))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_839)) then cipherstatepack(2-proj-3-tuple(v_839),minnonce) else fail-any),1-proj-3-tuple(v_839),3-proj-3-tuple(v_835)) else fail-any) else fail-any) else fail-any)) in
        {227}let v_841: bitstring = catch-fail(symmetricstateunpack(v_840)) in
        {228}let v_842: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_841))) in
        {229}let v_843: aead = catch-fail(decrypt(1-proj-2-tuple(v_842),2-proj-2-tuple(v_842),3-proj-3-tuple(v_841),3-proj-3-tuple(v_805))) in
        {230}let v_844: bitstring = catch-fail(aeadunpack(v_843)) in
        {231}let v_845: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_841))) in
        {232}let v_846: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_842))) && success?(1-proj-3-tuple(v_841))) then (if (not-caught-fail(v_845) && success?(is-true(success?(1-proj-2-tuple(v_845))))) then cipherstatepack(1-proj-2-tuple(v_845),increment_nonce(2-proj-2-tuple(v_842))) else fail-any) else fail-any)) in
        {233}let v_847: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_805)) && (success?(3-proj-3-tuple(v_841)) && success?(1-proj-3-tuple(v_841)))) then (if (not-caught-fail(v_842) && success?(is-true(success?(1-proj-2-tuple(v_842))))) then (if not-caught-fail(v_843) then (if (not-caught-fail(v_844) && success?(is-true(success?(1-proj-3-tuple(v_844))))) then (if not-caught-fail(v_846) then (v_846,3-proj-3-tuple(v_844),1-proj-3-tuple(v_844)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {234}let v_848: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_847),2-proj-3-tuple(v_841),3-proj-3-tuple(v_841)))) in
        {235}let v_849: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_805)) && success?(symmetricstatepack(1-proj-3-tuple(v_847),2-proj-3-tuple(v_841),3-proj-3-tuple(v_841)))) then (if (not-caught-fail(v_848) && success?(is-true(success?(1-proj-3-tuple(v_848))))) then symmetricstatepack(1-proj-3-tuple(v_848),2-proj-3-tuple(v_848),hash(3-proj-3-tuple(v_848),3-proj-3-tuple(v_805))) else fail-any) else fail-any)) in
        {236}let v_850: bitstring = catch-fail((if success?(3-proj-3-tuple(v_805)) then (if (not-caught-fail(v_841) && success?(is-true(success?(1-proj-3-tuple(v_841))))) then (if (not-caught-fail(v_847) && success?(is-true(success?(1-proj-3-tuple(v_847))))) then (if not-caught-fail(v_849) then (v_849,2-proj-3-tuple(v_847),3-proj-3-tuple(v_847)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {237}let v_851: key = catch-fail(dhexp(key_0,g)) in
        {238}let v_852: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_850),2-proj-7-tuple(v_804),3-proj-7-tuple(v_804),v_833,v_807,6-proj-7-tuple(v_804),7-proj-7-tuple(v_804))) in
        {239}let (hsb_853: handshakestate,re_854: key,plaintext_a: bitstring,valid_855: bool) = (if (not-caught-fail(v_804) && success?(is-true(success?(1-proj-7-tuple(v_804))))) then (if (not-caught-fail(v_805) && success?(is-true(success?(1-proj-3-tuple(v_805))))) then (if not-caught-fail(v_806) then (if not-caught-fail(v_807) then (if not-caught-fail(v_809) then (if not-caught-fail(v_815) then (if not-caught-fail(v_822) then (if (not-caught-fail(v_832) && success?(is-true(success?(1-proj-3-tuple(v_832))))) then (if not-caught-fail(v_833) then (if not-caught-fail(v_840) then (if (not-caught-fail(v_850) && success?(is-true(success?(1-proj-3-tuple(v_850))))) then (if ((3-proj-3-tuple(v_832) && 3-proj-3-tuple(v_850)) && (v_833 = getpublickey((if not-caught-fail(v_851) then keypairpack(v_851,key_0) else fail-any)))) then (if not-caught-fail(v_852) then (v_852,getpublickey(3-proj-7-tuple(v_804)),2-proj-3-tuple(v_850),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {240}event RecvMsg(bob,alice,stage_a,plaintext_a,valid_855);
        {241}insert statestore(bob,statepack_b(hsb_853))
    ) | (
        {293}get statestore(=bob,statepack_b(hsb_856: handshakestate)) in
        {243}let v_857: bitstring = catch-fail(handshakestateunpack(hsb_856)) in
        {244}let v_858: bitstring = catch-fail((empty,empty,empty)) in
        {245}let v_859: key = catch-fail(dhexp(key_3,g)) in
        {246}let v_860: keypair = catch-fail((if not-caught-fail(v_859) then keypairpack(v_859,key_3) else fail-any)) in
        {247}let v_861: bitstring = catch-fail(getpublickey(v_860)) in
        {248}let v_862: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_857))) in
        {249}let v_863: symmetricstate = catch-fail((if success?(1-proj-7-tuple(v_857)) then (if (not-caught-fail(v_862) && success?(is-true(success?(1-proj-3-tuple(v_862))))) then symmetricstatepack(1-proj-3-tuple(v_862),2-proj-3-tuple(v_862),hash(3-proj-3-tuple(v_862),v_861)) else fail-any) else fail-any)) in
        {250}let v_864: bitstring = catch-fail(symmetricstateunpack(v_863)) in
        {251}let v_865: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_864),getpublickey(v_860))) in
        {252}let v_866: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_864),getpublickey(v_860))) in
        {253}let v_867: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_864),getpublickey(v_860))) in
        {254}let v_868: bitstring = catch-fail((if (success?(getpublickey(v_860)) && success?(2-proj-3-tuple(v_864))) then (if not-caught-fail(v_865) then (if not-caught-fail(v_866) then (if not-caught-fail(v_867) then (v_865,v_866,v_867) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {255}let v_869: symmetricstate = catch-fail((if success?(getpublickey(v_860)) then (if (not-caught-fail(v_864) && success?(is-true(success?(1-proj-3-tuple(v_864))))) then (if (not-caught-fail(v_868) && success?(is-true(success?(1-proj-3-tuple(v_868))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_868)) then cipherstatepack(2-proj-3-tuple(v_868),minnonce) else fail-any),1-proj-3-tuple(v_868),3-proj-3-tuple(v_864)) else fail-any) else fail-any) else fail-any)) in
        {256}let v_870: bitstring = catch-fail(keypairunpack(v_860)) in
        {257}let v_871: bitstring = catch-fail(symmetricstateunpack(v_869)) in
        {258}let v_872: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_871),(if success?(5-proj-7-tuple(v_857)) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-2-tuple(v_870))))) then dhexp(2-proj-2-tuple(v_870),5-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {259}let v_873: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_871),(if success?(5-proj-7-tuple(v_857)) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-2-tuple(v_870))))) then dhexp(2-proj-2-tuple(v_870),5-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {260}let v_874: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_871),(if success?(5-proj-7-tuple(v_857)) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-2-tuple(v_870))))) then dhexp(2-proj-2-tuple(v_870),5-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {261}let v_875: bitstring = catch-fail((if (success?((if success?(5-proj-7-tuple(v_857)) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-2-tuple(v_870))))) then dhexp(2-proj-2-tuple(v_870),5-proj-7-tuple(v_857)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_871))) then (if not-caught-fail(v_872) then (if not-caught-fail(v_873) then (if not-caught-fail(v_874) then (v_872,v_873,v_874) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {262}let v_876: symmetricstate = catch-fail((if success?((if success?(5-proj-7-tuple(v_857)) then (if (not-caught-fail(v_870) && success?(is-true(success?(1-proj-2-tuple(v_870))))) then dhexp(2-proj-2-tuple(v_870),5-proj-7-tuple(v_857)) else fail-any) else fail-any)) then (if (not-caught-fail(v_871) && success?(is-true(success?(1-proj-3-tuple(v_871))))) then (if (not-caught-fail(v_875) && success?(is-true(success?(1-proj-3-tuple(v_875))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_875)) then cipherstatepack(2-proj-3-tuple(v_875),minnonce) else fail-any),1-proj-3-tuple(v_875),3-proj-3-tuple(v_871)) else fail-any) else fail-any) else fail-any)) in
        {263}let v_877: bitstring = catch-fail(keypairunpack(v_860)) in
        {264}let v_878: bitstring = catch-fail(symmetricstateunpack(v_876)) in
        {265}let v_879: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_878),(if success?(4-proj-7-tuple(v_857)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then dhexp(2-proj-2-tuple(v_877),4-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {266}let v_880: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_878),(if success?(4-proj-7-tuple(v_857)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then dhexp(2-proj-2-tuple(v_877),4-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {267}let v_881: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_878),(if success?(4-proj-7-tuple(v_857)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then dhexp(2-proj-2-tuple(v_877),4-proj-7-tuple(v_857)) else fail-any) else fail-any))) in
        {268}let v_882: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_857)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then dhexp(2-proj-2-tuple(v_877),4-proj-7-tuple(v_857)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_878))) then (if not-caught-fail(v_879) then (if not-caught-fail(v_880) then (if not-caught-fail(v_881) then (v_879,v_880,v_881) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {269}let v_883: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_857)) then (if (not-caught-fail(v_877) && success?(is-true(success?(1-proj-2-tuple(v_877))))) then dhexp(2-proj-2-tuple(v_877),4-proj-7-tuple(v_857)) else fail-any) else fail-any)) then (if (not-caught-fail(v_878) && success?(is-true(success?(1-proj-3-tuple(v_878))))) then (if (not-caught-fail(v_882) && success?(is-true(success?(1-proj-3-tuple(v_882))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_882)) then cipherstatepack(2-proj-3-tuple(v_882),minnonce) else fail-any),1-proj-3-tuple(v_882),3-proj-3-tuple(v_878)) else fail-any) else fail-any) else fail-any)) in
        {270}let v_884: bitstring = catch-fail(symmetricstateunpack(v_883)) in
        {271}let v_885: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_884),6-proj-7-tuple(v_857))) in
        {272}let v_886: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_884),6-proj-7-tuple(v_857))) in
        {273}let v_887: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_884),6-proj-7-tuple(v_857))) in
        {274}let v_888: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_857)) && success?(2-proj-3-tuple(v_884))) then (if not-caught-fail(v_885) then (if not-caught-fail(v_886) then (if not-caught-fail(v_887) then (v_885,v_886,v_887) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {275}let v_889: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_884),1-proj-3-tuple(v_888),3-proj-3-tuple(v_884)))) in
        {276}let v_890: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_888)) && success?(symmetricstatepack(1-proj-3-tuple(v_884),1-proj-3-tuple(v_888),3-proj-3-tuple(v_884)))) then (if (not-caught-fail(v_889) && success?(is-true(success?(1-proj-3-tuple(v_889))))) then symmetricstatepack(1-proj-3-tuple(v_889),2-proj-3-tuple(v_889),hash(3-proj-3-tuple(v_889),2-proj-3-tuple(v_888))) else fail-any) else fail-any))) in
        {277}let v_891: symmetricstate = catch-fail((if success?(6-proj-7-tuple(v_857)) then (if (not-caught-fail(v_884) && success?(is-true(success?(1-proj-3-tuple(v_884))))) then (if (not-caught-fail(v_888) && success?(is-true(success?(1-proj-3-tuple(v_888))))) then (if (not-caught-fail(v_890) && success?(is-true(success?(1-proj-3-tuple(v_890))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_888)) then cipherstatepack(3-proj-3-tuple(v_888),minnonce) else fail-any),1-proj-3-tuple(v_888),3-proj-3-tuple(v_890)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {278}let v_892: bitstring = catch-fail(symmetricstateunpack(v_891)) in
        {279}let v_893: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_892))) in
        {280}let v_894: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_893),2-proj-2-tuple(v_893),3-proj-3-tuple(v_892),msg_b)) in
        {281}let v_895: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_892))) in
        {282}let v_896: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_893))) && success?(1-proj-3-tuple(v_892))) then (if (not-caught-fail(v_895) && success?(is-true(success?(1-proj-2-tuple(v_895))))) then cipherstatepack(1-proj-2-tuple(v_895),increment_nonce(2-proj-2-tuple(v_893))) else fail-any) else fail-any)) in
        {283}let v_897: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_892)) && success?(1-proj-3-tuple(v_892))) then (if (not-caught-fail(v_893) && success?(is-true(success?(1-proj-2-tuple(v_893))))) then (if not-caught-fail(v_894) then (if not-caught-fail(v_896) then (v_896,v_894) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {284}let v_898: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_897),2-proj-3-tuple(v_892),3-proj-3-tuple(v_892)))) in
        {285}let v_899: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_897)) && success?(symmetricstatepack(1-proj-2-tuple(v_897),2-proj-3-tuple(v_892),3-proj-3-tuple(v_892)))) then (if (not-caught-fail(v_898) && success?(is-true(success?(1-proj-3-tuple(v_898))))) then symmetricstatepack(1-proj-3-tuple(v_898),2-proj-3-tuple(v_898),hash(3-proj-3-tuple(v_898),2-proj-2-tuple(v_897))) else fail-any) else fail-any)) in
        {286}let v_900: bitstring = catch-fail((if (not-caught-fail(v_892) && success?(is-true(success?(1-proj-3-tuple(v_892))))) then (if (not-caught-fail(v_897) && success?(is-true(success?(1-proj-2-tuple(v_897))))) then (if not-caught-fail(v_899) then (v_899,2-proj-2-tuple(v_897)) else fail-any) else fail-any) else fail-any)) in
        {287}let v_901: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_900),2-proj-7-tuple(v_857),v_860,4-proj-7-tuple(v_857),5-proj-7-tuple(v_857),6-proj-7-tuple(v_857),7-proj-7-tuple(v_857))) in
        {288}let v_902: bitstring = catch-fail(concat3(v_861,2-proj-3-tuple(v_858),2-proj-2-tuple(v_900))) in
        {289}let (hsb_903: handshakestate,re_904: key,message_b_905: bitstring) = (if (not-caught-fail(v_857) && success?(is-true(success?(1-proj-7-tuple(v_857))))) then (if (not-caught-fail(v_858) && success?(is-true(success?(1-proj-3-tuple(v_858))))) then (if not-caught-fail(v_860) then (if not-caught-fail(v_861) then (if not-caught-fail(v_863) then (if not-caught-fail(v_869) then (if not-caught-fail(v_876) then (if not-caught-fail(v_883) then (if not-caught-fail(v_891) then (if (not-caught-fail(v_900) && success?(is-true(success?(1-proj-2-tuple(v_900))))) then (if not-caught-fail(v_901) then (if not-caught-fail(v_902) then (v_901,5-proj-7-tuple(v_857),v_902) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {290}event SendMsg(bob,alice,stage_b,msg_b,true);
        {291}insert statestore(bob,statepack_c(hsb_903));
        {292}out(pub, message_b_905)
    ) | (
        {312}get statestore(=bob,statepack_c(hsb_906: handshakestate)) in
        {294}in(pub, message_c_907: bitstring);
        {295}let v_908: bitstring = catch-fail(handshakestateunpack(hsb_906)) in
        {296}let v_909: bitstring = catch-fail(deconcat3(message_c_907)) in
        {297}let v_910: bool = catch-fail(true) in
        {298}let v_911: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_908))) in
        {299}let v_912: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_911))) in
        {300}let v_913: aead = catch-fail(decrypt(1-proj-2-tuple(v_912),2-proj-2-tuple(v_912),3-proj-3-tuple(v_911),3-proj-3-tuple(v_909))) in
        {301}let v_914: bitstring = catch-fail(aeadunpack(v_913)) in
        {302}let v_915: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_911))) in
        {303}let v_916: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_912))) && success?(1-proj-3-tuple(v_911))) then (if (not-caught-fail(v_915) && success?(is-true(success?(1-proj-2-tuple(v_915))))) then cipherstatepack(1-proj-2-tuple(v_915),increment_nonce(2-proj-2-tuple(v_912))) else fail-any) else fail-any)) in
        {304}let v_917: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_909)) && (success?(3-proj-3-tuple(v_911)) && success?(1-proj-3-tuple(v_911)))) then (if (not-caught-fail(v_912) && success?(is-true(success?(1-proj-2-tuple(v_912))))) then (if not-caught-fail(v_913) then (if (not-caught-fail(v_914) && success?(is-true(success?(1-proj-3-tuple(v_914))))) then (if not-caught-fail(v_916) then (v_916,3-proj-3-tuple(v_914),1-proj-3-tuple(v_914)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {305}let v_918: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_917),2-proj-3-tuple(v_911),3-proj-3-tuple(v_911)))) in
        {306}let v_919: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_909)) && success?(symmetricstatepack(1-proj-3-tuple(v_917),2-proj-3-tuple(v_911),3-proj-3-tuple(v_911)))) then (if (not-caught-fail(v_918) && success?(is-true(success?(1-proj-3-tuple(v_918))))) then symmetricstatepack(1-proj-3-tuple(v_918),2-proj-3-tuple(v_918),hash(3-proj-3-tuple(v_918),3-proj-3-tuple(v_909))) else fail-any) else fail-any)) in
        {307}let v_920: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_909)) && success?(1-proj-7-tuple(v_908))) then (if (not-caught-fail(v_911) && success?(is-true(success?(1-proj-3-tuple(v_911))))) then (if (not-caught-fail(v_917) && success?(is-true(success?(1-proj-3-tuple(v_917))))) then (if not-caught-fail(v_919) then (v_919,2-proj-3-tuple(v_917),3-proj-3-tuple(v_917)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {308}let v_921: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_920),2-proj-7-tuple(v_908),3-proj-7-tuple(v_908),4-proj-7-tuple(v_908),5-proj-7-tuple(v_908),6-proj-7-tuple(v_908),7-proj-7-tuple(v_908))) in
        {309}let (hsb_922: handshakestate,re_923: key,plaintext_c: bitstring,valid_924: bool) = (if (not-caught-fail(v_908) && success?(is-true(success?(1-proj-7-tuple(v_908))))) then (if (not-caught-fail(v_909) && success?(is-true(success?(1-proj-3-tuple(v_909))))) then (if not-caught-fail(v_910) then (if (not-caught-fail(v_920) && success?(is-true(success?(1-proj-3-tuple(v_920))))) then (if (v_910 && 3-proj-3-tuple(v_920)) then (if not-caught-fail(v_921) then (v_921,getpublickey(3-proj-7-tuple(v_908)),2-proj-3-tuple(v_920),true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {310}event RecvMsg(bob,alice,stage_c,plaintext_c,valid_924);
        {311}insert statestore(bob,statepack_d(hsb_922))
    ) | (
        {338}get statestore(=bob,statepack_d(hsb_925: handshakestate)) in
        {313}let v_926: bitstring = catch-fail(handshakestateunpack(hsb_925)) in
        {314}let v_927: bitstring = catch-fail((empty,empty,empty)) in
        {315}let v_928: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_926))) in
        {316}let v_929: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_928))) in
        {317}let v_930: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_929),2-proj-2-tuple(v_929),3-proj-3-tuple(v_928),msg_d)) in
        {318}let v_931: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_928))) in
        {319}let v_932: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_929))) && success?(1-proj-3-tuple(v_928))) then (if (not-caught-fail(v_931) && success?(is-true(success?(1-proj-2-tuple(v_931))))) then cipherstatepack(1-proj-2-tuple(v_931),increment_nonce(2-proj-2-tuple(v_929))) else fail-any) else fail-any)) in
        {320}let v_933: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_928)) && success?(1-proj-3-tuple(v_928))) then (if (not-caught-fail(v_929) && success?(is-true(success?(1-proj-2-tuple(v_929))))) then (if not-caught-fail(v_930) then (if not-caught-fail(v_932) then (v_932,v_930) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {321}let v_934: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_933),2-proj-3-tuple(v_928),3-proj-3-tuple(v_928)))) in
        {322}let v_935: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_933)) && success?(symmetricstatepack(1-proj-2-tuple(v_933),2-proj-3-tuple(v_928),3-proj-3-tuple(v_928)))) then (if (not-caught-fail(v_934) && success?(is-true(success?(1-proj-3-tuple(v_934))))) then symmetricstatepack(1-proj-3-tuple(v_934),2-proj-3-tuple(v_934),hash(3-proj-3-tuple(v_934),2-proj-2-tuple(v_933))) else fail-any) else fail-any)) in
        {323}let v_936: bitstring = catch-fail((if success?(1-proj-7-tuple(v_926)) then (if (not-caught-fail(v_928) && success?(is-true(success?(1-proj-3-tuple(v_928))))) then (if (not-caught-fail(v_933) && success?(is-true(success?(1-proj-2-tuple(v_933))))) then (if not-caught-fail(v_935) then (v_935,2-proj-2-tuple(v_933)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {324}let v_937: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_936),2-proj-7-tuple(v_926),3-proj-7-tuple(v_926),4-proj-7-tuple(v_926),5-proj-7-tuple(v_926),6-proj-7-tuple(v_926),7-proj-7-tuple(v_926))) in
        {325}let v_938: bitstring = catch-fail(concat3(1-proj-3-tuple(v_927),2-proj-3-tuple(v_927),2-proj-2-tuple(v_936))) in
        {326}let v_939: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_936))) in
        {327}let v_940: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_939),zero)) in
        {328}let v_941: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_939),zero)) in
        {329}let v_942: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_939),zero)) in
        {330}let v_943: bitstring = catch-fail((if success?(2-proj-3-tuple(v_939)) then (if not-caught-fail(v_940) then (if not-caught-fail(v_941) then (if not-caught-fail(v_942) then (v_940,v_941,v_942) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {331}let v_944: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_943)) then cipherstatepack(1-proj-3-tuple(v_943),minnonce) else fail-any)) in
        {332}let v_945: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_943)) then cipherstatepack(2-proj-3-tuple(v_943),minnonce) else fail-any)) in
        {333}let v_946: bitstring = catch-fail((if success?(1-proj-2-tuple(v_936)) then (if (not-caught-fail(v_939) && success?(is-true(success?(1-proj-3-tuple(v_939))))) then (if (not-caught-fail(v_943) && success?(is-true(success?(1-proj-3-tuple(v_943))))) then (if not-caught-fail(v_944) then (if not-caught-fail(v_945) then (1-proj-2-tuple(v_936),v_944,v_945) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {334}let (hsb_947: handshakestate,re_948: key,message_d_949: bitstring,cs1_950: cipherstate,cs2_951: cipherstate) = (if (not-caught-fail(v_926) && success?(is-true(success?(1-proj-7-tuple(v_926))))) then (if (not-caught-fail(v_927) && success?(is-true(success?(1-proj-3-tuple(v_927))))) then (if (not-caught-fail(v_936) && success?(is-true(success?(1-proj-2-tuple(v_936))))) then (if not-caught-fail(v_937) then (if not-caught-fail(v_938) then (if (not-caught-fail(v_946) && success?(is-true(success?(1-proj-3-tuple(v_946))))) then (v_937,5-proj-7-tuple(v_926),v_938,2-proj-3-tuple(v_946),3-proj-3-tuple(v_946)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {335}event SendMsg(bob,alice,stage_d,msg_d,true);
        {336}insert statestore(bob,statepack_e(hsb_947));
        {337}out(pub, message_d_949)
    ) | (
        {339}event LeakS(phase0,bob);
        {340}out(pub, key_1)
    ) | (
        {341}phase 1;
        {342}event LeakS(phase1,bob);
        {343}out(pub, key_1)
    )
) | (
    {344}event LeakPsk(phase0,key_psk);
    {345}out(pub, key_psk)
) | (
    {346}phase 1;
    {347}event LeakPsk(phase1,key_psk);
    {348}out(pub, key_psk)
)

-- Query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); not attacker_p1(msg_a); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)); not attacker_p1(msg_a); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); not attacker_p1(msg_b); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)); not attacker_p1(msg_b); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); not attacker_p1(msg_c); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)); not attacker_p1(msg_c); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)); event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)); not attacker_p1(msg_d); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)); not attacker_p1(msg_d); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)); attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 167 rules in the queue.
400 rules inserted. The rule base contains 396 rules. 53 rules in the queue.
600 rules inserted. The rule base contains 580 rules. 301 rules in the queue.
800 rules inserted. The rule base contains 749 rules. 274 rules in the queue.
1000 rules inserted. The rule base contains 910 rules. 166 rules in the queue.
1200 rules inserted. The rule base contains 1094 rules. 382 rules in the queue.
1400 rules inserted. The rule base contains 1294 rules. 541 rules in the queue.
1600 rules inserted. The rule base contains 1483 rules. 603 rules in the queue.
1800 rules inserted. The rule base contains 1662 rules. 586 rules in the queue.
2000 rules inserted. The rule base contains 1841 rules. 568 rules in the queue.
2200 rules inserted. The rule base contains 2028 rules. 583 rules in the queue.
2400 rules inserted. The rule base contains 2228 rules. 625 rules in the queue.
2600 rules inserted. The rule base contains 2428 rules. 671 rules in the queue.
2800 rules inserted. The rule base contains 2602 rules. 690 rules in the queue.
3000 rules inserted. The rule base contains 2773 rules. 700 rules in the queue.
3200 rules inserted. The rule base contains 2943 rules. 710 rules in the queue.
3400 rules inserted. The rule base contains 3070 rules. 681 rules in the queue.
3600 rules inserted. The rule base contains 3174 rules. 654 rules in the queue.
3800 rules inserted. The rule base contains 3264 rules. 593 rules in the queue.
4000 rules inserted. The rule base contains 3394 rules. 609 rules in the queue.
4200 rules inserted. The rule base contains 3523 rules. 608 rules in the queue.
4400 rules inserted. The rule base contains 3645 rules. 621 rules in the queue.
4600 rules inserted. The rule base contains 3803 rules. 693 rules in the queue.
4800 rules inserted. The rule base contains 3965 rules. 750 rules in the queue.
5000 rules inserted. The rule base contains 4124 rules. 790 rules in the queue.
5200 rules inserted. The rule base contains 4228 rules. 775 rules in the queue.
5400 rules inserted. The rule base contains 4334 rules. 765 rules in the queue.
5600 rules inserted. The rule base contains 4444 rules. 755 rules in the queue.
5800 rules inserted. The rule base contains 4566 rules. 758 rules in the queue.
6000 rules inserted. The rule base contains 4711 rules. 773 rules in the queue.
6200 rules inserted. The rule base contains 4864 rules. 796 rules in the queue.
6400 rules inserted. The rule base contains 5013 rules. 819 rules in the queue.
6600 rules inserted. The rule base contains 5128 rules. 826 rules in the queue.
6800 rules inserted. The rule base contains 5258 rules. 855 rules in the queue.
7000 rules inserted. The rule base contains 5379 rules. 876 rules in the queue.
7200 rules inserted. The rule base contains 5481 rules. 854 rules in the queue.
7400 rules inserted. The rule base contains 5547 rules. 768 rules in the queue.
7600 rules inserted. The rule base contains 5605 rules. 674 rules in the queue.
7800 rules inserted. The rule base contains 5724 rules. 640 rules in the queue.
8000 rules inserted. The rule base contains 5886 rules. 648 rules in the queue.
8200 rules inserted. The rule base contains 6046 rules. 656 rules in the queue.
8400 rules inserted. The rule base contains 6218 rules. 660 rules in the queue.
8600 rules inserted. The rule base contains 6394 rules. 693 rules in the queue.
8800 rules inserted. The rule base contains 6565 rules. 710 rules in the queue.
9000 rules inserted. The rule base contains 6714 rules. 696 rules in the queue.
9200 rules inserted. The rule base contains 6845 rules. 682 rules in the queue.
9400 rules inserted. The rule base contains 6989 rules. 661 rules in the queue.
9600 rules inserted. The rule base contains 7155 rules. 683 rules in the queue.
9800 rules inserted. The rule base contains 7355 rules. 742 rules in the queue.
10000 rules inserted. The rule base contains 7555 rules. 785 rules in the queue.
10200 rules inserted. The rule base contains 7719 rules. 817 rules in the queue.
10400 rules inserted. The rule base contains 7813 rules. 779 rules in the queue.
10600 rules inserted. The rule base contains 7893 rules. 736 rules in the queue.
10800 rules inserted. The rule base contains 7980 rules. 704 rules in the queue.
11000 rules inserted. The rule base contains 8139 rules. 704 rules in the queue.
11200 rules inserted. The rule base contains 8314 rules. 711 rules in the queue.
11400 rules inserted. The rule base contains 8485 rules. 720 rules in the queue.
11600 rules inserted. The rule base contains 8649 rules. 756 rules in the queue.
11800 rules inserted. The rule base contains 8814 rules. 805 rules in the queue.
12000 rules inserted. The rule base contains 8975 rules. 847 rules in the queue.
12200 rules inserted. The rule base contains 9097 rules. 823 rules in the queue.
12400 rules inserted. The rule base contains 9211 rules. 799 rules in the queue.
12600 rules inserted. The rule base contains 9331 rules. 779 rules in the queue.
12800 rules inserted. The rule base contains 9454 rules. 768 rules in the queue.
13000 rules inserted. The rule base contains 9647 rules. 799 rules in the queue.
13200 rules inserted. The rule base contains 9843 rules. 839 rules in the queue.
13400 rules inserted. The rule base contains 10038 rules. 800 rules in the queue.
13600 rules inserted. The rule base contains 10196 rules. 784 rules in the queue.
13800 rules inserted. The rule base contains 10305 rules. 748 rules in the queue.
14000 rules inserted. The rule base contains 10395 rules. 738 rules in the queue.
14200 rules inserted. The rule base contains 10487 rules. 733 rules in the queue.
14400 rules inserted. The rule base contains 10635 rules. 743 rules in the queue.
14600 rules inserted. The rule base contains 10792 rules. 743 rules in the queue.
14800 rules inserted. The rule base contains 10943 rules. 718 rules in the queue.
15000 rules inserted. The rule base contains 11084 rules. 698 rules in the queue.
15200 rules inserted. The rule base contains 11241 rules. 706 rules in the queue.
15400 rules inserted. The rule base contains 11413 rules. 684 rules in the queue.
15600 rules inserted. The rule base contains 11562 rules. 679 rules in the queue.
15800 rules inserted. The rule base contains 11733 rules. 671 rules in the queue.
16000 rules inserted. The rule base contains 11892 rules. 670 rules in the queue.
16200 rules inserted. The rule base contains 12032 rules. 663 rules in the queue.
16400 rules inserted. The rule base contains 12163 rules. 648 rules in the queue.
16600 rules inserted. The rule base contains 12298 rules. 633 rules in the queue.
16800 rules inserted. The rule base contains 12439 rules. 617 rules in the queue.
17000 rules inserted. The rule base contains 12612 rules. 639 rules in the queue.
17200 rules inserted. The rule base contains 12796 rules. 590 rules in the queue.
17400 rules inserted. The rule base contains 12924 rules. 531 rules in the queue.
17600 rules inserted. The rule base contains 13040 rules. 497 rules in the queue.
17800 rules inserted. The rule base contains 13163 rules. 482 rules in the queue.
18000 rules inserted. The rule base contains 13334 rules. 498 rules in the queue.
18200 rules inserted. The rule base contains 13495 rules. 483 rules in the queue.
18400 rules inserted. The rule base contains 13637 rules. 485 rules in the queue.
18600 rules inserted. The rule base contains 13828 rules. 498 rules in the queue.
18800 rules inserted. The rule base contains 13939 rules. 473 rules in the queue.
19000 rules inserted. The rule base contains 14047 rules. 465 rules in the queue.
19200 rules inserted. The rule base contains 14192 rules. 472 rules in the queue.
19400 rules inserted. The rule base contains 14358 rules. 438 rules in the queue.
19600 rules inserted. The rule base contains 14458 rules. 351 rules in the queue.
19800 rules inserted. The rule base contains 14495 rules. 290 rules in the queue.
20000 rules inserted. The rule base contains 14629 rules. 254 rules in the queue.
20200 rules inserted. The rule base contains 14745 rules. 185 rules in the queue.
20400 rules inserted. The rule base contains 14864 rules. 163 rules in the queue.
20600 rules inserted. The rule base contains 14927 rules. 135 rules in the queue.
20800 rules inserted. The rule base contains 14956 rules. 62 rules in the queue.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_a,msg_a,true))
RESULT event(RecvMsg(bob,alice,stage_a,m,true)) ==> event(SendMsg(alice,bob,stage_a,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query not attacker_p1(msg_a)
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT not attacker_p1(msg_a) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
goal reachable: begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice)))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) cannot be proved.
Starting query not attacker_p1(msg_a)
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT not attacker_p1(msg_a) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
goal reachable: begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
goal reachable: begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk)) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk)) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) cannot be proved.
Starting query attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> attacker_p1(msg_a)

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on this channel.
So the attacker may obtain the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) by listening on this channel.
attacker(concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

5. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

7. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).

8. By 4, the attacker may know concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).
Using the function 1-proj-concat3 the attacker may obtain dhexp(key_2,g).
attacker(dhexp(key_2,g)).

9. The message dhexp(key_1,g) may be sent on channel pub at output {176}.
mess(pub,dhexp(key_1,g)).

10. By 1, the attacker may have the channel pub.
By 9, the message dhexp(key_1,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_1,g) by listening on this channel.
attacker(dhexp(key_1,g)).

11. Using the function empty the attacker may obtain empty.
attacker(empty).

12. Using the function somename the attacker may obtain somename.
attacker(somename).

13. By 12, the attacker may know somename.
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

14. By 13, the attacker may know hash(somename,empty).
By 11, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

15. By 14, the attacker may know hash(hash(somename,empty),empty).
By 10, the attacker may know dhexp(key_1,g).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
attacker(hash(hash(hash(somename,empty),empty),dhexp(key_1,g))).

16. By 15, the attacker may know hash(hash(hash(somename,empty),empty),dhexp(key_1,g)).
By 8, the attacker may know dhexp(key_2,g).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
attacker(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g))).

17. By 16, the attacker may know hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

18. By 17, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)))).

19. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

20. The message dhexp(key_0,g) may be sent on channel pub at output {4}.
mess(pub,dhexp(key_0,g)).

21. By 1, the attacker may have the channel pub.
By 20, the message dhexp(key_0,g) may be sent on this channel.
So the attacker may obtain the message dhexp(key_0,g) by listening on this channel.
attacker(dhexp(key_0,g)).

22. By 21, the attacker may know dhexp(key_0,g).
So the attacker may know dhexp(key_0,g) in phase 1.
attacker_p1(dhexp(key_0,g)).

23. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

24. The event LeakS(phase1,bob) may be executed at {342}.
So the message key_1 may be sent on channel pub in phase 1 at output {343}.
mess_p1(pub,key_1).

25. By 23, the attacker may have the channel pub in phase 1.
By 24, the message key_1 in phase 1 may be sent on this channel.
So the attacker may obtain the message key_1 in phase 1 by listening on this channel.
attacker_p1(key_1).

26. By 25, the attacker may know key_1 in phase 1.
By 22, the attacker may know dhexp(key_0,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_0,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_0,dhexp(key_1,g))).

27. By 8, the attacker may know dhexp(key_2,g).
So the attacker may know dhexp(key_2,g) in phase 1.
attacker_p1(dhexp(key_2,g)).

28. By 25, the attacker may know key_1 in phase 1.
By 27, the attacker may know dhexp(key_2,g) in phase 1.
Using the function dhexp the attacker may obtain dhexp(key_2,dhexp(key_1,g)) in phase 1.
attacker_p1(dhexp(key_2,dhexp(key_1,g))).

29. By 13, the attacker may know hash(somename,empty).
By 8, the attacker may know dhexp(key_2,g).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
attacker(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

30. By 29, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)).
So the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp(key_2,g))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp(key_2,g)) in phase 1.
By 28, the attacker may know dhexp(key_2,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g)))).

32. By 31, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))) in phase 1.
By 26, the attacker may know dhexp(key_0,dhexp(key_1,g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g)))).

33. By 32, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))) in phase 1.
By 19, the attacker may know minnonce in phase 1.
By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)).

34. By 33, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a in phase 1.
attacker_p1(msg_a).


Could not find a trace corresponding to this derivation.
RESULT attacker_p1(msg_a) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_b,msg_b,true))
RESULT event(RecvMsg(alice,bob,stage_b,m,true)) ==> event(SendMsg(bob,alice,stage_b,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query not attacker_p1(msg_b)
RESULT not attacker_p1(msg_b) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob)))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) is true.
Starting query not attacker_p1(msg_b)
RESULT not attacker_p1(msg_b) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_b) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(bob,alice,stage_c,msg_c,true))
RESULT event(RecvMsg(bob,alice,stage_c,m,true)) ==> event(SendMsg(alice,bob,stage_c,m,true)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query not attacker_p1(msg_c)
RESULT not attacker_p1(msg_c) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice)))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) is true.
Starting query not attacker_p1(msg_c)
RESULT not attacker_p1(msg_c) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_c) ==> event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvMsg(alice,bob,stage_d,msg_d,true))
RESULT event(RecvMsg(alice,bob,stage_d,m,true)) ==> event(SendMsg(bob,alice,stage_d,m,true)) || event(LeakS(phase0,bob)) || event(LeakPsk(p,key_psk)) is true.
Starting query not attacker_p1(msg_d)
RESULT not attacker_p1(msg_d) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob)))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) is true.
Starting query not attacker_p1(msg_d)
RESULT not attacker_p1(msg_d) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) || event(LeakPsk(p,key_psk)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(phase0,key_psk)) is true.
Starting query attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk))
RESULT attacker_p1(msg_d) ==> event(LeakS(phase0,alice)) || event(LeakPsk(p,key_psk)) is true.
Starting query not event(RecvEnd(true))
goal reachable: begin(SendMsg(bob,alice,stage_d,msg_d,true)) && begin(SendMsg(alice,bob,stage_c,msg_c,true)) && begin(SendMsg(bob,alice,stage_b,msg_b,true)) && begin(SendMsg(alice,bob,stage_a,msg_a,true)) -> end(RecvEnd(true))

1. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

2. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 1 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the entry statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {69}.
table(statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true)))).

3. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) may be inserted in a table at insert {188}.
table(statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false)))).

4. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

5. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 4 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

6. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) that may be in a table by 3 may be read at get {242}.
The message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) that may be sent on channel pub by 5 may be received at input {189}.
So the entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) may be inserted in a table at insert {241}.
table(statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false)))).

7. The entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) that may be in a table by 6 may be read at get {293}.
The event SendMsg(bob,alice,stage_b,msg_b,true) may be executed at {290}.
So the message concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)) may be sent on channel pub at output {292}.
mess(pub,concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))).

8. The entry statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 2 may be read at get {121}.
The message concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)) that may be sent on channel pub by 7 may be received at input {72}.
We have dhexp(key_3,g) <> caught-fail.
So the entry statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) may be inserted in a table at insert {120}.
table(statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true)))).

9. The entry statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) that may be in a table by 8 may be read at get {139}.
The event SendMsg(alice,bob,stage_c,msg_c,true) may be executed at {136}.
So the entry statestore(alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) may be inserted in a table at insert {137}.
table(statestore(alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true)))).

10. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) may be inserted in a table at insert {188}.
table(statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false)))).

11. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

12. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 11 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

13. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) that may be in a table by 10 may be read at get {242}.
The message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) that may be sent on channel pub by 12 may be received at input {189}.
So the entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) may be inserted in a table at insert {241}.
table(statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false)))).

14. The entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) that may be in a table by 13 may be read at get {293}.
The event SendMsg(bob,alice,stage_b,msg_b,true) may be executed at {290}.
So the entry statestore(bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) may be inserted in a table at insert {291}.
table(statestore(bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false)))).

15. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

16. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 15 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the entry statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {69}.
table(statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true)))).

17. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) may be inserted in a table at insert {188}.
table(statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false)))).

18. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) may be inserted in a table at insert {17}.
table(statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true)))).

19. The entry statestore(alice,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(empty,empty),keypairpack(empty,empty),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 18 may be read at get {71}.
The event SendMsg(alice,bob,stage_a,msg_a,true) may be executed at {68}.
So the message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) may be sent on channel pub at output {70}.
mess(pub,concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))).

20. The entry statestore(bob,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(somename,empty),empty),dhexp(key_1,g))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),empty,empty,key_psk,false))) that may be in a table by 17 may be read at get {242}.
The message concat3(dhexp(key_2,g),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g)),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)) that may be sent on channel pub by 19 may be received at input {189}.
So the entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) may be inserted in a table at insert {241}.
table(statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false)))).

21. The entry statestore(bob,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_1,g),key_1),keypairpack(empty,empty),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) that may be in a table by 20 may be read at get {293}.
The event SendMsg(bob,alice,stage_b,msg_b,true) may be executed at {290}.
So the message concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)) may be sent on channel pub at output {292}.
mess(pub,concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))).

22. The entry statestore(alice,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),empty,key_psk,true))) that may be in a table by 16 may be read at get {121}.
The message concat3(dhexp(key_3,g),empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)) that may be sent on channel pub by 21 may be received at input {72}.
We have dhexp(key_3,g) <> caught-fail.
So the entry statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) may be inserted in a table at insert {120}.
table(statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true)))).

23. The entry statestore(alice,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) that may be in a table by 22 may be read at get {139}.
The event SendMsg(alice,bob,stage_c,msg_c,true) may be executed at {136}.
So the message concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c)) may be sent on channel pub at output {138}.
mess(pub,concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))).

24. The entry statestore(bob,statepack_c(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) that may be in a table by 14 may be read at get {312}.
The message concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c)) that may be sent on channel pub by 23 may be received at input {294}.
So the entry statestore(bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) may be inserted in a table at insert {311}.
table(statestore(bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false)))).

25. The entry statestore(bob,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_1,g),key_1),keypairpack(dhexp(key_3,g),key_3),dhexp(key_0,g),dhexp(key_2,g),key_psk,false))) that may be in a table by 24 may be read at get {338}.
The event SendMsg(bob,alice,stage_d,msg_d,true) may be executed at {335}.
So the message concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c)),msg_d)) may be sent on channel pub at output {337}.
mess(pub,concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c)),msg_d))).

26. The entry statestore(alice,statepack_d(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce))),hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c))),keypairpack(dhexp(key_0,g),key_0),keypairpack(dhexp(key_2,g),key_2),dhexp(key_1,g),dhexp(key_3,g),key_psk,true))) that may be in a table by 9 may be read at get {167}.
The message concat3(empty,empty,encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),encrypt(hmac_hash3(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk),minnonce,hash(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),minnonce,hash(hash(hash(hash(somename,empty),empty),dhexp(key_1,g)),dhexp(key_2,g)),dhexp(key_0,g))),msg_a)),dhexp(key_3,g)),hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp(key_2,g)),dhexp(key_2,dhexp(key_1,g))),dhexp(key_0,dhexp(key_1,g))),dhexp(key_3,g)),dhexp(key_2,dhexp(key_3,g))),dhexp(key_0,dhexp(key_3,g))),key_psk)),msg_b)),msg_c)),msg_d)) that may be sent on channel pub by 25 may be received at input {140}.
So event RecvEnd(true) may be executed at {166}.
end(RecvEnd(true)).


Could not find a trace corresponding to this derivation.
RESULT not event(RecvEnd(true)) cannot be proved.
